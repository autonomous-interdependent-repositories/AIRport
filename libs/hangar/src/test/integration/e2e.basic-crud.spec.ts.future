import {
	createEntity, entitiesEqual, info, updateEntity, deleteEntity, updateWhere,
	deleteWhere, assertTaskCount, assertGoalCount, verifyGeneratedId, sortTasksById
} from "../misc/utils.spec";
import {ucase, lcase, or, and, not} from "@airport/air-control";
import {RawEntityQuery} from "@airport/ground-control";
import {ITqTestGoal, TqTestGoal} from "../misc/TqTestGoal";
import {initializeTQ} from "../misc/setup.spec";
import {ITqTestTask} from "../misc/TqTestTask";
import {IEPTqTestTask, QTqTestTask} from "../../generated/test/misc/qTqTestTask";
import {QTqTestGoal} from "../../generated/test/misc/qTqTestGoal";

/**
 * Created by Papa on 11/26/2016.
 */

describe('Basic CRUD: End-to-End:', () => {
	tq('Initialize', async ( done ) => {
		await initializeTQ(done, ['BASIC_CRUD']);
	});

	let db = dbConst.DEFAULT_DB;

	let firstTaskId: number;

	let goal: ITqTestGoal = {
		accomplished: false,
		description: 'Insert',
		goalId: 1,
		name: 'Basic Insert',
		dueDate: new Date()
	};
	tq(`Insert w/ no foreign keys and entity.findOne.tree {'*'}`, async ( done ) => {
		await createEntity(goal, QTqTestGoal, done);
		let goalResult = await QTqTestGoal.db(db).findOne.tree({
			select: {
				'*': null
			}
		});
		entitiesEqual(goalResult, goal, done);
	});


	let task1: ITqTestTask = {
		complete: false,
		description: 'Insert with foreign keys',
		goal: {
			goalId: 1
		},
		taskId: null,
		name: 'Foreign key insert'
	};
	tq('Insert w/ a foreign key and entity.find.tree {}', async ( done ) => {
		await createEntity(task1, QTqTestTask, done);
		let task1Result = await QTqTestTask.db(db).find.tree({
			select: {}
		});
		expect(task1Result.length).toBe(1);
		firstTaskId = task1Result[0].taskId;
		verifyGeneratedId(task1Result[0], task1, 'taskId');
		entitiesEqual(task1Result[0], task1, done);
	});


	let goalNTasks2: ITqTestGoal = {
		accomplished: false,
		description: 'Cascading Insert Goal with Tasks',
		goalId: 2,
		name: 'Cascading Insert',
		dueDate: new Date(),
		tasks: [
			{
				complete: false,
				description: 'Cascaded Insert with stub OneToMany',
				goal: {
					goalId: 2
				},
				taskId: 2,
				name: 'Cascaded Insert w/ Stub'
			}
		]
	};
	goalNTasks2.tasks.push({
		complete: false,
		description: 'Cascaded Insert with OneToMany object reference',
		goal: goalNTasks2,
		taskId: 3,
		name: 'Cascaded Insert w/ Ref'
	});
	let goal2Result: TqTestGoal;
	tq('Insert cascading and start cache and entity.findOne.graph', async ( done ) => {
		await createEntity(goalNTasks2, QTqTestGoal, done);
		TQ.startUpdateContext();
		goal2Result = await QTqTestGoal.db(db).findOne.graph(
			(
				g: QTqTestGoal,
				t: QTqTestTask
			) => ({
				select: {
					'*': null,
					tasks: {}
				},
				from: [
					g = QTqTestGoal.db(db).from,
					t = g.tasks.innerJoin()
				],
				where: g.goalId.equals(goalNTasks2.goalId),
				orderBy: [g.goalId.asc(), g.dueDate.desc(), t.taskId.asc()]
			}));
		goalNTasks2.tasks[0].goal = goalNTasks2;
		goal2Result.tasks.sort(sortTasksById);
		entitiesEqual(goal2Result, goalNTasks2, done);
	});


	let findTasks = ( t: QTqTestTask ): RawEntityQuery<IEPTqTestTask> => ({
		select: {
			'*': null,
			goal: {
				'*': null,
				tasks: {
					taskId: null
				}
			}
		},
		from: [
			t = QTqTestTask.db(db).from
		],
		where: t.taskId.isIn([2, 3])
	});
	tq('Update cascading and entity.find.graph and end cache', async ( done ) => {
		goal2Result.name += ' and Update';
		goal2Result.description += ' and Update';
		goal2Result.tasks.forEach(( task ) => {
			task.name += ' and Update';
			task.description += ' and Update';
		});
		await updateEntity(goal2Result, QTqTestGoal, done);
		TQ.endUpdateContext();
		let tasksForGoal2Result = await QTqTestTask.db(db).find.graph(findTasks);
		expect(tasksForGoal2Result.length).toBe(2);
		entitiesEqual(tasksForGoal2Result[0], goal2Result.tasks[0], done, false);
		entitiesEqual(tasksForGoal2Result[1], goal2Result.tasks[1], done, false);
		entitiesEqual(tasksForGoal2Result[0].goal, goal2Result, done);
		expect(tasksForGoal2Result[0].goal === tasksForGoal2Result[1].goal).toBe(true);

	});


	tq('UpdateWhere and findOne.field', async ( done ) => {
		await updateWhere(( t: QTqTestTask ) => ({
			update: [t = QTqTestTask.db(db).from],
			set: {
				complete: true
			},
			where: t.complete.equals(false)
		}), QTqTestTask, done);
		await assertTaskCount(3,
			t => t.complete.equals(true));
	});


	tq('UpdateWhere all and find.sheet', async ( done ) => {
		await updateWhere(( g: QTqTestGoal ) => ({
			update: g = QTqTestGoal.db(db).from,
			set: {
				accomplished: true
			}
		}), QTqTestGoal, done);
		let results = await TQ.db(db).find.sheet(
			(
				g: QTqTestGoal,
				t: QTqTestTask
			) => ({
				from: [
					g = QTqTestGoal.db(db).from,
					t = g.tasks.leftJoin()],
				select: [
					g.goalId,
					g.accomplished,
					t.taskId,
					t.complete],
				where: or(
					t.complete.equals(true),
					g.accomplished.equals(true)),
				orderBy: [g.goalId.asc(), t.taskId.desc()]
			}));
		expect(results.length).toBe(3);
		entitiesEqual(results[0], [1, true, firstTaskId, true], done);
		entitiesEqual(results[1], [2, true, '3', true], done);
		entitiesEqual(results[2], [2, true, '2', true], done);
	});

	function subQueryWhereClause( t: QTqTestTask ) {
		return and(
			ucase(t.name).like('% REF%'),
			t.taskId.equals(( t2: QTqTestTask ) => ({
				from: [t2 = QTqTestTask.db(db).from],
				select: t2.taskId,
				where: t2.taskId.equals(t.taskId)
			}))
		);
	}

	tq('UpdateWhere w/ sub-query and entity.find.graph', async ( done ) => {
		await updateWhere(( t: QTqTestTask ) => ({
			update: t = QTqTestTask.db(db).from,
			set: {
				name: 'Cascaded Insert w/ Reference'
			},
			where: subQueryWhereClause(t)
		}), QTqTestTask, done);
		let results = await QTqTestTask.db(db).find.graph(( t: QTqTestTask ) => ({
			select: {},
			from: [t = QTqTestTask.db(db).from],
			where: subQueryWhereClause(t)
		}));
		expect(results.length).toBe(1);
		goalNTasks2.tasks[1].description += ' and Update';
		goalNTasks2.tasks[1].name = 'Cascaded Insert w/ Reference';
		goalNTasks2.tasks[1].complete = true;
		entitiesEqual(results[0], goalNTasks2.tasks[1], done, false);
	});

	tq('findOne.tree', async ( done ) => {
		let result = await TQ.db(db).findOne.tree(
			(
				g: QTqTestGoal,
				t: QTqTestTask
			) => ({
				from: [g = QTqTestGoal.db(db).from,
					t = g.innerJoin(QTqTestTask.db(db).from).on(( t: QTqTestTask ) =>
						g.goalId.equals(t.goal.goalId)
					)],
				select: {
					id: g.goalId,
					goal: g.name,
					reached: g.accomplished,
					tasks: {
						id: t.taskId,
						task: t.name,
						finished: t.complete
					}
				},
				where: and(
					not(lcase(t.name).like('cascade%')),
					t.taskId.equals(firstTaskId)
				),
				orderBy: [g.goalId.asc(), t.taskId.desc()]
			}));
		entitiesEqual(result, {
			id: 1,
			goal: 'Basic Insert',
			reached: true,
			tasks: [{
				id: firstTaskId,
				task: 'Foreign key insert',
				finished: true
			}]
		}, done);
	});


	tq('Delete cascading', async ( done ) => {
		await deleteEntity(goal2Result, QTqTestGoal, done);
		let tasksForGoal2Result = await QTqTestTask.db(db).find.tree(findTasks);
		expect(tasksForGoal2Result.length).toBe(0);
	});


	tq('DeleteWhere', async ( done ) => {
		await deleteWhere(( t: QTqTestTask ) => ({
			deleteFrom: t = QTqTestTask.db(db).from,
			where: t.complete.equals(true)
		}), QTqTestTask, done);
		await assertTaskCount(0);

		await deleteWhere(( g: QTqTestGoal ) => ({
			deleteFrom: g = QTqTestGoal.db(db).from
		}), QTqTestGoal, done);
		await assertGoalCount(0);
	});

});