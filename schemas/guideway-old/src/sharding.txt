Guideway data is sharded reginally by location.

This works easily for all user and database related information:

User
Database

Repositories can has be be sharded the same way since they belong to given
users
Repository

For sharing Repositories across Databases a this approach cannot be used.  The
trick would be joining repositories to databases that are in a different shard.
There are two connections that require joining no repository (cross-shard) key:

Database <--> Repository
User <--> Repository

Let's look at it one example at a time.

1) Realtime syncing

For realtime syncing we can first sync up all repositories and databases that live
in the same shard.

Then for repositories that are referenced from this shard but don't live it, we could
reply on left outer joins to identify those records?

A way for left joins to work would be to have two tables for the relation between
repositories and databases:

/**
 * stores data per database shard
 */
DATABASE_REPOSITORIES
----------------------
DATABASE_LOCATION_ID
DATABASE_ID
REPOSITORY_LOCATION_ID
REPOSITORY_ID

This table would be queried for joins coming from the database table and would always
have to have only LEFT OUT JOINs to the repository table.
Then the query results would have to be parsed and the repositories that live on different
shards would have to be queried for separately.


REPOSITORY_DATABASES
----------------------
REPOSITORY_LOCATION_ID
REPOSITORY_ID
DATABASE_LOCATION_ID
DATABASE_ID

This table handles all queries that start with repositories and works the same exact way in
the opposite direction.

Again, the assumption is that most of the records in these tables would have both the
DATABASE_LOCATION_ID and REPOSITORY_LOCATION_ID pointing to the same shard.  Eventually
stats can be gathered off these tables to figure out how much cross shard sharing there
really is there.

2)  Uniqueness

During migration of (a) database(s) from one shard to another there cannot be collision of
record ids.  Uniqueness can be guaranteed by adding ORIGINAL_SHARD_ID to all records.  This
will ensure that BIGSERIALS generated on the target shard will never collide with the
identifiers generated on the original shard.  For temporal tables it is possible that ids
will eventually be rolled back to a smaller numbers but in that case all of the records with
those same ids would already have been dropped.

3)  Time of re-sharding.

There are tree fundamental modification operations on shards.

Record incoming changes
Archive data
Rebalance shards.

Recording of incoming changes can run at any time but Archiving and Rebalancing are mutually
exclusive.

Rebalancing is an on-going process that can either:

a)  Take individual users based on their repository distribution and move all of their
records to a different shard.  This is done if most of the reads or creates for that user's
repositories come from a different shard.  This is an ongoing process that runs in the back
ground for all shards.  TODO: define the process steps

b)  Alternatively a given shard can suspend it's on-going rebalancing and move records in
bulk to a different shard.  This would be done when an existing shard is being split into
a new one.

Rebalancing cannot begin until Archiving is not running and vice versa. This is done to avoid
missing archived