
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
function noop$1() { }
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function children(element) {
    return Array.from(element.childNodes);
}
function custom_event(type, detail, bubbles = false) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, false, detail);
    return e;
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop$1,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options.context || []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop$1;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.42.4' }, detail), true));
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error("'target' is a required option");
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn('Component was already destroyed'); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var page = createCommonjsModule(function (module, exports) {
(function (global, factory) {
	module.exports = factory() ;
}(commonjsGlobal, (function () {
var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {String} str
 * @return {Array}
 */
function parse (str) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var suffix = res[6];
    var asterisk = res[7];

    var repeat = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';
    var delimiter = prefix || '/';
    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      pattern: escapeGroup(pattern)
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {String}   str
 * @return {Function}
 */
function compile (str) {
  return tokensToFunction(parse(str))
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^' + tokens[i].pattern + '$');
    }
  }

  return function (obj) {
    var path = '';
    var data = obj || {};

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encodeURIComponent(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = encodeURIComponent(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {String} str
 * @return {String}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function stringToRegexp (path, keys, options) {
  var tokens = parse(path);
  var re = tokensToRegExp(tokens, options);

  // Attach keys back to the regexp.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] !== 'string') {
      keys.push(tokens[i]);
    }
  }

  return attachKeys(re, keys)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {Array}  tokens
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function tokensToRegExp (tokens, options) {
  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';
  var lastToken = tokens[tokens.length - 1];
  var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken);

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = token.pattern;

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (prefix) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return new RegExp('^' + route, flags(options))
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isarray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys)
  }

  if (isarray(path)) {
    return arrayToRegexp(path, keys, options)
  }

  return stringToRegexp(path, keys, options)
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/**
   * Module dependencies.
   */

  

  /**
   * Short-cuts for global-object checks
   */

  var hasDocument = ('undefined' !== typeof document);
  var hasWindow = ('undefined' !== typeof window);
  var hasHistory = ('undefined' !== typeof history);
  var hasProcess = typeof process !== 'undefined';

  /**
   * Detect click event
   */
  var clickEvent = hasDocument && document.ontouchstart ? 'touchstart' : 'click';

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var isLocation = hasWindow && !!(window.history.location || window.location);

  /**
   * The page instance
   * @api private
   */
  function Page() {
    // public things
    this.callbacks = [];
    this.exits = [];
    this.current = '';
    this.len = 0;

    // private things
    this._decodeURLComponents = true;
    this._base = '';
    this._strict = false;
    this._running = false;
    this._hashbang = false;

    // bound functions
    this.clickHandler = this.clickHandler.bind(this);
    this._onpopstate = this._onpopstate.bind(this);
  }

  /**
   * Configure the instance of page. This can be called multiple times.
   *
   * @param {Object} options
   * @api public
   */

  Page.prototype.configure = function(options) {
    var opts = options || {};

    this._window = opts.window || (hasWindow && window);
    this._decodeURLComponents = opts.decodeURLComponents !== false;
    this._popstate = opts.popstate !== false && hasWindow;
    this._click = opts.click !== false && hasDocument;
    this._hashbang = !!opts.hashbang;

    var _window = this._window;
    if(this._popstate) {
      _window.addEventListener('popstate', this._onpopstate, false);
    } else if(hasWindow) {
      _window.removeEventListener('popstate', this._onpopstate, false);
    }

    if (this._click) {
      _window.document.addEventListener(clickEvent, this.clickHandler, false);
    } else if(hasDocument) {
      _window.document.removeEventListener(clickEvent, this.clickHandler, false);
    }

    if(this._hashbang && hasWindow && !hasHistory) {
      _window.addEventListener('hashchange', this._onpopstate, false);
    } else if(hasWindow) {
      _window.removeEventListener('hashchange', this._onpopstate, false);
    }
  };

  /**
   * Get or set basepath to `path`.
   *
   * @param {string} path
   * @api public
   */

  Page.prototype.base = function(path) {
    if (0 === arguments.length) return this._base;
    this._base = path;
  };

  /**
   * Gets the `base`, which depends on whether we are using History or
   * hashbang routing.

   * @api private
   */
  Page.prototype._getBase = function() {
    var base = this._base;
    if(!!base) return base;
    var loc = hasWindow && this._window && this._window.location;

    if(hasWindow && this._hashbang && loc && loc.protocol === 'file:') {
      base = loc.pathname;
    }

    return base;
  };

  /**
   * Get or set strict path matching to `enable`
   *
   * @param {boolean} enable
   * @api public
   */

  Page.prototype.strict = function(enable) {
    if (0 === arguments.length) return this._strict;
    this._strict = enable;
  };


  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  Page.prototype.start = function(options) {
    var opts = options || {};
    this.configure(opts);

    if (false === opts.dispatch) return;
    this._running = true;

    var url;
    if(isLocation) {
      var window = this._window;
      var loc = window.location;

      if(this._hashbang && ~loc.hash.indexOf('#!')) {
        url = loc.hash.substr(2) + loc.search;
      } else if (this._hashbang) {
        url = loc.search + loc.hash;
      } else {
        url = loc.pathname + loc.search + loc.hash;
      }
    }

    this.replace(url, null, true, opts.dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  Page.prototype.stop = function() {
    if (!this._running) return;
    this.current = '';
    this.len = 0;
    this._running = false;

    var window = this._window;
    this._click && window.document.removeEventListener(clickEvent, this.clickHandler, false);
    hasWindow && window.removeEventListener('popstate', this._onpopstate, false);
    hasWindow && window.removeEventListener('hashchange', this._onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {string} path
   * @param {Object=} state
   * @param {boolean=} dispatch
   * @param {boolean=} push
   * @return {!Context}
   * @api public
   */

  Page.prototype.show = function(path, state, dispatch, push) {
    var ctx = new Context(path, state, this),
      prev = this.prevContext;
    this.prevContext = ctx;
    this.current = ctx.path;
    if (false !== dispatch) this.dispatch(ctx, prev);
    if (false !== ctx.handled && false !== push) ctx.pushState();
    return ctx;
  };

  /**
   * Goes back in the history
   * Back should always let the current route push state and then go back.
   *
   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base
   * @param {Object=} state
   * @api public
   */

  Page.prototype.back = function(path, state) {
    var page = this;
    if (this.len > 0) {
      var window = this._window;
      // this may need more testing to see if all browsers
      // wait for the next tick to go back in history
      hasHistory && window.history.back();
      this.len--;
    } else if (path) {
      setTimeout(function() {
        page.show(path, state);
      });
    } else {
      setTimeout(function() {
        page.show(page._getBase(), state);
      });
    }
  };

  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {string} from - if param 'to' is undefined redirects to 'from'
   * @param {string=} to
   * @api public
   */
  Page.prototype.redirect = function(from, to) {
    var inst = this;

    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page.call(this, from, function(e) {
        setTimeout(function() {
          inst.replace(/** @type {!string} */ (to));
        }, 0);
      });
    }

    // Wait for the push state and replace it with another
    if ('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
        inst.replace(from);
      }, 0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {string} path
   * @param {Object=} state
   * @param {boolean=} init
   * @param {boolean=} dispatch
   * @return {!Context}
   * @api public
   */


  Page.prototype.replace = function(path, state, init, dispatch) {
    var ctx = new Context(path, state, this),
      prev = this.prevContext;
    this.prevContext = ctx;
    this.current = ctx.path;
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) this.dispatch(ctx, prev);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Context} ctx
   * @api private
   */

  Page.prototype.dispatch = function(ctx, prev) {
    var i = 0, j = 0, page = this;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];

      if (ctx.path !== page.current) {
        ctx.handled = false;
        return;
      }
      if (!fn) return unhandled.call(page, ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  Page.prototype.exit = function(path, fn) {
    if (typeof path === 'function') {
      return this.exit('*', path);
    }

    var route = new Route(path, null, this);
    for (var i = 1; i < arguments.length; ++i) {
      this.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
   * Handle "click" events.
   */

  /* jshint +W054 */
  Page.prototype.clickHandler = function(e) {
    if (1 !== this._which(e)) return;

    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;

    // ensure link
    // use shadow dom when available if not, fall back to composedPath()
    // for browsers that only have shady
    var el = e.target;
    var eventPath = e.path || (e.composedPath ? e.composedPath() : null);

    if(eventPath) {
      for (var i = 0; i < eventPath.length; i++) {
        if (!eventPath[i].nodeName) continue;
        if (eventPath[i].nodeName.toUpperCase() !== 'A') continue;
        if (!eventPath[i].href) continue;

        el = eventPath[i];
        break;
      }
    }

    // continue ensure link
    // el.nodeName for svg links are 'a' instead of 'A'
    while (el && 'A' !== el.nodeName.toUpperCase()) el = el.parentNode;
    if (!el || 'A' !== el.nodeName.toUpperCase()) return;

    // check if link is inside an svg
    // in this case, both href and target are always inside an object
    var svg = (typeof el.href === 'object') && el.href.constructor.name === 'SVGAnimatedString';

    // Ignore if tag has
    // 1. "download" attribute
    // 2. rel="external" attribute
    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if(!this._hashbang && this._samePath(el) && (el.hash || '#' === link)) return;

    // Check for mailto: in the href
    if (link && link.indexOf('mailto:') > -1) return;

    // check target
    // svg target is an object and its desired value is in .baseVal property
    if (svg ? el.target.baseVal : el.target) return;

    // x-origin
    // note: svg links that are not relative don't call click events (and skip page.js)
    // consequently, all svg links tested inside page.js are relative and in the same origin
    if (!svg && !this.sameOrigin(el.href)) return;

    // rebuild path
    // There aren't .pathname and .search properties in svg links, so we use href
    // Also, svg href is an object and its desired value is in .baseVal property
    var path = svg ? el.href.baseVal : (el.pathname + el.search + (el.hash || ''));

    path = path[0] !== '/' ? '/' + path : path;

    // strip leading "/[drive letter]:" on NW.js on Windows
    if (hasProcess && path.match(/^\/[a-zA-Z]:\//)) {
      path = path.replace(/^\/[a-zA-Z]:\//, '/');
    }

    // same page
    var orig = path;
    var pageBase = this._getBase();

    if (path.indexOf(pageBase) === 0) {
      path = path.substr(pageBase.length);
    }

    if (this._hashbang) path = path.replace('#!', '');

    if (pageBase && orig === path && (!isLocation || this._window.location.protocol !== 'file:')) {
      return;
    }

    e.preventDefault();
    this.show(orig);
  };

  /**
   * Handle "populate" events.
   * @api private
   */

  Page.prototype._onpopstate = (function () {
    var loaded = false;
    if ( ! hasWindow ) {
      return function () {};
    }
    if (hasDocument && document.readyState === 'complete') {
      loaded = true;
    } else {
      window.addEventListener('load', function() {
        setTimeout(function() {
          loaded = true;
        }, 0);
      });
    }
    return function onpopstate(e) {
      if (!loaded) return;
      var page = this;
      if (e.state) {
        var path = e.state.path;
        page.replace(path, e.state);
      } else if (isLocation) {
        var loc = page._window.location;
        page.show(loc.pathname + loc.search + loc.hash, undefined, undefined, false);
      }
    };
  })();

  /**
   * Event button.
   */
  Page.prototype._which = function(e) {
    e = e || (hasWindow && this._window.event);
    return null == e.which ? e.button : e.which;
  };

  /**
   * Convert to a URL object
   * @api private
   */
  Page.prototype._toURL = function(href) {
    var window = this._window;
    if(typeof URL === 'function' && isLocation) {
      return new URL(href, window.location.toString());
    } else if (hasDocument) {
      var anc = window.document.createElement('a');
      anc.href = href;
      return anc;
    }
  };

  /**
   * Check if `href` is the same origin.
   * @param {string} href
   * @api public
   */
  Page.prototype.sameOrigin = function(href) {
    if(!href || !isLocation) return false;

    var url = this._toURL(href);
    var window = this._window;

    var loc = window.location;

    /*
       When the port is the default http port 80 for http, or 443 for
       https, internet explorer 11 returns an empty string for loc.port,
       so we need to compare loc.port with an empty string if url.port
       is the default port 80 or 443.
       Also the comparition with `port` is changed from `===` to `==` because
       `port` can be a string sometimes. This only applies to ie11.
    */
    return loc.protocol === url.protocol &&
      loc.hostname === url.hostname &&
      (loc.port === url.port || loc.port === '' && (url.port == 80 || url.port == 443)); // jshint ignore:line
  };

  /**
   * @api private
   */
  Page.prototype._samePath = function(url) {
    if(!isLocation) return false;
    var window = this._window;
    var loc = window.location;
    return url.pathname === loc.pathname &&
      url.search === loc.search;
  };

  /**
   * Remove URL encoding from the given `str`.
   * Accommodates whitespace in both x-www-form-urlencoded
   * and regular percent-encoded form.
   *
   * @param {string} val - URL component to decode
   * @api private
   */
  Page.prototype._decodeURLEncodedURIComponent = function(val) {
    if (typeof val !== 'string') { return val; }
    return this._decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
  };

  /**
   * Create a new `page` instance and function
   */
  function createPage() {
    var pageInstance = new Page();

    function pageFn(/* args */) {
      return page.apply(pageInstance, arguments);
    }

    // Copy all of the things over. In 2.0 maybe we use setPrototypeOf
    pageFn.callbacks = pageInstance.callbacks;
    pageFn.exits = pageInstance.exits;
    pageFn.base = pageInstance.base.bind(pageInstance);
    pageFn.strict = pageInstance.strict.bind(pageInstance);
    pageFn.start = pageInstance.start.bind(pageInstance);
    pageFn.stop = pageInstance.stop.bind(pageInstance);
    pageFn.show = pageInstance.show.bind(pageInstance);
    pageFn.back = pageInstance.back.bind(pageInstance);
    pageFn.redirect = pageInstance.redirect.bind(pageInstance);
    pageFn.replace = pageInstance.replace.bind(pageInstance);
    pageFn.dispatch = pageInstance.dispatch.bind(pageInstance);
    pageFn.exit = pageInstance.exit.bind(pageInstance);
    pageFn.configure = pageInstance.configure.bind(pageInstance);
    pageFn.sameOrigin = pageInstance.sameOrigin.bind(pageInstance);
    pageFn.clickHandler = pageInstance.clickHandler.bind(pageInstance);

    pageFn.create = createPage;

    Object.defineProperty(pageFn, 'len', {
      get: function(){
        return pageInstance.len;
      },
      set: function(val) {
        pageInstance.len = val;
      }
    });

    Object.defineProperty(pageFn, 'current', {
      get: function(){
        return pageInstance.current;
      },
      set: function(val) {
        pageInstance.current = val;
      }
    });

    // In 2.0 these can be named exports
    pageFn.Context = Context;
    pageFn.Route = Route;

    return pageFn;
  }

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {string|!Function|!Object} path
   * @param {Function=} fn
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page.call(this, '*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(/** @type {string} */ (path), null, this);
      for (var i = 1; i < arguments.length; ++i) {
        this.callbacks.push(route.middleware(arguments[i]));
      }
      // show <path> with [state]
    } else if ('string' === typeof path) {
      this['string' === typeof fn ? 'redirect' : 'show'](path, fn);
      // start [options]
    } else {
      this.start(path);
    }
  }

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */
  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;
    var page = this;
    var window = page._window;

    if (page._hashbang) {
      current = isLocation && this._getBase() + window.location.hash.replace('#!', '');
    } else {
      current = isLocation && window.location.pathname + window.location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    isLocation && (window.location.href = ctx.canonicalPath);
  }

  /**
   * Escapes RegExp characters in the given string.
   *
   * @param {string} s
   * @api private
   */
  function escapeRegExp(s) {
    return s.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @constructor
   * @param {string} path
   * @param {Object=} state
   * @api public
   */

  function Context(path, state, pageInstance) {
    var _page = this.page = pageInstance || page;
    var window = _page._window;
    var hashbang = _page._hashbang;

    var pageBase = _page._getBase();
    if ('/' === path[0] && 0 !== path.indexOf(pageBase)) path = pageBase + (hashbang ? '#!' : '') + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    var re = new RegExp('^' + escapeRegExp(pageBase));
    this.path = path.replace(re, '') || '/';
    if (hashbang) this.path = this.path.replace('#!', '') || '/';

    this.title = (hasDocument && window.document.title);
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i ? _page._decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
    this.pathname = _page._decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
    this.params = {};

    // fragment
    this.hash = '';
    if (!hashbang) {
      if (!~this.path.indexOf('#')) return;
      var parts = this.path.split('#');
      this.path = this.pathname = parts[0];
      this.hash = _page._decodeURLEncodedURIComponent(parts[1]) || '';
      this.querystring = this.querystring.split('#')[0];
    }
  }

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function() {
    var page = this.page;
    var window = page._window;
    var hashbang = page._hashbang;

    page.len++;
    if (hasHistory) {
        window.history.pushState(this.state, this.title,
          hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
    }
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function() {
    var page = this.page;
    if (hasHistory) {
        page._window.history.replaceState(this.state, this.title,
          page._hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
    }
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @constructor
   * @param {string} path
   * @param {Object=} options
   * @api private
   */

  function Route(path, options, page) {
    var _page = this.page = page || globalPage;
    var opts = options || {};
    opts.strict = opts.strict || _page._strict;
    this.path = (path === '*') ? '(.*)' : path;
    this.method = 'GET';
    this.regexp = pathToRegexp_1(this.path, this.keys = [], opts);
  }

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn) {
    var self = this;
    return function(ctx, next) {
      if (self.match(ctx.path, ctx.params)) {
        ctx.routePath = self.path;
        return fn(ctx, next);
      }
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {string} path
   * @param {Object} params
   * @return {boolean}
   * @api private
   */

  Route.prototype.match = function(path, params) {
    var keys = this.keys,
      qsIndex = path.indexOf('?'),
      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
      m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    delete params[0];

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];
      var val = this.page._decodeURLEncodedURIComponent(m[i]);
      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
        params[key.name] = val;
      }
    }

    return true;
  };


  /**
   * Module exports.
   */

  var globalPage = createPage();
  var page_js = globalPage;
  var default_1 = globalPage;

page_js.default = default_1;

return page_js;

})));
});

/* src/App.svelte generated by Svelte v3.42.4 */

const { console: console_1 } = globals;

function create_fragment(ctx) {
	const block = {
		c: noop$1,
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: noop$1,
		p: noop$1,
		i: noop$1,
		o: noop$1,
		d: noop$1
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('App', slots, []);

	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	page('/:uiPath', context => {
		console.log(context);
	});

	page();

	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
		
	}));

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<App> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ __awaiter, onMount, page });

	$$self.$inject_state = $$props => {
		if ('__awaiter' in $$props) __awaiter = $$props.__awaiter;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: create_fragment.name
		});
	}
}

class InjectionDomain {
    constructor(name) {
        this.name = name;
        this.applicationMap = {};
    }
    app(applicationName) {
        if (this.applicationMap[applicationName]) {
            throw new Error(`
			Application already defined.
			Domain:      ${this.name}
			Application: ${applicationName}
			`);
        }
        const application = new InjectionApplication(applicationName, this);
        this.applicationMap[applicationName] = application;
        return application;
    }
    getApp(applicationName) {
        return this.applicationMap[applicationName];
    }
}
const DOMAIN_MAP = {};
function domain(domainName) {
    if (DOMAIN_MAP[domainName]) {
        return DOMAIN_MAP[domainName];
    }
    const domain = new InjectionDomain(domainName);
    DOMAIN_MAP[domainName] = domain;
    return domain;
}
const AIRPORT_DOMAIN = domain('turbase.app');

class DependencyInjectionToken {
    constructor(application, descriptor) {
        this.application = application;
        this.descriptor = descriptor;
    }
    get dependencyConfiguration() {
        return this.getInheritedDependencyConfiguration(this.descriptor.class);
    }
    getPath() {
        return this.application.domain.name + ':' + this.application.name + ':'
            + this.descriptor.token;
    }
    setDependencies(dependencyConfiguration) {
        if (this._dependencyConfiguration) {
            this._dependencyConfiguration = {
                ...this._dependencyConfiguration,
                ...dependencyConfiguration
            };
        }
        else {
            this._dependencyConfiguration = dependencyConfiguration;
        }
        if (!this.descriptor.class) {
            return;
        }
        if (this.descriptor.class.dependencyConfiguration) {
            this.descriptor.class.dependencyConfiguration = {
                ...this.descriptor.class.dependencyConfiguration,
                ...dependencyConfiguration
            };
        }
        else {
            this.descriptor.class.dependencyConfiguration = dependencyConfiguration;
        }
    }
    setClass(aClass) {
        this.descriptor.class = aClass;
        aClass.dependencyConfiguration = this._dependencyConfiguration;
    }
    getInheritedDependencyConfiguration(aClass) {
        const parentClass = Object.getPrototypeOf(aClass);
        let returnedDependencyConfiguration = {};
        if (parentClass) {
            returnedDependencyConfiguration = this.getInheritedDependencyConfiguration(parentClass);
        }
        const dependencyConfiguration = aClass.dependencyConfiguration;
        if (dependencyConfiguration) {
            returnedDependencyConfiguration = {
                ...returnedDependencyConfiguration,
                ...dependencyConfiguration
            };
        }
        return returnedDependencyConfiguration;
    }
}

class InjectionApplication {
    constructor(name, domain) {
        this.name = name;
        this.domain = domain;
        this.tokenMap = new Map();
        this.autopilot = false;
    }
    token(descriptor) {
        const existingToken = this.tokenMap.get(descriptor.token);
        if (existingToken) {
            throw new Error(`Token with name '${name}' has already been created`);
        }
        const diToken = new DependencyInjectionToken(this, descriptor);
        this.tokenMap.set(descriptor.token, diToken);
        return diToken;
    }
}
function lib$1(libraryName) {
    return AIRPORT_DOMAIN.app(libraryName);
}

var ContextType;
(function (ContextType) {
    ContextType["DB"] = "DB";
    ContextType["UI"] = "UI";
})(ContextType || (ContextType = {}));
class Context {
    constructor(id, type) {
        this.id = id;
        this.type = type;
    }
}

class Container {
}

const Injected = function () {
    return function (constructor) {
        // No runtime logic required.
    };
};
const Inject = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};

var __decorate$2G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ContainerAccessor = class ContainerAccessor {
    getContainer(injectedObject) {
        const iocContainer = injectedObject.__container__;
        if (!iocContainer) {
            throw new Error('"container" is not set on injectable object.');
        }
        if (!(iocContainer instanceof Container)) {
            throw new Error('"container" property of injectable is not an' +
                'instance of @airport/direction-indicator Container');
        }
        return iocContainer;
    }
};
ContainerAccessor = __decorate$2G([
    Injected()
], ContainerAccessor);

const directionIndicator = lib$1('direction-indicator');
const AUTOPILOT_API_LOADER = directionIndicator.token({
    class: null,
    interface: 'IAutopilotApiLoader',
    token: 'AUTOPILOT_API_LOADER'
});
const CONTAINER_ACCESSOR = directionIndicator.token({
    class: ContainerAccessor,
    interface: 'IContainerAccessor',
    token: 'CONTAINER_ACCESSOR'
});

class ChildContainer extends Container {
    constructor(rootContainer, context) {
        super();
        this.rootContainer = rootContainer;
        this.context = context;
        // TODO: implement continuous upgrading
        // classes: any[]  = []
        // numPendingInits = 0
        // theObjects: any[]  = []
        this.objectMap = new Map();
    }
    doEventuallyGet(tokens, successCallback, errorCallback) {
        let { firstDiNotSetClass, firstMissingClassToken, objects } = this.doGetCore(tokens);
        if (firstMissingClassToken || firstDiNotSetClass) {
            setTimeout(() => {
                this.doEventuallyGet(tokens, successCallback, errorCallback);
            }, 100);
        }
        else {
            if (objects.length > 1) {
                successCallback(objects);
            }
            else {
                successCallback(objects[0]);
            }
        }
    }
    doGet(tokens, successCallback, errorCallback) {
        const { firstDiNotSetClass, firstMissingClassToken, objects } = this.doGetCore(tokens);
        if (firstDiNotSetClass) {
            console.log(`Dependency Injection is not ready for token ${firstMissingClassToken.getPath()}
			, class: ${firstDiNotSetClass.name}. Delaying injection by 100ms`);
            setTimeout(() => {
                this.doGet(tokens, successCallback, errorCallback);
            }, 100);
            return;
        }
        else if (objects.filter(object => object && !object.__initialized__).length) {
            const notInitializedObjectIndexes = objects.map((object, index) => object.__initialized__ ? -1 : index)
                .filter(index => index !== -1);
            const objectPaths = [];
            for (const index of notInitializedObjectIndexes) {
                objectPaths.push(tokens[index].getPath());
            }
            console.log(`Dependency Injection is not ready for tokens:
				 ${objectPaths.join('\n')}
			, these classes are not yet initialized, delaying injection by 100ms`);
            setTimeout(() => {
                this.doGet(tokens, successCallback, errorCallback);
            }, 100);
            return;
        }
        if (firstMissingClassToken) {
            const message = 'Dependency Injection could not find class for token: '
                + firstMissingClassToken.getPath();
            console.log(message);
            errorCallback(message);
        }
        else {
            if (objects.length > 1) {
                successCallback(objects);
            }
            else {
                successCallback(objects[0]);
            }
        }
    }
    doGetCore(tokens) {
        let firstMissingClassToken;
        let firstDiNotSetClass;
        const objects = tokens.map(token => {
            if (firstMissingClassToken || firstDiNotSetClass) {
                return;
            }
            let object = this.objectMap.get(token.descriptor.token);
            if (!object) {
                if (!this.rootContainer.isFramework && token.application.autopilot) {
                    object = this.getSync(AUTOPILOT_API_LOADER)
                        .loadApiAutopilot(token);
                }
                else {
                    // NOTE: object pooling is not supported, see RootContainer for why
                    // const rootObjectPool = this.rootContainer.objectPoolMap.get(token.descriptor.token);
                    // if (rootObjectPool && rootObjectPool.length) {
                    //     object = rootObjectPool.pop()
                    // } else {
                    const aClass = token.descriptor.class;
                    if (!aClass) {
                        firstMissingClassToken = token;
                        return;
                    }
                    if (aClass.diSet && !aClass.diSet()) {
                        firstMissingClassToken = token;
                        firstDiNotSetClass = aClass;
                        return;
                    }
                    object = new aClass();
                    this.setDependencyGetters(object, token);
                    // }
                }
                object.__container__ = this;
                this.objectMap.set(token.descriptor.token, object);
                if (!token.application.autopilot && object.init) {
                    const result = object.init();
                    if (result instanceof Promise) {
                        result.then(_ => {
                            object.__initialized__ = true;
                            console.log(`${token.getPath()} initialized.`);
                        });
                    }
                    else {
                        object.__initialized__ = true;
                        console.log(`${token.getPath()} initialized.`);
                    }
                }
                else {
                    object.__initialized__ = true;
                }
            }
            return object;
        });
        return {
            firstDiNotSetClass,
            firstMissingClassToken,
            objects
        };
    }
    setDependencyGetters(object, token) {
        if (!token.dependencyConfiguration) {
            return;
        }
        const dependencyConfiguration = token.dependencyConfiguration;
        for (let propertyName in dependencyConfiguration) {
            delete object[propertyName];
            const dependencyToken = dependencyConfiguration[propertyName];
            Object.defineProperty(object, propertyName, {
                get() {
                    return this.__container__.getSync(dependencyToken);
                }
            });
            object['get' + propertyName + 'Async'] = async function () {
                return await this.__container__.get(dependencyToken);
            };
        }
    }
    async getByNames(domainName, applicationName, tokenName) {
        const injectionDomain = domain(domainName);
        if (!injectionDomain) {
            throw new Error(`Could nof find
	Domain:
		${domainName}
		`);
        }
        const application = domain(domainName).getApp(applicationName);
        if (!application) {
            throw new Error(`Could not find
	Domain:
		${domainName}
	Application:
		${applicationName}
		`);
        }
        const token = application.tokenMap.get(tokenName);
        if (!token) {
            throw new Error(`Could not find token: ${tokenName}
	in Domain:
		${domainName}
 	Application:
			${applicationName}
		`);
        }
        return await this.get(token);
    }
    get(...tokens) {
        return new Promise((resolve, reject) => {
            this.doGet(tokens, resolve, reject);
        });
    }
    eventuallyGet(...tokens) {
        return new Promise((resolve, reject) => {
            this.doEventuallyGet(tokens, resolve, reject);
        });
    }
    getSync(...tokens) {
        const { firstDiNotSetClass, firstMissingClassToken, objects } = this.doGetCore(tokens);
        if (firstMissingClassToken) {
            throw new Error('Dependency Injection could not find class for token: '
                + firstMissingClassToken.getPath());
        }
        else if (firstDiNotSetClass) {
            throw new Error('Dependency Injection is not ready for class: '
                + firstDiNotSetClass.name);
        }
        if (objects.length > 1) {
            return objects;
        }
        else {
            return objects[0];
        }
    }
}

class RootContainer extends Container {
    constructor() {
        super(...arguments);
        this.isFramework = false;
        this.dbContainerMap = new Map();
        this.uiContainers = new Set();
    }
    // NOTE: Object pooling is not supported because of possible callbacks
    // that are out of synchronous flow of a transaction.  Thus objects are
    // retained in the container even after the container is removed
    // in order to allow for transactionId reference
    // objectPoolMap: Map<string, any[]> = new Map();
    db(id = null) {
        let dbContainer = this.dbContainerMap.get(id);
        if (!dbContainer) {
            dbContainer = new ChildContainer(this, new Context(id, ContextType.DB));
            this.dbContainerMap.set(id, dbContainer);
        }
        return dbContainer;
    }
    remove(container) {
        if (!container) {
            return;
        }
        const dbContainer = this.dbContainerMap.get(container.context.id);
        if (dbContainer) {
            this.dbContainerMap.delete(container.context.id);
            // NOTE: objectPooling is not supported, see above
            // const objectTokens = dbContainer.objectMap.keys()
            // for (const objectToken of objectTokens) {
            // const object = dbContainer.objectMap.get(objectToken)
            // let objectPool = this.objectPoolMap.get(objectToken)
            // if (!objectPool) {
            //     objectPool = []
            //     this.objectPoolMap.set(objectToken, objectPool)
            // }
            // objectPool.push(object)
            // }
        }
        else {
            this.uiContainers.delete(container);
        }
    }
    ui(componentName) {
        const context = new Context(componentName, ContextType.UI);
        const childContainer = new ChildContainer(this, context);
        this.uiContainers.add(childContainer);
        return childContainer;
    }
}
const DEPENDENCY_INJECTION = new RootContainer();

class InversionOfControl {
    async get(...tokens) {
        return await DEPENDENCY_INJECTION.db().get(...tokens);
    }
    async eventuallyGet(...tokens) {
        return await DEPENDENCY_INJECTION.db().eventuallyGet(...tokens);
    }
    getSync(...tokens) {
        return DEPENDENCY_INJECTION.db().getSync(...tokens);
    }
}

if (typeof window !== 'undefined') {
    window.DEPENDENCY_INJECTION = DEPENDENCY_INJECTION;
    window.lib = lib$1;
    window.domain = domain;
}
const IOC = new InversionOfControl();

var __decorate$2F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RepositoryLoader = class RepositoryLoader {
    /*
    Repository can be loaded because:
    - Repository is not present at all
    - Central: Last non-local Transaction Log timestamp is too old
    - Distributed:  Also stale timestamp but not as frequently (maybe once an hour)
    Immutable repositories are only loaded once
    */
    async loadRepository(repositorySource, repositoryUuId, context) {
        if (context.repositoryExistenceChecked) {
            return;
        }
        context.repositoryExistenceChecked = true;
        const repositoryLoadInfo = await this.repositoryDao.getRepositoryLoadInfo(repositorySource, repositoryUuId, context);
        let loadRepository = false;
        let lastSyncTimestamp = 0;
        if (!repositoryLoadInfo) {
            loadRepository = true;
        }
        else if (!repositoryLoadInfo.immutable) {
            loadRepository = true;
            for (const remoteRepositoryTransactionHistory of repositoryLoadInfo.repositoryTransactionHistory) {
                if (lastSyncTimestamp < remoteRepositoryTransactionHistory.saveTimestamp) {
                    lastSyncTimestamp = remoteRepositoryTransactionHistory.saveTimestamp;
                }
            }
        }
        if (!loadRepository) {
            return;
        }
        const now = new Date().getTime();
        const synchronizationAdapter = await this.synchronizationAdapterLoader
            .load(repositorySource);
        let messages;
        try {
            if (lastSyncTimestamp) {
                // If it's been less than 10 seconds, don't retrieve the repository
                if (lastSyncTimestamp >= now - 10000) {
                    return;
                }
                // Check 100 seconds back, in case there were update issues
                lastSyncTimestamp -= 100000;
                messages = await synchronizationAdapter.getTransactionsForRepository(repositorySource, repositoryUuId, lastSyncTimestamp);
            }
            else {
                messages = await synchronizationAdapter.getTransactionsForRepository(repositorySource, repositoryUuId);
            }
            // TODO: Add a special message for repository for adding users
            // into the repository 
            // each user will have a public key that they will distribute
            // each message is signed with the private key and the initial
            // message for repository is CREATE_REPOSITORY with the public 
            // key of the owner user
            const messageMapByUuId = new Map();
            for (const message of messages) {
                messageMapByUuId.set(message.history.uuId, message);
            }
            await this.synchronizationInManager.receiveMessages(messageMapByUuId, context);
        }
        catch (e) {
            console.error(e);
            return;
        }
    }
};
__decorate$2F([
    Inject()
], RepositoryLoader.prototype, "repositoryDao", void 0);
__decorate$2F([
    Inject()
], RepositoryLoader.prototype, "synchronizationAdapterLoader", void 0);
__decorate$2F([
    Inject()
], RepositoryLoader.prototype, "synchronizationInManager", void 0);
RepositoryLoader = __decorate$2F([
    Injected()
], RepositoryLoader);

/**
 * Created by Papa on 8/20/2016.
 */
const Id = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const Column = function (columnConfiguration) {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const JoinColumn = function (joinColumnConfiguration) {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const JoinColumns = function (joinColumnConfigurations) {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const Json = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const DbAny = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const DbBoolean = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const DbDate = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const DbNumber = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const DbString = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const Transient = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const ManyToOne = function (elements) {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const OneToMany = function (elements) {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const GeneratedValue = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const SequenceGenerator$1 = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};

/**
 * Created by Papa on 8/20/2016.
 */
const Entity = function () {
    return function (constructor) {
        // No runtime logic required.
    };
};
const Table = function (tableConfiguration) {
    return function (constructor) {
        // No runtime logic required.
    };
};
const MappedSuperclass = function () {
    return function (constructor) {
    };
};

/**
 * Created by Papa on 10/18/2016.
 */
const ALIASES = ['a', 'b', 'c', 'd', 'e',
    'f', 'g', 'h', 'i', 'j',
    'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z'];
class AliasCache {
    constructor(aliasPrefix = '') {
        this.aliasPrefix = aliasPrefix;
        this.reset();
    }
    getFollowingAlias() {
        let currentAlias = this.lastAlias;
        for (var i = 2; i >= 0; i--) {
            let currentIndex = currentAlias[i];
            currentIndex = (currentIndex + 1) % 26;
            currentAlias[i] = currentIndex;
            if (currentIndex !== 0) {
                break;
            }
        }
        let aliasString = this.aliasPrefix;
        for (var i = 0; i < 3; i++) {
            aliasString += ALIASES[currentAlias[i]];
        }
        if (aliasString === 'add') {
            aliasString = this.getFollowingAlias();
        }
        return aliasString;
    }
    reset() {
        this.lastAlias = [-1, -1, -1];
    }
}
class AliasMap {
    constructor(aliasCache) {
        this.aliasCache = aliasCache;
        this.aliasMap = new Map();
    }
    getNextAlias(object) {
        if (this.hasAliasFor(object)) {
            return this.getExistingAlias(object);
        }
        let aliasString = this.aliasCache.getFollowingAlias();
        this.aliasMap.set(object, aliasString);
        return aliasString;
    }
    hasAliasFor(object) {
        return this.aliasMap.has(object);
    }
}
class EntityAliases extends AliasMap {
    constructor(entityAliasCache = new AliasCache('E'), columnAliasCache = new AliasCache('C'), parameterAliasCache = new AliasCache('P')) {
        super(entityAliasCache);
        this.columnAliasCache = columnAliasCache;
        this.parameterAliases = new ParameterAliases(parameterAliasCache);
    }
    getParams( //
    ) {
        return this.parameterAliases;
    }
    getNewFieldColumnAliases() {
        return new FieldColumnAliases(this, this.columnAliasCache);
    }
    getExistingAlias(entity) {
        if (!this.hasAliasFor(entity)) {
            throw new Error(`No alias found for entity ${entity.__driver__.dbEntity.name}`);
        }
        return this.aliasMap.get(entity);
    }
    getOnlyAlias( //
    ) {
        if (this.aliasMap.size !== 1) {
            return `Expecting only 1 entry in Field's alias map`;
        }
        return this.aliasMap.get(this.aliasMap.keys().next().value);
    }
}
class ParameterAliases extends AliasMap {
    constructor(aliasCache) {
        super(aliasCache);
    }
    getNextAlias(object) {
        if (this.hasAliasFor(object)) {
            return this.getExistingAlias(object).alias;
        }
        let aliasString = this.aliasCache.getFollowingAlias();
        let parameter = {
            alias: aliasString,
            value: object.value
        };
        this.aliasMap.set(object, parameter);
        return aliasString;
    }
    getExistingAlias(field) {
        if (!this.hasAliasFor(field)) {
            throw new Error(`No alias found for a parameter`);
        }
        return this.aliasMap.get(field);
    }
    getParameters( //
    ) {
        let parameters = {};
        this.aliasMap.forEach((value, key) => {
            parameters[value.alias] = value;
        });
        return parameters;
    }
}
class FieldColumnAliases extends AliasMap {
    constructor(_entityAliases, aliasCache) {
        super(aliasCache);
        this._entityAliases = _entityAliases;
    }
    get entityAliases( //
    ) {
        return this._entityAliases;
    }
    getExistingAlias(field) {
        if (!this.hasAliasFor(field)) {
            const qField = field;
            throw new Error(`No alias found for property ${qField.dbProperty.entity.name}.${qField.dbProperty.name}`);
        }
        return this.aliasMap.get(field);
    }
}

/**
 * Created by Papa on 9/10/2016.
 */
const ALL_TABLE_COLUMNS = 'A';
class TableMap {
    constructor(applicationVersionId, tableMap = {}) {
        this.applicationVersionId = applicationVersionId;
        this.tableMap = tableMap;
    }
    ensure(tableIndex, allColumns = false, ColumnMapConstructor = ColumnMap) {
        let tableColumnMap = this.tableMap[tableIndex];
        if (!tableColumnMap) {
            tableColumnMap = new ColumnMapConstructor(tableIndex, allColumns);
            this.tableMap[tableIndex] = tableColumnMap;
        }
        return tableColumnMap;
    }
    existsByStructure(tableIndex, columnIndex) {
        let tableColumnMap = this.tableMap[tableIndex];
        if (!tableColumnMap) {
            return false;
        }
        return !!tableColumnMap.columnMap[columnIndex];
    }
}

class ColumnMap {
    constructor(tableIndex, allColumns = false) {
        this.tableIndex = tableIndex;
        this.columnMap = {};
        if (allColumns) {
            this.columnMap[ALL_TABLE_COLUMNS] = true;
        }
    }
    ensure(columnIndex) {
        this.columnMap[columnIndex] = true;
    }
}

var __decorate$2E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DbApplicationUtils = class DbApplicationUtils {
    getFullApplicationName({ domain, name, }) {
        if (domain.name) {
            domain = domain.name;
        }
        return this.getFullApplicationNameFromDomainAndName(domain, name);
    }
    getFullApplicationNameFromDomainAndName(domainName, applicationName) {
        if (domainName.indexOf('___') > -1) {
            throw new Error('Domain Name cannot contain "___" (3 consecutive underscores) in it.');
        }
        if (domainName.endsWith('.')
            || domainName.endsWith('-')
            || domainName.endsWith(':')
            || domainName.endsWith('__')) {
            throw new Error('Domain Name cannot end with ".", "-", ":" or "__"');
        }
        const domainPrefix = domainName
            .replace(/\./g, '_dot_')
            .replace(/-/g, '_dash_')
            .replace(/:/g, '_colon_');
        if (domainPrefix.indexOf('___') > -1) {
            throw new Error('Domain Name cannot have with ".", "-", ":", or "_" right next to each other.');
        }
        if (applicationName.indexOf('_') > -1) {
            throw new Error('Application Name cannot contain "_" in it.');
        }
        if (applicationName.indexOf('@') !== applicationName.lastIndexOf('@')) {
            throw new Error('Application Name cannot have more than one "@" in it.');
        }
        if (applicationName.indexOf('@') > 0) {
            throw new Error('Application Name cannot contain "@" after the first character in it.');
        }
        if (applicationName.indexOf('/') !== applicationName.lastIndexOf('/')) {
            throw new Error('Application Name cannot have more than one "/" in it.');
        }
        const applicationPrefix = applicationName
            .replace(/@/g, '_at_')
            .replace(/\//g, '_slash_')
            .replace(/-/g, '_dash_');
        if (applicationPrefix.endsWith('_')) {
            throw new Error('Application Name cannot end with "@", "/" or "."');
        }
        if (applicationPrefix.indexOf('___') > -1) {
            throw new Error('Application Name cannot have with "@", "/", "." or "_" right next to each other.');
        }
        let fullApplicationName = `${domainPrefix}___${applicationPrefix}`;
        if (!fullApplicationName.endsWith('_dash_runtime')) {
            fullApplicationName += '_dash_runtime';
        }
        return fullApplicationName;
    }
    getSequenceName(prefixedTableName, columnName) {
        return `${prefixedTableName}_${columnName}__SEQUENCE`;
    }
};
DbApplicationUtils = __decorate$2E([
    Injected()
], DbApplicationUtils);

class ApplicationMap {
    constructor(applicationMap = {}) {
        this.applicationMap = applicationMap;
    }
    ensureEntity(entity, allColumns = false, TableMapConstructor = TableMap) {
        return this.ensure(entity.applicationVersion.id, entity.index, allColumns, TableMapConstructor);
    }
    ensure(applicationIndex, tableIndex, allColumns = false, TableMapConstructor = TableMap) {
        let tableMap = this.applicationMap[applicationIndex];
        if (!tableMap) {
            tableMap = new TableMapConstructor(applicationIndex);
            this.applicationMap[applicationIndex] = tableMap;
        }
        return tableMap.ensure(tableIndex, allColumns);
    }
    existsByStructure(applicationIndex, tableIndex, columnIndex) {
        let tableMap = this.applicationMap[applicationIndex];
        if (!tableMap) {
            return false;
        }
        return tableMap.existsByStructure(tableIndex, columnIndex);
    }
}

class SyncColumnMap extends ColumnMap {
    constructor(tableIndex, allColumns = false) {
        super(tableIndex, allColumns);
    }
}

/**
 * Created by Papa on 10/7/2016.
 */
class SyncTableMap extends TableMap {
    constructor(applicationIndex, tableMap) {
        super(applicationIndex, tableMap);
    }
    ensureEntity(tableIndex, allColumns = false) {
        return super.ensure(tableIndex, allColumns, SyncColumnMap);
    }
    intersects(columnMap) {
        for (let tableIndex in this.tableMap) {
            if (columnMap.tableMap[tableIndex]) {
                let tableColumnMap = this.tableMap[tableIndex];
                let otherTableColumnMap = columnMap.tableMap[tableIndex];
                if (tableColumnMap[ALL_TABLE_COLUMNS] || tableColumnMap[ALL_TABLE_COLUMNS]) {
                    return true;
                }
                for (let columnIndex in tableColumnMap.columnMap) {
                    if (otherTableColumnMap.columnMap[columnIndex]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}

class SyncApplicationMap extends ApplicationMap {
    constructor(applicationMap) {
        super(applicationMap);
    }
    ensureEntity(entity, allColumns = false) {
        return super.ensureEntity(entity, allColumns, SyncTableMap);
    }
    intersects(applicationMap) {
        for (const applicationIndex in this.applicationMap) {
            if (applicationMap.applicationMap[applicationIndex]) {
                const syncTableMap = new SyncTableMap(parseInt(applicationIndex), this.applicationMap[applicationIndex].tableMap);
                if (syncTableMap.intersects(applicationMap.applicationMap[applicationIndex])) {
                    return true;
                }
            }
        }
        return false;
    }
}

var BlockSyncStatus;
(function (BlockSyncStatus) {
    // Sync request has been sent but no reply has come yet
    BlockSyncStatus["SYNCHRONIZING"] = "SYNCHRONIZING";
    // Sync has been acknowledged by the AGT
    BlockSyncStatus["SYNCHRONIZED"] = "SYNCHRONIZED";
    // Sync has not been acked by AGT so, requesting sync status from AGT
    BlockSyncStatus["REQUESTING_SYNC_STATUS"] = "REQUESTING_SYNC_STATUS";
    /*
       Do not re-sync until AGT starts responds with a request for more data.
       NOTE: no need of a separate status, state is maintained on SharingNode level.
     */
    // RESYNC_SUSPENDED = 'RESYNC_SUSPENDED',
    // AGT requested re-sync for this block, send it again
    BlockSyncStatus["RESYNC_REQUESTED"] = "RESYNC_REQUESTED";
})(BlockSyncStatus || (BlockSyncStatus = {}));
var RepositorySyncStatus;
(function (RepositorySyncStatus) {
    // Actively syncing this repository
    RepositorySyncStatus["ACTIVE"] = "ACTIVE";
    // AGT is not responding, temporarily pending AGT responses
    RepositorySyncStatus["PENDING"] = "PENDING";
    // AGT (or TM) delayed sync of this repository (for a period of time)
    RepositorySyncStatus["DELAYED"] = "DELAYED";
    // AGT (or TM) suspended sync of this repository
    RepositorySyncStatus["SUSPENDED"] = "SUSPENDED";
    // AGT (or TM) temporarily rerouted syncing of this repository to a different AGT
    RepositorySyncStatus["TEMPORARILY_REROUTED"] = "TEMPORARILY_REROUTED";
    // AGT (or TM) permanently rerouted syncing of this repository to a different AGT
    RepositorySyncStatus["PERMANENTLY_REROUTED"] = "PERMANENTLY_REROUTED";
})(RepositorySyncStatus || (RepositorySyncStatus = {}));
var TerminalSyncStatus;
(function (TerminalSyncStatus) {
    // Terminal is actively syncing
    TerminalSyncStatus["ACTIVE"] = "ACTIVE";
    // Terminal syncing has been suspended
    TerminalSyncStatus["SUSPENDED"] = "SUSPENDED";
})(TerminalSyncStatus || (TerminalSyncStatus = {}));

function ensureChildArray(parentContainer, index) {
    let childArray;
    if (parentContainer instanceof Map) {
        childArray = parentContainer.get(index);
    }
    else {
        childArray = parentContainer[index];
    }
    if (!childArray) {
        childArray = [];
        if (parentContainer instanceof Map) {
            parentContainer.set(index, childArray);
        }
        else {
            parentContainer[index] = childArray;
        }
    }
    return childArray;
}
function ensureChildMap(parentContainer, index) {
    let childObject;
    if (parentContainer instanceof Map) {
        childObject = parentContainer.get(index);
        if (!childObject) {
            childObject = {};
            parentContainer.set(index, childObject);
        }
    }
    else {
        childObject = parentContainer[index];
        if (!childObject) {
            childObject = {};
            parentContainer[index] = childObject;
        }
    }
    return childObject;
}
function ensureChildJsMap(parentContainer, index) {
    let childMap = parentContainer.get(index);
    if (!childMap) {
        childMap = new Map();
        parentContainer.set(index, childMap);
    }
    return childMap;
}
function ensureChildJsSet(parentContainer, index) {
    let childSet = parentContainer.get(index);
    if (!childSet) {
        childSet = new Set();
        parentContainer.set(index, childSet);
    }
    return childSet;
}
function undefinedToNull(value) {
    return value === undefined ? null : value;
}

/**
 * Column keys.
 */
var column;
(function (column) {
    /**
     * Name property of the column.
     * @type {string}
     */
    column.NAME = 'name';
    (function (type) {
        type.ANY = 'any';
        type.BOOLEAN = 'boolean';
        type.DATE = 'Date';
        type.NUMBER = 'number';
        type.STRING = 'string';
    })(column.type || (column.type = {}));
})(column || (column = {}));
/**
 * File level keys.
 */
var file;
(function (file) {
    file.ENTITY = 'Entity';
    file.TABLE = 'Table';
})(file || (file = {}));
/**
 * Entity configuration keys.
 */
var entity;
(function (entity) {
    entity.DATABASES = 'databases';
})(entity || (entity = {}));
/**
 * Foreign Key configuration keys.
 */
var foreignkey;
(function (foreignkey) {
    foreignkey.DEFINITION = 'foreignKeyDefinition';
    foreignkey.NAME = 'name';
    foreignkey.VALUE = 'value';
})(foreignkey || (foreignkey = {}));
/**
 * Index configuration keys.
 */
var index$1;
(function (index) {
    index.COLUMN_LIST = 'columnList';
    index.NAME = 'name';
    index.UNIQUE = 'unique';
})(index$1 || (index$1 = {}));
/**
 * JoinColumn configuration keys.
 */
var joincolumn;
(function (joincolumn) {
    joincolumn.FOREIGN_KEY = 'foreignKey';
    joincolumn.REFERENCED_COLUMN_NAME = 'referencedColumnName';
    joincolumn.VALUE = 'value';
})(joincolumn || (joincolumn = {}));
/**
 * Property annotation keys.
 */
var property;
(function (property) {
    property.COLUMN = 'Column';
    property.ENUM_TYPE = 'Enum';
    property.ID = 'Id';
    property.JOIN_COLUMN = 'JoinColumn';
    property.JOIN_COLUMNS = 'JoinColumns';
    property.JSON_TYPE = 'Json';
    property.MANY_TO_ONE = 'ManyToOne';
    property.ONE_TO_MANY = 'OneToMany';
    // R_JOIN_COLUMN(s) are not needed since Repository relations are now
    // standardized - simple (@ManyToOne) and (@OneToMany) suffice.
    // export const R_JOIN_COLUMN    = 'RJoinColumn';
    // export const R_JOIN_COLUMNS   = 'RJoinColumns';
    property.SUB_QUERY = 'SubQuery';
    // export const WHERE_JOIN_TABLE = 'WhereJoinTable';
})(property || (property = {}));
/**
 * OneToMany configuration keys.
 */
var onetomany;
(function (onetomany) {
    onetomany.MAPPED_BY = 'mappedBy';
})(onetomany || (onetomany = {}));
/**
 * Table configuration keys.
 */
var table;
(function (table) {
    table.INDEXES = 'indexes';
    table.NAME = 'name';
    table.PRIMARY_KEY = 'primaryKey';
    table.APPLICATION = 'application';
})(table || (table = {}));
/**
 * Name of the RepositoryId column
 * @type {string}
 */
var repositoryEntity;
(function (repositoryEntity) {
    repositoryEntity.ACTOR_ID = 'ACTOR_ID';
    repositoryEntity.ACTOR_RECORD_ID = 'ACTOR_RECORD_ID';
    repositoryEntity.ENTITY_NAME = 'RepositoryEntity';
    repositoryEntity.FOREIGN_KEY = 'REPOSITORY_ID';
    repositoryEntity.LOCAL_ENTITY_NAME = 'LocalRepositoryEntity';
    repositoryEntity.REPOSITORY_ID = 'REPOSITORY_ID';
    repositoryEntity.ORIGINAL_ACTOR_ID = 'ORIGINAL_ACTOR_ID';
    repositoryEntity.ORIGINAL_ACTOR_RECORD_ID = 'ORIGINAL_ACTOR_RECORD_ID';
    repositoryEntity.ORIGINAL_REPOSITORY_ID = 'ORIGINAL_REPOSITORY_ID';
    repositoryEntity.SYS_WIDE_OP_ID_APPLICATION = 'air____at_airport_slash_airport_dash_code';
    repositoryEntity.SYS_WIDE_OP_ID_ENTITY = 'SystemWideOperationId';
    repositoryEntity.systemWideOperationId = 'systemWideOperationId';
    repositoryEntity.SYSTEM_WIDE_OPERATION_ID = 'SYSTEM_WIDE_OPERATION_ID';
})(repositoryEntity || (repositoryEntity = {}));

/**
 * SQL Join contentType.
 */
var JoinType;
(function (JoinType) {
    JoinType["FULL_JOIN"] = "FULL_JOIN";
    JoinType["INNER_JOIN"] = "INNER_JOIN";
    JoinType["LEFT_JOIN"] = "LEFT_JOIN";
    JoinType["RIGHT_JOIN"] = "RIGHT_JOIN";
})(JoinType || (JoinType = {}));
/**
 * Type of Entity Relation
 */
var EntityRelationType;
(function (EntityRelationType) {
    EntityRelationType["ONE_TO_MANY"] = "ONE_TO_MANY";
    EntityRelationType["MANY_TO_ONE"] = "MANY_TO_ONE";
})(EntityRelationType || (EntityRelationType = {}));
/**
 * Serialized relation contentType.
 */
var JSONRelationType;
(function (JSONRelationType) {
    // Join of an entity with the ON clause
    JSONRelationType["ENTITY_JOIN_ON"] = "ENTITY_JOIN_ON";
    // Join of an entity via a application relation
    JSONRelationType["ENTITY_APPLICATION_RELATION"] = "ENTITY_APPLICATION_RELATION";
    // The root entity in a join
    JSONRelationType["ENTITY_ROOT"] = "ENTITY_ROOT";
    // Join of a sub-query (with the ON clause)
    JSONRelationType["SUB_QUERY_JOIN_ON"] = "SUB_QUERY_JOIN_ON";
    // The root sub-query in a join
    JSONRelationType["SUB_QUERY_ROOT"] = "SUB_QUERY_ROOT";
})(JSONRelationType || (JSONRelationType = {}));

/**
 * Order of a sorted field, as specified in the ORDER BY clause.
 */
var SortOrder;
(function (SortOrder) {
    SortOrder["ASCENDING"] = "ASCENDING";
    SortOrder["DESCENDING"] = "DESCENDING";
})(SortOrder || (SortOrder = {}));

/**
 * Extracted from http://www.w3schools.com/sql/sql_functions.asp
 */
var SqlFunction;
(function (SqlFunction) {
    // SQL Aggregate Functions
    // SQL aggregate functions return a single value, calculated from values in a column.
    // Useful Aggregate functions:
    SqlFunction["ABS"] = "ABS";
    SqlFunction["AVG"] = "AVG";
    SqlFunction["COUNT"] = "COUNT";
    //FIRST, // not in SqLite: Returns the first value
    //LAST, // not in SqLite: Returns the last value
    SqlFunction["MAX"] = "MAX";
    SqlFunction["MIN"] = "MIN";
    SqlFunction["SUM"] = "SUM";
    //SQL Scalar functions
    //SQL scalar functions return a single value, based on the input value.
    // Useful scalar functions:
    SqlFunction["UCASE"] = "UCASE";
    SqlFunction["LCASE"] = "LCASE";
    SqlFunction["MID"] = "MID";
    SqlFunction["LEN"] = "LEN";
    SqlFunction["ROUND"] = "ROUND";
    SqlFunction["NOW"] = "NOW";
    SqlFunction["FORMAT"] = "FORMAT";
    // Added
    SqlFunction["REPLACE"] = "REPLACE";
    SqlFunction["TRIM"] = "TRIM";
    // Other
    SqlFunction["DISTINCT"] = "DISTINCT";
    SqlFunction["EXISTS"] = "EXISTS";
    // Algebra Operators
    SqlFunction["DIVIDE"] = "DIVIDE";
    SqlFunction["MINUS"] = "MINUS";
    SqlFunction["MODULUS"] = "MODULUS";
    SqlFunction["MULTIPLY"] = "MULTIPLY";
    SqlFunction["PLUS"] = "PLUS";
    // Concatenate '||' functions
    SqlFunction["CONCATENATE"] = "CONCATENATE";
    // Other functions
    SqlFunction["COALESCE"] = "COALESCE";
})(SqlFunction || (SqlFunction = {}));

/**
 * All possible types of serialized JSON clauses.
 */
var JSONClauseObjectType;
(function (JSONClauseObjectType) {
    JSONClauseObjectType["FIELD"] = "FIELD";
    JSONClauseObjectType["FIELD_FUNCTION"] = "FIELD_FUNCTION";
    JSONClauseObjectType["FIELD_QUERY"] = "FIELD_QUERY";
    JSONClauseObjectType["DISTINCT_FUNCTION"] = "DISTINCT_FUNCTION";
    JSONClauseObjectType["EXISTS_FUNCTION"] = "EXISTS_FUNCTION";
    JSONClauseObjectType["MANY_TO_ONE_RELATION"] = "MANY_TO_ONE_RELATION"; // A many-to-one relation (used in a query)
})(JSONClauseObjectType || (JSONClauseObjectType = {}));
/**
 * Types of data
 */
var SQLDataType;
(function (SQLDataType) {
    // Allowing ANY allows developers to de-type their data
    SQLDataType["ANY"] = "ANY";
    SQLDataType["BOOLEAN"] = "BOOLEAN";
    SQLDataType["DATE"] = "DATE";
    // Allowing JSON allows developers to de-normalize their data
    SQLDataType["JSON"] = "JSON";
    SQLDataType["NUMBER"] = "NUMBER";
    SQLDataType["STRING"] = "STRING";
})(SQLDataType || (SQLDataType = {}));

var EntityState$1;
(function (EntityState) {
    EntityState["CREATE"] = "CREATE";
    EntityState["DATE"] = "DATE";
    EntityState["DELETE"] = "DELETE";
    // TODO: PARENT_ID is currently not implemented.  It is meant for @ManyToOne()
    // references when nothing is returned except for the id fields of the relation
    EntityState["PARENT_ID"] = "PARENT_ID";
    EntityState["PASS_THROUGH"] = "PASS_THROUGH";
    EntityState["STUB"] = "STUB";
    EntityState["UPDATE"] = "UPDATE";
    // Json fields promote application de-normalization and a currently not implemented
    // except for internal APIs
    // RESULT_JSON = 'RESULT_JSON',
    // RESULT_JSON_ARRAY = 'RESULT_JSON_ARRAY'
})(EntityState$1 || (EntityState$1 = {}));

/**
 * Category of a SQL contentType
 */
var OperationCategory;
(function (OperationCategory) {
    OperationCategory["BOOLEAN"] = "BOOLEAN";
    OperationCategory["DATE"] = "DATE";
    OperationCategory["FUNCTION"] = "FUNCTION";
    OperationCategory["LOGICAL"] = "LOGICAL";
    OperationCategory["NUMBER"] = "NUMBER";
    OperationCategory["STRING"] = "STRING";
    OperationCategory["UNTYPED"] = "UNTYPED"; // Operation on an untyped field
})(OperationCategory || (OperationCategory = {}));
var SqlOperator;
(function (SqlOperator) {
    SqlOperator["AND"] = "AND";
    SqlOperator["EQUALS"] = "EQUALS";
    SqlOperator["EXISTS"] = "EXISTS";
    SqlOperator["GREATER_THAN"] = "GREATER_THAN";
    SqlOperator["GREATER_THAN_OR_EQUALS"] = "GREATER_THAN_OR_EQUALS";
    SqlOperator["IN"] = "IN";
    SqlOperator["IS_NOT_NULL"] = "IS_NOT_NULL";
    SqlOperator["IS_NULL"] = "IS_NULL";
    SqlOperator["LESS_THAN"] = "LESS_THAN";
    SqlOperator["LESS_THAN_OR_EQUALS"] = "LESS_THAN_OR_EQUALS";
    SqlOperator["LIKE"] = "LIKE";
    SqlOperator["OR"] = "OR";
    SqlOperator["NOT"] = "NOT";
    SqlOperator["NOT_EQUALS"] = "NOT_EQUALS";
    SqlOperator["NOT_IN"] = "NOT_IN";
})(SqlOperator || (SqlOperator = {}));
var CRUDOperation;
(function (CRUDOperation) {
    CRUDOperation["CREATE"] = "CREATE";
    CRUDOperation["READ"] = "READ";
    CRUDOperation["UPDATE"] = "UPDATE";
    CRUDOperation["DELETE"] = "DELETE";
})(CRUDOperation || (CRUDOperation = {}));

var TransactionType;
(function (TransactionType) {
    TransactionType["LOCAL"] = "LOCAL";
    TransactionType["REMOTE_SYNC"] = "REMOTE_SYNC";
})(TransactionType || (TransactionType = {}));

var ChangeType;
(function (ChangeType) {
    ChangeType["DELETE_ROWS"] = "DELETE_ROWS";
    ChangeType["INSERT_VALUES"] = "INSERT_VALUES";
    ChangeType["UPDATE_ROWS"] = "UPDATE_ROWS";
})(ChangeType || (ChangeType = {}));

/**
 * Possible distribution strategies for Change List Federations.
 *
 * A common (and only currently supported) basic setup:
 *
 * There is always a Single Shared Store (S3).
 * There are always at least one or more 'Personal' Stores.
 *
 * The stores communicate via servers that propagate data from
 * personal stores to the shared store.
 *
 * What differs is how this propagation is accomplished.
 *
 * In the future, we'll add a truly distributed setup, without any S3s.
 */
var DistributionStrategy;
(function (DistributionStrategy) {
    /**
     *  The server is aware of all Personal Stores and it
     *  subscribes to any possible changes in any of these stores.
     *  It is the server's responsibility to update the S3.
     */
    DistributionStrategy["S3_SECURE_POLL"] = "S3_SECURE_POLL";
    /**
     * There is no need for a server, all clients are aware of S3
     * and are responsible for pushing their changes to it.
     */
    DistributionStrategy["S3_DISTIBUTED_PUSH"] = "S3_DISTIBUTED_PUSH";
})(DistributionStrategy || (DistributionStrategy = {}));

var QueryType;
(function (QueryType) {
    QueryType["DDL"] = "DDL";
    QueryType["SELECT"] = "SELECT";
    QueryType["MUTATE"] = "MUTATE";
})(QueryType || (QueryType = {}));

var PlatformType;
(function (PlatformType) {
    PlatformType["GOOGLE_DOCS"] = "GOOGLE_DOCS";
    PlatformType["IN_MEMORY"] = "IN_MEMORY";
    PlatformType["OFFLINE"] = "OFFLINE";
    PlatformType["STUB"] = "STUB";
})(PlatformType || (PlatformType = {}));

var StoreType;
(function (StoreType) {
    StoreType["COCKROACHDB"] = "COCKROACHDB";
    StoreType["MYSQL"] = "MYSQL";
    StoreType["POSTGRESQL"] = "POSTGRESQL";
    StoreType["REMOTE"] = "REMOTE";
    StoreType["SQLITE"] = "SQLITE";
    StoreType["SQLJS"] = "SQLJS";
    StoreType["WEB_SQL"] = "WEB_SQL";
})(StoreType || (StoreType = {}));
var IdGeneration;
(function (IdGeneration) {
    IdGeneration["ENTITY_CHANGE_ID"] = "ENTITY_CHANGE_ID";
})(IdGeneration || (IdGeneration = {}));

var JsonStatementType;
(function (JsonStatementType) {
    JsonStatementType["ENTITY_QUERY"] = "ENTITY_QUERY";
    JsonStatementType["NON_ENTITY_QUERY"] = "NON_ENTITY_QUERY";
})(JsonStatementType || (JsonStatementType = {}));

var QueryResultType;
(function (QueryResultType) {
    // Ordered query result with bridging for all MtOs and OtM
    QueryResultType["ENTITY_GRAPH"] = "ENTITY_GRAPH";
    // Ordered query result, with objects grouped hierarchically by entity
    QueryResultType["ENTITY_TREE"] = "ENTITY_TREE";
    // Ordered query result, with objects grouped hierarchically by mapping
    QueryResultType["TREE"] = "TREE";
    // Flat array query result, with no forced ordering or grouping
    QueryResultType["SHEET"] = "SHEET";
    // A single field query result, with no forced ordering or grouping
    QueryResultType["FIELD"] = "FIELD";
    // Raw result, returned by a SQL string query
    QueryResultType["RAW"] = "RAW";
    // ENTITY_GRAPH with all arrays returned as a MappedEntityArray
    QueryResultType["MAPPED_ENTITY_GRAPH"] = "MAPPED_ENTITY_GRAPH";
    // ENTITY_TREE with all arrays returned as a MappedEntityArray
    QueryResultType["MAPPED_ENTITY_TREE"] = "MAPPED_ENTITY_TREE";
})(QueryResultType || (QueryResultType = {}));

var OperationType;
(function (OperationType) {
    OperationType["DELETE"] = "DELETE";
    OperationType["FIND_ONE_GRAPH"] = "FIND_ONE_GRAPH";
    OperationType["FIND_ONE_TREE"] = "FIND_ONE_TREE";
    OperationType["FIND_GRAPH"] = "FIND_GRAPH";
    OperationType["FIND_TREE"] = "FIND_TREE";
    OperationType["SAVE"] = "SAVE";
    OperationType["SEARCH_ONE_GRAPH"] = "SEARCH_ONE_GRAPH";
    OperationType["SEARCH_ONE_TREE"] = "SEARCH_ONE_TREE";
    OperationType["SEARCH_GRAPH"] = "SEARCH_GRAPH";
    OperationType["SEARCH_TREE"] = "SEARCH_TREE";
})(OperationType || (OperationType = {}));
var QueryInputKind;
(function (QueryInputKind) {
    QueryInputKind["PARAMETER"] = "PARAMETER";
    QueryInputKind["Q"] = "Q";
    QueryInputKind["QENTITY"] = "QENTITY";
})(QueryInputKind || (QueryInputKind = {}));
var QueryParameterType;
(function (QueryParameterType) {
    QueryParameterType["BOOLEAN"] = "BOOLEAN";
    QueryParameterType["DATE"] = "DATE";
    QueryParameterType["NUMBER"] = "NUMBER";
    QueryParameterType["STRING"] = "STRING";
})(QueryParameterType || (QueryParameterType = {}));

var ApplicationStatus;
(function (ApplicationStatus) {
    ApplicationStatus["CURRENT"] = "CURRENT";
    ApplicationStatus["MISSING"] = "MISSING";
    ApplicationStatus["NEEDS_UPGRADES"] = "NEEDS_UPGRADES";
    ApplicationStatus["STUB"] = "STUB";
})(ApplicationStatus || (ApplicationStatus = {}));

const INTERNAL_APP = '@airport/terminal';
const INTERNAL_DOMAIN = 'internal://domain';

const groundControl = lib$1('ground-control');
const DB_APPLICATION_UTILS = groundControl.token({
    class: DbApplicationUtils,
    interface: 'IDbApplicationUtils',
    token: 'DB_APPLICATION_UTILS'
});
const ENTITY_STATE_MANAGER = groundControl.token({
    class: null,
    interface: 'IEntityStateManager',
    token: 'ENTITY_STATE_MANAGER'
});
groundControl.token({
    class: null,
    interface: 'IInterAppAPIClient',
    token: 'INTER_APP_API_CLIENT'
});
const OPERATION_CONTEXT_LOADER = groundControl.token({
    class: null,
    interface: 'IOperationContextLoader',
    token: 'OPERATION_CONTEXT_LOADER'
});
const TRANSACTIONAL_CONNECTOR = groundControl.token({
    class: null,
    interface: 'ITransactionalConnector',
    token: 'TRANSACTIONAL_CONNECTOR'
});
TRANSACTIONAL_CONNECTOR.setDependencies({
    dbApplicationUtils: DB_APPLICATION_UTILS,
});

/**
 * Created by Papa on 4/21/2016.
 */
class Operation {
    constructor(category) {
        this.category = category;
    }
}
class ValueOperation extends Operation {
    constructor(category) {
        super(category);
        this.category = category;
    }
    equals(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.EQUALS,
            r: rValue
        };
    }
    greaterThan(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.GREATER_THAN,
            r: rValue
        };
    }
    greaterThanOrEquals(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.GREATER_THAN_OR_EQUALS,
            r: rValue
        };
    }
    isNotNull(lValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.IS_NOT_NULL
        };
    }
    isNull(lValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.IS_NULL
        };
    }
    in(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.IN,
            r: rValue
        };
    }
    lessThan(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.LESS_THAN,
            r: rValue
        };
    }
    lessThanOrEquals(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.LESS_THAN_OR_EQUALS,
            r: rValue
        };
    }
    notEquals(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.NOT_EQUALS,
            r: lValue
        };
    }
    notIn(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.NOT_IN,
            r: rValue
        };
    }
}

/**
 * Created by Papa on 4/21/2016.
 */
const and = function (...ops) {
    return new LogicalOperation().and(ops);
};
const or = function (...ops) {
    return new LogicalOperation().or(ops);
};
const not = function (op) {
    return new LogicalOperation().not(op);
};
class LogicalOperation extends Operation {
    constructor() {
        super(null);
    }
    static verifyChildOps(ops) {
        if (!ops || !ops.length) {
            throw new Error(`No child operations provided`);
        }
    }
    and(ops) {
        return {
            c: OperationCategory.LOGICAL,
            o: SqlOperator.AND,
            v: ops
        };
    }
    or(ops) {
        return {
            c: OperationCategory.LOGICAL,
            o: SqlOperator.OR,
            v: ops
        };
    }
    not(op) {
        return {
            c: OperationCategory.LOGICAL,
            o: SqlOperator.NOT,
            v: op
        };
    }
}

/**
 * Created by Papa on 4/26/2016.
 */
/*
 * Cannot use 'class' syntax because it brakes dynamic creation of subclasses.
 * With 'class' browser reports:
 *   Class constructor QRelation cannot be invoked without 'new'
 * When calling:
 *   Q...Relation.base.constructor.call(this, relation, qEntity)
 */
function QRelation(dbRelation, parentQ, applicationUtils, relationManager) {
    this.dbRelation = dbRelation;
    this.parentQ = parentQ;
    this.applicationUtils = applicationUtils;
    this.relationManager = relationManager;
}
QRelation.prototype.innerJoin = function () {
    return this.getNewQEntity(JoinType.INNER_JOIN);
};
QRelation.prototype.leftJoin = function () {
    return this.getNewQEntity(JoinType.LEFT_JOIN);
};
QRelation.prototype.getNewQEntity = function (joinType) {
    const dbEntity = this.dbRelation.relationEntity;
    const qEntityConstructor = this.applicationUtils.getQEntityConstructor(this.dbRelation.relationEntity);
    let newQEntity = new qEntityConstructor(dbEntity, this.applicationUtils, this.relationManager, this.relationManager.getNextChildJoinPosition(this.parentQ.__driver__), this.dbRelation, joinType, this.applicationUtils, this.relationManager);
    newQEntity.__driver__.parentJoinEntity = this.parentQ;
    return newQEntity;
};
function QRepositoryEntityRelation(dbRelation, parentQ, applicationUtils, relationManager) {
    QRepositoryEntityRelation.base.constructor.call(this, dbRelation, parentQ, applicationUtils, relationManager);
}
QRepositoryEntityRelation.prototype.equals = function (entity) {
    let thisRelation = this;
    let other = entity;
    return and(thisRelation.actor.id.equals(other.actor.id), thisRelation.actorRecordId.equals(other.actorRecordId), thisRelation.id.equals(other.repository.id));
};
extend(QRelation, QRepositoryEntityRelation, {});

/**
 * Created by Papa on 6/20/2016.
 */
class BooleanOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.BOOLEAN);
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
class FieldInOrderBy {
    constructor(field, sortOrder) {
        this.field = field;
        this.sortOrder = sortOrder;
    }
    toJSON(columnAliases) {
        if (!columnAliases.hasAliasFor(this.field)) {
            throw new Error(`Field used in order by clause is not present in select clause`);
        }
        return {
            fa: columnAliases.getExistingAlias(this.field),
            so: this.sortOrder
        };
    }
    toEntityJSON() {
        let qField = this.field;
        return {
            fa: undefined,
            ci: qField.dbColumn.index,
            pi: qField.dbProperty.index,
            ti: qField.dbProperty.entity.index,
            si: qField.dbProperty.entity.applicationVersion.id,
            so: this.sortOrder
        };
    }
}

/**
 * Created by Papa on 4/21/2016.
 */
class QField {
    constructor(dbColumn, dbProperty, q, objectType) {
        this.dbColumn = dbColumn;
        this.dbProperty = dbProperty;
        this.q = q;
        this.objectType = objectType;
        this.__appliedFunctions__ = [];
    }
    /**
     protected getFieldKey() {
        let rootEntityPrefix = columnAliases.entityAliases.getExistingAlias(this.parentQ.getRootJoinEntity());
        let key = `${relationManager.getPositionAlias(rootEntityPrefix, this.parentQ.fromClausePosition)}.${this.fieldName}`;
        return key;
    }
     */
    applySqlFunction(sqlFunctionCall) {
        let appliedField = this.getInstance();
        appliedField.__appliedFunctions__.push(sqlFunctionCall);
        return appliedField;
    }
    toJSON(columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager) {
        let alias;
        if (forSelectClause) {
            alias = columnAliases.getNextAlias(this);
        }
        let rootEntityPrefix;
        if (this.__fieldSubQuery__) {
            rootEntityPrefix = columnAliases.entityAliases.getOnlyAlias();
        }
        else {
            rootEntityPrefix = columnAliases.entityAliases.getExistingAlias(this.q.__driver__.getRootJoinEntity());
        }
        let jsonField = {
            appliedFunctions: this.appliedFunctionsToJson(this.__appliedFunctions__, columnAliases, queryUtils, fieldUtils, relationManager),
            si: this.dbProperty.entity.applicationVersion.id,
            ti: this.dbProperty.entity.index,
            fa: alias,
            pi: this.dbProperty.index,
            ci: this.dbColumn.index,
            ta: relationManager.getPositionAlias(rootEntityPrefix, this.q.__driver__.fromClausePosition),
            ot: this.objectType,
            dt: this.dbColumn.type
        };
        if (this.__fieldSubQuery__) {
            jsonField.fieldSubQuery = fieldUtils.getFieldQueryJson(this.__fieldSubQuery__, columnAliases.entityAliases, queryUtils);
            jsonField.ot = JSONClauseObjectType.FIELD_QUERY;
        }
        return jsonField;
    }
    asc() {
        return new FieldInOrderBy(this, SortOrder.ASCENDING);
    }
    desc() {
        return new FieldInOrderBy(this, SortOrder.DESCENDING);
    }
    addSubQuery(subQuery) {
        let appliedField = this.getInstance();
        appliedField.__fieldSubQuery__ = subQuery;
        return appliedField;
    }
    operableFunctionToJson(functionObject, columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager) {
        let alias;
        if (forSelectClause) {
            alias = columnAliases.getNextAlias(this);
        }
        return {
            appliedFunctions: this.appliedFunctionsToJson(this.__appliedFunctions__, columnAliases, queryUtils, fieldUtils, relationManager),
            fa: alias,
            ot: this.objectType,
            dt: this.dbColumn.type,
            v: this.valueToJSON(functionObject, columnAliases, false, true, queryUtils, fieldUtils, relationManager)
        };
    }
    copyFunctions(field) {
        field.__appliedFunctions__ = this.__appliedFunctions__.slice();
        return field;
    }
    appliedFunctionsToJson(appliedFunctions, columnAliases, queryUtils, fieldUtils, relationManager) {
        if (!appliedFunctions) {
            return appliedFunctions;
        }
        return appliedFunctions.map((appliedFunction) => {
            return this.functionCallToJson(appliedFunction, columnAliases, queryUtils, fieldUtils, relationManager);
        });
    }
    functionCallToJson(functionCall, columnAliases, queryUtils, fieldUtils, relationManager) {
        let parameters;
        if (functionCall.p) {
            parameters = functionCall.p.map((parameter) => {
                return this.valueToJSON(parameter, columnAliases, false, false, queryUtils, fieldUtils, relationManager);
            });
        }
        return {
            ft: functionCall.ft,
            p: parameters
        };
    }
    valueToJSON(functionObject, columnAliases, forSelectClause, fromFunctionObject, queryUtils, fieldUtils, relationManager) {
        if (!functionObject) {
            throw new Error(`Function object must be provided to valueToJSON function.`);
        }
        if (!fromFunctionObject && functionObject instanceof QField) {
            return functionObject.toJSON(columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager);
        }
        let value = functionObject.value;
        switch (typeof value) {
            case 'boolean':
            case 'number':
            case 'string':
                return columnAliases.entityAliases.getParams()
                    .getNextAlias(functionObject);
            case 'object':
                if (value instanceof Date) {
                    return columnAliases.entityAliases.getParams()
                        .getNextAlias(functionObject);
                }
                else if (value instanceof Array) {
                    return columnAliases.entityAliases.getParams()
                        .getNextAlias(functionObject);
                }
                else if (value === null) {
                    return columnAliases.entityAliases.getParams()
                        .getNextAlias(functionObject);
                }
                else {
                    throw new Error(`Unexpected query parameter type allowed types are:
boolean | Date | Date[] | number | number[] | string | string[]
`);
                }
            case 'undefined':
                throw new Error(`Undefined is not allowed as a query parameter`);
            default:
                throw new Error(`Unexpected query parameter type allowed types are:
boolean | Date | Date[] | number | number[] | string | string[]
`);
        }
        // TODO: this never gets called, is this needed?
        /*
        if (value === null || value instanceof Date) {
            return columnAliases.entityAliases.getParams()
                .getNextAlias(functionObject as IQFunction<any>)
        }
        if (value instanceof QField) {
            return value.toJSON(columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager)
        }
        // must be a field sub-query
        let rawFieldQuery: RawFieldQuery<any> = value
        return fieldUtils.getFieldQueryJson(
            rawFieldQuery, columnAliases.entityAliases, queryUtils)
         */
    }
}

/**
 * Created by Papa on 10/25/2016.
 */
class QOperableField extends QField {
    constructor(dbColumn, dbProperty, q, objectType, operation) {
        super(dbColumn, dbProperty, q, objectType);
        this.operation = operation;
    }
    equals(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.equals(this, value);
    }
    greaterThan(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.greaterThan(this, value);
    }
    greaterThanOrEquals(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.greaterThanOrEquals(this, value);
    }
    isNotNull() {
        return this.operation.isNotNull(this);
    }
    isNull() {
        return this.operation.isNull(this);
    }
    in(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.in(this, value);
    }
    lessThan(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.lessThan(this, value);
    }
    lessThanOrEquals(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.lessThanOrEquals(this, value);
    }
    notEquals(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.notEquals(this, value);
    }
    notIn(values) {
        values = values.map((value) => {
            if (value instanceof Function) {
                return value();
            }
            return value;
        });
        return this.operation.notIn(this, values);
    }
}

class QBooleanField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new BooleanOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QBooleanField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
}
class QBooleanFunction extends QBooleanField {
    constructor(value, isQueryParameter = false) {
        super({ type: SQLDataType.BOOLEAN }, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = value;
        this.isQueryParameter = isQueryParameter;
    }
    getInstance() {
        return this.copyFunctions(new QBooleanFunction(this.value));
    }
    toJSON(columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager) {
        let json = this.operableFunctionToJson(this, columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager);
        if (this.isQueryParameter) {
            this.parameterAlias = json.v;
        }
        return json;
    }
}

/**
 * Created by Papa on 6/20/2016.
 */
class DateOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.DATE);
    }
}

class QDateField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new DateOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QDateField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
}
class QDateFunction extends QDateField {
    constructor(value, isQueryParameter = false) {
        super({ type: SQLDataType.DATE }, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = value;
        this.isQueryParameter = isQueryParameter;
    }
    getInstance() {
        return this.copyFunctions(new QDateFunction(this.value, this.isQueryParameter));
    }
    toJSON(columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager) {
        let json = this.operableFunctionToJson(this, columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager);
        if (this.isQueryParameter) {
            this.parameterAlias = json.v;
        }
        return json;
    }
}

/**
 * Created by Papa on 6/20/2016.
 */
class NumberOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.NUMBER);
    }
}

class QNumberField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new NumberOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QNumberField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
}
class QNumberFunction extends QNumberField {
    constructor(value, isQueryParameter = false) {
        super({ type: SQLDataType.NUMBER }, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = value;
        this.isQueryParameter = isQueryParameter;
    }
    getInstance() {
        return this.copyFunctions(new QNumberFunction(this.value, this.isQueryParameter));
    }
    toJSON(columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager) {
        let json = this.operableFunctionToJson(this, columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager);
        if (this.isQueryParameter) {
            this.parameterAlias = json.v;
        }
        return json;
    }
}

/**
 * Created by Papa on 6/20/2016.
 */
class StringOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.STRING);
    }
    like(lValue, rValue
    // TODO: implement ReqExp
    //| RegExp
    ) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.LIKE,
            r: rValue
        };
    }
}

class QStringField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new StringOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QStringField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
    like(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.like(this, value);
    }
}
class QStringFunction extends QStringField {
    constructor(value, isQueryParameter = false) {
        super({ type: SQLDataType.STRING }, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = value;
        this.isQueryParameter = isQueryParameter;
    }
    getInstance() {
        return this.copyFunctions(new QStringFunction(this.value, this.isQueryParameter));
    }
    toJSON(columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager) {
        let json = this.operableFunctionToJson(this, columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager);
        if (this.isQueryParameter) {
            this.parameterAlias = json.v;
        }
        return json;
    }
}

/**
 * Created by papa on 7/13/17.
 */
class UntypedOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.UNTYPED);
    }
    like(lValue, rValue
    // TODO: implement ReqExp
    //| RegExp
    ) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.LIKE,
            r: rValue
        };
    }
}

class QUntypedField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new UntypedOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QUntypedField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
    like(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.like(this, value);
    }
}

/**
 * From:
 * http://js-bits.blogspot.com/2010/08/javascript-inheritance-done-right.html
 * Via:
 * https://stackoverflow.com/questions/6617780/how-to-call-parent-constructor
 */
function extend(base, sub, methods) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    sub.base = base.prototype;
    // Copy the methods passed in to the prototype
    for (const name in methods) {
        sub.prototype[name] = methods[name];
    }
    // so we can define the constructor inline
    return sub;
}
function getColumnQField(entity, property, q, column) {
    switch (column.type) {
        case SQLDataType.ANY:
            return new QUntypedField(column, property, q);
        case SQLDataType.BOOLEAN:
            return new QBooleanField(column, property, q);
        case SQLDataType.DATE:
            return new QDateField(column, property, q);
        case SQLDataType.NUMBER:
            return new QNumberField(column, property, q);
        case SQLDataType.JSON:
        case SQLDataType.STRING:
            return new QStringField(column, property, q);
        default:
            throw new Error(`Unsupported data type for property ${entity.applicationVersion.application.name}.${entity.name}.${property.name}`);
    }
}
function getQRelation(entity, property, q, allQApplications, applicationUtils, relationManager) {
    const relation = property.relation[0];
    switch (relation.relationType) {
        case EntityRelationType.MANY_TO_ONE:
            const relationEntity = relation.relationEntity;
            const relationApplication = relationEntity.applicationVersion.application;
            const qIdRelationConstructor = allQApplications[relationApplication.index]
                .__qIdRelationConstructors__[relationEntity.index];
            return new qIdRelationConstructor(relation.relationEntity, relation, q, applicationUtils, relationManager);
        case EntityRelationType.ONE_TO_MANY:
            if (entity.isRepositoryEntity) {
                return new QRepositoryEntityOneToManyRelation(relation, q, applicationUtils, relationManager);
            }
            else {
                return new QOneToManyRelation(relation, q, applicationUtils, relationManager);
            }
        default:
            throw new Error(`Unknown EntityRelationType: ${relation.relationType}.`);
    }
}
function getQEntityConstructor(allQApplications) {
    // ChildQEntity refers to the constructor
    var ChildQEntity = function (entity, applicationUtils, relationManager, nextChildJoinPosition, dbRelation, joinType) {
        ChildQEntity.base.constructor.call(this, entity, applicationUtils, relationManager, nextChildJoinPosition, dbRelation, joinType);
        entity.properties.forEach((property) => {
            let qFieldOrRelation;
            if (property.relation && property.relation.length) {
                qFieldOrRelation = getQRelation(entity, property, this, allQApplications, applicationUtils, relationManager);
                for (const propertyColumn of property.propertyColumns) {
                    addColumnQField(entity, property, this, propertyColumn.column);
                }
            }
            else {
                qFieldOrRelation = addColumnQField(entity, property, this, property.propertyColumns[0].column);
            }
            this[property.name] = qFieldOrRelation;
        });
        // entity.__qConstructor__ = ChildQEntity
    };
    extend(QEntity, ChildQEntity, {});
    return ChildQEntity;
}
function addColumnQField(entity, property, q, column) {
    const qFieldOrRelation = getColumnQField(entity, property, q, column);
    q.__driver__.allColumns[column.index]
        = qFieldOrRelation;
    if (column.idIndex || column.idIndex === 0) {
        q.__driver__.idColumns[column.idIndex]
            = qFieldOrRelation;
    }
    return qFieldOrRelation;
}
function getQEntityIdRelationConstructor(dbEntity) {
    function QEntityIdRelation(entity, relation, qEntity, appliationUtils, relationManager) {
        QEntityIdRelation.base.constructor.call(this, relation, qEntity, appliationUtils, relationManager);
        getQEntityIdFields(this, entity, qEntity, relation.property);
        // (<any>entity).__qConstructor__.__qIdRelationConstructor__ = QEntityIdRelation
    }
    if (dbEntity.isRepositoryEntity) {
        extend(QRepositoryEntityRelation, QEntityIdRelation, {});
    }
    else {
        extend(QRelation, QEntityIdRelation, {});
    }
    return QEntityIdRelation;
}
/**
 * Set all fields behind an id relation.  For example
 *
 * QA.id
 *
 * or
 *
 * QA.rel1.id
 *
 * or
 *
 * QA.rel2.otherRel.id
 * QA.rel2.id
 *
 * @param addToObject  Object to add to (Ex: QA | QA.rel1 | QA.rel2.otherRel
 * @param relationEntity  Entity to which the fields belong (Ex: QA, QRel1, QRel2, QOtherRel)
 * @param utils
 * @param parentProperty  The parent property from which the current property was
 *    navigated to
 * @param relationColumnMap  DbColumn map for the current path of properties
 *  (QA.rel2.otherRel), keyed by the column from the One side of the relation
 */
function getQEntityIdFields(addToObject, relationEntity, qEntity, parentProperty, relationColumnMap) {
    if (!relationColumnMap) {
        const parentRelation = parentProperty.relation[0];
        const relationColumns = parentRelation.manyRelationColumns;
        relationColumnMap = new Map();
        for (const relationColumn of relationColumns) {
            relationColumnMap.set(relationColumn.oneColumn, relationColumn.manyColumn);
        }
    }
    relationEntity.properties.forEach((property) => {
        if (!property.isId) {
            return;
        }
        let qFieldOrRelation;
        // If it's a relation property (and therefore has backing columns)
        if (property.relation && property.relation.length) {
            const relation = property.relation[0];
            const relationColumns = relation.manyRelationColumns;
            for (const relationColumn of relationColumns) {
                const originalColumn = relationColumnMap.get(relationColumn.manyColumn);
                // Remove the mapping of the parent relation
                relationColumnMap.delete(relationColumn.manyColumn);
                // And replace it with the nested relation
                relationColumnMap.set(relationColumn.oneColumn, originalColumn);
            }
            qFieldOrRelation = getQEntityIdFields({}, relation.relationEntity, qEntity, parentProperty, relationColumnMap);
        }
        else {
            const originalColumn = relationColumnMap.get(property.propertyColumns[0].column);
            qFieldOrRelation = getColumnQField(relationEntity, parentProperty, qEntity, originalColumn);
        }
        addToObject[property.name] = qFieldOrRelation;
    });
    return addToObject;
}
function setQApplicationEntities(application, qApplication, allQApplications, appliationUtils, relationManager) {
    // const entities = orderEntitiesByIdDependencies(application.currentVersion[0].applicationVersion.entities,
    // application)
    qApplication.__qIdRelationConstructors__ = [];
    qApplication.__qConstructors__ = {};
    // let haveMissingDependencies
    // do {
    // 	haveMissingDependencies = false
    // NOTE: only need to compute the keys of entities for Many-to-One(s)
    // Many-to-Ones must reference the table by primary key in order to
    // guarantee a single record.  Any other type of join may return multiple
    // records and is in fact a Many-to-Many
    application.currentVersion[0].applicationVersion.entities.forEach((
    // entities.forEach((
    entity) => {
        // NOTE: an @Id column is guaranteed to be present in only one property
        for (const idColumn of entity.idColumns) {
            if (idColumn.manyRelationColumns
                && idColumn.manyRelationColumns.length) {
                const oneColumn = idColumn.manyRelationColumns[0].oneColumn;
                const relatedEntity = oneColumn.entity;
                const relatedQApplication = allQApplications[relatedEntity.applicationVersion.application.index];
                if (!relatedQApplication) {
                    throw new Error(`QApplication not yet initialized for ID relation:
					${entity.name}.${oneColumn.name}
					`);
                }
                // const manyColumn = idColumn.manyRelationColumns[0].manyColumn
                // if (relatedEntity.id === manyColumn.entity.id
                // 	&& relatedEntity.applicationVersion.application.index
                // 	=== manyColumn.entity.applicationVersion.application.index) {
                // 	continue
                // }
                // const relatedQEntityConstructor =
                // qApplication.__qConstructors__[relatedEntity.index] if (!relatedQEntityConstructor)
                // { throw new Error(`QEntity not yet initialized for ID relation:
                // ${entity.name}.${manyColumn.name} `) haveMissingDependencies = true }
            }
        }
        const qIdRelationConstructor = getQEntityIdRelationConstructor(entity);
        qApplication.__qIdRelationConstructors__[entity.index] = qIdRelationConstructor;
        // TODO: compute many-to-many relations
        const qConstructor = getQEntityConstructor(allQApplications);
        qApplication.__qConstructors__[entity.index] = qConstructor;
        if (!Object.getOwnPropertyNames(qApplication)
            .filter(propertyName => propertyName === entity.name).length) {
            Object.defineProperty(qApplication, entity.name, {
                get: function () {
                    return new this.__qConstructors__[entity.index](entity, appliationUtils, relationManager);
                }
            });
        }
    });
    // } while (haveMissingDependencies)
}
function orderApplicationsInOrderOfPrecedence(applications) {
    const applicationWithDepsMap = new Map();
    const applicationsWithDeps = applications.map(application => {
        const dependencies = new Set();
        for (const applicationReference of application.currentVersion[0]
            .applicationVersion.references) {
            dependencies.add(applicationReference.referencedApplicationVersion.application.index);
        }
        const applicationWithDependencies = {
            application,
            dependencies
        };
        applicationWithDepsMap.set(application.index, applicationWithDependencies);
        return applicationWithDependencies;
    });
    applicationsWithDeps.sort((orderedApplication1, orderedApplication2) => {
        if (applicationDependsOn(orderedApplication1, orderedApplication2.application.index)) {
            return 1;
        }
        else if (applicationDependsOn(orderedApplication2, orderedApplication1.application.index)) {
            return -1;
        }
        return 0;
    });
    return applicationsWithDeps.map(applicationWithDeps => applicationWithDeps.application);
}
function applicationDependsOn(dependantApplication, dependsOnApplicationIndex, applicationWithDepsMap) {
    if (dependantApplication.dependencies.has(dependsOnApplicationIndex)) {
        return true;
    }
    // for(const dependencyApplicationIndex of dependantApplication.dependencies) {
    //
    // }
    return false;
}

/**
 * Created by Papa on 10/25/2016.
 */
/*
 * Cannot use 'class' syntax because it brakes dynamic creation of subclasses.
 * With 'class' browser reports:
 *   Class constructor QRelation cannot be invoked without 'new'
 * When calling:
 *   Q...Relation.base.constructor.call(this, relation, qEntity)
 */
function QOneToManyRelation(dbRelation, parentQ, applicationUtils, repationManager) {
    QOneToManyRelation.base.constructor.call(this, dbRelation, parentQ, applicationUtils, repationManager);
}
extend(QRelation, QOneToManyRelation, {});
function QRepositoryEntityOneToManyRelation(dbRelation, parentQ, applicationUtils, repationManager) {
    QRepositoryEntityOneToManyRelation.base.constructor.call(this, dbRelation, parentQ, applicationUtils, repationManager);
}
extend(QRepositoryEntityRelation, QRepositoryEntityOneToManyRelation, {});

/**
 * Created by Papa on 11/29/2016.
 */
class QNullFunction extends QField {
    constructor() {
        super(null, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = null;
    }
    getInstance() {
        return this.copyFunctions(new QNullFunction());
    }
    toJSON(columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager) {
        return this.operableFunctionToJson(this, columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager);
    }
}

/**
 * Created by Papa on 12/31/2016.
 */
const bool = function (primitive) {
    if (typeof primitive !== 'boolean') {
        throw new Error(`bool() accepts booleans only.`);
    }
    return new QBooleanFunction(primitive);
};
const date = function (primitive) {
    if (!(primitive instanceof Date)) {
        throw new Error(`date() accepts Dates only.`);
    }
    return new QDateFunction(primitive);
};
const num = function (primitive) {
    if (typeof primitive !== 'number') {
        throw new Error(`num() accepts numbers only.`);
    }
    return new QNumberFunction(primitive);
};
const str = function (primitive) {
    if (typeof primitive !== 'string') {
        throw new Error(`str() accepts strings only.`);
    }
    return new QStringFunction(primitive);
};
function wrapPrimitive(value) {
    switch (typeof value) {
        case 'boolean':
            return bool(value);
        case 'number':
            return num(value);
        case 'string':
            return str(value);
        case 'undefined':
            throw new Error(`Cannot use an 'undefined' value in an operation.`);
    }
    if (value === null) {
        return new QNullFunction();
    }
    if (value instanceof Date) {
        return date(value);
    }
    return value;
}
function getPrimitiveValue(value, dbColumn, rowIndex, datesToNumbers = true) {
    switch (dbColumn.type) {
        case SQLDataType.ANY: {
            assertDataType([
                'boolean', 'number', 'object', 'string'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.BOOLEAN: {
            assertDataType([
                'boolean'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.DATE: {
            assertDataType([
                'number', 'object'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.JSON: {
            assertDataType([
                'object'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.NUMBER: {
            assertDataType([
                'number'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.STRING: {
            assertDataType([
                'string'
            ], dbColumn, rowIndex, value);
            break;
        }
        default:
            throw new Error('Unexpected SQLDataType: ' + dbColumn.type);
    }
    switch (typeof value) {
        case 'boolean':
            return value ? 1 : 0;
        case 'number':
        case 'string':
            // FIXME: prevent SQL injection
            return value;
        case 'object': {
            if (value === null) {
                return value;
            }
            if (value instanceof Date) {
                if (dbColumn.type !== SQLDataType.DATE) {
                    throw new Error(`Unexpected Date object for row: ${rowIndex + 1}, column: ${getColumnName(dbColumn)}`);
                }
                return datesToNumbers ? value.getTime() : value;
            }
            else {
                if (dbColumn.type !== SQLDataType.JSON) {
                    throw new Error(`Unexpected Json object for row: ${rowIndex + 1}, column: ${getColumnName(dbColumn)}`);
                }
                return JSON.stringify(value);
            }
        }
        case 'undefined':
            throw new Error(`Cannot use an 'undefined' value in an operation.`);
        default:
            throw new Error(`Unexpected object in operation.`);
    }
}
function assertDataType(typesOfData, dbColumn, rowIndex, value) {
    if (typesOfData.indexOf(typeof value) < -1) {
        const expectedDataTypes = typesOfData.join(', ');
        throw new Error(`Unexpected typeof value for row: ${rowIndex + 1}, column: ${getColumnName(dbColumn)}.  Expecting: ${expectedDataTypes}`);
    }
}
function getColumnName(dbColumn) {
    return dbColumn.name
        ? dbColumn.name
        : dbColumn.propertyColumns[0].property.name;
}

function getSqlFunctionCall(sqlFunction, parameters) {
    if (parameters) {
        parameters = parameters.map((parameter) => {
            switch (typeof parameter) {
                case 'boolean':
                    return bool(parameter);
                case 'number':
                    return num(parameter);
                case 'string':
                    return str(parameter);
                case 'undefined':
                    throw new Error(`'undefined' cannot be used as a function parameter`);
            }
            if (parameter instanceof Date) {
                return date(parameter);
            }
            return parameter;
        });
    }
    return {
        ft: sqlFunction,
        p: parameters
    };
}
const abs = function (numeric) {
    if (numeric instanceof QNumberField) {
        return numeric.applySqlFunction(getSqlFunctionCall(SqlFunction.AVG));
    }
    else {
        return new QNumberFunction(numeric).applySqlFunction(getSqlFunctionCall(SqlFunction.ABS));
    }
};
const avg = function (numeric) {
    if (numeric instanceof QNumberField) {
        return numeric.applySqlFunction(getSqlFunctionCall(SqlFunction.AVG));
    }
    else {
        return new QNumberFunction(numeric).applySqlFunction(getSqlFunctionCall(SqlFunction.AVG));
    }
};
function getFunctionObject(value) {
    switch (typeof value) {
        case 'boolean':
            return new QBooleanFunction(value);
        case 'number':
            return new QNumberFunction(value);
        case 'string':
            return new QStringFunction(value);
    }
    if (value instanceof Date) {
        return new QDateFunction(value);
    }
    let selectClause = value.select;
    if (selectClause instanceof QDistinctFunction) {
        selectClause = selectClause.getSelectClause();
    }
    if (selectClause instanceof QBooleanField) {
        return new QBooleanFunction(value);
    }
    else if (selectClause instanceof QDateField) {
        return new QDateFunction(value);
    }
    else if (selectClause instanceof QNumberField) {
        return new QNumberFunction(value);
    }
    else if (selectClause instanceof QStringField) {
        return new QStringFunction(value);
    }
    throw new Error(`Function rValue must be a primitive, Date, Field or Field query`);
}
const count = function (value) {
    if (value instanceof QOperableField) {
        return value.applySqlFunction(getSqlFunctionCall(SqlFunction.COUNT));
    }
    else {
        return getFunctionObject(value)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.COUNT));
    }
};
const max = function (value) {
    if (value instanceof QOperableField) {
        return value.applySqlFunction(getSqlFunctionCall(SqlFunction.MAX));
    }
    else {
        return getFunctionObject(value)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MAX));
    }
};
const min = function (value) {
    if (value instanceof QOperableField) {
        return value.applySqlFunction(getSqlFunctionCall(SqlFunction.MIN));
    }
    else {
        return getFunctionObject(value)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MIN));
    }
};
const sum = function (numeric) {
    if (numeric instanceof QNumberField) {
        return numeric.applySqlFunction(getSqlFunctionCall(SqlFunction.SUM));
    }
    else {
        return new QNumberFunction(numeric)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.SUM));
    }
};
const plus = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.PLUS, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.PLUS, [numeric2]));
    }
};
const ucase = function (stringValue) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.UCASE));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.UCASE));
    }
};
const lcase = function (stringValue) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.LCASE));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.LCASE));
    }
};
const mid = function (stringValue, start, length) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.MID, [start, length]));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MID, [start, length]));
    }
};
const len = function (stringValue) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.LEN));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.LEN));
    }
};
const round = function (numeric, digits = 0) {
    if (numeric instanceof QNumberField) {
        return numeric.applySqlFunction(getSqlFunctionCall(SqlFunction.ROUND, [digits]));
    }
    else {
        return new QNumberFunction(numeric)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.ROUND, [digits]));
    }
};
const now$1 = function () {
    return new QDateFunction(null)
        .applySqlFunction(getSqlFunctionCall(SqlFunction.NOW));
};
const format = function (format, ...formatParameters) {
    if (format instanceof QStringField) {
        return format.applySqlFunction(getSqlFunctionCall(SqlFunction.FORMAT, formatParameters));
    }
    else {
        return new QStringFunction(format)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.FORMAT, formatParameters));
    }
};
const replace = function (stringValue, toReplace, replaceWith) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.REPLACE, [toReplace, replaceWith]));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.REPLACE, [toReplace, replaceWith]));
    }
};
const trim = function (stringField) {
    if (stringField instanceof QStringField) {
        return stringField.applySqlFunction(getSqlFunctionCall(SqlFunction.TRIM));
    }
    else {
        return new QStringFunction(stringField)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.TRIM));
    }
};
class StandAloneFunction {
}
const distinct = function (selectClause) {
    let distinctFunction = new QDistinctFunction(selectClause);
    distinctFunction.applySqlFunction(getSqlFunctionCall(SqlFunction.DISTINCT));
    return distinctFunction;
};
class QDistinctFunction extends StandAloneFunction {
    constructor(selectClause) {
        super();
        this.selectClause = selectClause;
        this.__appliedFunctions__ = [];
    }
    static getSelect(distinct) {
        return distinct.__appliedFunctions__[0].p[0];
    }
    applySqlFunction(sqlFunctionCall) {
        this.__appliedFunctions__.push(sqlFunctionCall);
        return this;
    }
    getSelectClause() {
        return this.selectClause;
    }
    toJSON(parsedSelectClause) {
        if (this.__appliedFunctions__.length != 1) {
            throw new Error(`Not expecting and parent or child functions on "distinct"`);
        }
        if (!this.selectClause) {
            throw new Error(`SELECT clause is missing in "distinct" function.`);
        }
        let appliedFunctions = [
            getSqlFunctionCall(SqlFunction.DISTINCT)
        ];
        return {
            appliedFunctions: appliedFunctions,
            dt: null,
            fa: null,
            ot: JSONClauseObjectType.DISTINCT_FUNCTION,
            v: parsedSelectClause
        };
    }
}
const exists = function (rawQuery) {
    let selectClause = rawQuery.select;
    if (!selectClause) {
        throw new Error(`Sub-Query must have SELECT clause defined to be used in EXITS function`);
    }
    let existsFunction = new QExistsFunction(rawQuery);
    return existsFunction.applySqlFunction(getSqlFunctionCall(SqlFunction.EXISTS));
};
class QExistsFunction extends StandAloneFunction {
    constructor(subQuery) {
        super();
        this.subQuery = subQuery;
        this.__appliedFunctions__ = [];
        this.operator = SqlOperator.EXISTS;
        this.o = SqlOperator.EXISTS;
        this.category = OperationCategory.FUNCTION;
        this.c = OperationCategory.FUNCTION;
    }
    applySqlFunction(sqlFunctionCall) {
        this.__appliedFunctions__.push(sqlFunctionCall);
        return this;
    }
    getQuery() {
        return this.subQuery;
    }
    toJSON(parsedQuery) {
        if (this.__appliedFunctions__.length != 1) {
            throw new Error(`Not expecting and parent or child functions on "exists"`);
        }
        if (!this.subQuery) {
            throw new Error(`Subquery is not defined in "exists" function.`);
        }
        let appliedFunctions = [
            getSqlFunctionCall(SqlFunction.EXISTS)
        ];
        return {
            c: this.category,
            ob: {
                appliedFunctions: appliedFunctions,
                dt: null,
                ot: JSONClauseObjectType.EXISTS_FUNCTION,
                v: parsedQuery
            },
            o: this.operator
        };
    }
}
// Algebra Operators
const divide = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.DIVIDE, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.DIVIDE, [numeric2]));
    }
};
const subtract = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.MINUS, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MINUS, [numeric2]));
    }
};
const modulus = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.MODULUS, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MODULUS, [numeric2]));
    }
};
const multiply = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.MULTIPLY, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MULTIPLY, [numeric2]));
    }
};
const add$2 = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.PLUS, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.PLUS, [numeric2]));
    }
};
const concat = function (//
...fragments) {
    if (fragments.length > 2) {
        throw new Error(`Less than two operands passed to 'concat' function.`);
    }
    let firstFragment = fragments[0];
    let restOfFragments = fragments.slice(1);
    if (firstFragment instanceof QStringField) {
        return firstFragment.applySqlFunction(getSqlFunctionCall(SqlFunction.CONCATENATE, restOfFragments));
    }
    else {
        return new QStringFunction(firstFragment)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.CONCATENATE, restOfFragments));
    }
};
/**
 * A
 * UNION
 * B
 */
const union = function (...rawQueries) {
    throw new Error('not implemented');
};
/**
 * A
 * UNION ALL
 * B
 */
const unionAll = function (...rawQueries) {
    throw new Error('not implemented');
};
/**
 * A
 * INTERSECT
 * B
 */
const intersect = function (...rawQueries) {
    throw new Error('not implemented');
};
/**
 * A
 * MINUS
 * B
 */
const except = function (...rawQueries) {
    throw new Error('not implemented');
};
/**
 * A
 * MINUS
 * B
 */
const minus = except;

/**
 * Created by Papa on 10/27/2016.
 */
class AbstractQuery {
    constructor(entityAliases = new EntityAliases(), columnAliases = entityAliases.getNewFieldColumnAliases()) {
        this.entityAliases = entityAliases;
        this.columnAliases = columnAliases;
        this.isEntityQuery = false;
    }
    getParameters( //
    ) {
        return this.entityAliases.getParams().getParameters();
    }
    getNonEntityQuery(rawQuery, jsonQuery, createSelectCallback, queryUtils, fieldUtils, relationManager) {
        let from = this.fromClauseToJSON(rawQuery.from, queryUtils, fieldUtils, relationManager);
        jsonQuery.F = from;
        if (createSelectCallback) {
            createSelectCallback(jsonQuery);
        }
        jsonQuery.W = queryUtils.whereClauseToJSON(rawQuery.where, this.columnAliases);
        jsonQuery.GB = this.groupByClauseToJSON(rawQuery.groupBy);
        jsonQuery.H = queryUtils.whereClauseToJSON(rawQuery.having, this.columnAliases);
        jsonQuery.OB = this.orderByClauseToJSON(rawQuery.orderBy);
        jsonQuery.L = rawQuery.limit;
        jsonQuery.O = rawQuery.offset;
        return jsonQuery;
    }
    fromClauseToJSON(fromClause, queryUtils, fieldUtils, relationManager) {
        if (!fromClause) {
            if (this.isEntityQuery) {
                return [];
            }
            else {
                throw new Error('From clause must be present in a non-Entity based query.');
            }
        }
        return fromClause.map((fromEntity) => {
            if (!(fromEntity instanceof QEntity)) {
                throw new Error(`FROM clause can contain only Views or Entities.`);
            }
            if (this.isEntityQuery) {
                if (fromEntity instanceof QTree) {
                    throw new Error(`Entity FROM clauses can contain only Entities.`);
                }
            }
            return fromEntity.__driver__
                .getRelationJson(this.columnAliases, queryUtils, fieldUtils, relationManager);
        });
    }
    groupByClauseToJSON(groupBy) {
        if (!groupBy || !groupBy.length) {
            return null;
        }
        return groupBy.map((field) => {
            if (!this.columnAliases.hasAliasFor(field)) {
                throw new Error(`Field used in group by clause is not present in select clause`);
            }
            return {
                fa: this.columnAliases.getExistingAlias(field)
            };
        });
    }
    orderByClauseToJSON(orderBy) {
        if (!orderBy || !orderBy.length) {
            return null;
        }
        return orderBy.map((field) => {
            return field.toJSON(this.columnAliases);
        });
    }
}

/**
 * Created by Papa on 10/24/2016.
 */
const NON_ENTITY_SELECT_ERROR_MESSAGE = `Unsupported entry in Non-Entity SELECT clause, must be a(n): Entity Field | ManyToOne Relation | primitive wrapped by "bool","date","num","str" | query wrapped by "field"`;
class DistinguishableQuery extends AbstractQuery {
    constructor(entityAliases) {
        super(entityAliases);
        this.isHierarchicalEntityQuery = false;
    }
    selectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager) {
        if (rawSelect instanceof QDistinctFunction) {
            if (this.isHierarchicalEntityQuery) {
                throw new Error(`Distinct cannot be used in SELECT of Hierarchical/Bridged Entity queries.`);
            }
            let rawInnerSelect = rawSelect.getSelectClause();
            let innerSelect = this.nonDistinctSelectClauseToJSON(rawInnerSelect, queryUtils, fieldUtils, relationManager);
            return rawSelect.toJSON(innerSelect);
        }
        else {
            return this.nonDistinctSelectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager);
        }
    }
}

/**
 * Created by Papa on 10/24/2016.
 */
const FIELD_IN_SELECT_CLAUSE_ERROR_MESSAGE = `Entity SELECT clauses can only contain fields assigned: null | undefined | boolean | Date | number | string | Relation SELECT`;
/**
 * A query whose select facade is a collection of properties.
 */
class MappableQuery extends DistinguishableQuery {
    nonDistinctSelectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager) {
        let select = {};
        for (let property in rawSelect) {
            let value = rawSelect[property];
            if (value instanceof QField) {
                if (this.isEntityQuery) {
                    throw new Error(FIELD_IN_SELECT_CLAUSE_ERROR_MESSAGE);
                }
                // The same value may appear in the select clause more than once.
                // In that case the last one will set the alias for all of them.
                // Because the alias only matters for GROUP BY and ORDER BY
                // that is OK.
                select[property] = value.toJSON(this.columnAliases, true, queryUtils, fieldUtils, relationManager);
            }
            else if (value instanceof QOneToManyRelation
                || value instanceof QRepositoryEntityOneToManyRelation) {
                throw new Error(`@OneToMany relation objects can cannot be used in SELECT clauses`);
            } // Must be a primitive
            else {
                let isChildObject = false;
                try {
                    // Must be an entity query here
                    switch (typeof value) {
                        case 'boolean':
                        case 'number':
                        case 'string':
                        case 'undefined':
                            continue;
                        case 'object':
                            if (value instanceof Date) {
                            }
                            else if (value === null) {
                            }
                            else {
                                isChildObject = true;
                                select[property] = this.nonDistinctSelectClauseToJSON(value, queryUtils, fieldUtils, relationManager);
                            }
                    }
                }
                finally {
                    if (!isChildObject && !this.isEntityQuery) {
                        throw new Error(NON_ENTITY_SELECT_ERROR_MESSAGE);
                    }
                }
            }
        }
        return select;
    }
}
class TreeQuery extends MappableQuery {
    constructor(rawQuery, entityAliases = new EntityAliases()) {
        super(entityAliases);
        this.rawQuery = rawQuery;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        let jsonMappedQuery = this.getNonEntityQuery(this.rawQuery, {}, (jsonQuery) => {
            jsonQuery.S = this.selectClauseToJSON(this.rawQuery.select, queryUtils, fieldUtils, relationManager);
        }, queryUtils, fieldUtils, relationManager);
        return jsonMappedQuery;
    }
}

/**
 * Created by Papa on 10/25/2016.
 */
function tree(query) {
    let queryDefinition;
    if (query instanceof Function) {
        queryDefinition = query();
    }
    else {
        queryDefinition = query;
    }
    let view = new QTree([], queryDefinition);
    let customEntity = queryDefinition.select;
    view = convertMappedEntitySelect(customEntity, queryDefinition, view, view, 'f');
    return view;
}
function convertMappedEntitySelect(customEntity, queryDefinition, view, selectProxy, fieldPrefix) {
    let fieldIndex = 0;
    for (let property in customEntity) {
        let alias = `${fieldPrefix}${++fieldIndex}`;
        let value = customEntity[property];
        if (value instanceof QField) {
            let field = value.getInstance(view);
            field.alias = alias;
            field.q = view;
            selectProxy[property] = field;
        }
        else {
            if (value instanceof Object && !(value instanceof Date)) {
                selectProxy[value] = convertMappedEntitySelect(value, queryDefinition, view, {}, `${alias}_`);
            }
            else {
                throw new Error(`All SELECT clause entries of a Mapped query must be Fields or Functions`);
            }
        }
    }
    return view;
}
/**
 * Sub-queries in select clause
 * @param query
 * @returns {IQF}
 */
function field(query) {
    let queryDefinition;
    if (query instanceof Function) {
        queryDefinition = query();
    }
    else {
        queryDefinition = query;
    }
    let customField = queryDefinition.select;
    customField = customField.addSubQuery(queryDefinition);
    // Field query cannot be joined to any other query so don't have set the positional fields
    return customField;
}
class JoinFields {
    constructor(joinTo) {
        this.joinTo = joinTo;
        if (!(this.joinTo instanceof QEntity)) {
            throw new Error(`Right value in join must be a View or an Entity`);
        }
    }
    on(joinOperation) {
        let joinChild = this.joinTo;
        joinChild.__driver__.joinWhereClause = joinOperation(this.joinTo);
        return this.joinTo;
    }
}

function QEntity(dbEntity, applicationUtils, relationManager, fromClausePosition = [], dbRelation = null, joinType = null, QDriver = QEntityDriver) {
    this.__driver__ = new QDriver(dbEntity, applicationUtils, relationManager, fromClausePosition, dbRelation, joinType, this);
}
QEntity.prototype.fullJoin = function (right) {
    return this.__driver__.join(right, JoinType.FULL_JOIN);
};
QEntity.prototype.innerJoin = function (right) {
    return this.__driver__.join(right, JoinType.INNER_JOIN);
};
QEntity.prototype.leftJoin = function (right) {
    return this.__driver__.join(right, JoinType.LEFT_JOIN);
};
QEntity.prototype.rightJoin = function (right) {
    return this.__driver__.join(right, JoinType.RIGHT_JOIN);
};
class QEntityDriver {
    constructor(dbEntity, applicationUtils, relationManager, fromClausePosition = [], dbRelation = null, joinType = null, qEntity) {
        this.dbEntity = dbEntity;
        this.applicationUtils = applicationUtils;
        this.relationManager = relationManager;
        this.fromClausePosition = fromClausePosition;
        this.dbRelation = dbRelation;
        this.joinType = joinType;
        this.qEntity = qEntity;
        this.entityFieldMap = {};
        this.entityRelations = [];
        this.idColumns = [];
        this.allColumns = [];
        this.relations = [];
        this.currentChildIndex = -1;
    }
    getInstance() {
        const qEntityConstructor = this.applicationUtils
            .getQEntityConstructor(this.dbEntity);
        let instance = new qEntityConstructor(this.dbEntity, this.applicationUtils, this.relationManager, this.fromClausePosition, this.dbRelation, this.joinType);
        instance.__driver__.currentChildIndex = this.currentChildIndex;
        instance.__driver__.joinWhereClause = this.joinWhereClause;
        instance.__driver__.entityFieldMap = this.entityFieldMap;
        instance.__driver__.entityRelations = this.entityRelations;
        return instance;
    }
    /*
    addEntityRelation<R extends IQEntityInternal>(
        relation: IQInternalRelation<R>
    ): void {
        this.entityRelations[relation.parentRelationIndex] = relation;
    }

    addEntityField<T, IQF extends IQOperableFieldInternal<T, JSONBaseOperation, any, any>>(
        field: IQF
    ): void {
        this.entityFieldMap[field.fieldName] = field;
    }
    */
    /*
    getRelationPropertyName(): string {
        return QMetadataUtils.getRelationPropertyName(QMetadataUtils.getRelationByIndex(this.qEntity, this.relationIndex));
    }
*/
    getRelationJson(columnAliases, queryUtils, fieldUtils, relationManager) {
        // FIXME: this does not work for non-entity tree queries, as there is not dbEntity
        // see ApplicationDao.findMaxVersionedMapByApplicationAndDomainNames for an example
        let jsonRelation = {
            currentChildIndex: this.currentChildIndex,
            ti: this.dbEntity.index,
            fromClausePosition: this.fromClausePosition,
            jt: this.joinType,
            rt: null,
            rep: columnAliases.entityAliases.getNextAlias(this.getRootJoinEntity()),
            si: this.dbEntity.applicationVersion.application.index
        };
        if (this.joinWhereClause) {
            this.getJoinRelationJson(jsonRelation, columnAliases, queryUtils, fieldUtils, relationManager);
        }
        else if (this.dbRelation) {
            this.getEntityRelationJson(jsonRelation);
        }
        else {
            this.getRootRelationJson(jsonRelation, columnAliases, queryUtils, fieldUtils, relationManager);
        }
        return jsonRelation;
    }
    getJoinRelationJson(jsonRelation, columnAliases, queryUtils, fieldUtils, relationManager) {
        jsonRelation.rt = JSONRelationType.ENTITY_JOIN_ON;
        jsonRelation.joinWhereClause = queryUtils.whereClauseToJSON(this.joinWhereClause, columnAliases);
        return jsonRelation;
    }
    getEntityRelationJson(jsonRelation) {
        jsonRelation.rt = JSONRelationType.ENTITY_APPLICATION_RELATION;
        jsonRelation.ri = this.dbRelation.index;
        // if (!this.dbRelation.whereJoinTable) {
        return jsonRelation;
        // }
        // let otmQEntity;
        // let mtoQEntity;
        // switch (this.dbRelation.relationType) {
        // 	case EntityRelationType.ONE_TO_MANY:
        // 		mtoQEntity = this.qEntity;
        // 		otmQEntity = this.parentJoinEntity;
        // 		break;
        // 	case EntityRelationType.MANY_TO_ONE:
        // 		otmQEntity = this.qEntity;
        // 		mtoQEntity = this.parentJoinEntity;
        // 		break;
        // 	default:
        // 		throw new Error(`Unknown EntityRelationType: ${this.dbRelation.relationType}`);
        // }
        //
        // let joinWhereClause = this.dbRelation.whereJoinTable.addToJoinFunction(otmQEntity,
        // mtoQEntity, this.airportDb, this.airportDb.F); jsonRelation.joinWhereClause    =
        // this.utils.Query.whereClauseToJSON(joinWhereClause, columnAliases);
        // jsonRelation.joinWhereClauseOperator   = this.dbRelation.joinFunctionWithOperator;  return
        // jsonRelation;
    }
    getRootRelationJson(jsonRelation, columnAliases, queryUtils, fieldUtils, relationManager) {
        jsonRelation.rt = (this instanceof QTreeDriver) ? JSONRelationType.SUB_QUERY_ROOT : JSONRelationType.ENTITY_ROOT;
        return jsonRelation;
    }
    getQ() {
        return this.qEntity;
    }
    join(right, joinType) {
        let joinChild = right
            .__driver__.getInstance();
        joinChild.__driver__.currentChildIndex = 0;
        let nextChildPosition = this.relationManager.getNextChildJoinPosition(this);
        joinChild.__driver__.fromClausePosition = nextChildPosition;
        joinChild.__driver__.joinType = joinType;
        joinChild.__driver__.parentJoinEntity = this.qEntity;
        return new JoinFields(joinChild);
    }
    isRootEntity() {
        return !this.parentJoinEntity;
    }
    getRootJoinEntity() {
        let rootEntity = this.qEntity;
        while (rootEntity.__driver__.parentJoinEntity) {
            rootEntity = rootEntity.__driver__.parentJoinEntity;
        }
        return rootEntity;
    }
}
function QTree(fromClausePosition = [], subQuery) {
    QTree.base.constructor.call(this, null, fromClausePosition, null, null, QTreeDriver);
    this.__driver__.subQuery = subQuery;
}
extend(QEntity, QTree, {});
class QTreeDriver extends QEntityDriver {
    getInstance() {
        let instance = super.getInstance();
        instance.__driver__
            .subQuery = this.subQuery;
        return instance;
    }
    // getRelationPropertyName(): string {
    // 	throw new Error(`not implemented`);
    // }
    getJoinRelationJson(jsonRelation, columnAliases, queryUtils, fieldUtils, relationManager) {
        jsonRelation = super.getJoinRelationJson(jsonRelation, columnAliases, queryUtils, fieldUtils, relationManager);
        jsonRelation.rt = JSONRelationType.SUB_QUERY_JOIN_ON;
        jsonRelation.subQuery = new TreeQuery(this.subQuery, columnAliases.entityAliases)
            .toJSON(queryUtils, fieldUtils, relationManager);
        return jsonRelation;
    }
    getRootRelationJson(jsonRelation, columnAliases, queryUtils, fieldUtils, relationManager) {
        jsonRelation = super.getJoinRelationJson(jsonRelation, columnAliases, queryUtils, fieldUtils, relationManager);
        jsonRelation.rt = JSONRelationType.SUB_QUERY_ROOT;
        jsonRelation.subQuery = new TreeQuery(this.subQuery, columnAliases.entityAliases)
            .toJSON(queryUtils, fieldUtils, relationManager);
        return jsonRelation;
    }
}

/**
 * Created by Papa on 10/18/2016.
 */
class JoinTreeNode {
    constructor(jsonRelation, childNodes, parentNode) {
        this.jsonRelation = jsonRelation;
        this.childNodes = childNodes;
        this.parentNode = parentNode;
    }
    addChildNode(joinTreeNode) {
        let childFromClausePositionArray = joinTreeNode.jsonRelation.fromClausePosition;
        let childPosition = childFromClausePositionArray[childFromClausePositionArray.length - 1];
        this.childNodes[childPosition] = joinTreeNode;
    }
    getEntityRelationChildNode(dbRelation) {
        return this.getEntityRelationChildNodeByIndexes(dbRelation.property.entity.applicationVersion.id, dbRelation.property.entity.index, dbRelation.index);
    }
    getEntityRelationChildNodeByIndexes(applicationIndex, tableIndex, relationIndex) {
        let matchingNodes = this.childNodes.filter((childNode) => {
            return childNode.jsonRelation.ri === relationIndex;
        });
        switch (matchingNodes.length) {
            case 0:
                break;
            case 1:
                return matchingNodes[0];
            default:
                throw new Error(`More than one child node matched relation property index '${relationIndex}'`);
        }
        // No node matched, this must be reference to a sub-entity in select clause (in a Entity
        // query)
        let childPosition = this.jsonRelation.fromClausePosition.slice();
        childPosition.push(this.childNodes.length);
        let rootEntityPrefix;
        if (this.parentNode) {
            rootEntityPrefix = this.parentNode.jsonRelation.rep;
        }
        else {
            rootEntityPrefix = this.jsonRelation.rep;
        }
        let jsonEntityRelation = {
            currentChildIndex: 0,
            fromClausePosition: childPosition,
            ti: tableIndex,
            jt: JoinType.LEFT_JOIN,
            rt: JSONRelationType.ENTITY_APPLICATION_RELATION,
            rep: rootEntityPrefix,
            ri: relationIndex,
            si: applicationIndex
        };
        let childTreeNode = new JoinTreeNode(jsonEntityRelation, [], this);
        this.addChildNode(childTreeNode);
        return childTreeNode;
    }
}

var __decorate$2D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RelationManager = class RelationManager {
    getPositionAlias(rootEntityPrefix, fromClausePosition) {
        return `${rootEntityPrefix}_${fromClausePosition.join('_')}`;
    }
    getAlias(jsonRelation) {
        return this.getPositionAlias(jsonRelation.rep, jsonRelation.fromClausePosition);
    }
    getParentAlias(jsonRelation) {
        let fromClausePosition = jsonRelation.fromClausePosition;
        if (fromClausePosition.length === 0) {
            throw new Error(`Cannot find alias of a parent entity for the root entity`);
        }
        return this.getPositionAlias(jsonRelation.rep, fromClausePosition.slice(0, fromClausePosition.length - 1));
    }
    createRelatedQEntity(joinRelation, context) {
        const dbEntity = this.applicationUtils.getDbEntity(joinRelation.si, joinRelation.ti);
        let QEntityConstructor = this.applicationUtils.getQEntityConstructor(dbEntity);
        return new QEntityConstructor(dbEntity, this.applicationUtils, this, joinRelation.fromClausePosition, dbEntity.relations[joinRelation.ri], joinRelation.jt);
    }
    getNextChildJoinPosition(joinParentDriver) {
        let nextChildJoinPosition = joinParentDriver.fromClausePosition.slice();
        nextChildJoinPosition.push(++joinParentDriver.currentChildIndex);
        return nextChildJoinPosition;
    }
};
__decorate$2D([
    Inject()
], RelationManager.prototype, "applicationUtils", void 0);
RelationManager = __decorate$2D([
    Injected()
], RelationManager);

var __decorate$2C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class LookupProxy {
    constructor(dao) {
        this.dao = dao;
    }
    ensureContext(context) {
        return doEnsureContext(context);
    }
    async lookup(rawQuery, queryResultType, search, one, QueryClass, context, mapResults) {
        return await this.dao.lookup.lookup(rawQuery, queryResultType, search, one, QueryClass, context, mapResults);
    }
}
let Lookup = class Lookup {
    ensureContext(context) {
        return doEnsureContext(context);
    }
    async lookup(rawQuery, queryResultType, search, one, QueryClass, context, mapResults) {
        let query;
        if (QueryClass) {
            const rawNonEntityQuery = this.entityUtils.getQuery(rawQuery);
            query = new QueryClass(rawNonEntityQuery);
        }
        else {
            query = this.entityUtils.getEntityQuery(rawQuery);
            queryResultType = this.getQueryResultType(queryResultType, mapResults);
        }
        let queryMethod;
        if (search) {
            if (one) {
                queryMethod = this.queryFacade.searchOne;
            }
            else {
                queryMethod = this.queryFacade.search;
            }
        }
        else {
            if (one) {
                queryMethod = this.queryFacade.findOne;
            }
            else {
                queryMethod = this.queryFacade.find;
            }
        }
        let result = await queryMethod.call(this.queryFacade, query, this.getQueryResultType(queryResultType, mapResults), context);
        if (!one && !result) {
            result = [];
        }
        return result;
    }
    getQueryResultType(baseQueryResultType, mapResults) {
        switch (baseQueryResultType) {
            case QueryResultType.ENTITY_GRAPH:
                if (mapResults) {
                    return QueryResultType.MAPPED_ENTITY_GRAPH;
                }
                return QueryResultType.ENTITY_GRAPH;
            case QueryResultType.ENTITY_TREE:
                if (mapResults) {
                    return QueryResultType.MAPPED_ENTITY_TREE;
                }
                return QueryResultType.ENTITY_TREE;
            case QueryResultType.FIELD:
            case QueryResultType.RAW:
            case QueryResultType.TREE:
            case QueryResultType.SHEET:
                return baseQueryResultType;
            default:
                throw new Error(`Unexpected Base Query ResultType: '${baseQueryResultType}'.`);
        }
    }
};
__decorate$2C([
    Inject()
], Lookup.prototype, "entityUtils", void 0);
__decorate$2C([
    Inject()
], Lookup.prototype, "queryFacade", void 0);
Lookup = __decorate$2C([
    Injected()
], Lookup);
function doEnsureContext(context) {
    if (!context) {
        context = {};
    }
    if (!context.startedAt) {
        context.startedAt = new Date();
    }
    return context;
}

class EntityLookup extends LookupProxy {
    constructor(dbEntity, dao, mapResults = EntityLookup.mapResults) {
        super(dao);
        this.dbEntity = dbEntity;
        this.mapResults = mapResults;
    }
    setMap(MappedChildClass, isMapped = true) {
        return new MappedChildClass(this.dbEntity, this.dao, isMapped);
    }
    setNoCache(ChildClass) {
        return new ChildClass(this.dbEntity, this.dao, this.mapResults);
    }
    async entityLookup(rawEntityQuery, queryResultType, search, one, context) {
        context.dbEntity = this.dbEntity;
        const result = await this.lookup(rawEntityQuery, queryResultType, search, one, null, context, this.mapResults);
        if (search) {
            throw new Error(`Search operations are not yet supported`);
        }
        else {
            this.dao.updateCacheManager.saveOriginalValues(result, context.dbEntity);
        }
        return result;
    }
}
EntityLookup.mapResults = false;

/**
 * Created by Papa on 11/12/2016.
 */
class EntityFind extends EntityLookup {
    async graph(rawGraphQuery, context) {
        return await this.find(rawGraphQuery, QueryResultType.ENTITY_GRAPH, context);
    }
    async tree(rawTreeQuery, context) {
        return await this.find(rawTreeQuery, QueryResultType.ENTITY_TREE, context);
    }
    async find(rawEntityQuery, queryResultType, context) {
        return await this.entityLookup(rawEntityQuery, queryResultType, false, false, this.ensureContext(context));
    }
    map(isMapped) {
        return this.setMap(EntityFind, isMapped);
    }
    noCache() {
        return this.setNoCache(EntityFind);
    }
}

/**
 * Created by Papa on 11/12/2016.
 */
class EntityFindOne extends EntityLookup {
    async graph(rawGraphQuery, context) {
        return await this.findOne(rawGraphQuery, QueryResultType.ENTITY_GRAPH, context);
    }
    async tree(rawTreeQuery, context) {
        return await this.findOne(rawTreeQuery, QueryResultType.ENTITY_TREE, context);
    }
    // TODO: return Observable from deep within the framework
    // and detect changes to the underlying data
    async findOne(rawEntityQuery, queryResultType, context) {
        return await this.entityLookup(rawEntityQuery, queryResultType, false, true, this.ensureContext(context));
    }
    map(isMapped) {
        return this.setMap(EntityFindOne, isMapped);
    }
    noCache() {
        return this.setNoCache(EntityFindOne);
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function isFunction(value) {
    return typeof value === 'function';
}

function createErrorClass(createImpl) {
    var _super = function (instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
}

var UnsubscriptionError = createErrorClass(function (_super) {
    return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors
            ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
            : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
    };
});

function arrRemove(arr, item) {
    if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
    }
}

var Subscription = (function () {
    function Subscription(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._teardowns = null;
    }
    Subscription.prototype.unsubscribe = function () {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) {
                    try {
                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                            var parent_1 = _parentage_1_1.value;
                            parent_1.remove(this);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                else {
                    _parentage.remove(this);
                }
            }
            var initialTeardown = this.initialTeardown;
            if (isFunction(initialTeardown)) {
                try {
                    initialTeardown();
                }
                catch (e) {
                    errors = e instanceof UnsubscriptionError ? e.errors : [e];
                }
            }
            var _teardowns = this._teardowns;
            if (_teardowns) {
                this._teardowns = null;
                try {
                    for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
                        var teardown_1 = _teardowns_1_1.value;
                        try {
                            execTeardown(teardown_1);
                        }
                        catch (err) {
                            errors = errors !== null && errors !== void 0 ? errors : [];
                            if (err instanceof UnsubscriptionError) {
                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                            }
                            else {
                                errors.push(err);
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return)) _b.call(_teardowns_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (errors) {
                throw new UnsubscriptionError(errors);
            }
        }
    };
    Subscription.prototype.add = function (teardown) {
        var _a;
        if (teardown && teardown !== this) {
            if (this.closed) {
                execTeardown(teardown);
            }
            else {
                if (teardown instanceof Subscription) {
                    if (teardown.closed || teardown._hasParent(this)) {
                        return;
                    }
                    teardown._addParent(this);
                }
                (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
        }
    };
    Subscription.prototype._hasParent = function (parent) {
        var _parentage = this._parentage;
        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
    };
    Subscription.prototype._addParent = function (parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription.prototype._removeParent = function (parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
            this._parentage = null;
        }
        else if (Array.isArray(_parentage)) {
            arrRemove(_parentage, parent);
        }
    };
    Subscription.prototype.remove = function (teardown) {
        var _teardowns = this._teardowns;
        _teardowns && arrRemove(_teardowns, teardown);
        if (teardown instanceof Subscription) {
            teardown._removeParent(this);
        }
    };
    Subscription.EMPTY = (function () {
        var empty = new Subscription();
        empty.closed = true;
        return empty;
    })();
    return Subscription;
}());
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
    return (value instanceof Subscription ||
        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
}
function execTeardown(teardown) {
    if (isFunction(teardown)) {
        teardown();
    }
    else {
        teardown.unsubscribe();
    }
}

var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false,
};

var timeoutProvider = {
    setTimeout: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray([], __read(args)));
    },
    clearTimeout: function (handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined,
};

function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function () {
        var onUnhandledError = config.onUnhandledError;
        if (onUnhandledError) {
            onUnhandledError(err);
        }
        else {
            throw err;
        }
    });
}

function noop() { }

var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
function errorNotification(error) {
    return createNotification('E', undefined, error);
}
function nextNotification(value) {
    return createNotification('N', value, undefined);
}
function createNotification(kind, value, error) {
    return {
        kind: kind,
        value: value,
        error: error,
    };
}

var context = null;
function errorContext(cb) {
    if (config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
            context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
            context = null;
            if (errorThrown) {
                throw error;
            }
        }
    }
    else {
        cb();
    }
}
function captureError(err) {
    if (config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
    }
}

var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
            _this.destination = destination;
            if (isSubscription(destination)) {
                destination.add(_this);
            }
        }
        else {
            _this.destination = EMPTY_OBSERVER;
        }
        return _this;
    }
    Subscriber.create = function (next, error, complete) {
        return new SafeSubscriber(next, error, complete);
    };
    Subscriber.prototype.next = function (value) {
        if (this.isStopped) {
            handleStoppedNotification(nextNotification(value), this);
        }
        else {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (this.isStopped) {
            handleStoppedNotification(errorNotification(err), this);
        }
        else {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (this.isStopped) {
            handleStoppedNotification(COMPLETE_NOTIFICATION, this);
        }
        else {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
        }
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        try {
            this.destination.error(err);
        }
        finally {
            this.unsubscribe();
        }
    };
    Subscriber.prototype._complete = function () {
        try {
            this.destination.complete();
        }
        finally {
            this.unsubscribe();
        }
    };
    return Subscriber;
}(Subscription));
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var next;
        if (isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            (next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete);
            var context_1;
            if (_this && config.useDeprecatedNextContext) {
                context_1 = Object.create(observerOrNext);
                context_1.unsubscribe = function () { return _this.unsubscribe(); };
            }
            else {
                context_1 = observerOrNext;
            }
            next = next === null || next === void 0 ? void 0 : next.bind(context_1);
            error = error === null || error === void 0 ? void 0 : error.bind(context_1);
            complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
        }
        _this.destination = {
            next: next ? wrapForErrorHandling(next) : noop,
            error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler),
            complete: complete ? wrapForErrorHandling(complete) : noop,
        };
        return _this;
    }
    return SafeSubscriber;
}(Subscriber));
function wrapForErrorHandling(handler, instance) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        try {
            handler.apply(void 0, __spreadArray([], __read(args)));
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                captureError(err);
            }
            else {
                reportUnhandledError(err);
            }
        }
    };
}
function defaultErrorHandler(err) {
    throw err;
}
function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
}
var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop,
};

var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

function identity(x) {
    return x;
}

function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}

var Observable = (function () {
    function Observable(subscribe) {
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
        errorContext(function () {
            var _a = _this, operator = _a.operator, source = _a.source;
            subscriber.add(operator
                ?
                    operator.call(subscriber, source)
                : source
                    ?
                        _this._subscribe(subscriber)
                    :
                        _this._trySubscribe(subscriber));
        });
        return subscriber;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.error(err);
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable.prototype[observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
}

function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
    return function (source) {
        if (hasLift(source)) {
            return source.lift(function (liftedSource) {
                try {
                    return init(liftedSource, this);
                }
                catch (err) {
                    this.error(err);
                }
            });
        }
        throw new TypeError('Unable to lift unknown Observable type');
    };
}

var OperatorSubscriber = (function (_super) {
    __extends(OperatorSubscriber, _super);
    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this._next = onNext
            ? function (value) {
                try {
                    onNext(value);
                }
                catch (err) {
                    destination.error(err);
                }
            }
            : _super.prototype._next;
        _this._error = onError
            ? function (err) {
                try {
                    onError(err);
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._error;
        _this._complete = onComplete
            ? function () {
                try {
                    onComplete();
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._complete;
        return _this;
    }
    OperatorSubscriber.prototype.unsubscribe = function () {
        var _a;
        var closed = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    };
    return OperatorSubscriber;
}(Subscriber));

var ObjectUnsubscribedError = createErrorClass(function (_super) {
    return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = 'ObjectUnsubscribedError';
        this.message = 'object unsubscribed';
    };
});

var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype._throwIfClosed = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
    };
    Subject.prototype.next = function (value) {
        var _this = this;
        errorContext(function () {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
                var copy = _this.observers.slice();
                try {
                    for (var copy_1 = __values(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {
                        var observer = copy_1_1.value;
                        observer.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return)) _a.call(copy_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    };
    Subject.prototype.error = function (err) {
        var _this = this;
        errorContext(function () {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.hasError = _this.isStopped = true;
                _this.thrownError = err;
                var observers = _this.observers;
                while (observers.length) {
                    observers.shift().error(err);
                }
            }
        });
    };
    Subject.prototype.complete = function () {
        var _this = this;
        errorContext(function () {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.isStopped = true;
                var observers = _this.observers;
                while (observers.length) {
                    observers.shift().complete();
                }
            }
        });
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = this.closed = true;
        this.observers = null;
    };
    Object.defineProperty(Subject.prototype, "observed", {
        get: function () {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
    });
    Subject.prototype._trySubscribe = function (subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject.prototype._subscribe = function (subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
    };
    Subject.prototype._innerSubscribe = function (subscriber) {
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        return hasError || isStopped
            ? EMPTY_SUBSCRIPTION
            : (observers.push(subscriber), new Subscription(function () { return arrRemove(observers, subscriber); }));
    };
    Subject.prototype._checkFinalizedStatuses = function (subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
            subscriber.error(thrownError);
        }
        else if (isStopped) {
            subscriber.complete();
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject.prototype.error = function (err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject.prototype.complete = function () {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject;
}(Subject));

var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: false,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
            throw thrownError;
        }
        this._throwIfClosed();
        return _value;
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, (this._value = value));
    };
    return BehaviorSubject;
}(Subject));

var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

function isInteropObservable(input) {
    return isFunction(input[observable]);
}

function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = getSymbolIterator();

function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    reader = readableStream.getReader();
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, , 9, 10]);
                    _b.label = 2;
                case 2:
                    return [4, __await(reader.read())];
                case 3:
                    _a = _b.sent(), value = _a.value, done = _a.done;
                    if (!done) return [3, 5];
                    return [4, __await(void 0)];
                case 4: return [2, _b.sent()];
                case 5: return [4, __await(value)];
                case 6: return [4, _b.sent()];
                case 7:
                    _b.sent();
                    return [3, 2];
                case 8: return [3, 10];
                case 9:
                    reader.releaseLock();
                    return [7];
                case 10: return [2];
            }
        });
    });
}
function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

function innerFrom(input) {
    if (input instanceof Observable) {
        return input;
    }
    if (input != null) {
        if (isInteropObservable(input)) {
            return fromInteropObservable(input);
        }
        if (isArrayLike(input)) {
            return fromArrayLike(input);
        }
        if (isPromise(input)) {
            return fromPromise(input);
        }
        if (isAsyncIterable(input)) {
            return fromAsyncIterable(input);
        }
        if (isIterable(input)) {
            return fromIterable(input);
        }
        if (isReadableStreamLike(input)) {
            return fromReadableStreamLike(input);
        }
    }
    throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
    return new Observable(function (subscriber) {
        var obs = obj[observable]();
        if (isFunction(obs.subscribe)) {
            return obs.subscribe(subscriber);
        }
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    });
}
function fromArrayLike(array) {
    return new Observable(function (subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    });
}
function fromPromise(promise) {
    return new Observable(function (subscriber) {
        promise
            .then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, reportUnhandledError);
    });
}
function fromIterable(iterable) {
    return new Observable(function (subscriber) {
        var e_1, _a;
        try {
            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                var value = iterable_1_1.value;
                subscriber.next(value);
                if (subscriber.closed) {
                    return;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        subscriber.complete();
    });
}
function fromAsyncIterable(asyncIterable) {
    return new Observable(function (subscriber) {
        process$1(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
    });
}
function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process$1(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function () {
        var value, e_2_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 5, 6, 11]);
                    asyncIterable_1 = __asyncValues(asyncIterable);
                    _b.label = 1;
                case 1: return [4, asyncIterable_1.next()];
                case 2:
                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                    value = asyncIterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return [2];
                    }
                    _b.label = 3;
                case 3: return [3, 1];
                case 4: return [3, 11];
                case 5:
                    e_2_1 = _b.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 11];
                case 6:
                    _b.trys.push([6, , 9, 10]);
                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                    return [4, _a.call(asyncIterable_1)];
                case 7:
                    _b.sent();
                    _b.label = 8;
                case 8: return [3, 10];
                case 9:
                    if (e_2) throw e_2.error;
                    return [7];
                case 10: return [7];
                case 11:
                    subscriber.complete();
                    return [2];
            }
        });
    });
}

function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) { delay = 0; }
    if (repeat === void 0) { repeat = false; }
    var scheduleSubscription = scheduler.schedule(function () {
        work();
        if (repeat) {
            parentSubscription.add(this.schedule(null, delay));
        }
        else {
            this.unsubscribe();
        }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
        return scheduleSubscription;
    }
}

function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return operate(function (source, subscriber) {
        source.subscribe(new OperatorSubscriber(subscriber, function (value) { return executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
    });
}

function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return operate(function (source, subscriber) {
        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
    });
}

function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

function scheduleArray(input, scheduler) {
    return new Observable(function (subscriber) {
        var i = 0;
        return scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
            }
            else {
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    this.schedule();
                }
            }
        });
    });
}

function scheduleIterable(input, scheduler) {
    return new Observable(function (subscriber) {
        var iterator$1;
        executeSchedule(subscriber, scheduler, function () {
            iterator$1 = input[iterator]();
            executeSchedule(subscriber, scheduler, function () {
                var _a;
                var value;
                var done;
                try {
                    (_a = iterator$1.next(), value = _a.value, done = _a.done);
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                }
            }, 0, true);
        });
        return function () { return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return(); };
    });
}

function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable(function (subscriber) {
        executeSchedule(subscriber, scheduler, function () {
            var iterator = input[Symbol.asyncIterator]();
            executeSchedule(subscriber, scheduler, function () {
                iterator.next().then(function (result) {
                    if (result.done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(result.value);
                    }
                });
            }, 0, true);
        });
    });
}

function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable(input)) {
            return scheduleObservable(input, scheduler);
        }
        if (isArrayLike(input)) {
            return scheduleArray(input, scheduler);
        }
        if (isPromise(input)) {
            return schedulePromise(input, scheduler);
        }
        if (isAsyncIterable(input)) {
            return scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable(input)) {
            return scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike(input)) {
            return scheduleReadableStreamLike(input, scheduler);
        }
    }
    throw createInvalidObservableTypeError(input);
}

function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

function map(project, thisArg) {
    return operate(function (source, subscriber) {
        var index = 0;
        source.subscribe(new OperatorSubscriber(subscriber, function (value) {
            subscriber.next(project.call(thisArg, value, index++));
        }));
    });
}

function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === void 0) { keySelector = identity; }
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return operate(function (source, subscriber) {
        var previousKey;
        var first = true;
        source.subscribe(new OperatorSubscriber(subscriber, function (value) {
            var currentKey = keySelector(value);
            if (first || !comparator(previousKey, currentKey)) {
                first = false;
                previousKey = currentKey;
                subscriber.next(value);
            }
        }));
    });
}
function defaultCompare(a, b) {
    return a === b;
}

/**
 * Created by Papa on 10/24/2016.
 */
class FieldQuery extends DistinguishableQuery {
    // private qEntityMap: {[entityName: string]: QEntity<any>},
    //	private entitiesRelationPropertyMap: {[entityName: string]: {[propertyName: string]:
    // EntityRelationRecord}},
    //		private entitiesPropertyTypeMap: {[entityName: string]: {[propertyName: string]:
    // boolean}}
    constructor(rawQuery, entityAliases = new EntityAliases()) {
        super(entityAliases);
        this.rawQuery = rawQuery;
    }
    nonDistinctSelectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager) {
        if (!(this.rawQuery.select instanceof QField)) {
            throw new Error(NON_ENTITY_SELECT_ERROR_MESSAGE);
        }
        this.columnAliases.entityAliases.getNextAlias(this.rawQuery.select.q.__driver__.getRootJoinEntity());
        return this.rawQuery.select.toJSON(this.columnAliases, true, queryUtils, fieldUtils, relationManager);
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        let select = this.selectClauseToJSON(this.rawQuery.select, queryUtils, fieldUtils, relationManager);
        let jsonFieldQuery = {
            S: select,
            ot: JSONClauseObjectType.FIELD_QUERY,
            dt: this.getClauseDataType()
        };
        return this.getNonEntityQuery(this.rawQuery, jsonFieldQuery, null, queryUtils, fieldUtils, relationManager);
    }
    getClauseDataType() {
        let selectField = this.rawQuery.select;
        if (selectField instanceof QDistinctFunction) {
            selectField = selectField.getSelectClause();
        }
        if (selectField instanceof QBooleanField) {
            return SQLDataType.BOOLEAN;
        }
        else if (selectField instanceof QDateField) {
            return SQLDataType.DATE;
        }
        else if (selectField instanceof QNumberField) {
            return SQLDataType.NUMBER;
        }
        else if (selectField instanceof QStringField) {
            return SQLDataType.STRING;
        }
        else if (selectField instanceof QUntypedField) {
            return SQLDataType.ANY;
        }
        else {
            throw new Error(`Unsupported type of select field in Field Query`);
        }
    }
}

/**
 * Created by Papa on 10/23/2016.
 */
class SheetQuery extends DistinguishableQuery {
    constructor(rawQuery) {
        super();
        this.rawQuery = rawQuery;
    }
    nonDistinctSelectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager) {
        if (!(rawSelect instanceof Array)) {
            throw new Error(`Flat Queries an array of fields in SELECT clause.`);
        }
        return rawSelect.map((selectField) => {
            if (!(selectField instanceof QField)) {
                throw new Error(NON_ENTITY_SELECT_ERROR_MESSAGE);
            }
            this.columnAliases.entityAliases.getNextAlias(selectField.q.__driver__.getRootJoinEntity());
            return selectField.toJSON(this.columnAliases, true, queryUtils, fieldUtils, relationManager);
        });
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        let select = this.selectClauseToJSON(this.rawQuery.select, queryUtils, fieldUtils, relationManager);
        let jsonFieldQuery = {
            S: select
        };
        return this.getNonEntityQuery(this.rawQuery, jsonFieldQuery, null, queryUtils, fieldUtils, relationManager);
    }
}

var __decorate$2B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 11/12/2016.
 */
let NonEntityFind = class NonEntityFind extends Lookup {
    field(rawFieldQuery, context) {
        return this.find(rawFieldQuery, QueryResultType.FIELD, FieldQuery, context);
    }
    sheet(rawSheetQuery, cursorSize, callback, context) {
        if (cursorSize || callback) {
            throw new Error(`Implement!`);
        }
        return this.find(rawSheetQuery, QueryResultType.SHEET, SheetQuery, context);
    }
    tree(rawTreeQuery, context) {
        return this.find(rawTreeQuery, QueryResultType.TREE, TreeQuery, context);
    }
    find(rawNonEntityQuery, queryResultType, QueryClass, context) {
        return this.lookup(rawNonEntityQuery, queryResultType, false, false, QueryClass, this.ensureContext(context));
    }
};
NonEntityFind = __decorate$2B([
    Injected()
], NonEntityFind);

var __decorate$2A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 11/12/2016.
 */
let NonEntityFindOne = class NonEntityFindOne extends Lookup {
    field(rawFieldQuery, context) {
        return this.findOne(rawFieldQuery, QueryResultType.FIELD, FieldQuery, context);
    }
    sheet(rawSheetQuery, context) {
        return this.findOne(rawSheetQuery, QueryResultType.SHEET, SheetQuery, context);
    }
    tree(rawTreeQuery, context) {
        return this.findOne(rawTreeQuery, QueryResultType.TREE, TreeQuery, context);
    }
    findOne(rawNonEntityQuery, queryResultType, QueryClass, context) {
        return this.lookup(rawNonEntityQuery, queryResultType, false, true, QueryClass, this.ensureContext(context));
    }
};
NonEntityFindOne = __decorate$2A([
    Injected()
], NonEntityFindOne);

var __decorate$2z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 11/12/2016.
 */
let NonEntitySearch = class NonEntitySearch extends Lookup {
    field(rawFieldQuery, context) {
        return from(this.search(rawFieldQuery, QueryResultType.FIELD, FieldQuery, context));
    }
    sheet(rawSheetQuery, context) {
        return from(this.search(rawSheetQuery, QueryResultType.SHEET, SheetQuery, context));
    }
    tree(rawTreeQuery, context) {
        return from(this.search(rawTreeQuery, QueryResultType.TREE, TreeQuery, context));
    }
    search(rawNonEntityQuery, queryResultType, QueryClass, context) {
        return this.lookup(rawNonEntityQuery, queryResultType, true, false, QueryClass, this.ensureContext(context));
    }
};
NonEntitySearch = __decorate$2z([
    Injected()
], NonEntitySearch);

var __decorate$2y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 11/12/2016.
 */
let NonEntitySearchOne = class NonEntitySearchOne extends Lookup {
    field(rawFieldQuery, context) {
        return from(this.searchOne(rawFieldQuery, QueryResultType.FIELD, FieldQuery, context));
    }
    sheet(rawSheetQuery, context) {
        return from(this.searchOne(rawSheetQuery, QueryResultType.SHEET, SheetQuery, context));
    }
    tree(rawTreeQuery, context) {
        return from(this.searchOne(rawTreeQuery, QueryResultType.TREE, TreeQuery, context));
    }
    searchOne(rawNonEntityQuery, queryResultType, QueryClass, context) {
        return this.lookup(rawNonEntityQuery, queryResultType, true, true, QueryClass, this.ensureContext(context));
    }
};
NonEntitySearchOne = __decorate$2y([
    Injected()
], NonEntitySearchOne);

/**
 * Created by Papa on 11/17/2016.
 */
// FIXME: add support for a full blown INSERT VALUES, with expression support for VALUES
class AbstractInsertValues extends AbstractQuery {
    constructor(rawInsertValues, columnIndexes) {
        super();
        this.rawInsertValues = rawInsertValues;
        this.columnIndexes = columnIndexes;
    }
    validateColumn(dbColumn, dbEntity, columnName) {
        if (!dbColumn) {
            throw new Error(`
		Could not find column ${columnName} in entity: ${dbEntity.name}
				(table: ${dbEntity.tableConfig.name})
						`);
        }
        if (dbColumn.entity.applicationVersion.application.index !==
            dbEntity.applicationVersion.application.index
            || dbColumn.entity.index !== dbEntity.index) {
            const columnApplication = dbColumn.entity.applicationVersion.application;
            const entityApplication = dbEntity.applicationVersion.application;
            throw new Error(`Unexpected entity for column ${dbColumn.name}.
			Expecting:
				Domain: ${entityApplication.domain.name}
				Application: ${entityApplication.name}
				Entity: ${dbEntity.name}
			Found:
				Domain: ${columnApplication.domain.name}
				Application: ${columnApplication.name}
				Entity: ${dbColumn.entity.name}`);
        }
    }
    valuesToJSON(valueSets, dbColumns, queryUtils, fieldUtils, relationManager) {
        // let currentValueIndex = -1;
        // this.values           = [];
        return valueSets.map((valueSet, rowIndex) => {
            return valueSet.map((value, columnIndex) => {
                if (value === undefined) {
                    throw new Error(`Cannot use 'undefined' in VALUES clause.`);
                }
                if (!(value instanceof QField)) {
                    return getPrimitiveValue(value, dbColumns[columnIndex], rowIndex);
                    // this.values.push(getPrimitiveValue(value));
                    // return ++currentValueIndex;
                }
                else {
                    return value.toJSON(this.columnAliases, false, queryUtils, fieldUtils, relationManager);
                }
            });
        });
    }
}

class AbstractUpdate extends AbstractQuery {
    constructor(rawUpdate) {
        super();
        this.rawUpdate = rawUpdate;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        return {
            U: this.rawUpdate.update
                .__driver__.getRelationJson(this.columnAliases, queryUtils, fieldUtils, relationManager),
            S: this.setToJSON(this.rawUpdate.set, queryUtils, fieldUtils, relationManager),
            W: queryUtils.whereClauseToJSON(this.rawUpdate.where, this.columnAliases)
        };
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
class Delete extends AbstractQuery {
    constructor(rawDelete) {
        super();
        this.rawDelete = rawDelete;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        return {
            DF: this.rawDelete.deleteFrom
                .__driver__.getRelationJson(this.columnAliases, queryUtils, fieldUtils, relationManager),
            W: queryUtils.whereClauseToJSON(this.rawDelete.where, this.columnAliases)
        };
    }
}

/**
 * Created by Papa on 10/24/2016.
 */
class EntityQuery extends MappableQuery {
    constructor(rawQuery) {
        super();
        this.rawQuery = rawQuery;
        this.isEntityQuery = true;
        this.isHierarchicalEntityQuery = true;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        return {
            S: this.selectClauseToJSON(this.rawQuery.select, queryUtils, fieldUtils, relationManager),
            F: this.fromClauseToJSON(this.rawQuery.from, queryUtils, fieldUtils, relationManager),
            W: queryUtils.whereClauseToJSON(this.rawQuery.where, this.columnAliases),
            OB: this.orderByClauseToJSON(this.rawQuery.orderBy)
        };
    }
    nonDistinctSelectClauseToJSON(rawSelect) {
        for (let field in rawSelect) {
            let value = rawSelect[field];
            if (value instanceof QField) {
                throw new Error(`Field References cannot be used in Entity Queries`);
            }
            else if (value instanceof Object && !(value instanceof Date)) {
                this.nonDistinctSelectClauseToJSON(value);
            }
        }
        return rawSelect;
    }
    orderByClauseToJSON(orderBy) {
        if (!orderBy || !orderBy.length) {
            return null;
        }
        return orderBy.map((field) => {
            return field.toEntityJSON();
        });
    }
}

// FIXME: add support for a full blown INSERT VALUES, with expression support for VALUES
class InsertColumnValues extends AbstractInsertValues {
    toJSON(queryUtils, fieldUtils, relationManager) {
        const entityDriver = this.rawInsertValues.insertInto.__driver__;
        const insertInto = entityDriver.getRelationJson(this.columnAliases, queryUtils, fieldUtils, relationManager);
        const columnMap = entityDriver.dbEntity.columnMap;
        const dbColumns = [];
        const columnIndexes = this.columnIndexes ? this.columnIndexes : this.rawInsertValues.columns.map((columnName) => {
            const dbColumn = columnMap[columnName];
            this.validateColumn(dbColumn, entityDriver.dbEntity, columnName);
            dbColumns.push(dbColumn);
            return dbColumn.index;
        });
        return {
            II: insertInto,
            C: columnIndexes,
            V: this.valuesToJSON(this.rawInsertValues.values, dbColumns, queryUtils, fieldUtils, relationManager)
        };
    }
}

/**
 * Created by Papa on 11/17/2016.
 */
// FIXME: add support for a full blown INSERT VALUES, with expression support for VALUES
class InsertValues extends AbstractInsertValues {
    toJSON(queryUtils, fieldUtils, relationManager) {
        const driver = this.rawInsertValues.insertInto
            .__driver__;
        const insertInto = driver.getRelationJson(this.columnAliases, queryUtils, fieldUtils, relationManager);
        const dbColumns = [];
        let columnIndexes;
        if (this.columnIndexes) {
            columnIndexes = this.columnIndexes;
            for (let i = 0; i < columnIndexes.length; i++) {
                const dbColumn = driver.dbEntity.columns[columnIndexes[i]];
                this.validateColumn(dbColumn, driver.dbEntity);
                dbColumns.push(dbColumn);
            }
        }
        else {
            columnIndexes = this.rawInsertValues.columns.map(column => {
                const dbColumn = column.dbColumn;
                this.validateColumn(dbColumn, driver.dbEntity);
                dbColumns.push(dbColumn);
                return dbColumn.index;
            });
        }
        return {
            II: insertInto,
            C: columnIndexes,
            V: this.valuesToJSON(this.rawInsertValues.values, dbColumns, queryUtils, fieldUtils, relationManager)
        };
    }
}

class UpdateColumns extends AbstractUpdate {
    constructor(rawUpdate) {
        super(rawUpdate);
    }
    setToJSON(set, queryUtils, fieldUtils, relationManager) {
        const setClause = {};
        const dbEntity = this.rawUpdate.update
            .__driver__.dbEntity;
        const dbColumnMap = dbEntity.columnMap;
        const idDbColumnMap = dbEntity.idColumnMap;
        for (const columnName in set) {
            let value = set[columnName];
            if (value === undefined) {
                delete set[columnName];
                continue;
            }
            if (!dbColumnMap[columnName]) {
                throw new Error(`
	Unknown column: '${columnName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            if (idDbColumnMap[columnName]) {
                throw new Error(`
	Cannot update @Id columns:
	Column: '${columnName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            value = wrapPrimitive(value);
            if (!value.toJSON) {
                throw `Unexpected value ${JSON.stringify(value)} for property ${columnName} of entity ${this.rawUpdate.update.__driver__.dbEntity.name}`;
            }
            setClause[columnName] = value.toJSON(this.columnAliases, false, queryUtils, fieldUtils, relationManager);
        }
        return setClause;
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
// FIXME: add support for a full blown UPDATE, with expression support for SET
class UpdateProperties extends AbstractUpdate {
    constructor(rawUpdate) {
        super(rawUpdate);
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        return {
            U: this.rawUpdate.update
                .__driver__.getRelationJson(this.columnAliases, queryUtils, fieldUtils, relationManager),
            S: this.setToJSON(this.rawUpdate.set, queryUtils, fieldUtils, relationManager),
            W: queryUtils.whereClauseToJSON(this.rawUpdate.where, this.columnAliases)
        };
    }
    setToJSON(rawSet, queryUtils, fieldUtils, relationManager) {
        const jsonSetClause = {};
        const dbEntity = this.rawUpdate.update.__driver__.dbEntity;
        const dbPropertyMap = dbEntity.propertyMap;
        this.setEntityFragmentsToJSON(rawSet, jsonSetClause, [], dbPropertyMap, [], queryUtils, fieldUtils, relationManager);
        return jsonSetClause;
    }
    setEntityFragmentsToJSON(rawSetFragment, jsonSetClause, dbPropertyChain, dbPropertyMap, childDbRelationChain, queryUtils, fieldUtils, relationManager) {
        const isTopLevelFragment = !dbPropertyMap.length;
        for (const propertyName in rawSetFragment) {
            const dbProperty = dbPropertyMap[propertyName];
            const dbEntity = dbProperty.entity;
            if (!dbProperty) {
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Unknown property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            if (isTopLevelFragment && dbProperty.isId) {
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Cannot update @Id properties:
	Property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            else if (!isTopLevelFragment && !dbProperty.isId) {
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Updated properties of nested entities must be @Id properties:
	Property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            const childDbPropertyChain = [...dbPropertyChain];
            childDbPropertyChain.push(dbProperty);
            this.setFragmentToJSON(rawSetFragment, jsonSetClause, childDbPropertyChain, propertyName, childDbRelationChain, queryUtils, fieldUtils, relationManager);
        }
    }
    setFragmentToJSON(rawSetFragment, jsonSetClause, dbPropertyChain, propertyName, dbRelationChain, queryUtils, fieldUtils, relationManager) {
        const dbProperty = dbPropertyChain[dbPropertyChain.length - 1];
        const dbEntity = dbProperty.entity;
        let value = rawSetFragment[propertyName];
        if (value === undefined) {
            delete rawSetFragment[propertyName];
            return;
        }
        value = wrapPrimitive(value);
        // If this is not a nested object definition
        if (value.toJSON) {
            if (dbProperty.propertyColumns.length !== 1) {
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Cannot update multi-column property to a single value:
	Property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}')
			has ${dbProperty.propertyColumns.length + 1} columns 
			but is being updates to a single value.
				`);
            }
            else {
                let dbColumn = dbProperty.propertyColumns[0].column;
                if (dbRelationChain.length) {
                    for (let i = dbRelationChain.length - 1; i >= 0; i--) {
                        const currentDbRelation = dbRelationChain[i];
                        const matchingManyRelationColumn = currentDbRelation.manyRelationColumns.filter((manyRelationColumn) => {
                            return manyRelationColumn.manyColumn.index ===
                                dbColumn.index;
                        })[0];
                        dbColumn = matchingManyRelationColumn.oneColumn;
                    }
                }
                if (jsonSetClause[dbColumn.name]) {
                    const firstProperty = dbPropertyChain[0];
                    throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Cannot update the same column multiple times in the same statement:
	Property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}')
	maps to table: ${firstProperty.entity.tableConfig.name}, column: ${dbColumn.name}
		which has already been set in this update statement (above).
				`);
                }
                jsonSetClause[dbColumn.name] = value.toJSON(this.columnAliases, false, queryUtils, fieldUtils, relationManager);
                return;
            }
        }
        // This should be a nested property definition
        else {
            if (typeof value === 'object') {
                const dbRelation = dbProperty.relation[0];
                const childDbRelationChain = [...dbRelationChain];
                childDbRelationChain.push(dbRelation);
                switch (dbRelation.relationType) {
                    case EntityRelationType.MANY_TO_ONE: {
                        this.setEntityFragmentsToJSON(value, jsonSetClause, dbPropertyChain, dbRelation.relationEntity.propertyMap, childDbRelationChain, queryUtils, fieldUtils, relationManager);
                        break;
                    }
                    case EntityRelationType.ONE_TO_MANY:
                        // Not  nested property definition
                        throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

				Cannot update @OneToMany properties:
					Property: '${propertyName}' of entity: '${this.rawUpdate.update.__driver__.dbEntity.name}
					is a @OneToMany relation and cannot be updated since it is
					assumed to be based on @Id columns (which cannot be updated).'
				`);
                    default:
                        // Not  nested property definition
                        throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

				Undefined relation type: 
					Property: '${propertyName}' of entity: '${this.rawUpdate.update.__driver__.dbEntity.name}'
					is defined with an unknown type of a relation.  Expecting either
					@ManyToOne(...)
					or
					@OneToMany(...)
				`);
                }
                return;
            }
            else {
                // Not  nested property definition
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

				Unexpected value ${JSON.stringify(value)} 
					for property: '${propertyName}' of entity: '${this.rawUpdate.update.__driver__.dbEntity.name}'
				Expecting a nested property definition.
				`);
            }
        }
    }
    getPropertyChainDesription(dbPropertyChain) {
        const rootDbEntity = dbPropertyChain[0].entity;
        let prefix = '    ';
        let lastPrefix = '';
        let ending = `...
}`;
        let message = `
Updated Entity: ${rootDbEntity.name}, property chain:
{`;
        const maxChainDepth = dbPropertyChain.length;
        for (let i = 0; i < maxChainDepth; i++) {
            let dbProperty = dbPropertyChain[i];
            message += `${prefix}${dbProperty.name}: `;
            if (i + 1 < maxChainDepth) {
                message += `: {\n`;
            }
            else {
                message += 'VALUE';
            }
            ending = prefix + `...
${lastPrefix}}`;
            lastPrefix = prefix;
            prefix += '    ';
        }
        return `${message}
${ending}`;
    }
}

var __decorate$2x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 6/14/2016.
 */
let EntityUtils = class EntityUtils {
    getObjectClassName(object) {
        if (typeof object != 'object' || object === null) {
            throw new Error(`Not an object instance`);
        }
        return this.getClassName(object.constructor);
    }
    getClassName(clazz) {
        if (typeof clazz != 'function') {
            throw new Error(`Not a constructor function`);
        }
        let className = clazz['name'];
        // let className = /(\w+)\(/.exec(clazz.toString())[1];
        return className;
    }
    exists(object) {
        return this.utils.objectExists(object);
    }
    /*
     static isBlank(
     object: any
     ) {
     for (let propertyName in object) {
     let property = object[propertyName];
     if (this.exists(property)) {
     if (property instanceof Array) {
     if (property.length > 0) {
     return false;
     }
     } else {
     return false;
     }
     }
     }
     return true;
     }
     */
    isAppliable(object) {
        return object instanceof QOperableField;
    }
    getQuery(query) {
        return this.getRawQuery(query);
    }
    getRawQuery(rawQuery) {
        if (rawQuery instanceof Function) {
            return rawQuery();
        }
        else {
            return rawQuery;
        }
    }
    getEntityQuery(rawGraphQuery) {
        return new EntityQuery(this.getRawQuery(rawGraphQuery));
    }
};
__decorate$2x([
    Inject()
], EntityUtils.prototype, "utils", void 0);
EntityUtils = __decorate$2x([
    Injected()
], EntityUtils);

var __decorate$2w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let FieldUtils = class FieldUtils {
    getFieldQueryJson(fieldSubQuery, entityAliases, queryUtils) {
        let subSelectQuery = new FieldQuery(fieldSubQuery, entityAliases);
        return subSelectQuery.toJSON(queryUtils, this, this.relationManager);
    }
};
__decorate$2w([
    Inject()
], FieldUtils.prototype, "relationManager", void 0);
FieldUtils = __decorate$2w([
    Injected()
], FieldUtils);

var __decorate$2v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let QMetadataUtils = class QMetadataUtils {
    getAllColumns(qEntity) {
        return qEntity.__driver__.allColumns;
    }
    getAllNonGeneratedColumns(qEntity) {
        return this.getAllColumns(qEntity).filter(qField => !qField.dbColumn.isGenerated);
    }
    getAllInsertableColumns(qEntity) {
        return this.getAllColumns(qEntity).filter(qField => {
            if (qField.dbColumn.isGenerated) {
                return false;
            }
            if (qEntity.__driver__.dbEntity.isRepositoryEntity) {
                switch (qField.dbColumn.name) {
                    case repositoryEntity.SYSTEM_WIDE_OPERATION_ID:
                        return false;
                }
            }
            return true;
        });
    }
    getDbEntity(qEntity) {
        return qEntity.__driver__.dbEntity;
    }
    getNewEntity(qEntity, airDb) {
        const dbEntity = qEntity.__driver__.dbEntity;
        const entityConstructor = airDb.qApplications[dbEntity.applicationVersion.application.index].__constructors__[dbEntity.name];
        if (!entityConstructor) {
            return {};
        }
        return new entityConstructor();
    }
};
QMetadataUtils = __decorate$2v([
    Injected()
], QMetadataUtils);

var __decorate$2u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let QueryUtils = class QueryUtils {
    whereClauseToJSON(whereClause, columnAliases) {
        if (!whereClause) {
            return null;
        }
        let operation = whereClause;
        let jsonOperation = {
            c: operation.c,
            o: operation.o
        };
        switch (operation.c) {
            case OperationCategory.LOGICAL:
                let logicalOperation = operation;
                let jsonLogicalOperation = jsonOperation;
                switch (operation.o) {
                    case SqlOperator.NOT:
                        jsonLogicalOperation.v = this.whereClauseToJSON(logicalOperation.v, columnAliases);
                        break;
                    case SqlOperator.AND:
                    case SqlOperator.OR:
                        jsonLogicalOperation.v = logicalOperation.v.map((value) => this.whereClauseToJSON(value, columnAliases));
                        break;
                    default:
                        throw new Error(`Unsupported logical operation '${operation.o}'`);
                }
                break;
            case OperationCategory.FUNCTION:
                // TODO: verify that cast of Q object is valid
                let functionOperation = operation;
                let query = functionOperation.getQuery();
                let jsonQuery = new TreeQuery(query, columnAliases.entityAliases).toJSON(this, this.fieldUtils, this.relationManager);
                jsonOperation = functionOperation.toJSON(jsonQuery);
                break;
            case OperationCategory.BOOLEAN:
            case OperationCategory.DATE:
            case OperationCategory.NUMBER:
            case OperationCategory.STRING:
            case OperationCategory.UNTYPED:
                let valueOperation = operation;
                // All Non logical or exists operations are value operations (eq, isNull, like,
                // etc.)
                let jsonValueOperation = jsonOperation;
                jsonValueOperation.l = this.convertLRValue(valueOperation.l, columnAliases);
                let rValue = valueOperation.r;
                if (rValue instanceof Array) {
                    jsonValueOperation.r = rValue.map((anRValue) => {
                        return this.convertLRValue(anRValue, columnAliases);
                    });
                }
                else {
                    jsonValueOperation.r = this.convertLRValue(rValue, columnAliases);
                }
                break;
        }
        return jsonOperation;
    }
    convertLRValue(value, columnAliases) {
        value = wrapPrimitive(value);
        switch (typeof value) {
            case 'undefined':
                throw new Error(`'undefined' is not a valid L or R value`);
            default:
                if (value instanceof QOperableField) {
                    return value.toJSON(columnAliases, false, this, this.fieldUtils, this.relationManager);
                } // Must be a Field Query
                else {
                    let rawFieldQuery = value;
                    return this.fieldUtils.getFieldQueryJson(rawFieldQuery, columnAliases.entityAliases, this);
                }
        }
    }
};
__decorate$2u([
    Inject()
], QueryUtils.prototype, "fieldUtils", void 0);
__decorate$2u([
    Inject()
], QueryUtils.prototype, "relationManager", void 0);
QueryUtils = __decorate$2u([
    Injected()
], QueryUtils);

const Y = {
    airportSelectField: true,
    insert: true,
    update: false
};
const ALL_FIELDS = {
    __allFields__: true
};
function convertToY(object) {
    object.airportSelectField = true;
}
function isY(object) {
    return object && object.airportSelectField === true;
}
function isN(object) {
    return object && object.airportSelectField === false;
}
function isID(object) {
    return object && object.airportSelectField === 'ID';
}

var __decorate$2t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ApplicationUtils_1;
let ApplicationUtils = ApplicationUtils_1 = class ApplicationUtils {
    getDbEntity(applicationIndex, tableIndex) {
        return this.airportDatabase.applications[applicationIndex].currentVersion[0]
            .applicationVersion.entities[tableIndex];
    }
    isActorId(columnName) {
        return columnName === repositoryEntity.ACTOR_ID;
    }
    isActorRecordId(columnName) {
        return columnName === repositoryEntity.ACTOR_RECORD_ID;
    }
    isRepositoryId(columnName) {
        return columnName === repositoryEntity.REPOSITORY_ID;
    }
    doCascade(dbRelation, crudOperation) {
        if (dbRelation.relationType !== EntityRelationType.ONE_TO_MANY) {
            return false;
        }
        if (!dbRelation.oneToManyElems) {
            return false;
        }
        switch (crudOperation) {
            case CRUDOperation.CREATE:
            case CRUDOperation.UPDATE:
            case CRUDOperation.DELETE:
                return true;
            default:
                throw new Error(`Unsupported CRUDOperation '${crudOperation}' for cascade check.`);
        }
    }
    getQEntityConstructor(dbEntity) {
        return this.airportDatabase.qApplications[dbEntity.applicationVersion.application.index]
            .__qConstructors__[dbEntity.index];
    }
    getEntityConstructor(dbEntity) {
        const entityConstructor = this.airportDatabase.qApplications[dbEntity.applicationVersion.application.index]
            .__constructors__[dbEntity.name];
        return entityConstructor;
    }
    getNewEntity(dbEntity) {
        const entityConstructor = this.getEntityConstructor(dbEntity);
        if (!entityConstructor) {
            return {};
        }
        return new entityConstructor();
    }
    isIdEmpty(idValue) {
        return !idValue && idValue !== 0;
    }
    isEmpty(value) {
        return this.isIdEmpty(value) && value !== false && value !== '';
    }
    isRelationColumn(dbColumn) {
        return this.isManyRelationColumn(dbColumn)
            || this.isOneRelationColumn(dbColumn);
    }
    isManyRelationColumn(dbColumn) {
        return !!(dbColumn.manyRelationColumns && dbColumn.manyRelationColumns.length);
    }
    isOneRelationColumn(dbColumn) {
        return !!(dbColumn.oneRelationColumns && dbColumn.oneRelationColumns.length);
    }
    getIdKey(entityObject, dbEntity, failOnNoId = true, 
    // noIdValueCallback: {
    // 	(
    // 		relationColumn: DbColumn,
    // 		value: any,
    // 		propertyNameChains: string[][],
    // 	): boolean;
    // } = null,
    idValueCallback) {
        const keys = this.getIdKeyInfo(entityObject, dbEntity, failOnNoId, idValueCallback);
        return keys.arrayByIdColumnIndex.join('|');
    }
    getIdKeyInfo(entityObject, dbEntity, failOnNoId = true, idValueCallback) {
        if (!dbEntity.idColumns.length) {
            if (failOnNoId) {
                throw new Error(`@Id is not defined on entity '${dbEntity.name}'.`);
            }
            return null;
        }
        const idKeys = {
            arrayByIdColumnIndex: [],
            mapByIdColumnName: {}
        };
        for (const dbColumn of dbEntity.idColumns) {
            const [propertyNameChains, idValue] = this.getColumnPropertyNameChainsAndValue(dbEntity, dbColumn, entityObject, true, failOnNoId);
            idValueCallback && idValueCallback(dbColumn, idValue, propertyNameChains);
            idKeys.arrayByIdColumnIndex.push(idValue);
            idKeys.mapByIdColumnName[dbColumn.name] = idValue;
        }
        return idKeys;
    }
    getColumnPropertyNameChainsAndValue(dbEntity, dbColumn, entityObject, forIdKey = false, generateNegativeIdsForMissing = true) {
        const columnValuesAndPaths = this.getColumnValuesAndPaths(dbColumn, entityObject, [], forIdKey, generateNegativeIdsForMissing);
        const firstColumnValueAndPath = columnValuesAndPaths[0];
        const propertyNameChains = [firstColumnValueAndPath.path];
        const value = firstColumnValueAndPath.value;
        columnValuesAndPaths.reduce((last, current) => {
            if (!this.utils.valuesEqual(last.value, current.value, true)) {
                throw new Error(`Values differ for ${dbEntity.name}.${dbColumn.name}:
						'${last.path.join('.')}' = ${last.value}
						'${current.path.join('.')}' = ${current.value}`);
            }
            propertyNameChains.push(current.path);
            return current;
        });
        return [propertyNameChains, value];
    }
    addRelationToEntitySelectClause(dbRelation, selectClause, allowDefaults = false) {
        this.forEachColumnTypeOfRelation(dbRelation, (dbColumn, propertyNameChains) => {
            let convertTo = true;
            let propertySelectClause = selectClause;
            const firstPropertyNameChain = propertyNameChains[0];
            firstPropertyNameChain.forEach((propertyNameLink, index) => {
                let propertyObject = propertySelectClause[propertyNameLink];
                if (!propertyObject) {
                    propertyObject = {};
                    this.entityStateManager.markAsStub(propertyObject);
                    propertySelectClause[propertyNameLink] = propertyObject;
                }
                else {
                    if (index < firstPropertyNameChain.length - 1) {
                        if (!(propertyObject instanceof Object) || propertyObject instanceof Date) {
                            throw new Error(`Invalid entry:
								...
								{
									...
									${propertyNameLink}: ${propertyObject}
								}
								in '${dbRelation.property.entity.name}.${dbRelation.property.name}',
								Property must be an Object.`);
                        }
                    }
                    else {
                        if (!allowDefaults && !isY(propertyObject)) {
                            const reason = dbRelation.property.isId
                                ? `'${dbRelation.property.entity.name}.${dbRelation.property.name}' is an @Id property`
                                : `'${dbRelation.property.entity.name}' has no @Id - all properties are treated as @Ids`;
                            throw new Error(`Defaults are not allowed in:
								...
								{
									...
									${propertyNameLink}: ${propertyObject}
								}
								${reason}.`);
                        }
                        convertTo = false;
                    }
                }
                propertySelectClause = propertyObject;
            });
            if (convertTo) {
                convertToY(propertySelectClause);
            }
        });
    }
    forEachColumnOfRelation(dbRelation, entity, callback, failOnNoValue = true) {
        const dbEntity = dbRelation.property.entity;
        for (const dbRelationColumn of dbRelation.manyRelationColumns) {
            const dbColumn = dbRelationColumn.manyColumn;
            const [propertyNameChains, value] = this.getColumnPropertyNameChainsAndValue(dbEntity, dbColumn, entity);
            if (callback(dbColumn, value, propertyNameChains)) {
                return;
            }
        }
    }
    forEachColumnTypeOfRelation(dbRelation, callback) {
        for (const dbRelationColumn of dbRelation.manyRelationColumns) {
            const dbColumn = dbRelationColumn.manyColumn;
            const propertyNameChains = this.getColumnPaths(dbColumn, []);
            if (callback(dbColumn, propertyNameChains)) {
                return;
            }
        }
    }
    getSheetSelectFromSetClause(dbEntity, qEntity, setClause, errorPrefix) {
        const selectClause = [];
        let actorIdColumnIndex;
        let actorRecordIdColumnIndex;
        let repositoryIdColumnIndex;
        let systemWideOperationIdColumn;
        for (const columnIndex in dbEntity.columns) {
            const dbColumn = dbEntity.columns[columnIndex];
            let dbProperty;
            const isIdColumn = dbColumn.propertyColumns.some(propertyColumn => {
                dbProperty = propertyColumn.property;
                return dbProperty.isId;
            });
            let nonIdColumnSet = false;
            if (isIdColumn) {
                if (setClause[dbColumn.name]) {
                    throw new Error(errorPrefix + `Cannot update @Id column '${dbColumn.name}' 
of property '${dbEntity.name}.${dbProperty.name}'.`);
                }
                this.addColumnToSheetSelect(dbColumn, qEntity, selectClause);
            }
            else if (setClause[dbColumn.name]) {
                nonIdColumnSet = true;
                this.addColumnToSheetSelect(dbColumn, qEntity, selectClause);
                // } else {
                // entitySelectClause[dbColumn.index] = null;
            }
            const inQueryColumnIndex = selectClause.length - 1;
            switch (dbColumn.name) {
                case repositoryEntity.ACTOR_ID:
                    actorIdColumnIndex = inQueryColumnIndex;
                    break;
                case repositoryEntity.ACTOR_RECORD_ID:
                    actorRecordIdColumnIndex = inQueryColumnIndex;
                    break;
                case repositoryEntity.REPOSITORY_ID:
                    repositoryIdColumnIndex = inQueryColumnIndex;
                    break;
                case repositoryEntity.SYSTEM_WIDE_OPERATION_ID:
                    if (nonIdColumnSet) {
                        throw new Error(errorPrefix +
                            `Cannot update 'systemWideOperationId' of Repository Entities.`);
                    }
                    systemWideOperationIdColumn = dbColumn;
                    break;
            }
        }
        return {
            actorIdColumnIndex,
            actorRecordIdColumnIndex,
            repositoryIdColumnIndex,
            selectClause,
            systemWideOperationIdColumn
        };
    }
    getColumnValuesAndPaths(dbColumn, relationObject, breadCrumb, forIdKey = false, generateNegativeIdsForMissing = true
    // noIdValueCallback: {
    // 	(
    // 		relationColumn: DbColumn,
    // 		value: any,
    // 		propertyNameChains: string[][],
    // 	): void;
    // }
    ) {
        if (this.isManyRelationColumn(dbColumn)) {
            let columnValuesAndPaths = [];
            // If a column is part of a relation, it would be on the Many Side
            for (const dbRelationColumn of dbColumn.manyRelationColumns) {
                const dbProperty = dbRelationColumn.manyRelation.property;
                const relationBreadCrumb = [...breadCrumb];
                const propertyName = dbProperty.name;
                relationBreadCrumb.push(propertyName);
                const value = relationObject[propertyName];
                if (!value) {
                    if (forIdKey
                    // && this.handleNoId(dbColumn, dbProperty, relationBreadCrumb, value,
                    // noIdValueCallback)
                    ) {
                        throw new Error(`Cannot retrieve composite Id value, value chain '${relationBreadCrumb.join('.')}' is : ${value}.`);
                        // return null;
                    }
                    columnValuesAndPaths.push({
                        path: relationBreadCrumb,
                        value
                    });
                }
                else {
                    const otherEntityColumn = dbRelationColumn.oneColumn;
                    const relationValuesAndPaths = this.getColumnValuesAndPaths(otherEntityColumn, value, relationBreadCrumb, forIdKey);
                    columnValuesAndPaths = columnValuesAndPaths.concat(relationValuesAndPaths);
                }
            }
            return columnValuesAndPaths;
        }
        else {
            // If a column is not a part of (a) relation(s) then it is associated
            // to only one property
            const dbProperty = dbColumn.propertyColumns[0].property;
            const propertyBreadCrumb = [...breadCrumb];
            const propertyName = dbProperty.name;
            propertyBreadCrumb.push(propertyName);
            let value = relationObject[propertyName];
            if (forIdKey && this.isIdEmpty(value)) {
                if (dbColumn.isGenerated) {
                    if (generateNegativeIdsForMissing) {
                        value = --ApplicationUtils_1.TEMP_ID;
                    }
                    else {
                        value = null;
                    }
                    relationObject[propertyName] = value;
                }
                else {
                    // if (this.handleNoId(dbColumn, dbProperty, propertyBreadCrumb, value,
                    // noValueCallback)) { return null; }
                    throw new Error(`Cannot retrieve composite Id value, value chain '${propertyBreadCrumb.join('.')}' is : ${value}.`);
                }
            }
            return [{
                    path: propertyBreadCrumb,
                    value
                }];
        }
    }
    getColumnPaths(dbColumn, breadCrumb) {
        let columnValuesAndPaths = [];
        if (this.isManyRelationColumn(dbColumn)) {
            // If a column is part of a relation, it would be on the Many Side
            for (const dbRelationColumn of dbColumn.manyRelationColumns) {
                const dbProperty = dbRelationColumn.manyRelation.property;
                const relationBreadCrumb = [...breadCrumb];
                relationBreadCrumb.push(dbProperty.name);
                const otherEntityColumn = dbRelationColumn.oneColumn;
                const relationValuesAndPaths = this.getColumnPaths(otherEntityColumn, relationBreadCrumb);
                columnValuesAndPaths = columnValuesAndPaths.concat(relationValuesAndPaths);
            }
        }
        else {
            // If a column is not a part of (a) relation(s) then it is associated
            // to only one property
            const dbProperty = dbColumn.propertyColumns[0].property;
            const propertyBreadCrumb = [...breadCrumb];
            propertyBreadCrumb.push(dbProperty.name);
            columnValuesAndPaths.push(propertyBreadCrumb);
        }
        return columnValuesAndPaths;
    }
    addColumnToSheetSelect(dbColumn, qEntity, entitySelectClause) {
        if (this.isManyRelationColumn(dbColumn)) {
            const columnPaths = this.getColumnPaths(dbColumn, []);
            const firstColumnPath = columnPaths[0];
            let relationColumn = qEntity[firstColumnPath[0]];
            firstColumnPath.reduce((last, current) => {
                relationColumn = relationColumn[current];
                return current;
            });
            entitySelectClause.push(relationColumn);
        }
        else {
            entitySelectClause.push(qEntity[dbColumn.propertyColumns[0].property.name]);
        }
    }
    /*
        private addColumnToEntitySelect(
            dbColumn: DbColumn,
            entitySelectClause: any,
        ) {
            const dbRelation = dbColumn.relation;
            if (dbRelation) {
                let selectClauseFragment = entitySelectClause;
                let lastSelectClauseFragment;
                let sourceColumn = dbColumn;
                let lastPropertyName;
                do {
                    lastPropertyName = sourceColumn.property.name;
                    lastSelectClauseFragment = selectClauseFragment;
                    if (!lastSelectClauseFragment[lastPropertyName]) {
                        selectClauseFragment = {};
                        lastSelectClauseFragment[lastPropertyName] = selectClauseFragment;
                    } else {
                        selectClauseFragment = lastSelectClauseFragment[lastPropertyName];
                    }
                    const relationColumn = sourceColumn.relation.relationColumns.filter(
                        relationColumn => relationColumn.ownColumn.index === sourceColumn.index)[0];
                    sourceColumn = relationColumn.relationColumn;
                } while (sourceColumn.relation);
                lastSelectClauseFragment[lastPropertyName] = null;
            } else {
                entitySelectClause[dbColumn.property.name] = null;
            }
        }
    */
    handleNoId(dbColumn, dbProperty, propertyNameChains, value, noIdValueCallback) {
        if (noIdValueCallback) {
            if (!noIdValueCallback(dbColumn, value, propertyNameChains)) {
                return true;
            }
        }
        else {
            throw new Error(`Cannot retrieve composite Id value, value chain '${propertyNameChains.join('.')}' is : ${value}.`);
        }
        return false;
    }
};
ApplicationUtils.TEMP_ID = 0;
__decorate$2t([
    Inject()
], ApplicationUtils.prototype, "airportDatabase", void 0);
__decorate$2t([
    Inject()
], ApplicationUtils.prototype, "entityStateManager", void 0);
__decorate$2t([
    Inject()
], ApplicationUtils.prototype, "utils", void 0);
ApplicationUtils = ApplicationUtils_1 = __decorate$2t([
    Injected()
], ApplicationUtils);

const databaseState = {
    applications: [],
    entityMap: new Map(),
    functions: {
        abs,
        avg,
        count,
        max,
        min,
        sum,
        ucase,
        lcase,
        mid,
        len,
        round,
        now: now$1,
        format,
        replace,
        trim,
        distinct,
        exists,
        divide,
        subtract,
        modulus,
        multiply,
        add: add$2,
        concat,
        union,
        unionAll,
        intersect,
        minus,
        // logical operators
        and,
        not,
        or,
        // primitive wrappers
        bool,
        date,
        num,
        str,
        wrapPrimitive,
    },
    qApplications: [],
    QM: {},
};

var __decorate$2s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DatabaseStore = class DatabaseStore {
    constructor() {
        this.databaseState = databaseState;
    }
    get applications() {
        return this.databaseState.applications;
    }
    get entityMap() {
        return this.databaseState.entityMap;
    }
    get functions() {
        return this.databaseState.functions;
    }
    get qApplications() {
        return this.databaseState.qApplications;
    }
    get QM() {
        return this.databaseState.QM;
    }
};
DatabaseStore = __decorate$2s([
    Injected()
], DatabaseStore);

var __decorate$2r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Utils = class Utils {
    strsToNums(strings) {
        return strings.map(str => parseInt(str));
    }
    objectExists(object) {
        return object !== null && object !== undefined;
    }
    valuesEqual(value1, value2, checkChildObjects = false) {
        if (typeof value1 === 'object') {
            if (value1 instanceof Date) {
                if (value2 instanceof Date) {
                    return value1.getTime() === value2.getTime();
                }
                else {
                    return false;
                }
            }
            else {
                if (typeof value2 !== 'object') {
                    return false;
                }
                if (!checkChildObjects) {
                    // Skip child objects
                    return true;
                }
                let checkedKeys = {};
                for (let key in value1) {
                    checkedKeys[key] = true;
                    if (!this.valuesEqual(value1[key], value2[key], checkChildObjects)) {
                        return false;
                    }
                }
                for (let key in value2) {
                    if (!checkedKeys[key]) {
                        return false;
                    }
                }
                return true;
            }
        }
        if (!value1) {
            if (value1 === '') {
                return value2 === '';
            }
            else if (value1 === false) {
                return value2 === false;
            }
            else if (value1 === 0) {
                return value2 === 0;
            }
            if (value2 === '' || value2 === false || value2 === 0) {
                return false;
            }
            // treat undefined and null as same value
            return (!value2);
        }
        if (!value2) {
            return false;
        }
        return value1 === value2;
    }
    compareNumbers(number1, number2) {
        if (number1 < number2) {
            return -1;
        }
        if (number1 > number2) {
            return 1;
        }
        return 0;
    }
};
Utils = __decorate$2r([
    Injected()
], Utils);

var ConstraintMode;
(function (ConstraintMode) {
    ConstraintMode["CONSTRAINT"] = "CONSTRAINT";
    ConstraintMode["NO_CONSTRAINT"] = "NO_CONSTRAINT";
    ConstraintMode["PROVIDER_DEFAULT"] = "PROVIDER_DEFAULT";
})(ConstraintMode || (ConstraintMode = {}));

const airTrafficControl = lib$1('air-traffic-control');
const AIRPORT_DATABASE = airTrafficControl.token({
    class: null,
    interface: 'IAirportDatabase',
    token: 'AIRPORT_DATABASE'
});
const APPLICATION_UTILS = airTrafficControl.token({
    class: ApplicationUtils,
    interface: 'IApplicationUtils',
    token: 'APPLICATION_UTILS'
});
const DATABASE_FACADE = airTrafficControl.token({
    class: null,
    interface: 'IDatabaseFacade',
    token: 'DATABASE_FACADE'
});
const DATABASE_STORE = airTrafficControl.token({
    class: DatabaseStore,
    interface: 'IDatabaseState',
    token: 'DATABASE_STORE'
});
const ENTITY_UTILS = airTrafficControl.token({
    class: EntityUtils,
    interface: 'IEntityUtils',
    token: 'ENTITY_UTILS'
});
const FIELD_UTILS = airTrafficControl.token({
    class: FieldUtils,
    interface: 'IFieldUtils',
    token: 'FIELD_UTILS'
});
const LOOKUP = airTrafficControl.token({
    class: Lookup,
    interface: 'ILookup',
    token: 'LOOKUP'
});
const NON_ENTITY_FIND = airTrafficControl.token({
    class: NonEntityFind,
    interface: 'INonEntityFind',
    token: 'NON_ENTITY_FIND'
});
const NON_ENTITY_FIND_ONE = airTrafficControl.token({
    class: NonEntityFindOne,
    interface: 'INonEntityFindOne',
    token: 'NON_ENTITY_FIND_ONE'
});
const NON_ENTITY_SEARCH = airTrafficControl.token({
    class: NonEntitySearch,
    interface: 'INonEntitySearch',
    token: 'NON_ENTITY_SEARCH'
});
const NON_ENTITY_SEARCH_ONE = airTrafficControl.token({
    class: NonEntitySearchOne,
    interface: 'INonEntitySearchOne',
    token: 'NON_ENTITY_SEARCH_ONE'
});
const Q_METADATA_UTILS = airTrafficControl.token({
    class: QMetadataUtils,
    interface: 'IQMetadataUtils',
    token: 'Q_METADATA_UTILS'
});
const QUERY_FACADE = airTrafficControl.token({
    class: null,
    interface: 'IQueryFacade',
    token: 'QUERY_FACADE'
});
const QUERY_UTILS = airTrafficControl.token({
    class: QueryUtils,
    interface: 'IQueryUtils',
    token: 'QUERY_UTILS'
});
const RELATION_MANAGER = airTrafficControl.token({
    class: RelationManager,
    interface: 'IRelationManager',
    token: 'RELATION_MANAGER'
});
const REPOSITORY_LOADER = airTrafficControl.token({
    class: null,
    interface: 'IRepositoryLoader',
    token: 'REPOSITORY_LOADER'
});
const UPDATE_CACHE_MANAGER = airTrafficControl.token({
    class: null,
    interface: 'IUpdateCacheManager',
    token: 'UPDATE_CACHE_MANAGER'
});
const UTILS = airTrafficControl.token({
    class: Utils,
    interface: 'IUtils',
    token: 'UTILS'
});
AIRPORT_DATABASE.setDependencies({
    appliationUtils: APPLICATION_UTILS,
    databaseFacade: DATABASE_FACADE,
    databaseStore: DATABASE_STORE,
    dbApplicationUtils: DB_APPLICATION_UTILS,
    find: NON_ENTITY_FIND,
    findOne: NON_ENTITY_FIND_ONE,
    relationManager: RELATION_MANAGER,
    search: NON_ENTITY_SEARCH,
    searchOne: NON_ENTITY_SEARCH_ONE
});
APPLICATION_UTILS.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    entityStateManager: ENTITY_STATE_MANAGER,
    utils: UTILS
});
DATABASE_FACADE.setDependencies({
    applicationUtils: APPLICATION_UTILS,
    entityStateManager: ENTITY_STATE_MANAGER,
    transactionalConnector: TRANSACTIONAL_CONNECTOR,
    updateCacheManager: UPDATE_CACHE_MANAGER
});
ENTITY_UTILS.setDependencies({
    utils: UTILS
});
FIELD_UTILS.setDependencies({
    relationManager: RELATION_MANAGER
});
LOOKUP.setDependencies({
    entityUtils: ENTITY_UTILS,
    queryFacade: QUERY_FACADE
});
QUERY_FACADE.setDependencies({
    fieldUtils: FIELD_UTILS,
    queryUtils: QUERY_UTILS,
    relationManager: RELATION_MANAGER,
    transactionalConnector: TRANSACTIONAL_CONNECTOR
});
QUERY_UTILS.setDependencies({
    fieldUtils: FIELD_UTILS,
    relationManager: RELATION_MANAGER
});
RELATION_MANAGER.setDependencies({
    applicationUtils: APPLICATION_UTILS
});
UPDATE_CACHE_MANAGER.setDependencies({
    applicationUtils: APPLICATION_UTILS,
    entityStateManager: ENTITY_STATE_MANAGER,
});

var UpdateState;
(function (UpdateState) {
    UpdateState["GO_ONLINE"] = "GO_ONLINE";
    UpdateState["REMOTE"] = "REMOTE";
    UpdateState["LOCAL"] = "LOCAL";
})(UpdateState || (UpdateState = {}));

/**
 * Created by Papa on 4/16/2017.
 */
var RepositoryEntityType;
(function (RepositoryEntityType) {
    RepositoryEntityType["NOT_REPOSITORY_ENTITY"] = "NOT_REPOSITORY_ENTITY";
    RepositoryEntityType["REPOSITORY_ENTITY"] = "REPOSITORY_ENTITY";
})(RepositoryEntityType || (RepositoryEntityType = {}));
const REPOSITORY_FIELD = 'repository';

/**
 * For logic classes to be hot-swappable for quick upgrades all state is contained
 * in one non-reloadable BehaviorSubject.
 */
const internalTerminalState = new BehaviorSubject({
    applicationActors: [],
    applications: [],
    domains: [],
    frameworkActor: null,
    internalConnector: {
        dbName: '',
        internalCredentials: {
            application: null,
            domain: INTERNAL_DOMAIN,
            methodName: null,
            objectName: null
        },
        serverUrl: ''
    },
    lastIds: {
        columns: 0,
        domains: 0,
        entities: 0,
        properties: 0,
        propertyColumns: 0,
        relations: 0,
        relationColumns: 0,
        applications: 0,
        applicationVersions: 0
    },
    receiver: {
        initializedApps: new Set(),
        initializingApps: new Set(),
    },
    sequenceGenerator: {
        sequences: [],
        sequenceBlocks: [],
        generatingSequenceNumbers: false
    },
    terminal: null,
    transactionManager: {
        pendingTransactionQueue: [],
        rootTransactionInProgressMap: new Map(),
        transactionInProgressMap: new Map()
    },
    webReceiver: {
        domainPrefix: '',
        localDomain: '',
        mainDomainFragments: [],
        onClientMessageCallback: null,
        pendingApplicationCounts: new Map(),
        pendingHostCounts: new Map(),
        pendingInterAppApiCallMessageMap: new Map(),
        subsriptionMap: new Map()
    }
});

var __decorate$2q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TerminalState = class TerminalState {
    constructor() {
        this.terminalState = internalTerminalState;
    }
};
TerminalState = __decorate$2q([
    Injected()
], TerminalState);

var __decorate$2p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TerminalStore = class TerminalStore {
    get state() {
        return this.terminalState.terminalState;
    }
    async init() {
        this.getTerminalState = this.selectorManager.createRootSelector(this.state);
        this.getApplicationActors = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.applicationActors);
        this.getApplicationActorMapByDomainAndApplicationNames = this.selectorManager.createSelector(this.getApplicationActors, applicationActors => {
            const applicationActorsByDomainAndApplicationNames = new Map();
            for (const applicationActor of applicationActors) {
                const applicationActorMapForDomain = ensureChildJsMap(applicationActorsByDomainAndApplicationNames, applicationActor.application.domain.name);
                let actorsForApplication = applicationActorMapForDomain
                    .get(applicationActor.application.name);
                if (!actorsForApplication) {
                    actorsForApplication = [];
                    applicationActorMapForDomain.set(applicationActor.application.name, actorsForApplication);
                }
                actorsForApplication.push(applicationActor);
            }
            return applicationActorsByDomainAndApplicationNames;
        });
        this.getDomains = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.domains);
        this.getDomainMapByName = this.selectorManager.createSelector(this.getDomains, domains => {
            const domainsByName = new Map();
            for (const domain of domains) {
                domainsByName.set(domain.name, domain);
            }
            return domainsByName;
        });
        this.getFrameworkActor = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.frameworkActor);
        this.getInternalConnector = this.selectorManager.createSelector(this.getTerminalState, terminalState => terminalState.internalConnector);
        this.getLastIds = this.selectorManager.createSelector(this.getTerminalState, terminalState => terminalState.lastIds);
        this.getLatestApplicationVersionMapByNames = this.selectorManager.createSelector(this.getDomains, domains => {
            const latestApplicationVersionMapByNames = new Map();
            for (const domain of domains) {
                const mapForDomain = ensureChildJsMap(latestApplicationVersionMapByNames, domain.name);
                for (const application of domain.applications) {
                    mapForDomain.set(application.name, application.currentVersion[0].applicationVersion);
                }
            }
            return latestApplicationVersionMapByNames;
        });
        this.getLatestApplicationVersionMapByFullApplicationName = this.selectorManager.createSelector(this.getLatestApplicationVersionMapByNames, (latestApplicationVersionMapByNames) => {
            const latestApplicationVersionMapByFullApplicationName = new Map();
            for (const applicationVersionsForDomainName of latestApplicationVersionMapByNames.values()) {
                for (const applicationVersion of applicationVersionsForDomainName.values()) {
                    latestApplicationVersionMapByFullApplicationName.set(applicationVersion.application.fullName, applicationVersion);
                }
            }
            return latestApplicationVersionMapByFullApplicationName;
        });
        this.getAllApplicationVersionsByIds = this.selectorManager.createSelector(this.getDomains, domains => {
            const allApplicationVersionsByIds = [];
            for (const domain of domains) {
                for (const application of domain.applications) {
                    for (const applicationVersion of application.versions) {
                        allApplicationVersionsByIds[applicationVersion.id] = applicationVersion;
                    }
                }
            }
            return allApplicationVersionsByIds;
        });
        this.getLatestApplicationVersionsByApplicationIndexes = this.selectorManager.createSelector(this.getDomains, domains => {
            const latestApplicationVersionsByApplicationIndexes = [];
            for (const domain of domains) {
                for (const application of domain.applications) {
                    latestApplicationVersionsByApplicationIndexes[application.index]
                        = application.currentVersion[0].applicationVersion;
                }
            }
            return latestApplicationVersionsByApplicationIndexes;
        });
        this.getApplications = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.applications);
        this.getAllEntities = this.selectorManager.createSelector(this.getLatestApplicationVersionsByApplicationIndexes, latestApplicationVersionsByApplicationIndexes => {
            const allEntities = [];
            for (const latestApplicationVersion of latestApplicationVersionsByApplicationIndexes) {
                if (!latestApplicationVersion) {
                    continue;
                }
                for (const entity of latestApplicationVersion.entities) {
                    allEntities[entity.id] = entity;
                }
            }
            return allEntities;
        });
        this.getAllColumns = this.selectorManager.createSelector(this.getAllEntities, allEntities => {
            const allColumns = [];
            for (const entity of allEntities) {
                if (!entity) {
                    continue;
                }
                for (const column of entity.columns) {
                    allColumns[column.id] = column;
                }
            }
            return allColumns;
        });
        this.getAllRelations = this.selectorManager.createSelector(this.getAllEntities, allEntities => {
            const allRelations = [];
            for (const entity of allEntities) {
                if (!entity) {
                    continue;
                }
                for (const relation of entity.relations) {
                    allRelations[relation.id] = relation;
                }
            }
            return allRelations;
        });
        this.getReceiver = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.receiver);
        this.getSequenceGenerator = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.sequenceGenerator);
        this.getTransactionManager = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.transactionManager);
        this.getWebReceiver = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.webReceiver);
    }
    tearDown() {
    }
};
__decorate$2p([
    Inject()
], TerminalStore.prototype, "selectorManager", void 0);
__decorate$2p([
    Inject()
], TerminalStore.prototype, "terminalState", void 0);
TerminalStore = __decorate$2p([
    Injected()
], TerminalStore);

/**
 * Created by Papa on 12/11/2016.
 */
class EntityDatabaseFacade {
    // search: IEntitySearch<Entity, Array<Entity> | MappedEntityArray<Entity>, EntitySelect>;
    // searchOne: IEntitySearchOne<Entity, EntitySelect>;
    constructor(dbEntity, Q, dao) {
        this.dbEntity = dbEntity;
        this.Q = Q;
        this.dao = dao;
        this.find = new EntityFind(this.dbEntity, dao);
        this.findOne = new EntityFindOne(this.dbEntity, dao);
        // this.search = new EntitySearch<Entity, Array<Entity>, EntitySelect>(
        //   this.dbEntity, updateCacheManager);
        // this.searchOne = new EntitySearchOne(this.dbEntity, updateCacheManager);
    }
    get from() {
        return this.Q[this.dbEntity.name];
    }
    async insertColumnValues(rawInsertColumnValues, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.insertColumnValues(rawInsertColumnValues, ctx);
        });
    }
    async insertValues(rawInsertValues, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.insertValues(rawInsertValues, ctx);
        });
    }
    async insertColumnValuesGenerateIds(rawInsertColumnValues, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.insertColumnValuesGenerateIds(rawInsertColumnValues, ctx);
        });
    }
    async insertValuesGenerateIds(rawInsertValues, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.insertValuesGenerateIds(rawInsertValues, ctx);
        });
    }
    async updateColumnsWhere(rawUpdateColumns, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.updateColumnsWhere(rawUpdateColumns, ctx);
        });
    }
    async updateWhere(rawUpdate, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.updateWhere(rawUpdate, ctx);
        });
    }
    async deleteWhere(rawDelete, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.deleteWhere(rawDelete, ctx);
        });
    }
    async save(entity, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.save(entity, ctx);
        });
    }
    /**
     * @return ISaveResult object with metadata on saved objects
     */
    async saveToDestination(repositoryDestination, entity, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.saveToDestination(repositoryDestination, entity, ctx);
        });
    }
    async withDbEntity(ctx, callback) {
        if (!ctx) {
            ctx = {};
        }
        if (!ctx.startedAt) {
            ctx.startedAt = new Date();
        }
        const previousEntity = ctx.dbEntity;
        ctx.dbEntity = this.dbEntity;
        try {
            return await callback(this.dao.databaseFacade, ctx);
        }
        finally {
            ctx.dbEntity = previousEntity;
        }
    }
}

class DaoFindOneStub {
    Graph(...args) {
        throw new Error(`Cannot use this.stub.Find.Graph for manual queries (it
		is meant for prepared queries (with @\${EntityName}Dao.Find).  Instead
		please use this.db.find.graph`);
    }
    Tree(...args) {
        throw new Error(`Cannot use this.stub.Find.Tree for manual queries (it
		is meant for prepared queries (with @\${EntityName}Dao.Find).  Instead
		please use this.db.find.tree`);
    }
}

class DaoFindStub {
    Graph(...args) {
        throw new Error(`Cannot use this.stub.Find.Graph for manual queries (it
		is meant for prepared queries (with @\${EntityName}Dao.Find).  Instead
		please use this.db.find.graph`);
    }
    Tree(...args) {
        throw new Error(`Cannot use this.stub.Find.Tree for manual queries (it
		is meant for prepared queries (with @\${EntityName}Dao.Find).  Instead
		please use this.db.find.tree`);
    }
}

class DaoSearchOneStub {
    Graph(...args) {
        throw new Error(`Cannot use this.stub.SearchOne.Graph for manual queries (it
		is meant for prepared queries (with @\${EntityName}Dao.SearchOne).  Instead
		please use this.db.searchOne.graph`);
    }
    Tree(...args) {
        throw new Error(`Cannot use this.stub.SearchOne.Tree for manual queries (it
		is meant for prepared queries (with @\${EntityName}Dao.SearchOne).  Instead
		please use this.db.searchOne.tree`);
    }
}

class DaoSearchStub {
    Graph(...args) {
        throw new Error(`Cannot use this.stub.Search.Graph for manual queries (it
		is meant for prepared queries (with @\${EntityName}Dao.Search).  Instead
		please use this.db.search.graph`);
    }
    Tree(...args) {
        throw new Error(`Cannot use this.stub.Search.Tree for manual queries (it
		is meant for prepared queries (with @\${EntityName}Dao.Search).  Instead
		please use this.db.search.tree`);
    }
}

class DaoStub {
    constructor() {
        this.Find = new DaoFindStub();
        this.FindOne = new DaoFindOneStub();
        this.Search = new DaoSearchStub();
        this.SearchOne = new DaoSearchOneStub();
    }
    save(entity) {
        throw new Error(`Cannot use this.stub.save for manual queries (it
		is meant for prepared queries (with @\${EntityName}Dao.Save).  Instead
		please use this.db.save`);
    }
}

var __decorate$2o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 8/26/2017.
 */
let Dao = class Dao {
    constructor(dbEntityId, Q, internal = false) {
        this.internal = internal;
        this.stub = new DaoStub();
        const dbEntity = Q.__dbApplication__.currentVersion[0]
            .applicationVersion.entities[dbEntityId];
        // TODO: figure out how to inject EntityDatabaseFacade and dependencies
        this.db = new EntityDatabaseFacade(dbEntity, Q, this);
    }
    static BaseSave(config) {
        return function (target, propertyKey) {
            // No runtime logic required.
        };
    }
    async count(context) {
        throw new Error(`Not Implemented`);
    }
    exists(entityId, context) {
        throw new Error(`Not Implemented`);
    }
    repositoryId() {
        return {
            actor: {
                id: Y,
                uuId: Y
            },
            actorRecordId: Y,
            ageSuitability: Y,
            repository: {
                id: Y,
                uuId: Y
            }
        };
    }
    async findAll(entityIds, context, cacheForUpdate = false) {
        if (entityIds) {
            throw new Error(`Not implemented`);
        }
        return await this.db.find.graph({
            select: {},
            from: [this.db.from],
        }, context);
    }
    async findAllAsTrees(entityIds, context, cacheForUpdate = false) {
        if (entityIds) {
            throw new Error(`Not implemented`);
        }
        return await this.db.find.tree({
            select: {},
            from: [this.db.from],
        }, context);
    }
    findById(entityId, context, cacheForUpdate = false) {
        throw new Error(`Not implemented`);
    }
    async save(entity, context) {
        return await this.db.save(entity, this.ensureContext(context));
    }
    markForDeletion(entityIdInfo, context) {
        if (entityIdInfo instanceof Array) {
            for (const anEntity of entityIdInfo) {
                this.entityStateManager.markForDeletion(anEntity);
            }
        }
        else {
            this.entityStateManager.markForDeletion(entityIdInfo);
        }
    }
    ensureContext(context) {
        return doEnsureContext(context);
    }
};
__decorate$2o([
    Inject()
], Dao.prototype, "airportDatabase", void 0);
__decorate$2o([
    Inject()
], Dao.prototype, "databaseFacade", void 0);
__decorate$2o([
    Inject()
], Dao.prototype, "entityStateManager", void 0);
__decorate$2o([
    Inject()
], Dao.prototype, "lookup", void 0);
__decorate$2o([
    Inject()
], Dao.prototype, "updateCacheManager", void 0);
Dao = __decorate$2o([
    Injected()
], Dao);

class DaoQueryDecorators {
    Graph(callback) {
        return function (target, propertyKey) {
            // No runtime logic required.
        };
    }
    Tree(callback) {
        return function (target, propertyKey) {
            // No runtime logic required.
        };
    }
}

const Api = function () {
    return function (target, propertyKey, descriptor) {
        // No runtime logic required.
        return null;
    };
};

var ApiObjectKind;
(function (ApiObjectKind) {
    ApiObjectKind["ARRAY"] = "ARRAY";
    ApiObjectKind["BOOLEAN"] = "BOOLEAN";
    ApiObjectKind["BOOLEAN_VALUE"] = "BOOLEAN_VALUE";
    ApiObjectKind["DATE"] = "DATE";
    ApiObjectKind["DB_ENTITY"] = "DB_ENTITY";
    ApiObjectKind["NUMBER"] = "NUMBER";
    ApiObjectKind["NUMBER_VALUE"] = "NUMBER_VALUE";
    ApiObjectKind["OBJECT"] = "OBJECT";
    ApiObjectKind["STRING"] = "STRING";
    ApiObjectKind["STRING_VALUE"] = "STRING_VALUE";
    ApiObjectKind["TYPE_UNION"] = "TYPE_UNION";
})(ApiObjectKind || (ApiObjectKind = {}));

/**
 * Created by Papa on 8/26/2017.
 */
class FieldsSelect {
    constructor(dbEntity) {
        this.dbEntity = dbEntity;
    }
    get ids() {
        const propertyNames = this.dbEntity.properties
            .filter(property => property.isId)
            .map(property => property.name);
        return this.getSelect(propertyNames, false);
    }
    get fields() {
        const propertyNames = this.dbEntity.properties
            .filter(property => !property.relation || !property.relation.length)
            .map(property => property.name);
        return this.getSelect(propertyNames, false);
    }
    get manyToOnes() {
        return this.getRelationSelect(EntityRelationType.MANY_TO_ONE);
    }
    get oneToManys() {
        return this.getRelationSelect(EntityRelationType.ONE_TO_MANY);
    }
    getRelationSelect(relationType) {
        const propertyNames = this.dbEntity.properties
            .filter(property => property.relation
            && property.relation.length
            && property.relation[0].relationType === relationType)
            .map(property => property.name);
        return this.getSelect(propertyNames, true);
    }
    getSelect(propertyNames, forRelations) {
        const selectFragment = {};
        for (const propertyName of propertyNames) {
            selectFragment[propertyName] = forRelations ? {} : Y;
        }
        return selectFragment;
    }
}
/**
 * Data Manipulation object.
 */
class Duo {
    constructor(dbEntityId, qApplication) {
        if (typeof dbEntityId === 'number') {
            this.dbEntity = qApplication.__dbApplication__.currentVersion[0]
                .applicationVersion.entities[dbEntityId];
        }
        else {
            this.dbEntity = dbEntityId;
        }
        this.select = new FieldsSelect(this.dbEntity);
    }
    getIdStub(ids) {
        throw new Error(`Not Implemented.`);
    }
    getIdStubs(ids) {
        throw new Error(`Not Implemented.`);
    }
}

var __decorate$2n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SelectorManager = class SelectorManager {
    createSelector(...args) {
        if (args.length < 2 || args.length > 6) {
            throw new Error(`Invalid createSelector call, Expecting 1 to 5 selectors and a callback.`);
        }
        const inputSelectors = args.slice(0, args.length - 1);
        const callback = args[args.length - 1];
        let sourceObservable;
        if (inputSelectors.length > 1) {
            // TODO: check if this will work
            sourceObservable = from(inputSelectors.map(selector => selector.observable));
        }
        else {
            sourceObservable = inputSelectors[0].observable;
        }
        let observable = sourceObservable.pipe(
        // share() TODO: implement once RxJs support is added
        distinctUntilChanged(), map(value => callback(value)));
        return this.getSelector(observable);
    }
    createRootSelector(stateObservable) {
        return this.getSelector(stateObservable);
    }
    getSelector(observable) {
        let selector = (function (
        // otherStateObservable?: Observable<SV>
        ) {
            let currentValue;
            observable.subscribe(value => currentValue = value).unsubscribe();
            return currentValue;
        });
        selector.observable = observable;
        return selector;
    }
};
SelectorManager = __decorate$2n([
    Injected()
], SelectorManager);

function duoDiSet$5(dbApplication, dbEntityId) {
    return dbApplication && dbApplication.currentVersion[0]
        .applicationVersion.entities[dbEntityId];
}
async function getSysWideOpId(airDb, sequenceGenerator) {
    const sequences = await getSysWideOpIds(1, airDb, sequenceGenerator);
    return sequences[0];
}
async function getSysWideOpIds(numSequencesNeeded, airportDatabase, sequenceGenerator) {
    if (!numSequencesNeeded) {
        return [];
    }
    const sysWideOpIdGeneratedColumn = airportDatabase.QM[repositoryEntity.SYS_WIDE_OP_ID_APPLICATION]
        .__dbApplication__.currentVersion[0].applicationVersion
        .entityMapByName[repositoryEntity.SYS_WIDE_OP_ID_ENTITY].columnMap['ID'];
    const generatedNumWrapper = await sequenceGenerator
        .generateSequenceNumbers([sysWideOpIdGeneratedColumn], [numSequencesNeeded]);
    return generatedNumWrapper[0];
}

const checkIn = lib$1('check-in');
const API_REGISTRY = checkIn.token({
    class: null,
    interface: 'IApiRegistry',
    token: 'API_REGISTRY'
});
const API_VALIDATOR = checkIn.token({
    class: null,
    interface: 'IApiValidator',
    token: 'API_VALIDATOR'
});
const DAO = checkIn.token({
    class: Dao,
    interface: 'class Dao',
    token: 'DAO'
});
const OPERATION_DESERIALIZER = checkIn.token({
    class: null,
    interface: 'IOperationDeserializer',
    token: 'OPERATION_DESERIALIZER'
});
const QUERY_PARAMETER_DESERIALIZER = checkIn.token({
    class: null,
    interface: 'IQueryParameterDeserializer',
    token: 'QUERY_PARAMETER_DESERIALIZER'
});
const QUERY_RESULTS_SERIALIZER = checkIn.token({
    class: null,
    interface: 'IQueryParameterDeserializer',
    token: 'QUERY_RESULTS_SERIALIZER'
});
const SELECTOR_MANAGER = checkIn.token({
    class: SelectorManager,
    interface: 'ISelectorManager',
    token: 'SELECTOR_MANAGER'
});
const SEQUENCE_GENERATOR = checkIn.token({
    class: null,
    interface: 'ISequenceGenerator',
    token: 'SEQUENCE_GENERATOR'
});
API_REGISTRY.setDependencies({
    containerAccessor: CONTAINER_ACCESSOR
});
DAO.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    databaseFacade: DATABASE_FACADE,
    entityStateManager: ENTITY_STATE_MANAGER,
    lookup: LOOKUP,
    updateCacheManager: UPDATE_CACHE_MANAGER
});

const terminalMap = lib$1('terminal-map');
const APPLICATION_INITIALIZER = terminalMap.token({
    class: null,
    interface: 'IApplicationInitializer',
    token: 'APPLICATION_INITIALIZER'
});
const DOMAIN_RETRIEVER = terminalMap.token({
    class: null,
    interface: 'IDomainRetriever',
    token: 'DOMAIN_RETRIEVER'
});
const STORE_DRIVER = terminalMap.token({
    class: null,
    interface: 'IStoreDriver',
    token: 'STORE_DRIVER'
});
const TERMINAL_STATE = terminalMap.token({
    class: TerminalState,
    interface: 'ITerminalStateContainer',
    token: 'TERMINAL_STATE'
});
const TERMINAL_STORE = terminalMap.token({
    class: TerminalStore,
    interface: 'ITerminalStore',
    token: 'TERMINAL_STORE'
});
const TRANSACTION_MANAGER = terminalMap.token({
    class: null,
    interface: 'ITransactionManager',
    token: 'TRANSACTION_MANAGER'
});
const TRANSACTIONAL_RECEIVER = terminalMap.token({
    class: null,
    interface: 'ITransactionalReceiver',
    token: 'TRANSACTIONAL_RECEIVER'
});
const TRANSACTIONAL_SERVER = terminalMap.token({
    class: null,
    interface: 'ITransactionalServer',
    token: 'TRANSACTIONAL_SERVER'
});
APPLICATION_INITIALIZER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    sequenceGenerator: SEQUENCE_GENERATOR,
    terminalStore: TERMINAL_STORE
});
DOMAIN_RETRIEVER.setDependencies({
    transactionalConnector: TRANSACTIONAL_CONNECTOR
});
TERMINAL_STORE.setDependencies({
    selectorManager: SELECTOR_MANAGER,
    terminalState: TERMINAL_STATE
});
TRANSACTION_MANAGER.setDependencies({
    storeDriver: STORE_DRIVER,
    terminalStore: TERMINAL_STORE
});
TRANSACTIONAL_RECEIVER.setDependencies({
    applicationInitializer: APPLICATION_INITIALIZER,
    dbApplicationUtils: DB_APPLICATION_UTILS,
});
TRANSACTIONAL_SERVER.setDependencies({
    operationContextLoader: OPERATION_CONTEXT_LOADER,
    terminalStore: TERMINAL_STORE,
    transactionManager: TRANSACTION_MANAGER
});

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

var __decorate$2m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RepositoryManager = class RepositoryManager {
    async initialize() {
    }
    async createRepository(actor, context) {
        if (context.newRepository) {
            throw new Error(`Cannot create more than one repository per transaction:
Attempting to create a new repository and Operation Context
already contains a new repository.`);
        }
        let repository = await this.createRepositoryRecord(actor, context);
        context.newRepository = repository;
        return repository;
    }
    goOffline() {
        throw new Error(`not implemented`);
    }
    getUpdateState(repository) {
        throw new Error(`not implemented`);
    }
    setUpdateStateForAll(updateState) {
        throw new Error(`not implemented`);
    }
    setUpdateState(repository, updateState) {
        throw new Error(`not implemented`);
    }
    getRepositoryRecord(actor) {
        const repository = {
            ageSuitability: 0,
            createdAt: new Date(),
            id: null,
            immutable: false,
            owner: actor.user,
            // platformConfig: platformConfig ? JSON.stringify(platformConfig) : null,
            // platformConfig: null,
            repositoryTransactionHistory: [],
            source: 'localhost:9000',
            uuId: v4(),
        };
        return repository;
    }
    async createRepositoryRecord(actor, context) {
        const repository = this.getRepositoryRecord(actor);
        await this.repositoryDao.save(repository, context);
        return repository;
    }
    ensureRepositoryScopeOnInsertValues(repository, rawInsertValues) {
        let qEntity = rawInsertValues.insertInto;
        if (!qEntity.__driver__.dbEntity.isRepositoryEntity) {
            return rawInsertValues;
        }
        let columns = rawInsertValues.columns.slice();
        if (columns.some((column, index) => {
            // return column.fieldName === REPOSITORY_FIELD
            return column.dbProperty.name === REPOSITORY_FIELD;
        })) {
            return rawInsertValues;
        }
        columns.push(qEntity[REPOSITORY_FIELD]);
        let values = rawInsertValues.values.slice();
        for (let i = 0; i < values.length; i++) {
            let row = values[i].slice();
            values[i] = row;
            row.push(repository.id);
        }
        return {
            insertInto: qEntity, columns: columns, values: values
        };
    }
    ensureRepositoryLinkOnUpdateWhere(qEntity, repository, rawUpdate) {
        if (!qEntity.__driver__.dbEntity.isRepositoryEntity) {
            return;
        }
        return {
            update: rawUpdate.update,
            set: rawUpdate.set,
            where: and(rawUpdate.where, qEntity.repository.id.equals(repository.id))
        };
    }
    ensureRepositoryScopeOnDeleteWhere(qEntity, repository, rawDelete) {
        if (!qEntity.__driver__.dbEntity.isRepositoryEntity) {
            return;
        }
        return {
            deleteFrom: rawDelete.deleteFrom,
            where: and(rawDelete.where, qEntity.repository.id.equals(repository.id))
        };
    }
};
__decorate$2m([
    Inject()
], RepositoryManager.prototype, "repositoryDao", void 0);
RepositoryManager = __decorate$2m([
    Injected()
], RepositoryManager);

var __decorate$2l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Marks a group of mutation history changes.
 */
let OperationHistory = class OperationHistory {
    constructor() {
        this.recordHistory = [];
    }
};
__decorate$2l([
    GeneratedValue(),
    SequenceGenerator$1(),
    Id()
], OperationHistory.prototype, "id", void 0);
__decorate$2l([
    Column(),
    DbNumber()
], OperationHistory.prototype, "orderNumber", void 0);
__decorate$2l([
    Column(),
    DbString()
], OperationHistory.prototype, "changeType", void 0);
__decorate$2l([
    Column(),
    DbNumber()
], OperationHistory.prototype, "systemWideOperationId", void 0);
__decorate$2l([
    ManyToOne(),
    JoinColumn()
], OperationHistory.prototype, "entity", void 0);
__decorate$2l([
    ManyToOne(),
    JoinColumn()
], OperationHistory.prototype, "actor", void 0);
__decorate$2l([
    ManyToOne(),
    JoinColumn()
], OperationHistory.prototype, "repositoryTransactionHistory", void 0);
__decorate$2l([
    OneToMany()
], OperationHistory.prototype, "recordHistory", void 0);
OperationHistory = __decorate$2l([
    Entity(),
    Table()
], OperationHistory);

var __decorate$2k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RecordHistory = class RecordHistory {
    constructor() {
        this.newValues = [];
        this.oldValues = [];
    }
};
__decorate$2k([
    Id(),
    GeneratedValue(),
    SequenceGenerator$1()
], RecordHistory.prototype, "id", void 0);
__decorate$2k([
    Column(),
    DbNumber()
], RecordHistory.prototype, "actorRecordId", void 0);
__decorate$2k([
    ManyToOne(),
    JoinColumn()
], RecordHistory.prototype, "actor", void 0);
__decorate$2k([
    ManyToOne(),
    JoinColumn()
], RecordHistory.prototype, "operationHistory", void 0);
__decorate$2k([
    OneToMany()
], RecordHistory.prototype, "newValues", void 0);
__decorate$2k([
    OneToMany()
], RecordHistory.prototype, "oldValues", void 0);
__decorate$2k([
    Transient()
], RecordHistory.prototype, "tableColumnMap", void 0);
RecordHistory = __decorate$2k([
    Entity(),
    Table()
], RecordHistory);

var __decorate$2j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Currently, syncing databases are always SqLite dbs.  This means
 * we don't need to store types for values.  If a need arises type
 * specific FieldChange classes can always be added.  Having
 * VARCHAR and NUMBER should suffice for other db implementations.
 * NUMBER covers (dates, booleans and numbers).  Maybe REALs will
 * also be required.
 */
let RecordHistoryNewValue = class RecordHistoryNewValue {
};
__decorate$2j([
    Id(),
    ManyToOne(),
    JoinColumn()
], RecordHistoryNewValue.prototype, "recordHistory", void 0);
__decorate$2j([
    Id(),
    Column(),
    DbNumber()
], RecordHistoryNewValue.prototype, "columnIndex", void 0);
__decorate$2j([
    Column(),
    DbAny()
], RecordHistoryNewValue.prototype, "newValue", void 0);
RecordHistoryNewValue = __decorate$2j([
    Entity(),
    Table()
], RecordHistoryNewValue);

var __decorate$2i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Currently, syncing databases are always SqLite dbs.  This means
 * we don't need to store types for values.  If a need arises type
 * specific FieldChange classes can always be added.  Having
 * VARCHAR and NUMBER should suffice for other db implementations.
 * NUMBER covers (dates, booleans and numbers).  Maybe REALs will
 * also be required.
 */
let RecordHistoryOldValue = class RecordHistoryOldValue {
};
__decorate$2i([
    Id(),
    ManyToOne(),
    JoinColumn()
], RecordHistoryOldValue.prototype, "recordHistory", void 0);
__decorate$2i([
    Id(),
    Column(),
    DbNumber()
], RecordHistoryOldValue.prototype, "columnIndex", void 0);
__decorate$2i([
    Column(),
    DbAny()
], RecordHistoryOldValue.prototype, "oldValue", void 0);
RecordHistoryOldValue = __decorate$2i([
    Entity(),
    Table()
], RecordHistoryOldValue);

var RepositoryTransactionType;
(function (RepositoryTransactionType) {
    RepositoryTransactionType["LOCAL"] = "LOCAL";
    RepositoryTransactionType["REMOTE"] = "REMOTE";
    RepositoryTransactionType["REMOTE_REFERENCE"] = "REMOTE_REFERENCE";
})(RepositoryTransactionType || (RepositoryTransactionType = {}));

var __decorate$2h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RepositoryTransactionHistory = class RepositoryTransactionHistory {
    constructor(data) {
        this.repositoryTransactionType = RepositoryTransactionType.LOCAL;
        this.operationHistory = [];
        if (!data) {
            return;
        }
        this.id = data.id;
        this.transactionHistory = data.transactionHistory;
        this.repository = data.repository;
        this.saveTimestamp = data.saveTimestamp;
        this.operationHistory = data.operationHistory;
    }
};
__decorate$2h([
    GeneratedValue(),
    Id(),
    SequenceGenerator$1()
], RepositoryTransactionHistory.prototype, "id", void 0);
__decorate$2h([
    Column(),
    DbString()
], RepositoryTransactionHistory.prototype, "repositoryTransactionType", void 0);
__decorate$2h([
    Column(),
    DbNumber()
], RepositoryTransactionHistory.prototype, "saveTimestamp", void 0);
__decorate$2h([
    Column(),
    DbNumber()
], RepositoryTransactionHistory.prototype, "syncTimestamp", void 0);
__decorate$2h([
    Column(),
    DbString()
], RepositoryTransactionHistory.prototype, "uuId", void 0);
__decorate$2h([
    Column(),
    DbBoolean()
], RepositoryTransactionHistory.prototype, "isRepositoryCreation", void 0);
__decorate$2h([
    ManyToOne(),
    JoinColumn()
], RepositoryTransactionHistory.prototype, "repository", void 0);
__decorate$2h([
    ManyToOne(),
    JoinColumn()
], RepositoryTransactionHistory.prototype, "transactionHistory", void 0);
__decorate$2h([
    OneToMany()
], RepositoryTransactionHistory.prototype, "operationHistory", void 0);
RepositoryTransactionHistory = __decorate$2h([
    Entity(),
    Table()
], RepositoryTransactionHistory);

var __decorate$2g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TransactionHistory = class TransactionHistory {
    constructor() {
        this.repositoryTransactionHistories = [];
        this.repositoryTransactionHistoryMap = {};
        this.applicationMap = new SyncApplicationMap();
        this.allOperationHistory = [];
        this.allRecordHistory = [];
        this.allRecordHistoryNewValues = [];
        this.allRecordHistoryOldValues = [];
    }
};
__decorate$2g([
    GeneratedValue(),
    Id(),
    SequenceGenerator$1()
], TransactionHistory.prototype, "id", void 0);
__decorate$2g([
    Column(),
    DbString()
], TransactionHistory.prototype, "transactionType", void 0);
__decorate$2g([
    OneToMany()
], TransactionHistory.prototype, "repositoryTransactionHistories", void 0);
__decorate$2g([
    Transient()
], TransactionHistory.prototype, "repositoryTransactionHistoryMap", void 0);
__decorate$2g([
    Transient()
], TransactionHistory.prototype, "applicationMap", void 0);
__decorate$2g([
    Transient()
], TransactionHistory.prototype, "allOperationHistory", void 0);
__decorate$2g([
    Transient()
], TransactionHistory.prototype, "allRecordHistory", void 0);
__decorate$2g([
    Transient()
], TransactionHistory.prototype, "allRecordHistoryNewValues", void 0);
__decorate$2g([
    Transient()
], TransactionHistory.prototype, "allRecordHistoryOldValues", void 0);
TransactionHistory = __decorate$2g([
    Entity(),
    Table()
], TransactionHistory);

var __decorate$2f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Actor = class Actor {
};
__decorate$2f([
    Id(),
    GeneratedValue(),
    DbNumber(),
    Column()
], Actor.prototype, "id", void 0);
__decorate$2f([
    Column(),
    DbString()
], Actor.prototype, "uuId", void 0);
__decorate$2f([
    ManyToOne(),
    JoinColumn()
], Actor.prototype, "user", void 0);
__decorate$2f([
    ManyToOne(),
    JoinColumn()
], Actor.prototype, "terminal", void 0);
__decorate$2f([
    ManyToOne(),
    JoinColumn()
], Actor.prototype, "application", void 0);
Actor = __decorate$2f([
    Entity()
], Actor);

var __decorate$2e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Repository = class Repository {
    constructor() {
        this.repositoryTransactionHistory = [];
    }
};
__decorate$2e([
    Column(),
    GeneratedValue(),
    Id(),
    DbNumber()
], Repository.prototype, "id", void 0);
__decorate$2e([
    Column(),
    DbNumber()
], Repository.prototype, "ageSuitability", void 0);
__decorate$2e([
    Column(),
    DbDate()
], Repository.prototype, "createdAt", void 0);
__decorate$2e([
    Column()
], Repository.prototype, "immutable", void 0);
__decorate$2e([
    Column(),
    DbString()
], Repository.prototype, "source", void 0);
__decorate$2e([
    Column(),
    DbString()
], Repository.prototype, "uuId", void 0);
__decorate$2e([
    ManyToOne(),
    JoinColumn()
], Repository.prototype, "owner", void 0);
__decorate$2e([
    OneToMany()
], Repository.prototype, "repositoryTransactionHistory", void 0);
Repository = __decorate$2e([
    Entity(),
    Table()
], Repository);

var __decorate$2d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RepositoryEntity = class RepositoryEntity {
};
__decorate$2d([
    Id(),
    ManyToOne(),
    JoinColumn()
], RepositoryEntity.prototype, "repository", void 0);
__decorate$2d([
    Id(),
    ManyToOne(),
    JoinColumn()
], RepositoryEntity.prototype, "actor", void 0);
__decorate$2d([
    Id(),
    Column(),
    GeneratedValue()
], RepositoryEntity.prototype, "actorRecordId", void 0);
__decorate$2d([
    Column(),
    DbNumber()
], RepositoryEntity.prototype, "ageSuitability", void 0);
__decorate$2d([
    Column()
], RepositoryEntity.prototype, "systemWideOperationId", void 0);
__decorate$2d([
    ManyToOne(),
    JoinColumn()
], RepositoryEntity.prototype, "originalRepository", void 0);
__decorate$2d([
    ManyToOne(),
    JoinColumn()
], RepositoryEntity.prototype, "originalActor", void 0);
__decorate$2d([
    Column()
], RepositoryEntity.prototype, "originalActorRecordId", void 0);
RepositoryEntity = __decorate$2d([
    MappedSuperclass()
], RepositoryEntity);

var __decorate$2c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RepositoryApplication = class RepositoryApplication {
};
__decorate$2c([
    Id(),
    Column(),
    GeneratedValue(),
    DbNumber()
], RepositoryApplication.prototype, "id", void 0);
__decorate$2c([
    Id(),
    ManyToOne(),
    JoinColumn()
], RepositoryApplication.prototype, "repository", void 0);
__decorate$2c([
    Column(),
    DbNumber()
], RepositoryApplication.prototype, "applicationIndex", void 0);
RepositoryApplication = __decorate$2c([
    Entity(),
    Table()
], RepositoryApplication);

var __decorate$2b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ChildRepoRow = class ChildRepoRow extends RepositoryEntity {
};
ChildRepoRow = __decorate$2b([
    MappedSuperclass()
], ChildRepoRow);

var __decorate$2a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ChildRow = class ChildRow {
};
ChildRow = __decorate$2a([
    MappedSuperclass()
], ChildRow);

var __decorate$29 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ImmutableRepoRow = class ImmutableRepoRow extends RepositoryEntity {
};
__decorate$29([
    Column()
], ImmutableRepoRow.prototype, "createdAt", void 0);
ImmutableRepoRow = __decorate$29([
    MappedSuperclass()
], ImmutableRepoRow);

var __decorate$28 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ImmutableRow = class ImmutableRow {
};
__decorate$28([
    ManyToOne(),
    JoinColumn()
], ImmutableRow.prototype, "user", void 0);
__decorate$28([
    Column()
], ImmutableRow.prototype, "createdAt", void 0);
ImmutableRow = __decorate$28([
    MappedSuperclass()
], ImmutableRow);

var __decorate$27 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let MutableRepoRow = class MutableRepoRow extends ImmutableRepoRow {
};
__decorate$27([
    Column()
], MutableRepoRow.prototype, "updatedAt", void 0);
MutableRepoRow = __decorate$27([
    MappedSuperclass()
], MutableRepoRow);

var __decorate$26 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let MutableRow = class MutableRow extends ImmutableRow {
};
__decorate$26([
    Column()
], MutableRow.prototype, "updatedAt", void 0);
MutableRow = __decorate$26([
    MappedSuperclass()
], MutableRow);

var __decorate$25 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ReferenceRow = class ReferenceRow {
};
ReferenceRow = __decorate$25([
    MappedSuperclass()
], ReferenceRow);

const __constructors__$4 = {
    Actor: Actor,
    ChildRepoRow: ChildRepoRow,
    ChildRow: ChildRow,
    ImmutableRepoRow: ImmutableRepoRow,
    ImmutableRow: ImmutableRow,
    MutableRepoRow: MutableRepoRow,
    MutableRow: MutableRow,
    OperationHistory: OperationHistory,
    RecordHistory: RecordHistory,
    RecordHistoryNewValue: RecordHistoryNewValue,
    RecordHistoryOldValue: RecordHistoryOldValue,
    ReferenceRow: ReferenceRow,
    Repository: Repository,
    RepositoryApplication: RepositoryApplication,
    RepositoryEntity: RepositoryEntity,
    RepositoryTransactionHistory: RepositoryTransactionHistory,
    TransactionHistory: TransactionHistory
};
const Q_APPLICATION$4 = {
    __constructors__: __constructors__$4,
    domain: 'air',
    name: '@airport/holding-pattern'
};
const Q$4 = Q_APPLICATION$4;
function duoDiSet$4(dbEntityId) {
    return duoDiSet$5(Q$4.__dbApplication__, dbEntityId);
}
DEPENDENCY_INJECTION.db().eventuallyGet(AIRPORT_DATABASE).then((airportDatabase) => {
    airportDatabase.setQApplication(Q_APPLICATION$4);
});

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$4 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q$4);
    }
}
class BaseActorDao extends SQDIDao$4 {
    constructor() {
        super(1);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$4(1);
    }
}
BaseActorDao.Find = new DaoQueryDecorators();
BaseActorDao.FindOne = new DaoQueryDecorators();
BaseActorDao.Search = new DaoQueryDecorators();
BaseActorDao.SearchOne = new DaoQueryDecorators();
class BaseOperationHistoryDao extends SQDIDao$4 {
    constructor() {
        super(5);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$4(5);
    }
}
BaseOperationHistoryDao.Find = new DaoQueryDecorators();
BaseOperationHistoryDao.FindOne = new DaoQueryDecorators();
BaseOperationHistoryDao.Search = new DaoQueryDecorators();
BaseOperationHistoryDao.SearchOne = new DaoQueryDecorators();
class BaseRecordHistoryDao extends SQDIDao$4 {
    constructor() {
        super(0);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$4(0);
    }
}
BaseRecordHistoryDao.Find = new DaoQueryDecorators();
BaseRecordHistoryDao.FindOne = new DaoQueryDecorators();
BaseRecordHistoryDao.Search = new DaoQueryDecorators();
BaseRecordHistoryDao.SearchOne = new DaoQueryDecorators();
class BaseRecordHistoryNewValueDao extends SQDIDao$4 {
    constructor() {
        super(6);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$4(6);
    }
}
BaseRecordHistoryNewValueDao.Find = new DaoQueryDecorators();
BaseRecordHistoryNewValueDao.FindOne = new DaoQueryDecorators();
BaseRecordHistoryNewValueDao.Search = new DaoQueryDecorators();
BaseRecordHistoryNewValueDao.SearchOne = new DaoQueryDecorators();
class BaseRecordHistoryOldValueDao extends SQDIDao$4 {
    constructor() {
        super(7);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$4(7);
    }
}
BaseRecordHistoryOldValueDao.Find = new DaoQueryDecorators();
BaseRecordHistoryOldValueDao.FindOne = new DaoQueryDecorators();
BaseRecordHistoryOldValueDao.Search = new DaoQueryDecorators();
BaseRecordHistoryOldValueDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryDao extends SQDIDao$4 {
    constructor() {
        super(2);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$4(2);
    }
}
BaseRepositoryDao.Find = new DaoQueryDecorators();
BaseRepositoryDao.FindOne = new DaoQueryDecorators();
BaseRepositoryDao.Search = new DaoQueryDecorators();
BaseRepositoryDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryApplicationDao extends SQDIDao$4 {
    constructor() {
        super(8);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$4(8);
    }
}
BaseRepositoryApplicationDao.Find = new DaoQueryDecorators();
BaseRepositoryApplicationDao.FindOne = new DaoQueryDecorators();
BaseRepositoryApplicationDao.Search = new DaoQueryDecorators();
BaseRepositoryApplicationDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryTransactionHistoryDao extends SQDIDao$4 {
    constructor() {
        super(4);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$4(4);
    }
}
BaseRepositoryTransactionHistoryDao.Find = new DaoQueryDecorators();
BaseRepositoryTransactionHistoryDao.FindOne = new DaoQueryDecorators();
BaseRepositoryTransactionHistoryDao.Search = new DaoQueryDecorators();
BaseRepositoryTransactionHistoryDao.SearchOne = new DaoQueryDecorators();
class BaseTransactionHistoryDao extends SQDIDao$4 {
    constructor() {
        super(3);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$4(3);
    }
}
BaseTransactionHistoryDao.Find = new DaoQueryDecorators();
BaseTransactionHistoryDao.FindOne = new DaoQueryDecorators();
BaseTransactionHistoryDao.Search = new DaoQueryDecorators();
BaseTransactionHistoryDao.SearchOne = new DaoQueryDecorators();

// Application Q object Dependency Injection readiness detection Duo
class SQDIDuo$1 extends Duo {
    constructor(dbEntityId) {
        super(dbEntityId, Q$4);
    }
}
class BaseOperationHistoryDuo extends SQDIDuo$1 {
    static diSet() {
        return duoDiSet$4(5);
    }
    constructor() {
        super(5);
    }
}
class BaseRecordHistoryDuo extends SQDIDuo$1 {
    static diSet() {
        return duoDiSet$4(0);
    }
    constructor() {
        super(0);
    }
}
class BaseRecordHistoryNewValueDuo extends SQDIDuo$1 {
    static diSet() {
        return duoDiSet$4(6);
    }
    constructor() {
        super(6);
    }
}
class BaseRecordHistoryOldValueDuo extends SQDIDuo$1 {
    static diSet() {
        return duoDiSet$4(7);
    }
    constructor() {
        super(7);
    }
}
class BaseRepositoryTransactionHistoryDuo extends SQDIDuo$1 {
    static diSet() {
        return duoDiSet$4(4);
    }
    constructor() {
        super(4);
    }
}
class BaseTransactionHistoryDuo extends SQDIDuo$1 {
    static diSet() {
        return duoDiSet$4(3);
    }
    constructor() {
        super(3);
    }
}

var __decorate$24 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RecordHistoryNewValueDao = class RecordHistoryNewValueDao extends BaseRecordHistoryNewValueDao {
    async findByRecordHistoryIdIn(recordHistoryIds) {
        let rhnv;
        return await this.db.find.tree({
            select: {},
            from: [
                rhnv = Q$4.RecordHistoryNewValue
            ],
            where: rhnv.recordHistory.id.in(recordHistoryIds)
        });
    }
};
RecordHistoryNewValueDao = __decorate$24([
    Injected()
], RecordHistoryNewValueDao);

var __decorate$23 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RecordHistoryOldValueDao = class RecordHistoryOldValueDao extends BaseRecordHistoryOldValueDao {
    async findByRecordHistoryIdIn(recordHistoryIds) {
        let rhov;
        return await this.db.find.tree({
            select: {},
            from: [
                rhov = Q$4.RecordHistoryOldValue
            ],
            where: rhov.recordHistory.id.in(recordHistoryIds)
        });
    }
};
RecordHistoryOldValueDao = __decorate$23([
    Injected()
], RecordHistoryOldValueDao);

var __decorate$22 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RepositoryTransactionHistoryDao = class RepositoryTransactionHistoryDao extends BaseRepositoryTransactionHistoryDao {
    /*
    async clearContentsWhereIdsIn(
        repositoryTransactionBlockIds: TmRepositoryTransactionBlockId[]
    ): Promise<void> {
        const rtb: QRepositoryTransactionBlock = Q.QRepositoryTransactionBlock
        await this.db.updateWhere({
            update: rtb,
            set: {
                contents: null
            },
            where: rtb.id.in(repositoryTransactionBlockIds)
        })
    }
    */
    async findWhereUuIdsIn(uuIds) {
        let rth;
        return await this.db.find.tree({
            select: {
                uuId: Y
            },
            from: [
                rth = Q$4.RepositoryTransactionHistory
            ],
            where: rth.uuId.in(uuIds)
        });
    }
    async findAllLocalChangesForRecordIds(changedRecordIds) {
        const repositoryTransactionHistoryMapByRepositoryId = new Map();
        const rth = Q$4.RepositoryTransactionHistory;
        const th = rth.transactionHistory.innerJoin();
        const oh = rth.operationHistory.leftJoin();
        const ae = oh.entity.leftJoin();
        const av = ae.applicationVersion.leftJoin();
        const rh = oh.recordHistory.leftJoin();
        const nv = rh.newValues.leftJoin();
        let id = Y;
        const repositoryEquals = [];
        for (const [repositoryId, idsForRepository] of changedRecordIds) {
            const recordMapForRepository = idsForRepository.ids;
            const entityEquals = [];
            for (const [entityId, recordMapForEntity] of recordMapForRepository) {
                const actorEquals = [];
                for (const [actorId, recordsForActor] of recordMapForEntity) {
                    actorEquals.push(and(oh.actor.id.equals(actorId), rh.actorRecordId.in(Array.from(recordsForActor))));
                }
                entityEquals.push(and(oh.entity.id.equals(entityId), or(...actorEquals)));
            }
            repositoryEquals.push(and(rth.repository.id.equals(repositoryId), rth.saveTimestamp.greaterThanOrEquals(idsForRepository.firstChangeTime), or(...entityEquals)));
        }
        const repoTransHistories = await this.db.find.tree({
            select: {
                ...ALL_FIELDS,
                operationHistory: {
                    orderNumber: Y,
                    changeType: Y,
                    entity: {
                        id,
                        // index: Y,
                        applicationVersion: {
                            id: Y,
                            // integerVersion: Y,
                            // application: {
                            // 	index: Y
                            // }
                        }
                    },
                    recordHistory: {
                        id,
                        newValues: {
                            columnIndex: Y,
                            newValue: Y
                        }
                    }
                }
            },
            from: [
                rth,
                th,
                oh,
                ae,
                av,
                rh,
                nv
            ],
            where: and(th.transactionType.equals(TransactionType.LOCAL), or(...repositoryEquals)),
            // orderBy: [
            // 	rth.repository.id.asc()
            // ]
        });
        for (const repoTransHistory of repoTransHistories) {
            ensureChildArray(repositoryTransactionHistoryMapByRepositoryId, repoTransHistory.repository.id)
                .push(repoTransHistory);
            repoTransHistory.operationHistory.sort((rth1, rth2) => {
                if (rth1.orderNumber < rth2.orderNumber) {
                    return -1;
                }
                if (rth1.orderNumber > rth2.orderNumber) {
                    return 1;
                }
                return 0;
            });
        }
        return repositoryTransactionHistoryMapByRepositoryId;
    }
    async updateSyncTimestamp(repositoryTransactionHistory) {
        let rth;
        await this.db.updateWhere({
            update: rth = Q$4.RepositoryTransactionHistory,
            set: {
                syncTimestamp: repositoryTransactionHistory.syncTimestamp
            },
            where: rth.id.equals(repositoryTransactionHistory.id)
        });
    }
};
RepositoryTransactionHistoryDao = __decorate$22([
    Injected()
], RepositoryTransactionHistoryDao);

var __decorate$21 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ActorDao = class ActorDao extends BaseActorDao {
    async findWithDetailsAndGlobalIdsByIds(actorIds) {
        return await this.findWithDetailsAndGlobalIdsByWhereClause((a) => a.id.in(actorIds));
    }
    async findMapsWithDetailsByGlobalIds(uuIds, userIds, terminalIds, actorMap, actorMapById) {
        const actors = await this.findWithDetailsByGlobalIds(uuIds, userIds, terminalIds);
        for (const actor of actors) {
            ensureChildJsMap(actorMap, actor.user.id)
                .set(actor.terminal.id, actor);
            actorMapById.set(actor.id, actor);
        }
    }
    async findWithDetailsByGlobalIds(uuIds, userIds, terminalIds) {
        return await this.findWithDetailsAndGlobalIdsByWhereClause((a) => and(a.uuId.in(uuIds), a.terminal.id.in(terminalIds), a.user.id.in(userIds)));
    }
    async findByDomainAndApplicationNames(domainName, applicationName) {
        let act;
        let application;
        let domain;
        return await this.db.find.tree({
            select: {
                id: Y,
                application: {
                    ...ALL_FIELDS,
                    domain: {}
                },
                terminal: {},
                user: {},
                uuId: Y
            },
            from: [
                act = Q$4.Actor,
                application = act.application.innerJoin(),
                domain = application.domain.innerJoin(),
                act.terminal.leftJoin(),
                act.user.leftJoin()
            ],
            where: and(domain.name.equals(domainName), application.name.equals(applicationName))
        });
    }
    async findByUuIds(uuIds) {
        let a;
        return await this.db.find.tree({
            select: {},
            from: [
                a = Q$4.Actor
            ],
            where: a.uuId.in(uuIds)
        });
    }
    async insert(actors) {
        let t;
        const values = [];
        for (const actor of actors) {
            values.push([
                actor.uuId, actor.application.index, actor.user.id, actor.terminal.id,
            ]);
        }
        const ids = await this.db.insertValuesGenerateIds({
            insertInto: t = Q$4.Actor,
            columns: [
                t.uuId,
                t.application.index,
                t.user.id,
                t.terminal.id
            ],
            values
        });
        for (let i = 0; i < actors.length; i++) {
            let actor = actors[i];
            actor.id = ids[i][0];
        }
    }
    async findWithDetailsAndGlobalIdsByWhereClause(getWhereClause) {
        let a;
        let ap;
        let t;
        const id = Y;
        const username = Y;
        const uuId = Y;
        return await this.db.find.tree({
            select: {
                ...ALL_FIELDS,
                application: {
                    index: Y,
                    name: Y,
                    domain: {
                        name: Y
                    }
                },
                terminal: {
                    id,
                    uuId,
                    owner: {
                        id,
                        username,
                        uuId,
                    }
                },
                user: {
                    id,
                    username,
                    uuId,
                }
            },
            from: [
                a = Q$4.Actor,
                ap = a.application.leftJoin(),
                ap.domain.leftJoin(),
                t = a.terminal.leftJoin(),
                t.owner.leftJoin(),
                a.user.leftJoin()
            ],
            where: getWhereClause(a)
        });
    }
};
ActorDao = __decorate$21([
    Injected()
], ActorDao);

var __decorate$20 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RepositoryDao = class RepositoryDao extends BaseRepositoryDao {
    async getRepositoryLoadInfo(repositorySource, repositoryUuId, context) {
        let r;
        let rth;
        let th;
        return await this.db.findOne.tree({
            select: {
                immutable: Y,
                repositoryTransactionHistory: {
                    saveTimestamp: Y
                }
            },
            from: [
                r = Q$4.Repository,
                rth = r.repositoryTransactionHistory.innerJoin(),
                th = rth.transactionHistory.innerJoin()
            ],
            where: and(r.source.equals(repositorySource), r.uuId.equals(repositoryUuId), th.transactionType.equals(TransactionType.REMOTE_SYNC))
        }, context);
    }
    async findReposWithDetailsAndSyncNodeIds(repositoryIds) {
        let r;
        const id = Y;
        return await this.db.find.tree({
            select: {
                id,
                owner: {
                    id
                },
                createdAt: Y,
                uuId: Y
            },
            from: [
                r = Q$4.Repository
            ],
            where: r.id.in(repositoryIds)
        });
    }
    async findByIds(repositoryIds) {
        let r;
        return await this.db.find.tree({
            select: {
                ...ALL_FIELDS,
                owner: {}
            },
            from: [
                r = Q$4.Repository,
                r.owner.innerJoin()
            ],
            where: r.id.in(repositoryIds)
        });
    }
    async findByUuIds(uuIds) {
        let r;
        return await this.db.find.tree({
            select: {},
            from: [
                r = Q$4.Repository
            ],
            where: r.uuId.in(uuIds)
        });
    }
    async insert(repositories) {
        let r;
        const values = [];
        for (const repository of repositories) {
            values.push([
                repository.createdAt, repository.uuId, repository.ageSuitability,
                repository.source, repository.immutable, repository.owner.id,
            ]);
        }
        const ids = await this.db.insertValuesGenerateIds({
            insertInto: r = Q$4.Repository,
            columns: [
                r.createdAt,
                r.uuId,
                r.ageSuitability,
                r.source,
                r.immutable,
                r.owner.id
            ],
            values
        });
        for (let i = 0; i < repositories.length; i++) {
            let repository = repositories[i];
            repository.id = ids[i][0];
        }
    }
};
RepositoryDao = __decorate$20([
    Injected()
], RepositoryDao);

var __decorate$1$ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let OperationHistoryDuo = class OperationHistoryDuo extends BaseOperationHistoryDuo {
    getNewRecord(entityChangeType, dbEntity, actor, repositoryTransactionHistory, systemWideOperationId, rootTransaction) {
        let operationHistory = {
            actor,
            changeType: entityChangeType,
            entity: dbEntity,
            id: undefined,
            orderNumber: ++rootTransaction.numberOfOperations,
            recordHistory: [],
            repositoryTransactionHistory: repositoryTransactionHistory,
            systemWideOperationId
        };
        return operationHistory;
    }
    sort(ew1, ew2) {
        let startId1 = ew1.orderNumber;
        let startId2 = ew2.orderNumber;
        if (startId1 > startId2) {
            return 1;
        }
        if (startId2 > startId1) {
            return -1;
        }
        return 0;
    }
    startRecordHistory(operationHistory, actorId, actorRecordId) {
        const recordHistory = this.recordHistoryDuo.getNewRecord(actorId, actorRecordId);
        recordHistory.operationHistory = operationHistory;
        operationHistory.recordHistory.push(recordHistory);
        operationHistory.repositoryTransactionHistory
            .transactionHistory.allRecordHistory.push(recordHistory);
        return recordHistory;
    }
};
__decorate$1$([
    Inject()
], OperationHistoryDuo.prototype, "recordHistoryDuo", void 0);
OperationHistoryDuo = __decorate$1$([
    Injected()
], OperationHistoryDuo);

var __decorate$1_ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RecordHistoryDuo = class RecordHistoryDuo extends BaseRecordHistoryDuo {
    getNewRecord(actorId, actorRecordId) {
        const recordHistory = new RecordHistory();
        recordHistory.actorRecordId = actorRecordId;
        recordHistory.actor = {
            id: actorId
        };
        return recordHistory;
    }
    addNewValue(recordHistory, dbColumn, newValue) {
        if (newValue === null) {
            // No need to record a null value
            return null;
        }
        const recordHistoryNewValue = this.recordHistoryNewValueDuo.getNewRecord(recordHistory, dbColumn, newValue);
        recordHistory.newValues.push(recordHistoryNewValue);
        recordHistory.operationHistory.repositoryTransactionHistory
            .transactionHistory.allRecordHistoryNewValues.push(recordHistoryNewValue);
        return recordHistoryNewValue;
    }
    addOldValue(recordHistory, dbColumn, oldValue) {
        if (oldValue === null) {
            // No need to record a null value
            return null;
        }
        const recordHistoryOldValue = this.recordHistoryOldValueDuo.getNewRecord(recordHistory, dbColumn, oldValue);
        recordHistory.oldValues.push(recordHistoryOldValue);
        recordHistory.operationHistory.repositoryTransactionHistory
            .transactionHistory.allRecordHistoryOldValues.push(recordHistoryOldValue);
        return recordHistoryOldValue;
    }
};
__decorate$1_([
    Inject()
], RecordHistoryDuo.prototype, "recordHistoryNewValueDuo", void 0);
__decorate$1_([
    Inject()
], RecordHistoryDuo.prototype, "recordHistoryOldValueDuo", void 0);
RecordHistoryDuo = __decorate$1_([
    Injected()
], RecordHistoryDuo);

var __decorate$1Z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RecordHistoryNewValueDuo = class RecordHistoryNewValueDuo extends BaseRecordHistoryNewValueDuo {
    constructor() {
        super();
    }
    getNewRecord(recordHistory, dbColumn, newValue) {
        const recordHistoryNewValue = new RecordHistoryNewValue();
        recordHistoryNewValue.columnIndex = dbColumn.index;
        recordHistoryNewValue.recordHistory = recordHistory;
        recordHistoryNewValue.newValue = newValue;
        return recordHistoryNewValue;
    }
};
RecordHistoryNewValueDuo = __decorate$1Z([
    Injected()
], RecordHistoryNewValueDuo);

var __decorate$1Y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RecordHistoryOldValueDuo = class RecordHistoryOldValueDuo extends BaseRecordHistoryOldValueDuo {
    constructor() {
        super();
    }
    getNewRecord(recordHistory, dbColumn, oldValue) {
        const recordHistoryOldValue = new RecordHistoryOldValue();
        recordHistoryOldValue.columnIndex = dbColumn.index;
        recordHistoryOldValue.recordHistory = recordHistory;
        recordHistoryOldValue.oldValue = oldValue;
        return recordHistoryOldValue;
    }
};
RecordHistoryOldValueDuo = __decorate$1Y([
    Injected()
], RecordHistoryOldValueDuo);

var __decorate$1X = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RepositoryTransactionHistoryDuo = class RepositoryTransactionHistoryDuo extends BaseRepositoryTransactionHistoryDuo {
    getNewRecord(repositoryId, isRepositoryCreation) {
        let repositoryTransactionHistory = new RepositoryTransactionHistory();
        let saveTimestamp = new Date().getTime();
        repositoryTransactionHistory.saveTimestamp = saveTimestamp;
        repositoryTransactionHistory.uuId = v4();
        repositoryTransactionHistory.isRepositoryCreation = isRepositoryCreation;
        repositoryTransactionHistory.repository = new Repository();
        repositoryTransactionHistory.repository.id = repositoryId;
        return repositoryTransactionHistory;
    }
    newRecord(data) {
        if (!data) {
            return null;
        }
        return { ...data };
    }
    sortRepoTransHistories(repoTransHistories, actorMapById) {
        repoTransHistories.sort((repoTransHistory1, repoTransHistory2) => {
            const syncTimeComparison = this.compareNumbers(repoTransHistory1.syncTimestamp, repoTransHistory2.syncTimestamp);
            if (syncTimeComparison) {
                return syncTimeComparison;
            }
            const saveTimeComparison = this.compareNumbers(repoTransHistory1.saveTimestamp, repoTransHistory2.saveTimestamp);
            if (saveTimeComparison) {
                return saveTimeComparison;
            }
            return 0;
        });
    }
    startOperation(repositoryTransactionHistory, systemWideOperationId, entityChangeType, dbEntity, actor, rootTransaction) {
        let operationHistory = this.operationHistoryDuo.getNewRecord(entityChangeType, dbEntity, actor, repositoryTransactionHistory, systemWideOperationId, rootTransaction);
        repositoryTransactionHistory.operationHistory.push(operationHistory);
        repositoryTransactionHistory
            .transactionHistory.allOperationHistory.push(operationHistory);
        return operationHistory;
    }
    compareDates(date1, date2) {
        const time1 = date1 ? date1.getTime() : -1;
        const time2 = date2 ? date2.getTime() : -1;
        return this.compareNumbers(time1, time2);
    }
    compareNumbers(number1, number2) {
        if (number1 < number2) {
            return -1;
        }
        if (number2 > number1) {
            return 1;
        }
        return 0;
    }
};
__decorate$1X([
    Inject()
], RepositoryTransactionHistoryDuo.prototype, "operationHistoryDuo", void 0);
RepositoryTransactionHistoryDuo = __decorate$1X([
    Injected()
], RepositoryTransactionHistoryDuo);

var __decorate$1W = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TransactionHistoryDuo = class TransactionHistoryDuo extends BaseTransactionHistoryDuo {
    getNewRecord(transactionType = TransactionType.LOCAL) {
        let transaction = new TransactionHistory();
        transaction.transactionType = TransactionType.LOCAL;
        return transaction;
    }
    getRepositoryTransaction(transactionHistory, repositoryId, isRepositoryCreation) {
        let repositoryTransactionHistory = transactionHistory.repositoryTransactionHistoryMap[repositoryId];
        if (!repositoryTransactionHistory) {
            repositoryTransactionHistory = this.repositoryTransactionHistoryDuo.getNewRecord(repositoryId, isRepositoryCreation);
            transactionHistory.repositoryTransactionHistories.push(repositoryTransactionHistory);
            transactionHistory.repositoryTransactionHistoryMap[repositoryId] = repositoryTransactionHistory;
            repositoryTransactionHistory.transactionHistory = transactionHistory;
        }
        return repositoryTransactionHistory;
    }
};
__decorate$1W([
    Inject()
], TransactionHistoryDuo.prototype, "repositoryTransactionHistoryDuo", void 0);
TransactionHistoryDuo = __decorate$1W([
    Injected()
], TransactionHistoryDuo);

const holdingPattern = lib$1('holding-pattern');

const ACTOR_DAO = holdingPattern.token({
    class: ActorDao,
    interface: 'IActorDao',
    token: 'ACTOR_DAO'
});
const OPERATION_HISTORY_DUO = holdingPattern.token({
    class: OperationHistoryDuo,
    interface: 'IOperationHistoryDuo',
    token: 'OPERATION_HISTORY_DUO'
});
const RECORD_HISTORY_DUO = holdingPattern.token({
    class: RecordHistoryDuo,
    interface: 'IRecordHistoryDuo',
    token: 'RECORD_HISTORY_DUO'
});
holdingPattern.token({
    class: RecordHistoryNewValueDao,
    interface: 'IRecordHistoryNewValueDao',
    token: 'RECORD_HISTORY_NEW_VALUE_DAO'
});
const RECORD_HISTORY_NEW_VALUE_DUO = holdingPattern.token({
    class: RecordHistoryNewValueDuo,
    interface: 'IRecordHistoryNewValueDuo',
    token: 'RECORD_HISTORY_NEW_VALUE_DUO'
});
holdingPattern.token({
    class: RecordHistoryOldValueDao,
    interface: 'IRecordHistoryOldValueDao',
    token: 'RECORD_HISTORY_OLD_VALUE_DAO'
});
const RECORD_HISTORY_OLD_VALUE_DUO = holdingPattern.token({
    class: RecordHistoryOldValueDuo,
    interface: 'IRecordHistoryOldValueDuo',
    token: 'RECORD_HISTORY_OLD_VALUE_DUO'
});
const REPOSITORY_DAO = holdingPattern.token({
    class: RepositoryDao,
    interface: 'IRepositoryDao',
    token: 'REPOSITORY_DAO'
});
const REPOSITORY_TRANSACTION_HISTORY_DAO = holdingPattern.token({
    class: RepositoryTransactionHistoryDao,
    interface: 'IRepositoryTransactionHistoryDao',
    token: 'REPOSITORY_TRANSACTION_HISTORY_DAO'
});
const REPOSITORY_TRANSACTION_HISTORY_DUO = holdingPattern.token({
    class: RepositoryTransactionHistoryDuo,
    interface: 'IRepositoryTransactionHistoryDuo',
    token: 'REPOSITORY_TRANSACTION_HISTORY_DUO'
});
const TRANSACTION_HISTORY_DUO = holdingPattern.token({
    class: TransactionHistoryDuo,
    interface: 'ITransactionHistoryDuo',
    token: 'TRANSACTION_HISTORY_DUO'
});
OPERATION_HISTORY_DUO.setDependencies({
    recordHistoryDuo: RECORD_HISTORY_DUO,
});
RECORD_HISTORY_DUO.setDependencies({
    recordHistoryNewValueDuo: RECORD_HISTORY_NEW_VALUE_DUO,
    recordHistoryOldValueDuo: RECORD_HISTORY_OLD_VALUE_DUO,
});
REPOSITORY_TRANSACTION_HISTORY_DUO.setDependencies({
    operationHistoryDuo: OPERATION_HISTORY_DUO,
});
TRANSACTION_HISTORY_DUO.setDependencies({
    repositoryTransactionHistoryDuo: REPOSITORY_TRANSACTION_HISTORY_DUO,
});

var __decorate$1V = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Agt = class Agt {
};
__decorate$1V([
    Id(),
    GeneratedValue()
], Agt.prototype, "id", void 0);
__decorate$1V([
    OneToMany()
], Agt.prototype, "terminalAgts", void 0);
__decorate$1V([
    OneToMany()
], Agt.prototype, "userTerminalAgts", void 0);
Agt = __decorate$1V([
    Entity(),
    Table()
], Agt);

var __decorate$1U = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Continent = class Continent {
};
__decorate$1U([
    Id(),
    GeneratedValue(),
    DbNumber()
], Continent.prototype, "id", void 0);
__decorate$1U([
    DbString()
], Continent.prototype, "name", void 0);
__decorate$1U([
    OneToMany()
], Continent.prototype, "countries", void 0);
Continent = __decorate$1U([
    Entity(),
    Table()
], Continent);

var __decorate$1T = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Country = class Country {
};
__decorate$1T([
    Id(),
    GeneratedValue(),
    DbNumber()
], Country.prototype, "id", void 0);
__decorate$1T([
    DbString()
], Country.prototype, "name", void 0);
__decorate$1T([
    ManyToOne(),
    JoinColumn()
], Country.prototype, "continent", void 0);
__decorate$1T([
    OneToMany()
], Country.prototype, "users", void 0);
Country = __decorate$1T([
    Entity(),
    Table()
], Country);

var __decorate$1S = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 *
 * DEPRECATED - syncing will now be done via IPFS/Peergos
 *
 */
let Terminal = class Terminal {
    constructor() {
        this.isLocal = false;
        // @OneToMany({ mappedBy: 'terminal' })
        // terminalAgts: TerminalAgt[]
        // @OneToMany({ mappedBy: 'terminal' })
        // userTerminal: UserTerminal[]
        // @OneToMany({ mappedBy: 'terminal' })
        // userTerminalAgt: UserTerminalAgt[]
    }
};
__decorate$1S([
    Id(),
    GeneratedValue(),
    DbNumber()
], Terminal.prototype, "id", void 0);
__decorate$1S([
    Column(),
    DbString()
], Terminal.prototype, "uuId", void 0);
__decorate$1S([
    ManyToOne(),
    JoinColumn()
], Terminal.prototype, "owner", void 0);
__decorate$1S([
    Column(),
    DbBoolean()
], Terminal.prototype, "isLocal", void 0);
Terminal = __decorate$1S([
    Entity(),
    Table()
], Terminal);

var __decorate$1R = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 *
 * DEPRECATED - syncing will now be done via IPFS/Peergos
 *
 */
let TerminalAgt = class TerminalAgt {
};
__decorate$1R([
    Id(),
    ManyToOne(),
    JoinColumn()
], TerminalAgt.prototype, "terminal", void 0);
__decorate$1R([
    Id(),
    ManyToOne(),
    JoinColumn()
], TerminalAgt.prototype, "agt", void 0);
__decorate$1R([
    OneToMany()
], TerminalAgt.prototype, "userTerminalAgts", void 0);
TerminalAgt = __decorate$1R([
    Entity(),
    Table()
], TerminalAgt);

var __decorate$1Q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let User = class User {
};
__decorate$1Q([
    Id(),
    GeneratedValue(),
    DbNumber()
], User.prototype, "id", void 0);
__decorate$1Q([
    Column(),
    DbString()
], User.prototype, "email", void 0);
__decorate$1Q([
    Column(),
    DbString()
], User.prototype, "passwordHash", void 0);
__decorate$1Q([
    Column(),
    DbString()
], User.prototype, "username", void 0);
__decorate$1Q([
    Column(),
    DbString()
], User.prototype, "uuId", void 0);
User = __decorate$1Q([
    Entity()
], User);

var __decorate$1P = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 *
 * DEPRECATED - syncing will now be done via IPFS/Peergos
 *
 */
let UserTerminal = class UserTerminal {
};
__decorate$1P([
    Id(),
    ManyToOne(),
    JoinColumn()
], UserTerminal.prototype, "user", void 0);
__decorate$1P([
    Id(),
    ManyToOne(),
    JoinColumn()
], UserTerminal.prototype, "terminal", void 0);
UserTerminal = __decorate$1P([
    Entity(),
    Table()
], UserTerminal);

var __decorate$1O = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * DEPRECATED - syncing will now be done via IPFS/Peergos
 *
 * User needs some sort of password that can be used to verify that
 * a given user is indeed making changes (instead of another one).
 *
 * The password should be AGT specific and Terminal specific
 * to reduce security risks.
 *
 * The password is generated as soon as a user is verified with
 * a terminal and then subsequently registered with an AGT (on
 * the next transaction)
 *
 * Registration is made using an already known to AGT Terminal
 * Id and password, to verify that is indeed coming from the
 * specified terminal.
 *
 * FIXME: additional credentials are needed for User-Agt registration
 * see of OpenConnect can provide something verifiable with the
 * provider
 */
let UserTerminalAgt = class UserTerminalAgt {
};
__decorate$1O([
    Id(),
    DbNumber(),
    GeneratedValue()
], UserTerminalAgt.prototype, "id", void 0);
__decorate$1O([
    Id(),
    Column(),
    DbNumber(),
    GeneratedValue()
], UserTerminalAgt.prototype, "agtId", void 0);
__decorate$1O([
    ManyToOne(),
    JoinColumn()
], UserTerminalAgt.prototype, "user", void 0);
__decorate$1O([
    ManyToOne(),
    JoinColumn()
], UserTerminalAgt.prototype, "terminal", void 0);
__decorate$1O([
    ManyToOne(),
    JoinColumn()
], UserTerminalAgt.prototype, "agt", void 0);
__decorate$1O([
    ManyToOne(),
    JoinColumns()
], UserTerminalAgt.prototype, "terminalAgt", void 0);
UserTerminalAgt = __decorate$1O([
    Entity(),
    Table()
], UserTerminalAgt);

const __constructors__$3 = {
    Agt: Agt,
    Continent: Continent,
    Country: Country,
    Terminal: Terminal,
    TerminalAgt: TerminalAgt,
    User: User,
    UserTerminal: UserTerminal,
    UserTerminalAgt: UserTerminalAgt
};
const Q_APPLICATION$3 = {
    __constructors__: __constructors__$3,
    domain: 'air',
    name: '@airport/travel-document-checkpoint'
};
const Q$3 = Q_APPLICATION$3;
function duoDiSet$3(dbEntityId) {
    return duoDiSet$5(Q$3.__dbApplication__, dbEntityId);
}
DEPENDENCY_INJECTION.db().eventuallyGet(AIRPORT_DATABASE).then((airportDatabase) => {
    airportDatabase.setQApplication(Q_APPLICATION$3);
});

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$3 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q$3);
    }
}
class BaseAgtDao extends SQDIDao$3 {
    constructor() {
        super(7);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$3(7);
    }
}
BaseAgtDao.Find = new DaoQueryDecorators();
BaseAgtDao.FindOne = new DaoQueryDecorators();
BaseAgtDao.Search = new DaoQueryDecorators();
BaseAgtDao.SearchOne = new DaoQueryDecorators();
class BaseContinentDao extends SQDIDao$3 {
    constructor() {
        super(0);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$3(0);
    }
}
BaseContinentDao.Find = new DaoQueryDecorators();
BaseContinentDao.FindOne = new DaoQueryDecorators();
BaseContinentDao.Search = new DaoQueryDecorators();
BaseContinentDao.SearchOne = new DaoQueryDecorators();
class BaseCountryDao extends SQDIDao$3 {
    constructor() {
        super(1);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$3(1);
    }
}
BaseCountryDao.Find = new DaoQueryDecorators();
BaseCountryDao.FindOne = new DaoQueryDecorators();
BaseCountryDao.Search = new DaoQueryDecorators();
BaseCountryDao.SearchOne = new DaoQueryDecorators();
class BaseTerminalDao extends SQDIDao$3 {
    constructor() {
        super(5);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$3(5);
    }
}
BaseTerminalDao.Find = new DaoQueryDecorators();
BaseTerminalDao.FindOne = new DaoQueryDecorators();
BaseTerminalDao.Search = new DaoQueryDecorators();
BaseTerminalDao.SearchOne = new DaoQueryDecorators();
class BaseTerminalAgtDao extends SQDIDao$3 {
    constructor() {
        super(6);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$3(6);
    }
}
BaseTerminalAgtDao.Find = new DaoQueryDecorators();
BaseTerminalAgtDao.FindOne = new DaoQueryDecorators();
BaseTerminalAgtDao.Search = new DaoQueryDecorators();
BaseTerminalAgtDao.SearchOne = new DaoQueryDecorators();
class BaseUserDao extends SQDIDao$3 {
    constructor() {
        super(4);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$3(4);
    }
}
BaseUserDao.Find = new DaoQueryDecorators();
BaseUserDao.FindOne = new DaoQueryDecorators();
BaseUserDao.Search = new DaoQueryDecorators();
BaseUserDao.SearchOne = new DaoQueryDecorators();
class BaseUserTerminalDao extends SQDIDao$3 {
    constructor() {
        super(2);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$3(2);
    }
}
BaseUserTerminalDao.Find = new DaoQueryDecorators();
BaseUserTerminalDao.FindOne = new DaoQueryDecorators();
BaseUserTerminalDao.Search = new DaoQueryDecorators();
BaseUserTerminalDao.SearchOne = new DaoQueryDecorators();
class BaseUserTerminalAgtDao extends SQDIDao$3 {
    constructor() {
        super(3);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$3(3);
    }
}
BaseUserTerminalAgtDao.Find = new DaoQueryDecorators();
BaseUserTerminalAgtDao.FindOne = new DaoQueryDecorators();
BaseUserTerminalAgtDao.Search = new DaoQueryDecorators();
BaseUserTerminalAgtDao.SearchOne = new DaoQueryDecorators();

var __decorate$1N = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TerminalDao = class TerminalDao extends BaseTerminalDao {
    async findByOwnerIdsAndUuIds(ownerIds, uuIds) {
        let d;
        return await this.db.find.tree({
            select: {},
            from: [
                d = Q$3.Terminal
            ],
            where: and(d.owner.id.in(ownerIds), d.uuId.in(uuIds))
        });
    }
    async findByUuIds(uuIds) {
        let d;
        return await this.db.find.tree({
            select: {},
            from: [
                d = Q$3.Terminal
            ],
            where: d.uuId.in(uuIds)
        });
    }
    async insert(terminals) {
        let t;
        const values = [];
        for (const terminal of terminals) {
            values.push([
                terminal.uuId, terminal.owner.id, false,
            ]);
        }
        const ids = await this.db.insertValuesGenerateIds({
            insertInto: t = Q$3.Terminal,
            columns: [
                t.uuId,
                t.owner.id,
                t.isLocal
            ],
            values
        });
        for (let i = 0; i < terminals.length; i++) {
            const terminal = terminals[i];
            terminal.id = ids[i][0];
        }
    }
};
TerminalDao = __decorate$1N([
    Injected()
], TerminalDao);

var __decorate$1M = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let UserDao = class UserDao extends BaseUserDao {
    async findByUserNames(usernames) {
        let u;
        return await this.db.find.tree({
            select: {},
            from: [
                u = Q$3.User
            ],
            where: u.username.in(usernames)
        });
    }
    async findByUuIds(uuIds) {
        let u;
        return await this.db.find.tree({
            select: {},
            from: [
                u = Q$3.User
            ],
            where: u.uuId.in(uuIds)
        });
    }
    async insert(users) {
        let u;
        const values = [];
        for (const user of users) {
            values.push([
                user.uuId, user.username
            ]);
        }
        const ids = await this.db.insertValuesGenerateIds({
            insertInto: u = Q$3.User,
            columns: [
                u.uuId,
                u.username
            ],
            values
        });
        for (let i = 0; i < users.length; i++) {
            const user = users[i];
            user.id = ids[i][0];
        }
    }
};
UserDao = __decorate$1M([
    Injected()
], UserDao);

var __decorate$1L = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AddUserErrorCodes;
(function (AddUserErrorCodes) {
    AddUserErrorCodes["EMAIL_TAKEN"] = "EMAIL_TAKEN";
    AddUserErrorCodes["INVALID_BIRTH_MONTH"] = "INVALID_BIRTH_MONTH";
    AddUserErrorCodes["INVALID_COUNTRY"] = "INVALID_COUNTRY";
    AddUserErrorCodes["INVALID_EMAIL"] = "INVALID_EMAIL";
    AddUserErrorCodes["INVALID_USERNAME"] = "INVALID_USERNAME";
    AddUserErrorCodes["USERNAME_TAKEN"] = "USERNAME_TAKEN";
})(AddUserErrorCodes || (AddUserErrorCodes = {}));
let UserApi = class UserApi {
    async addUser(username, email) {
        const existingUsers = await this.userDao.findByUserNames([username]);
        for (const existingUser of existingUsers) {
            if (existingUser.username === username) {
                return {
                    errorCode: AddUserErrorCodes.USERNAME_TAKEN
                };
            }
        }
        const user = {
            id: null,
            uuId: v4(),
            username
        };
        await this.userDao.save(user);
        return {
            user
        };
    }
    async findUser(privateId) {
        const users = await this.userDao.findByUuIds([privateId]);
        if (users.length) {
            return users[0];
        }
        return null;
    }
};
__decorate$1L([
    Api()
], UserApi.prototype, "addUser", null);
__decorate$1L([
    Api()
], UserApi.prototype, "findUser", null);
UserApi = __decorate$1L([
    Injected()
], UserApi);

const travelDocumentCheckpoint = lib$1('travel-document-checkpoint');
const USER_API = travelDocumentCheckpoint.token({
    class: null,
    interface: 'IUserApi',
    token: 'USER_API'
});

const TERMINAL_DAO = travelDocumentCheckpoint.token({
    class: TerminalDao,
    interface: 'ITerminalDao',
    token: 'TERMINAL_DAO'
});
const USER_DAO = travelDocumentCheckpoint.token({
    class: UserDao,
    interface: 'IUserDao',
    token: 'USER_DAO'
});
USER_API.setClass(UserApi);
USER_API.setDependencies({
    userDao: USER_DAO
});

var __decorate$1K = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let InternalRecordManager = class InternalRecordManager {
    async ensureApplicationRecords(application, context) {
        await this.transactionManager.transactInternal(async (_transaction) => {
            await this.updateDomain(application);
            let actorMapForDomain = this.terminalStore
                .getApplicationActorMapByDomainAndApplicationNames().get(application.domain);
            let actors;
            if (actorMapForDomain) {
                actors = actorMapForDomain.get(application.name);
                if (actors && actors.length) {
                    return;
                }
            }
            actors = await this.actorDao.findByDomainAndApplicationNames(application.domain, application.name);
            let anApplication = await this.applicationDao.findByIndex(application.lastIds.applications + 1);
            if (!actors || !actors.length) {
                const frameworkActor = this.terminalStore.getFrameworkActor();
                const actor = {
                    id: null,
                    application: anApplication,
                    terminal: frameworkActor.terminal,
                    user: frameworkActor.user,
                    uuId: v4()
                };
                await this.actorDao.save(actor);
                actors = [actor];
            }
            const lastTerminalState = this.terminalStore.getTerminalState();
            const applications = lastTerminalState.applications.slice();
            applications.push(anApplication);
            let applicationActors = lastTerminalState.applicationActors.slice();
            applicationActors = applicationActors.concat(actors);
            this.terminalStore.state.next({
                ...lastTerminalState,
                applicationActors,
                applications
            });
        }, context);
    }
    async initTerminal(domainName, context) {
        await this.transactionManager.transactInternal(async (_transaction) => {
            const user = new User();
            user.uuId = 'AIRportA-demo-demo-demo-functionalty';
            user.username = "internalUser";
            const terminal = new Terminal();
            terminal.owner = user;
            terminal.isLocal = true;
            terminal.uuId = v4();
            const actor = new Actor();
            actor.user = user;
            actor.terminal = terminal;
            actor.uuId = v4();
            const actorDao = await this.getactorDaoAsync();
            await actorDao.save(actor, context);
            const lastTerminalState = this.terminalStore.getTerminalState();
            this.terminalStore.state.next({
                ...lastTerminalState,
                frameworkActor: actor,
                terminal
            });
        }, context);
    }
    async updateDomain(application) {
        let domain = this.terminalStore.getDomainMapByName().get(application.domain);
        if (domain && this.entityStateManager.getOriginalValues(domain)) {
            return domain;
        }
        let dbDomain = await this.domainDao.findByName(application.domain);
        let updatedDomain;
        if (domain) {
            if (dbDomain) {
                this.entityStateManager.setOriginalValues(this.entityStateManager.getOriginalValues(dbDomain), domain);
                updatedDomain = domain;
            }
        }
        else {
            if (dbDomain) {
                updatedDomain = dbDomain;
            }
            else {
                updatedDomain = {
                    id: null,
                    name: application.domain,
                };
                await this.domainDao.save(updatedDomain);
            }
        }
        if (!updatedDomain) {
            return domain;
        }
        const lastTerminalState = this.terminalStore.getTerminalState();
        const domains = lastTerminalState.domains.slice();
        let replaced = false;
        for (let i = 0; i < domains.length; i++) {
            let currentDomain = domains[i];
            if (currentDomain.name === domain.name) {
                domains.splice(i, 1, domain);
                replaced = true;
            }
        }
        if (!replaced) {
            domains.push(domain);
        }
        this.terminalStore.state.next({
            ...lastTerminalState,
            domains
        });
        return updatedDomain;
    }
};
__decorate$1K([
    Inject()
], InternalRecordManager.prototype, "actorDao", void 0);
__decorate$1K([
    Inject()
], InternalRecordManager.prototype, "applicationDao", void 0);
__decorate$1K([
    Inject()
], InternalRecordManager.prototype, "domainDao", void 0);
__decorate$1K([
    Inject()
], InternalRecordManager.prototype, "entityStateManager", void 0);
__decorate$1K([
    Inject()
], InternalRecordManager.prototype, "terminalStore", void 0);
__decorate$1K([
    Inject()
], InternalRecordManager.prototype, "transactionManager", void 0);
InternalRecordManager = __decorate$1K([
    Injected()
], InternalRecordManager);

var __decorate$1J = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let InternalTransactionalConnector = class InternalTransactionalConnector {
    callApi(_) {
        throw new Error(`InternalTransactionalConnector.callApi should never be called.
Interal Application API requests should be made directly (since
they are internal to the AIRport framework).`);
    }
    async addRepository(
    // url: string,
    // platform: PlatformType,
    // platformConfig: string,
    // distributionStrategy: DistributionStrategy,
    context) {
        return await this.transactionalServer.addRepository(
        // url,
        // platform,
        // platformConfig,
        // distributionStrategy,
        this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    async find(portableQuery, context, cachedSqlQueryId) {
        return await this.transactionalServer.find(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, cachedSqlQueryId);
    }
    async findOne(portableQuery, context, cachedSqlQueryId) {
        return await this.transactionalServer.findOne(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, cachedSqlQueryId);
    }
    search(portableQuery, context, cachedSqlQueryId) {
        return this.transactionalServer.search(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, cachedSqlQueryId);
    }
    searchOne(portableQuery, context, cachedSqlQueryId) {
        return this.transactionalServer.searchOne(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, cachedSqlQueryId);
    }
    async save(entity, context) {
        return await this.transactionalServer.save(entity, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    async saveToDestination(repositoryDestination, entity, context) {
        return await this.transactionalServer.saveToDestination(repositoryDestination, entity, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    async insertValues(portableQuery, context, ensureGeneratedValues // For internal use only
    ) {
        return await this.transactionalServer.insertValues(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, ensureGeneratedValues);
    }
    async insertValuesGetIds(portableQuery, context) {
        return await this.transactionalServer.insertValuesGetIds(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    async updateValues(portableQuery, context) {
        return await this.transactionalServer.updateValues(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    async deleteWhere(portableQuery, context) {
        return await this.transactionalServer.deleteWhere(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    onMessage(callback) {
        // Nothing to do, onMessage callback was added for demo purposes for Web implementations
    }
};
__decorate$1J([
    Inject()
], InternalTransactionalConnector.prototype, "terminalStore", void 0);
__decorate$1J([
    Inject()
], InternalTransactionalConnector.prototype, "transactionalServer", void 0);
InternalTransactionalConnector = __decorate$1J([
    Injected()
], InternalTransactionalConnector);
function injectTransactionalConnector() {
    console.log('Injecting TransactionalConnector');
}

var __decorate$1I = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let OnlineManager = class OnlineManager {
    constructor() {
        this.online = false;
    }
    async goOffline(context = {}) {
        this.repositoryManager.goOffline();
        this.online = false;
    }
    /**
     There are tree update states:
     LOCAL            0
     REMOTE_CHANGES   1
     GO_ONLINE        2
     Mutation operations of lower order type are blocked until the higher order operation finishes.
     Blocking prevents conflicts in remove transaction application.
     Go-Online logic
     1)  Flip update state to GO_ONLINE
     2)  Find the lastSyncedTransaction recorded locally
     3)  Go Online and start listening for new transactions coming in
     a) While Go-Online is in progress continue gatethering all remote transactions that come in
     and add them to remoteChangesSinceInitialGoOffline
     b) Once Go-Online finishes, when remote transactions come in
     i)  Flip update state to REMOTE_CHANGES
     ii)  Add remote transactions to local store
     iii) Flip state to LOCAL
     4)  Load from deltaStore all remote transactions since lastSyncedTransaction
     5)  Add remote transactions to local store
     6)  While there are more transactions coming in remotely:
     Add them to local store
     7)  Find all local unsynced transactions
     a)  Mark them as synchronized
     b)  add them to deltaStore
     c)  save them back in local store, now with the synched flag
     (and update db with new lastSyncedTransaction)
     8)  While there are more transactions coming in remotely:
     Add them to local store
     9)  Flip the online state to true
     Finally, always flip update state to LOCAL
     * @returns {Promise<void>}
     */
    async goOnline(context = {}) {
        await this.transactionManager.transactInternal(async () => {
            try {
                // 1)  Flip update state to GO_ONLINE
                this.repositoryManager.setUpdateStateForAll(UpdateState.GO_ONLINE);
                // 2)  Find repositories
                // const repoRecords = await this.repositoryDao.findWithTransaction()
                const repoRecords = await this.repositoryDao.findReposWithDetailsByIds();
                // 3) make each repository go Online
                let goOnlineCalls = [];
                repoRecords.forEach((repository) => {
                    goOnlineCalls.push(this.repositoryGoOnline(repository, this.repositoryManager));
                });
                await Promise.all(goOnlineCalls);
                // 9)  Flip the online state to true
                this.online = true;
            }
            catch (error) {
                // TODO: notify of error
                throw error;
            }
            finally {
                // Finally, always flip update state to LOCAL
                this.repositoryManager.setUpdateStateForAll(UpdateState.LOCAL);
            }
        }, context);
    }
    async repositoryGoOnline(repository, repositoryManager) {
        let deltaStore = repositoryManager.deltaStore[repository.id];
        let remoteChangesSinceInitialGoOnline = [];
        // 3)  Go Online and start listening for new transactions coming in
        await deltaStore.goOnline(async (transactions) => {
            if (!transactions.length) {
                return;
            }
            transactions = transactions.map((repoTransaction) => {
                repoTransaction = new RepositoryTransactionHistory(repoTransaction);
                // TODO: ?is the following needed?
                // repoTransaction.deserialize(repository)
                return repoTransaction;
            });
            // a) While Go-Online is in progress continue gathering all remote transactions
            // that come in and add them to remoteChangesSinceInitialGoOffline
            if (repositoryManager.getUpdateState(repository) === UpdateState.GO_ONLINE) {
                remoteChangesSinceInitialGoOnline.push(transactions);
            }
            // b) Once Go-Online finishes, when remote transactions come in
            else {
                try {
                    // i)  Flip update state to REMOTE_CHANGES
                    repositoryManager.setUpdateState(repository, UpdateState.REMOTE);
                    // ii)  Add remote transactions to local store
                    await this.offlineDeltaStore.addRemoteChanges(repository, transactions);
                }
                catch (error) {
                    // TODO: notify of error
                    throw error;
                }
                finally {
                    // iii) Flip state to LOCAL
                    repositoryManager.setUpdateState(repository, UpdateState.LOCAL);
                }
            }
        });
        // 4)  Load from deltaStore all remote transactions since lastSyncedTransaction
        let remoteChangesIter = await deltaStore.loadTransactionsSinceLastKnown(repository.lastSyncedTransaction);
        let remoteChanges = [];
        while (remoteChangesIter.hasNext()) {
            remoteChanges.push(remoteChangesIter.next());
        }
        // 5)  Add remote transactions to local store
        if (remoteChanges.length) {
            await this.offlineDeltaStore.addRemoteChanges(repository, remoteChanges);
        }
        // 6)  While there are more transactions coming in remotely:
        while (remoteChangesSinceInitialGoOnline.length) {
            remoteChanges = remoteChangesSinceInitialGoOnline;
            remoteChangesSinceInitialGoOnline = [];
            // Add them to local store
            await this.offlineDeltaStore.addRemoteChanges(repository, remoteChanges);
        }
        // 7)  Find all local unsynced transactions
        let unsyncedChanges = await this.repositoryTransactionHistoryDao
            .findUnsyncedTransactions(repository);
        if (unsyncedChanges.length) {
            unsyncedChanges.forEach((transaction) => {
                // a)  Mark them as synchronized
                transaction.syncStatus = BlockSyncStatus.SYNCHRONIZED;
            });
            // b)  add them to deltaStore
            await deltaStore.addChanges(deltaStore.config.changeListConfig, unsyncedChanges);
            // c)  save them back in local store, now with the synched flag
            // (and update db with new lastSyncedTransaction)
            await this.offlineDeltaStore.markChangesAsSynced(repository, null);
        }
        // 	8)  While there are more transactions coming in remotely:
        // Add them to local store
        while (remoteChangesSinceInitialGoOnline.length) {
            remoteChanges = remoteChangesSinceInitialGoOnline;
            remoteChangesSinceInitialGoOnline = [];
            await this.offlineDeltaStore.addRemoteChanges(repository, remoteChanges);
        }
        // 9)  Flip the online state to true
        this.online = true;
    }
    isOnline(context = {}) {
        return this.online;
    }
};
__decorate$1I([
    Inject()
], OnlineManager.prototype, "repositoryDao", void 0);
__decorate$1I([
    Inject()
], OnlineManager.prototype, "repositoryManager", void 0);
__decorate$1I([
    Inject()
], OnlineManager.prototype, "repositoryTransactionHistoryDao", void 0);
__decorate$1I([
    Inject()
], OnlineManager.prototype, "transactionManager", void 0);
OnlineManager = __decorate$1I([
    Injected()
], OnlineManager);

var IsolateMessageType;
(function (IsolateMessageType) {
    IsolateMessageType["ADD_REPOSITORY"] = "ADD_REPOSITORY";
    IsolateMessageType["APP_INITIALIZING"] = "APP_INITIALIZING";
    IsolateMessageType["APP_INITIALIZED"] = "APP_INITIALIZED";
    IsolateMessageType["CALL_API"] = "CALL_API";
    IsolateMessageType["DELETE_WHERE"] = "DELETE_WHERE";
    IsolateMessageType["FIND"] = "FIND";
    IsolateMessageType["FIND_ONE"] = "FIND_ONE";
    IsolateMessageType["GET_LATEST_APPLICATION_VERSION_BY_APPLICATION_NAME"] = "GET_LATEST_APPLICATION_VERSION_BY_APPLICATION_NAME";
    IsolateMessageType["INSERT_VALUES"] = "INSERT_VALUES";
    IsolateMessageType["INSERT_VALUES_GET_IDS"] = "INSERT_VALUES_GET_IDS";
    IsolateMessageType["RETRIEVE_DOMAIN"] = "RETRIEVE_DOMAIN";
    IsolateMessageType["SEARCH"] = "SEARCH";
    IsolateMessageType["SEARCH_ONE"] = "SEARCH_ONE";
    IsolateMessageType["SEARCH_UNSUBSCRIBE"] = "UNSUBSCRIBE";
    IsolateMessageType["SAVE"] = "SAVE";
    IsolateMessageType["SAVE_TO_DESTINATION"] = "SAVE_TO_DESTINATION";
    IsolateMessageType["UPDATE_VALUES"] = "UPDATE_VALUES";
})(IsolateMessageType || (IsolateMessageType = {}));

var AppState;
(function (AppState) {
    AppState["NOT_INITIALIED"] = "NOT_INITIALIED";
    AppState["START_INITIALIZING"] = "START_INITIALIZING";
    AppState["INITIALIZING_IN_PROGRESS"] = "INITIALIZING_IN_PROGRESS";
    AppState["INITIALIZED"] = "INITIALIZED";
})(AppState || (AppState = {}));

const applicationState = {
    application: null,
    appState: AppState.NOT_INITIALIED,
    domain: null,
    // FIXME: make this dynamic for web version (https://turbase.app), local version (https://localhost:PORT)
    // and debugging (http://localhost:7500)
    hostServer: 'http://localhost:7500',
    lastIds: null,
    // FIXME: tie this in to the hostServer variable
    mainDomain: null,
    observableMessageMap: new Map(),
    pendingMessageMap: new Map(),
    messageCallback: null,
};

var __decorate$1H = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationStore = class ApplicationStore {
    constructor() {
        this.applicationState = applicationState;
    }
    get state() {
        return this.applicationState;
    }
};
ApplicationStore = __decorate$1H([
    Injected()
], ApplicationStore);

const apron = lib$1('apron');
apron.token({
    class: null,
    interface: 'IApplicationLoader',
    token: 'APPLICATION_LOADER'
});
apron.token({
    class: ApplicationStore,
    interface: 'IApplicationStore',
    token: 'APPLICATION_STORE'
});
const LOCAL_API_SERVER = apron.token({
    class: null,
    interface: 'ILocalAPIServer',
    token: 'LOCAL_API_SERVER'
});
LOCAL_API_SERVER.setDependencies({
    apiRegistry: API_REGISTRY
});

var __decorate$1G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TransactionalReceiver = class TransactionalReceiver {
    async processMessage(message) {
        let result;
        let errorMessage;
        try {
            if (message.domain === INTERNAL_DOMAIN) {
                throw new Error(`Internal domain cannot be used in external calls`);
            }
            let credentials = {
                application: message.application,
                domain: message.domain,
                methodName: message.methodName,
                objectName: message.objectName
            };
            let context = {};
            context.startedAt = new Date();
            switch (message.type) {
                case IsolateMessageType.CALL_API: {
                    const context = {};
                    try {
                        result = await this.nativeHandleApiCall(message, context);
                    }
                    catch (e) {
                        errorMessage = e.message;
                    }
                    break;
                }
                case IsolateMessageType.APP_INITIALIZING:
                    let initConnectionMessage = message;
                    const application = initConnectionMessage.jsonApplication;
                    const fullApplicationName = this.dbApplicationUtils.
                        getFullApplicationName(application);
                    const messageFullApplicationName = this.dbApplicationUtils.
                        getFullApplicationNameFromDomainAndName(message.domain, message.application);
                    if (fullApplicationName !== messageFullApplicationName) {
                        result = null;
                        break;
                    }
                    if (this.terminalStore.getReceiver().initializingApps
                        .has(fullApplicationName)) {
                        return null;
                    }
                    this.terminalStore.getReceiver().initializingApps
                        .add(fullApplicationName);
                    // FIXME: initalize ahead of time, at Isolate Loading
                    await this.databaseManager.initFeatureApplications({}, [application]);
                    await this.internalRecordManager.ensureApplicationRecords(application, {});
                    result = application.lastIds;
                    break;
                case IsolateMessageType.APP_INITIALIZED:
                    const initializedApps = this.terminalStore.getReceiver().initializedApps;
                    initializedApps.add(message.fullApplicationName);
                    return null;
                case IsolateMessageType.GET_LATEST_APPLICATION_VERSION_BY_APPLICATION_NAME: {
                    result = this.terminalStore.getLatestApplicationVersionMapByFullApplicationName()
                        .get(message.fullApplicationName);
                    break;
                }
                case IsolateMessageType.RETRIEVE_DOMAIN: {
                    result = this.terminalStore.getDomainMapByName()
                        .get(message.domain);
                    break;
                }
                case IsolateMessageType.ADD_REPOSITORY:
                    // const addRepositoryMessage: IAddRepositoryIMI = <IAddRepositoryIMI>message
                    result = await this.transactionalServer.addRepository(
                    // addRepositoryMessage.url,
                    // addRepositoryMessage.platform,
                    // addRepositoryMessage.platformConfig,
                    // addRepositoryMessage.distributionStrategy,
                    credentials, context);
                    break;
                case IsolateMessageType.DELETE_WHERE:
                    const deleteWhereMessage = message;
                    result = await this.transactionalServer.deleteWhere(deleteWhereMessage.portableQuery, credentials, context);
                    break;
                case IsolateMessageType.FIND:
                    const findMessage = message;
                    result = await this.transactionalServer.find(findMessage.portableQuery, credentials, {
                        ...context,
                        repository: findMessage.repository
                    });
                    break;
                case IsolateMessageType.FIND_ONE:
                    const findOneMessage = message;
                    result = await this.transactionalServer.findOne(findOneMessage.portableQuery, credentials, {
                        ...context,
                        repository: findMessage.repository,
                    });
                    break;
                case IsolateMessageType.INSERT_VALUES:
                    const insertValuesMessage = message;
                    result = await this.transactionalServer.insertValues(insertValuesMessage.portableQuery, credentials, context);
                    break;
                case IsolateMessageType.INSERT_VALUES_GET_IDS:
                    const insertValuesGetIdsMessage = message;
                    result = await this.transactionalServer.insertValuesGetIds(insertValuesGetIdsMessage.portableQuery, credentials, context);
                    break;
                case IsolateMessageType.SAVE:
                case IsolateMessageType.SAVE_TO_DESTINATION: {
                    const saveMessage = message;
                    if (!saveMessage.dbEntity) {
                        errorMessage = `DbEntity id was not passed in`;
                        break;
                    }
                    const dbEntityId = saveMessage.dbEntity.id;
                    const dbEntity = this.terminalStore.getAllEntities()[dbEntityId];
                    if (!dbEntity) {
                        errorMessage = `Could not find DbEntity with Id ${dbEntityId}`;
                        break;
                    }
                    context.dbEntity = dbEntity;
                    if (message.type === IsolateMessageType.SAVE) {
                        result = await this.transactionalServer.save(saveMessage.entity, credentials, context);
                    }
                    else {
                        const saveToDestinationMessage = message;
                        result = await this.transactionalServer.saveToDestination(saveToDestinationMessage.repositoryDestination, saveToDestinationMessage.entity, credentials, context);
                    }
                    break;
                }
                case IsolateMessageType.SEARCH:
                    const searchMessage = message;
                    result = await this.transactionalServer.search(searchMessage.portableQuery, credentials, {
                        ...context,
                        repository: findMessage.repository,
                    });
                    break;
                case IsolateMessageType.SEARCH_ONE:
                    const searchOneMessage = message;
                    result = await this.transactionalServer.search(searchOneMessage.portableQuery, credentials, {
                        ...context,
                        repository: findMessage.repository,
                    });
                    break;
                case IsolateMessageType.UPDATE_VALUES:
                    const updateValuesMessage = message;
                    result = await this.transactionalServer.updateValues(updateValuesMessage.portableQuery, credentials, context);
                    break;
                default:
                    // Unexpected IsolateMessageInType
                    return;
            }
        }
        catch (error) {
            console.error(error);
            result = null;
            errorMessage = error.message;
        }
        return {
            application: message.application,
            category: 'FromDb',
            domain: message.domain,
            errorMessage,
            id: message.id,
            type: message.type,
            result
        };
    }
    async startApiCall(message, context, nativeHandleCallback) {
        const transactionCredentials = {
            application: message.application,
            domain: message.domain,
            methodName: message.methodName,
            objectName: message.objectName,
            transactionId: message.transactionId
        };
        if (!await this.transactionalServer.startTransaction(transactionCredentials, context)) {
            return false;
        }
        const initiator = context.transaction.initiator;
        initiator.application = message.application;
        initiator.domain = message.domain;
        initiator.methodName = message.methodName;
        initiator.objectName = message.objectName;
        message.transactionId = context.transaction.id;
        try {
            await nativeHandleCallback();
        }
        catch (e) {
            context.errorMessage = e.message;
            this.transactionalServer.rollback(transactionCredentials, context);
            return false;
        }
        return true;
    }
    async endApiCall(credentials, errorMessage, context) {
        if (errorMessage) {
            return await this.transactionalServer.rollback(credentials, context);
        }
        else {
            return await this.transactionalServer.commit(credentials, context);
        }
    }
};
__decorate$1G([
    Inject()
], TransactionalReceiver.prototype, "databaseManager", void 0);
__decorate$1G([
    Inject()
], TransactionalReceiver.prototype, "dbApplicationUtils", void 0);
__decorate$1G([
    Inject()
], TransactionalReceiver.prototype, "internalRecordManager", void 0);
__decorate$1G([
    Inject()
], TransactionalReceiver.prototype, "terminalStore", void 0);
__decorate$1G([
    Inject()
], TransactionalReceiver.prototype, "transactionalServer", void 0);
TransactionalReceiver = __decorate$1G([
    Injected()
], TransactionalReceiver);

var __decorate$1F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Keeps track of transactions, per client and validates that a given
 * transaction belongs to the provided client.  If the connection
 * information matches, passes the transaction for handling.
 *
 * All transactions are queued.  Read operations are not blocked while
 * any transaction is in progress.  Best way to make sure that you get
 * the latest state is to subscribe to a query, which is guaranteed to
 * be updated after data has changed.
 *
 *
 * Should read operations be blocked while transactions are in process?
 * Probably not since they will just get snapshot of the state at any
 * given point in time and transactionality takes care of not exposing
 * inconsistent state.  There doesn't appear to be a need to que-up
 * read transactions, since SqLite can handle it:
 *
 * https://www.skoumal.net/en/parallel-read-and-write-in-sqlite/
 *
 * Also, there doesn't appear to be a reason to prioritize remote transactions
 * over local ones, since ultimately the state needs to sync either way.
 * A single transactional queue should be enough.
 *
 */
let TransactionalServer = class TransactionalServer {
    async init(context = {}) {
        return await this.transactionManager.initialize('airport', context);
    }
    async addRepository(credentials, context) {
        await this.ensureContext(context);
        this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        const actor = await this.getActor(credentials);
        // FIXME: check actor
        let repositoryId = 0;
        await this.transactionManager.transactInternal(async () => {
            const repository = await this.repositoryManager.createRepository(
            // url, platform, platformConfig, distributionStrategy
            actor, context);
            repositoryId = repository.id;
        }, context);
        return repositoryId;
    }
    async find(portableQuery, credentials, context, cachedSqlQueryId) {
        await this.ensureContext(context);
        if (credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        return await this.queryManager.find(portableQuery, context, cachedSqlQueryId);
    }
    async findOne(portableQuery, credentials, context, cachedSqlQueryId) {
        await this.ensureContext(context);
        if (credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        return await this.queryManager.findOne(portableQuery, context, cachedSqlQueryId);
    }
    search(portableQuery, credentials, context, cachedSqlQueryId) {
        this.ensureContextSync(context);
        if (credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        return this.queryManager.search(portableQuery, context);
    }
    searchOne(portableQuery, credentials, context, cachedSqlQueryId) {
        this.ensureContextSync(context);
        if (credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        return this.queryManager.searchOne(portableQuery, context);
    }
    async startTransaction(credentials, context) {
        try {
            await this.ensureContext(context);
            await this.transactionManager.startTransaction(credentials, context);
            return true;
        }
        catch (e) {
            context.errorMessage = e.message;
            console.error(e);
            return false;
        }
    }
    async commit(credentials, context) {
        try {
            await this.ensureContext(context);
            await this.transactionManager.commit(credentials, context);
            return true;
        }
        catch (e) {
            console.error(e);
            context.errorMessage = e.message;
            return false;
        }
    }
    async rollback(credentials, context) {
        if (context.transaction) ;
        try {
            await this.ensureContext(context);
            await this.transactionManager.rollback(credentials, context);
            return true;
        }
        catch (e) {
            console.error(e);
            context.errorMessage = e.message;
            return false;
        }
    }
    async save(entity, credentials, context) {
        if (!entity) {
            return null;
        }
        await this.ensureContext(context);
        this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        const actor = await this.getActor(credentials);
        context.actor = actor;
        let saveResult;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            saveResult = await this.operationManager.performSave(entity, actor, transaction, context.rootTransaction, context);
        }, context);
        return saveResult;
    }
    async saveToDestination(repositoryDestination, entity, credentials, context) {
        if (!entity) {
            return null;
        }
        await this.ensureContext(context);
        this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        const actor = await this.getActor(credentials);
        context.actor = actor;
        let saveResult;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            // TODO: save to serialized repository to the specified destination
            saveResult = await this.operationManager.performSave(entity, actor, transaction, context.rootTransaction, context);
        }, context);
        return saveResult;
    }
    async insertValues(portableQuery, credentials, context, ensureGeneratedValues // for internal use only
    ) {
        await this.ensureContext(context);
        this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        const actor = await this.getActor(credentials);
        let numInsertedRecords;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            numInsertedRecords = await this.insertManager.insertValues(portableQuery, actor, transaction, context.rootTransaction, context, ensureGeneratedValues);
        }, context);
        return numInsertedRecords;
    }
    async insertValuesGetIds(portableQuery, credentials, context) {
        await this.ensureContext(context);
        this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        const actor = await this.getActor(credentials);
        let ids;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            ids = await this.insertManager.insertValuesGetIds(portableQuery, actor, transaction, context.rootTransaction, context);
        }, context);
        return ids;
    }
    async updateValues(portableQuery, credentials, context) {
        await this.ensureContext(context);
        this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        const actor = await this.getActor(credentials);
        let numUpdatedRecords;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            numUpdatedRecords = await this.updateManager.updateValues(portableQuery, actor, transaction, context.rootTransaction, context);
        }, context);
        return numUpdatedRecords;
    }
    async deleteWhere(portableQuery, credentials, context) {
        await this.ensureContext(context);
        this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        const actor = await this.getActor(credentials);
        let numDeletedRecords;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            numDeletedRecords = await this.deleteManager.deleteWhere(portableQuery, actor, transaction, context.rootTransaction, context);
        }, context);
        return numDeletedRecords;
    }
    async getActor(credentials) {
        if (this.tempActor) {
            return this.tempActor;
        }
        if (credentials.domain === INTERNAL_DOMAIN) {
            return new Actor();
        }
        let actors;
        const actorMapForDomain = this.terminalStore
            .getApplicationActorMapByDomainAndApplicationNames().get(credentials.domain);
        if (actorMapForDomain) {
            actors = actorMapForDomain.get(credentials.application);
        }
        else {
            throw new Error(`No Actors found for
	Domain:
		${credentials.domain}
			`);
        }
        if (!actors) {
            throw new Error(`No Actors found for
	Domain:
		${credentials.domain}
	Application:
		${credentials.application}
			`);
        }
        const localTerminal = this.terminalStore.getFrameworkActor().terminal;
        if (!localTerminal.isLocal) {
            throw new Error(`Expecting terminal of the TerminalStore.frameworkActor to be .isLocal`);
        }
        let actor;
        for (const anActor of actors) {
            if (anActor.terminal.uuId === localTerminal.uuId) {
                actor = anActor;
                break;
            }
        }
        if (!actor) {
            throw new Error(`Could not find actor for
	Domain:
		${credentials.domain}
	Application:
		${credentials.application}
			`);
        }
        return actor;
    }
    async ensureContext(context) {
        await this.operationContextLoader.ensure(context);
    }
    async ensureContextSync(context) {
        this.operationContextLoader.ensureSync(context);
    }
};
__decorate$1F([
    Inject()
], TransactionalServer.prototype, "deleteManager", void 0);
__decorate$1F([
    Inject()
], TransactionalServer.prototype, "insertManager", void 0);
__decorate$1F([
    Inject()
], TransactionalServer.prototype, "operationManager", void 0);
__decorate$1F([
    Inject()
], TransactionalServer.prototype, "operationContextLoader", void 0);
__decorate$1F([
    Inject()
], TransactionalServer.prototype, "queryManager", void 0);
__decorate$1F([
    Inject()
], TransactionalServer.prototype, "repositoryManager", void 0);
__decorate$1F([
    Inject()
], TransactionalServer.prototype, "terminalStore", void 0);
__decorate$1F([
    Inject()
], TransactionalServer.prototype, "transactionManager", void 0);
__decorate$1F([
    Inject()
], TransactionalServer.prototype, "updateManager", void 0);
TransactionalServer = __decorate$1F([
    Injected()
], TransactionalServer);
function injectTransactionalServer() {
    console.log('Injecting TransactionalServer');
}

var __decorate$1E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let AbstractMutationManager = class AbstractMutationManager {
    getPortableQuery(applicationIndex, tableIndex, query, queryResultType) {
        return {
            applicationIndex,
            tableIndex,
            jsonQuery: query.toJSON(this.queryUtils, this.fieldUtils, this.relationManager),
            parameterMap: query.getParameters(),
            queryResultType,
        };
    }
    async doInsertValues(transaction, q, entities, context) {
        const dbEntity = q.__driver__.dbEntity;
        const columnIndexes = [];
        const columnValueLookups = [];
        for (const dbProperty of dbEntity.properties) {
            let columnValueLookup = {
                name: dbProperty.name,
                nested: null,
            };
            if (dbProperty.relation && dbProperty.relation.length) {
                const dbRelation = dbProperty.relation[0];
                this.applicationUtils.forEachColumnTypeOfRelation(dbRelation, (dbColumn, propertyNameChains) => {
                    if (columnIndexes[dbColumn.index]) {
                        return;
                    }
                    columnIndexes[dbColumn.index] = dbColumn.index;
                    columnValueLookups[dbColumn.index] = columnValueLookup;
                    const firstPropertyNameChain = propertyNameChains[0];
                    for (let i = 1; i < firstPropertyNameChain.length; i++) {
                        const propertyName = firstPropertyNameChain[i];
                        const nextColumnValueLookup = {
                            name: propertyName,
                            nested: null,
                        };
                        columnValueLookup.nested = nextColumnValueLookup;
                        columnValueLookup = nextColumnValueLookup;
                    }
                });
            }
            else {
                const dbColumn = dbProperty.propertyColumns[0].column;
                if (columnIndexes[dbColumn.index]) {
                    continue;
                }
                columnIndexes[dbColumn.index] = dbColumn.index;
                columnValueLookups[dbColumn.index] = columnValueLookup;
            }
        }
        const values = entities.map(entity => {
            return columnValueLookups.map(lookup => {
                let value = entity[lookup.name];
                while (lookup.nested) {
                    if (!(value instanceof Object)) {
                        break;
                    }
                    lookup = lookup.nested;
                    value = value[lookup.name];
                }
                return value === undefined ? null : value;
            });
        });
        const rawInsertValues = {
            insertInto: q,
            columns: null,
            values,
        };
        let insertValues = new InsertValues(rawInsertValues, columnIndexes);
        let portableQuery = this.getPortableQuery(dbEntity.applicationVersion.application.index, dbEntity.index, insertValues, null);
        return await transaction.insertValues(portableQuery, context);
    }
};
__decorate$1E([
    Inject()
], AbstractMutationManager.prototype, "applicationUtils", void 0);
__decorate$1E([
    Inject()
], AbstractMutationManager.prototype, "fieldUtils", void 0);
__decorate$1E([
    Inject()
], AbstractMutationManager.prototype, "queryUtils", void 0);
__decorate$1E([
    Inject()
], AbstractMutationManager.prototype, "relationManager", void 0);
AbstractMutationManager = __decorate$1E([
    Injected()
], AbstractMutationManager);

/* eslint-disable */
const APPLICATION$4 = {
    "domain": "air",
    "index": null,
    "name": "@airport/airport-code",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {
                    "IApplicationApi": {
                        "operationMap": {
                            "testApiDefinitionGeneration": {
                                "isAsync": true,
                                "parameters": []
                            }
                        }
                    }
                }
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TABLE_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMN_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SEQUENCE_INCREMENT_BY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CURRENT_VALUE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "Sequence",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "applicationIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": true,
                            "name": "tableIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": true,
                            "name": "columnIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "incrementBy",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "currentValue",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "SEQUENCES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "SystemWideOperationId",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "SYSTEM_WIDE_OPERATION_IDS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATE_TIMESTAMP",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "RANDOM_NUMBER",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "TerminalRun",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "createTimestamp",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "randomNumber",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TERMINAL_RUNS",
                        "columnIndexes": []
                    },
                    "operations": {}
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION$3 = {
    "domain": "air",
    "index": null,
    "name": "@airport/holding-pattern",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {}
            },
            "entities": [
                {
                    "columns": [
                        {
                            "allocationSize": 2000,
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ACTOR_RECORD_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 5,
                                    "oneRelationIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_OPERATION_HISTORY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "RecordHistory",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "actorRecordId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "actor",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "operationHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "newValues",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "oldValues",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "recordHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "recordHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 7,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_RECORD_HISTORY",
                        "columnIndexes": [
                            {
                                "name": "RCRD_HSTR_TO_OPRTN_HSTR_FX",
                                "columnList": [
                                    "REPOSITORY_OPERATION_HISTORY_ID"
                                ],
                                "unique": false
                            }
                        ]
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "UU_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": 0,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "USER_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": 0,
                                    "oneTableIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TERMINAL_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": 1,
                                    "oneTableIndex": 10,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_INDEX",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "Actor",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "uuId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "user",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "terminal",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "application",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 4,
                            "relationTableApplicationIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 5,
                            "relationTableApplicationIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 10,
                            "relationTableApplicationIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "AGE_SUITABILITY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATED_AT",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "DATE"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IMMUTABLE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SOURCE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "UU_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": 0,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OWNER_USER_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "Repository",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "ageSuitability",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "createdAt",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "immutable",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "source",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "uuId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "owner",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "repositoryTransactionHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 4,
                            "relationTableApplicationIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repository"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "allocationSize": 100,
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TRANSACTION_TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 3,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "TransactionHistory",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "transactionType",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "repositoryTransactionHistories",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "transactionHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TRANSACTION_HISTORY",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "allocationSize": 200,
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_TRANSACTION_TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SAVE_TIMESTAMP",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SYNC_TIMESTAMP",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "UUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_REPOSITORY_CREATION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 2,
                                    "oneRelationIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 3,
                                    "oneRelationIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TRANSACTION_HISTORY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 4,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "RepositoryTransactionHistory",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "repositoryTransactionType",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "saveTimestamp",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "syncTimestamp",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "uuId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "isRepositoryCreation",
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "repository",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "transactionHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "operationHistory",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repositoryTransactionHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_TRANSACTION_HISTORY",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "allocationSize": 600,
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ORDER_NUMBER",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CHANGE_TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SYSTEM_WIDE_OPERATION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": 1,
                                    "oneTableIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ENTITY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 4,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_TRANSACTION_HISTORY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 5,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "OperationHistory",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "orderNumber",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "changeType",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "systemWideOperationId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "actor",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "repositoryTransactionHistory",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "recordHistory",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 6,
                            "relationTableApplicationIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "operationHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_OPERATION_HISTORY",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMN_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NEW_VALUE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "ANY"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 0,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_RECORD_HISTORY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 6,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "RecordHistoryNewValue",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "recordHistory",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 1,
                            "isId": true,
                            "name": "columnIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 2,
                            "isId": false,
                            "name": "newValue",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_RECORD_HISTORY_NEW_VALUES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMN_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "OLD_VALUE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "ANY"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 0,
                                    "oneRelationIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_RECORD_HISTORY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 7,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "RecordHistoryOldValue",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "recordHistory",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 1,
                            "isId": true,
                            "name": "columnIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 2,
                            "isId": false,
                            "name": "oldValue",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_RECORD_HISTORY_OLD_VALUES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_APPLICATION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 8,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "RepositoryApplication",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 2,
                            "isId": false,
                            "name": "applicationIndex",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_APPLICATIONS",
                        "columnIndexes": []
                    }
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [
                {
                    "domain": "air",
                    "index": 0,
                    "name": "@airport/travel-document-checkpoint",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                },
                {
                    "domain": "air",
                    "index": 1,
                    "name": "@airport/airspace",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                }
            ],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION$2 = {
    "domain": "air",
    "index": null,
    "name": "@airport/airspace",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {}
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 4,
                                    "oneRelationIndex": 5,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "MANY_APPLICATION_COLUMN_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 4,
                                    "oneRelationIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ONE_APPLICATION_COLUMN_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 5,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 1,
                                    "oneRelationIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "MANY_APPLICATION_RELATION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 6,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 1,
                                    "oneRelationIndex": 7,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ONE_APPLICATION_RELATION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 7,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "PARENT_RELATION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationRelationColumn",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "manyColumn",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "oneColumn",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "manyRelation",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "oneRelation",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "parentRelation",
                            "relationRef": {
                                "index": 7
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_RELATION_COLUMNS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "RELATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "FOREIGN_KEY",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "MANY_TO_ONE_ELEMENTS",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ONE_TO_MANY_ELEMENTS",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "RELATION_TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 10
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 10,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 2,
                                    "oneRelationIndex": 5,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_PROPERTY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 11,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 7,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_TABLE_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 11
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 12,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 5,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 8,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "RELATION_APPLICATION_TABLE_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 12
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationRelation",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "property",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 6,
                            "isId": false,
                            "name": "foreignKey",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 7,
                            "isId": false,
                            "name": "manyToOneElems",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 8,
                            "isId": false,
                            "name": "oneToManyElems",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 8
                            },
                            "index": 9,
                            "isId": false,
                            "name": "relationType",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 9
                            },
                            "index": 10,
                            "isId": false,
                            "name": "isId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 11,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 12,
                            "isId": false,
                            "name": "relationEntity",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 13,
                            "isId": false,
                            "name": "manyRelationColumns",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 14,
                            "isId": false,
                            "name": "oneRelationColumns",
                            "relationRef": {
                                "index": 7
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 11
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 12
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "manyRelation"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 13
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "oneRelation"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 14
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_RELATIONS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PROPERTY_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationProperty",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "isId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "propertyColumns",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "relation",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "property"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "property"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_PROPERTIES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 4,
                                    "oneRelationIndex": 4,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_COLUMN_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 2,
                                    "oneRelationIndex": 4,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_PROPERTY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        },
                        {
                            "index": 4
                        }
                    ],
                    "index": 3,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationPropertyColumn",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": true,
                            "name": "column",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": true,
                            "name": "property",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_PROPERTY_COLUMNS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMN_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ID_INDEX",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_GENERATED",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ALLOCATION_SIZE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NOT_NULL",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 10,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PRECISION",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 10
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 11,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SCALE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 11
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 12,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 12
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 13,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 4,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 13
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 4,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationColumn",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "idIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "isGenerated",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 7,
                            "isId": false,
                            "name": "allocationSize",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 8
                            },
                            "index": 8,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 9
                            },
                            "index": 9,
                            "isId": false,
                            "name": "notNull",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 10
                            },
                            "index": 10,
                            "isId": false,
                            "name": "precision",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 11
                            },
                            "index": 11,
                            "isId": false,
                            "name": "scale",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 12
                            },
                            "index": 12,
                            "isId": false,
                            "name": "type",
                            "sinceVersion": 1
                        },
                        {
                            "index": 13,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 14,
                            "isId": false,
                            "name": "propertyColumns",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 15,
                            "isId": false,
                            "name": "manyRelationColumns",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 16,
                            "isId": false,
                            "name": "oneRelationColumns",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 13
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "column"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 14
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "manyColumn"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 15
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "oneColumn"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 16
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_COLUMNS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "RULE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 5,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 5,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationOperation",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "type",
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 6,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 7,
                            "isId": false,
                            "name": "rule",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_OPERATIONS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TABLE_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_LOCAL",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_REPOSITORY_ENTITY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TABLE_CONFIGURATION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneRelationIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 6,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationEntity",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "isLocal",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "isRepositoryEntity",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 7,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 8
                            },
                            "index": 8,
                            "isId": false,
                            "name": "tableConfig",
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "applicationVersion",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 10,
                            "isId": false,
                            "name": "columns",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 11,
                            "isId": false,
                            "name": "operations",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 12,
                            "isId": false,
                            "name": "properties",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 13,
                            "isId": false,
                            "name": "relations",
                            "relationRef": {
                                "index": 7
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 14,
                            "isId": false,
                            "name": "relationReferences",
                            "relationRef": {
                                "index": 8
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "entity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 10
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "entity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 11
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "entity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 12
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "entity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 13
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "relationEntity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 14
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_ENTITIES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_REFERENCE_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OWN_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneRelationIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REFERENCED_APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 4
                        },
                        {
                            "index": 5
                        }
                    ],
                    "index": 7,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationReference",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": true,
                            "name": "ownApplicationVersion",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": true,
                            "name": "referencedApplicationVersion",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 5,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_REFERENCES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "allocationSize": 100,
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "INTEGER_VERSION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "VERSION_STRING",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "MAJOR_VERSION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "MINOR_VERSION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PATCH_VERSION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "JSON_APPLICATION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 10,
                                    "oneRelationIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 8,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationVersion",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "integerVersion",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "versionString",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "majorVersion",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "minorVersion",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "patchVersion",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "jsonApplication",
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "application",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "entities",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "references",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 10,
                            "isId": false,
                            "name": "referencedBy",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 10,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "applicationVersion"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "ownApplicationVersion"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 7,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "referencedApplicationVersion"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 10
                            },
                            "relationTableIndex": 7,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_VERSIONS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 10,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_VERSION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 9,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "ApplicationCurrentVersion",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "application",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "applicationVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 10,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_CURRENT_VERSIONS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SCOPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "FULL_APPLICATION_NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "STATUS",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SIGNATURE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 11,
                                    "oneRelationIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DOMAIN_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 10,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "Application",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "domain",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 2,
                            "isId": false,
                            "name": "scope",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 3,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 4,
                            "isId": false,
                            "name": "fullName",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 5,
                            "isId": false,
                            "name": "status",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 6,
                            "isId": false,
                            "name": "signature",
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "versions",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "currentVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 11,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "application"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "application"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATIONS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 11,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "Domain",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "applications",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "domain"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 10,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "DOMAINS",
                        "columnIndexes": []
                    },
                    "operations": {}
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION$1 = {
    "domain": "air",
    "index": null,
    "name": "@airport/travel-document-checkpoint",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {
                    "IUserApi": {
                        "operationMap": {
                            "addUser": {
                                "isAsync": true,
                                "parameters": []
                            },
                            "findUser": {
                                "isAsync": true,
                                "parameters": []
                            }
                        }
                    }
                }
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "Continent",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "countries",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "continent"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "CONTINENTS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 0,
                                    "oneRelationIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "CONTINENT_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "Country",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "continent",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "users",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "country"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "COUNTRIES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "USER_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TERMINAL_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "UserTerminal",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "user",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "terminal",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "USER_TERMINAL",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 7,
                                    "oneRelationIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                },
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 2,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "AGT_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PASSWORD",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "USER_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                },
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 1,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TERMINAL_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                },
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 3,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "UserTerminalAgt",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": true,
                            "name": "agtId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "password",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "user",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "terminal",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "agt",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "terminalAgt",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 7,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "USER_TERMINAL_AGT",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "EMAIL",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PASSWORD_HASH",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "USERNAME",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "UUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 4,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "User",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "email",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "passwordHash",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "username",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "uuId",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "UUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_LOCAL",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OWNER_USER_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 5,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "Terminal",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "uuId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "owner",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 3,
                            "isId": false,
                            "name": "isLocal",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TERMINAL",
                        "propertyIndexes": [
                            {
                                "propertyIndex": 1,
                                "unique": true
                            }
                        ]
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PASSWORD",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TERMINAL_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 7,
                                    "oneRelationIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "AGT_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 1
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 6,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "TerminalAgt",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "terminal",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "agt",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 2,
                            "isId": false,
                            "name": "password",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "userTerminalAgts",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 7,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "terminalAgt"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TERMINAL_AGTS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ADDRESS",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 7,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "Agt",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "address",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "terminalAgts",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "userTerminalAgts",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "agt"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "agt"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "columnIndexes": []
                    }
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION = {
    "domain": "air",
    "index": null,
    "name": "@airport/moving-walkway",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {}
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMNINDEX",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": null,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SYNCHRONIZATION_CONFLICT_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "SynchronizationConflictValues",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "synchronizationConflict",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 1,
                            "isId": true,
                            "name": "columnIndex",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "SYNCHRONIZATION_CONFLICT_VALUES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TYPE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ACKNOWLEDGED",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": 0,
                                    "oneTableIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": 0,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OVERWRITTEN_RECORD_HISTORY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": 0,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OVERWRITING_RECORD_HISTORY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "SynchronizationConflict",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "type",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "acknowledged",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "repository",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "overwrittenRecordHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "overwritingRecordHistory",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "values",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 2,
                            "relationTableApplicationIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 0,
                            "relationTableApplicationIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 0,
                            "relationTableApplicationIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "SYNCHRONIZATION_CONFLICT_ID"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "SYNCHRONIZATION_CONFLICT",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ACTOR_RECORD_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "UPDATED_VALUE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "ANY"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplicationIndex": 1,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_VERSION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplicationIndex": 1,
                                    "oneTableIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplicationIndex": 0,
                                    "oneTableIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplicationIndex": 0,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplicationIndex": 1,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_COLUMN_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isRepositoryEntity": false,
                    "name": "RecordUpdateStage",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "applicationVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "repository",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "actor",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 5,
                            "isId": false,
                            "name": "actorRecordId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "column",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 7,
                            "isId": false,
                            "name": "updatedValue",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "relationTableApplicationIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 6,
                            "relationTableApplicationIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 2,
                            "relationTableApplicationIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 1,
                            "relationTableApplicationIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 4,
                            "relationTableApplicationIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "RECORD_UPDATE_STAGE",
                        "columnIndexes": []
                    },
                    "operations": {}
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [
                {
                    "domain": "air",
                    "index": 0,
                    "name": "@airport/holding-pattern-runtime",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                },
                {
                    "domain": "air",
                    "index": 1,
                    "name": "@airport/airspace",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                }
            ],
            "versionString": "1.0.0"
        }
    ]
};

const BLUEPRINT = [
    APPLICATION$4,
    APPLICATION$1,
    APPLICATION$2,
    APPLICATION$3,
    APPLICATION
];

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BLUEPRINT: BLUEPRINT
});

var __decorate$1D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DatabaseManager = class DatabaseManager {
    constructor() {
        this.initialized = false;
    }
    async initNoDb(context, ...applications) {
        this.airportDatabase.load();
        this.transactionalServer.tempActor = new Actor();
        await this.installStarterApplication(true, false, context);
        await this.applicationInitializer.stage(applications, context);
        this.transactionalServer.tempActor = null;
        this.initialized = true;
    }
    async initWithDb(domainName, context) {
        this.airportDatabase.load();
        this.transactionalServer.tempActor = new Actor();
        await this.transactionManager.transactInternal(async (_transaction, context) => {
            const hydrate = await this.storeDriver.doesTableExist(this.dbApplicationUtils
                .getFullApplicationName(BLUEPRINT[0]), 'PACKAGES', context);
            await this.installStarterApplication(false, hydrate, context);
            if (!hydrate) {
                await this.internalRecordManager.initTerminal(domainName, context);
            }
            this.transactionalServer.tempActor = null;
            this.initialized = true;
        }, {
            doNotRecordHistory: true
        });
    }
    isInitialized() {
        return this.initialized;
    }
    async initFeatureApplications(context, jsonApplications) {
        const applications = await this.applicationDao.findAllWithJson();
        const existingApplicationMap = new Map();
        for (const application of applications) {
            existingApplicationMap.set(application.fullName, application);
        }
        const applicationsToCreate = [];
        for (const jsonApplication of jsonApplications) {
            const existingApplication = existingApplicationMap.get(this.dbApplicationUtils
                .getFullApplicationName(jsonApplication));
            if (existingApplication) {
                jsonApplication.lastIds = existingApplication.versions[0].jsonApplication.lastIds;
            }
            else {
                applicationsToCreate.push(jsonApplication);
            }
        }
        this.transactionalServer.tempActor = new Actor();
        await this.applicationInitializer.initialize(applicationsToCreate, context, true, true);
        this.transactionalServer.tempActor = null;
    }
    async installStarterApplication(stage, hydrate, context) {
        const blueprintFile = await Promise.resolve().then(function () { return index; });
        if (stage) {
            await this.applicationInitializer.stage(blueprintFile.BLUEPRINT, context);
        }
        else if (hydrate) {
            await this.applicationInitializer.hydrate(blueprintFile.BLUEPRINT, context);
        }
        else {
            await this.applicationInitializer.initialize(blueprintFile.BLUEPRINT, context, false, false);
        }
    }
};
__decorate$1D([
    Inject()
], DatabaseManager.prototype, "airportDatabase", void 0);
__decorate$1D([
    Inject()
], DatabaseManager.prototype, "applicationDao", void 0);
__decorate$1D([
    Inject()
], DatabaseManager.prototype, "applicationInitializer", void 0);
__decorate$1D([
    Inject()
], DatabaseManager.prototype, "dbApplicationUtils", void 0);
__decorate$1D([
    Inject()
], DatabaseManager.prototype, "internalRecordManager", void 0);
__decorate$1D([
    Inject()
], DatabaseManager.prototype, "storeDriver", void 0);
__decorate$1D([
    Inject()
], DatabaseManager.prototype, "transactionalServer", void 0);
__decorate$1D([
    Inject()
], DatabaseManager.prototype, "transactionManager", void 0);
DatabaseManager = __decorate$1D([
    Injected()
], DatabaseManager);

var __decorate$1C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DeleteManager = class DeleteManager {
    async deleteWhere(portableQuery, actor, transaction, rootTransaction, context) {
        const dbEntity = this.airportDatabase
            .applications[portableQuery.applicationIndex].currentVersion[0].applicationVersion
            .entities[portableQuery.tableIndex];
        const deleteCommand = transaction.deleteWhere(portableQuery, context);
        if (dbEntity.isLocal || transaction.isSync) {
            return await deleteCommand;
        }
        const selectCascadeTree = this.getCascadeSubTree(dbEntity);
        const jsonDelete = portableQuery.jsonQuery;
        const jsonSelect = {
            S: selectCascadeTree,
            F: [jsonDelete.DF],
            W: jsonDelete.W,
        };
        const portableSelect = {
            applicationIndex: portableQuery.applicationIndex,
            tableIndex: portableQuery.tableIndex,
            jsonQuery: jsonSelect,
            queryResultType: QueryResultType.ENTITY_TREE,
            parameterMap: portableQuery.parameterMap,
            // values: portableQuery.values,
        };
        const treesToDelete = await transaction
            .find(portableSelect, {}, context);
        const recordsToDelete = new Map();
        const repositoryIdSet = new Set();
        for (const treeToDelete of treesToDelete) {
            this.recordRepositoryIds(treeToDelete, dbEntity, recordsToDelete, repositoryIdSet, this.applicationUtils);
        }
        await this.recordTreeToDelete(recordsToDelete, actor, transaction, rootTransaction, context);
        return await deleteCommand;
    }
    recordRepositoryIds(treeToDelete, dbEntity, recordsToDelete, repositoryIdSet, applicationUtils) {
        const repositoryId = treeToDelete.repository.id;
        repositoryIdSet.add(repositoryId);
        const recordsToDeleteForApplication = ensureChildJsMap(recordsToDelete, dbEntity.applicationVersion.application.index);
        const recordsToDeleteForTable = ensureChildJsMap(recordsToDeleteForApplication, dbEntity.index);
        const recordsToDeleteForRepository = ensureChildArray(recordsToDeleteForTable, repositoryId);
        const recordToDelete = {};
        // FIXME: implement
        recordsToDeleteForRepository.push(recordToDelete);
        for (const dbProperty of dbEntity.properties) {
            if (dbProperty.relation && dbProperty.relation.length) {
                if (!treeToDelete[dbProperty.name]) {
                    continue;
                }
                const dbRelation = dbProperty.relation[0];
                switch (dbRelation.relationType) {
                    case EntityRelationType.MANY_TO_ONE:
                        applicationUtils.forEachColumnOfRelation(dbRelation, treeToDelete, (dbColumn, value, propertyNameChains) => {
                            this.columnProcessed(dbProperty, recordToDelete, dbColumn, value);
                        }, false);
                        break;
                    case EntityRelationType.ONE_TO_MANY:
                        if (!dbRelation.oneToManyElems) {
                            continue;
                        }
                        let childTrees = treeToDelete[dbRelation.property.name];
                        if (childTrees && childTrees.length) {
                            const childDbEntity = dbRelation.relationEntity;
                            childTrees.forEach(childTree => {
                                this.recordRepositoryIds(childTree, childDbEntity, recordsToDelete, repositoryIdSet, applicationUtils);
                            });
                        }
                        break;
                    default:
                        throw new Error(`Unknown relation type: '${dbRelation.relationType}' 
							on '${dbEntity.name}.${dbRelation.property.name}'.`);
                }
            }
            else {
                const value = treeToDelete[dbProperty.name];
                if (value === null || value === undefined) {
                    continue;
                }
                this.columnProcessed(dbProperty, recordToDelete, dbProperty.propertyColumns[0].column, value);
            }
        }
    }
    /*
     Values for the same column could be repeated in different places in the object graph.
     For example, if the same column is mapped to two different @ManyToOne relations.
     In this case, when persisting an entity we need to make sure that all values for the
     entity in question are being persisted.
     */
    columnProcessed(dbProperty, foundValues, dbColumn, value) {
        // if (value === undefined) {
        // 	throw new Error(`Values cannot be undefined, please use null.`_;
        // }
        if (foundValues[dbColumn.name] === undefined) {
            foundValues[dbColumn.name] = value;
            return false;
        }
        if (!this.utils.valuesEqual(foundValues[dbColumn.name], value)) {
            throw new Error(`Found value mismatch in '${dbProperty.entity.name}.${dbProperty.name}'
			(column: '${dbColumn.name}'): ${foundValues[dbColumn.name]} !== ${value}`);
        }
        return true;
    }
    async recordTreeToDelete(recordsToDelete, actor, transaction, rootTransaction, context) {
        let systemWideOperationId;
        for (const [applicationIndex, applicationRecordsToDelete] of recordsToDelete) {
            for (const [entityIndex, entityRecordsToDelete] of applicationRecordsToDelete) {
                const dbEntity = this.airportDatabase.applications[applicationIndex].currentVersion[0]
                    .applicationVersion.entities[entityIndex];
                if (!systemWideOperationId) {
                    systemWideOperationId = await getSysWideOpId(this.airportDatabase, this.sequenceGenerator);
                }
                for (const [repositoryId, entityRecordsToDeleteForRepo] of entityRecordsToDelete) {
                    const repositoryTransactionHistory = await this.historyManager.getNewRepositoryTransactionHistory(transaction.transactionHistory, repositoryId, context);
                    const operationHistory = this.repositoryTransactionHistoryDuo.startOperation(repositoryTransactionHistory, systemWideOperationId, ChangeType.DELETE_ROWS, dbEntity, actor, rootTransaction);
                    for (const recordToDelete of entityRecordsToDeleteForRepo) {
                        const recordHistory = this.operationHistoryDuo.startRecordHistory(operationHistory, recordToDelete.actor.id, recordToDelete.actorRecordId);
                        for (const dbProperty of dbEntity.properties) {
                            if (dbProperty.relation && dbProperty.relation.length) {
                                const dbRelation = dbProperty.relation[0];
                                switch (dbRelation.relationType) {
                                    case EntityRelationType.MANY_TO_ONE:
                                        this.applicationUtils.forEachColumnOfRelation(dbRelation, recordToDelete, (dbColumn, value, propertyNameChains) => {
                                            switch (dbColumn.name) {
                                                // Do not add Actor or Repository the are recorded
                                                // at record history level
                                                case repositoryEntity.ACTOR_ID:
                                                case repositoryEntity.REPOSITORY_ID:
                                                    break;
                                                default:
                                                    this.recordHistoryDuo.addOldValue(recordHistory, dbColumn, value);
                                            }
                                        });
                                        break;
                                    case EntityRelationType.ONE_TO_MANY:
                                        // One-To-Many do not contain any columns in source entity
                                        break;
                                    default:
                                        throw new Error(`Unknown relation type: '${dbRelation.relationType}'
										on '${dbEntity.name}.${dbProperty.name}'.`);
                                }
                            }
                            else {
                                const dbColumn = dbProperty.propertyColumns[0].column;
                                this.recordHistoryDuo
                                    .addOldValue(recordHistory, dbColumn, recordToDelete[dbProperty.name]);
                            }
                        }
                    }
                }
            }
        }
    }
    getCascadeSubTree(dbEntity, selectClause = {}) {
        for (const dbProperty of dbEntity.properties) {
            let dbRelation;
            if (dbProperty.relation && dbProperty.relation.length) {
                dbRelation = dbProperty.relation[0];
            }
            if (dbRelation) {
                switch (dbRelation.relationType) {
                    case EntityRelationType.ONE_TO_MANY:
                        if (!dbRelation.oneToManyElems) {
                            continue;
                        }
                        const subTree = {};
                        selectClause[dbProperty.name] = subTree;
                        this.getCascadeSubTree(dbRelation.relationEntity, subTree);
                        break;
                    case EntityRelationType.MANY_TO_ONE:
                        this.applicationUtils.addRelationToEntitySelectClause(dbRelation, selectClause);
                        break;
                    default:
                        throw new Error(`Unknown relation type: '${dbRelation.relationType}' 
							on '${dbEntity.name}.${dbProperty.name}'.`);
                }
            }
            else {
                selectClause[dbProperty.name] = Y;
            }
        }
        return selectClause;
    }
};
__decorate$1C([
    Inject()
], DeleteManager.prototype, "airportDatabase", void 0);
__decorate$1C([
    Inject()
], DeleteManager.prototype, "applicationUtils", void 0);
__decorate$1C([
    Inject()
], DeleteManager.prototype, "historyManager", void 0);
__decorate$1C([
    Inject()
], DeleteManager.prototype, "operationHistoryDuo", void 0);
__decorate$1C([
    Inject()
], DeleteManager.prototype, "recordHistoryDuo", void 0);
__decorate$1C([
    Inject()
], DeleteManager.prototype, "repositoryTransactionHistoryDuo", void 0);
__decorate$1C([
    Inject()
], DeleteManager.prototype, "sequenceGenerator", void 0);
__decorate$1C([
    Inject()
], DeleteManager.prototype, "utils", void 0);
DeleteManager = __decorate$1C([
    Injected()
], DeleteManager);

var __decorate$1B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let HistoryManager = class HistoryManager {
    async getNewTransactionHistory(transactionType = TransactionType.LOCAL) {
        return await this.transactionHistoryDuo.getNewRecord(transactionType);
    }
    async getNewRepositoryTransactionHistory(transactionHistory, repositoryId, context) {
        return await this.transactionHistoryDuo.getRepositoryTransaction(transactionHistory, repositoryId, !!context.newRepository);
    }
};
__decorate$1B([
    Inject()
], HistoryManager.prototype, "transactionHistoryDuo", void 0);
HistoryManager = __decorate$1B([
    Injected()
], HistoryManager);

var __decorate$1A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let InsertManager = class InsertManager {
    async insertValues(portableQuery, actor, transaction, rootTransaction, context, ensureGeneratedValues) {
        return await this.internalInsertValues(portableQuery, actor, transaction, rootTransaction, context, false, ensureGeneratedValues);
    }
    async insertValuesGetIds(portableQuery, actor, transaction, rootTransaction, context) {
        return await this.internalInsertValues(portableQuery, actor, transaction, rootTransaction, context, true);
    }
    verifyNoGeneratedColumns(dbEntity, jsonInsertValues, errorPrefix) {
        for (let i = 0; i < jsonInsertValues.C.length; i++) {
            const columnIndex = jsonInsertValues.C[i];
            const dbColumn = dbEntity.columns[columnIndex];
            if (dbColumn.isGenerated) {
                throw new Error(errorPrefix +
                    `You cannot explicitly insert into a @GeneratedValue column '${dbColumn.name}'`);
            }
        }
        return dbEntity.columns.filter(dbColumn => dbColumn.isGenerated);
    }
    async internalInsertValues(portableQuery, actor, transaction, rootTransaction, context, getIds = false, ensureGeneratedValues = true) {
        const dbEntity = this.airportDatabase.applications[portableQuery.applicationIndex]
            .currentVersion[0].applicationVersion.entities[portableQuery.tableIndex];
        const errorPrefix = `Error inserting into '${dbEntity.name}'.'
`;
        this.validateValueRowLength(portableQuery, errorPrefix);
        const jsonInsertValues = portableQuery.jsonQuery;
        const columnIndexSet = {};
        let inStatementIndex = 0;
        for (const columnIndex of jsonInsertValues.C) {
            if (columnIndex < 0 || columnIndex >= dbEntity.columns.length) {
                throw new Error(errorPrefix +
                    `Invalid column index: ${columnIndex}`);
            }
            if (columnIndexSet[columnIndex]) {
                throw new Error(errorPrefix +
                    `Column ${dbEntity.name}.${dbEntity.columns[columnIndex].name} 
appears more than once in the Columns clause`);
            }
            let rowNumber = 1;
            for (let row of jsonInsertValues.V) {
                if (row[inStatementIndex] === undefined) {
                    throw new Error(errorPrefix +
                        `
	'undefined' value in column ${dbEntity.name}.${dbEntity.columns[columnIndex].name} of row ${rowNumber}.
	All values in an insert statment must either be null or have a non-null value.`);
                }
                rowNumber++;
            }
            inStatementIndex++;
            columnIndexSet[columnIndex] = true;
        }
        let columnsToPopulate;
        const insertValues = portableQuery.jsonQuery;
        if (dbEntity.isRepositoryEntity) {
            columnsToPopulate = this.ensureRepositoryEntityIdValues(actor, dbEntity, insertValues, errorPrefix, transaction, context);
        }
        let generatedColumns;
        if (!transaction.isSync || context.generateOnSync) {
            generatedColumns = this.verifyNoGeneratedColumns(dbEntity, portableQuery.jsonQuery, errorPrefix);
        }
        let ids;
        let systemWideOperationId;
        if (!dbEntity.isLocal) {
            systemWideOperationId = await getSysWideOpId(this.airportDatabase, this.sequenceGenerator);
        }
        if ((!transaction.isSync || context.generateOnSync) && ensureGeneratedValues) {
            ids = await this.ensureGeneratedValues(dbEntity, insertValues, actor, columnsToPopulate, generatedColumns, systemWideOperationId, errorPrefix, this.sequenceGenerator);
        }
        if (!dbEntity.isLocal && !transaction.isSync) {
            await this.addInsertHistory(dbEntity, portableQuery, actor, systemWideOperationId, transaction, rootTransaction, context);
        }
        const numberOfInsertedRecords = await transaction.insertValues(portableQuery, context);
        return getIds ? ids : numberOfInsertedRecords;
    }
    async validateValueRowLength(portableQuery, errorPrefix) {
        const values = portableQuery.jsonQuery.V;
        if (!values.length) {
            throw new Error(errorPrefix + `no colum values provided`);
        }
        const firstValuesRow = values[0];
        if (!firstValuesRow || !firstValuesRow.length) {
            throw new Error(errorPrefix + `First row has no values`);
        }
        const numValuesInRow = firstValuesRow.length;
        for (let i = 0; i < values.length; i++) {
            const valuesRow = values[i];
            if (valuesRow.length !== numValuesInRow) {
                throw new Error(errorPrefix + `First row has ${numValuesInRow} values,
	while row ${i + 1} has ${valuesRow.length} values`);
            }
        }
    }
    async ensureGeneratedValues(dbEntity, jsonInsertValues, actor, columnsToPopulate, generatedColumns, systemWideOperationId, errorPrefix, sequenceGenerator) {
        const values = jsonInsertValues.V;
        const idColumns = dbEntity.idColumns;
        const allIds = [];
        for (const _entityValues of values) {
            allIds.push([]);
        }
        let actorIdColumn;
        let sysWideOperationIdColumn;
        if (!dbEntity.isLocal) {
            actorIdColumn = columnsToPopulate.actorIdColumn;
            sysWideOperationIdColumn = columnsToPopulate.sysWideOperationIdColumn;
        }
        for (const idColumn of idColumns) {
            if (idColumn.isGenerated) {
                continue;
            }
            let isActorIdColumn = false;
            let inStatementColumnIndex;
            const matchingColumns = jsonInsertValues.C.filter((columnIndex, index) => {
                if (columnIndex === idColumn.index) {
                    inStatementColumnIndex = index;
                    return true;
                }
            });
            if (matchingColumns.length < 1) {
                // Actor Id cannot be in the insert statement
                if (idColumn.id === actorIdColumn.id) {
                    isActorIdColumn = true;
                    inStatementColumnIndex = jsonInsertValues.C.length;
                    jsonInsertValues.C.push(actorIdColumn.index);
                }
                else {
                    throw new Error(errorPrefix +
                        `Could not find @Id column ${dbEntity.name}.${idColumn.name} in
					the insert statement.  Non-generated @Id columns must be present in the Insert
					statement (with exception of Actor ID).`);
                }
            }
            for (let i = 0; i < values.length; i++) {
                const entityValues = values[i];
                const idValues = allIds[i];
                let idValue;
                if (isActorIdColumn) {
                    idValue = actor.id;
                }
                else {
                    idValue = entityValues[inStatementColumnIndex];
                    if (!idValue && idValue !== 0) {
                        throw new Error(errorPrefix +
                            `No value provided on insert for @Id '${dbEntity.name}.${idColumn.name}'.`);
                    }
                }
                idValues[idColumn.index] = idValue;
            }
        }
        // if (dbEntity.isRepositoryEntity) {
        // 	const repositoryColumn  = dbEntity.columnMap[repositoryEntity.FOREIGN_KEY]
        // 	const repositoryIdIndex = repositoryColumn.index
        // 	for (const entityValues of values) {
        // 		const repositoryId = entityValues[repositoryIdIndex]
        // 		if (!repositoryId && repositoryId !== 0) {
        // 			throw new Error(`@Column({ name: 'REPOSITORY_ID'}) value is not specified on
        // insert for '${dbEntity0.name}.${repositoryColumn.name}'.`) } } }
        const generatedColumnIndexes = [];
        // let numAddedColumns                    = 0
        for (const generatedColumn of generatedColumns) {
            // const matchingColumns = jsonInsertValues.C.filter(
            // 	columnIndex => columnIndex === generatedColumn.index)
            // if (!matchingColumns.length) {
            // TODO: verify that it is OK to mutate the JsonInsertValues query
            jsonInsertValues.C.length;
            generatedColumnIndexes.push(jsonInsertValues.C.length);
            jsonInsertValues.C.push(generatedColumn.index);
            // numAddedColumns++
            continue;
        }
        // Populating generated values AFTER the checks
        // to not waste sequence numbers on invalid input
        // (thus reducing storage requirements in SqLite)
        const numSequencesNeeded = generatedColumns.map(_ => values.length);
        const generatedSequenceValues = await sequenceGenerator.generateSequenceNumbers(generatedColumns, numSequencesNeeded);
        generatedColumns.forEach((dbColumn, generatedColumnIndex) => {
            const generatedColumnSequenceValues = generatedSequenceValues[generatedColumnIndex];
            const insertColumnIndex = generatedColumnIndexes[generatedColumnIndex];
            // const columnIndex                   = dbColumn.index
            values.forEach((entityValues, index) => {
                const generatedValue = generatedColumnSequenceValues[index];
                entityValues[insertColumnIndex] = generatedValue;
                allIds[index][dbColumn.index] = generatedValue;
            });
        });
        if (!dbEntity.isLocal) {
            jsonInsertValues.C.push(sysWideOperationIdColumn.index);
            values.forEach(entityValues => {
                entityValues.push(systemWideOperationId);
            });
        }
        if (!idColumns.length && !generatedColumns.length) {
            return values.length;
        }
        // switch (idColumns.length) {
        // 	case 0: {
        // 		// If there is just one @Generated column and no @Id columns
        // 		if (generatedColumns.length == 1) {
        // 			const columnIndex = generatedColumns[0].index
        // 			return allIds.map(
        // 				rowIds => rowIds[columnIndex])
        // 		}
        // 		break
        // 	}
        // 	case 1: {
        // 		// If there is exactly 1 @Id column and no @Generated columns
        // 		// or it is the @Generated column
        // 		if (!generatedColumns.length
        // 			|| (generatedColumns.length === 1
        // 				&& idColumns[0].index === generatedColumns[0].index)) {
        // 			const columnIndex = idColumns[0].index
        // 			return allIds.map(
        // 				rowIds => rowIds[columnIndex])
        // 		}
        // 		break
        // 	}
        // }
        return allIds;
    }
    ensureRepositoryEntityIdValues(actor, dbEntity, jsonInsertValues, errorPrefix, transaction, context) {
        const actorIdColumn = dbEntity.idColumnMap[repositoryEntity.ACTOR_ID];
        const actorRecordIdColumn = dbEntity.idColumnMap[repositoryEntity.ACTOR_RECORD_ID];
        const repositoryIdColumn = dbEntity.idColumnMap[repositoryEntity.REPOSITORY_ID];
        const sysWideOperationIdColumn = dbEntity.columnMap[repositoryEntity.SYSTEM_WIDE_OPERATION_ID];
        let repositoryIdColumnQueryIndex;
        let foundActorIdColumn = false;
        let foundActorRecordIdColumn = false;
        let foundSystemWideOperationIdColumn = false;
        for (let i = 0; i < jsonInsertValues.C.length; i++) {
            const columnIndex = jsonInsertValues.C[i];
            switch (columnIndex) {
                case actorIdColumn.index:
                    foundActorIdColumn = true;
                    if (context.isSaveOperation) {
                        // Save operations validate Actor ealier and set it on the entity objects
                        break;
                    }
                    if (!transaction.isSync) {
                        throw new Error(errorPrefix +
                            `You cannot explicitly provide an ACTOR_ID value for Repository entities.`);
                    }
                    break;
                case actorRecordIdColumn.index:
                    foundActorRecordIdColumn = true;
                    if (!transaction.isSync) {
                        throw new Error(errorPrefix +
                            `You cannot explicitly provide an ACTOR_RECORD_ID value for Repository entities.`);
                    }
                    break;
                case sysWideOperationIdColumn.index:
                    foundSystemWideOperationIdColumn = true;
                    if (!transaction.isSync) {
                        throw new Error(`Error inserting into '${dbEntity.name}'.
You cannot explicitly provide a SYSTEM_WIDE_OPERATION_ID value for Repository entities.`);
                    }
                    break;
                case repositoryIdColumn.index:
                    repositoryIdColumnQueryIndex = i;
                    break;
            }
        }
        const missingRepositoryIdErrorMsg = errorPrefix +
            `Error inserting into '${dbEntity.name}'.
You must provide a valid REPOSITORY_ID value for Repository entities.`;
        if (repositoryIdColumnQueryIndex === undefined) {
            throw new Error(missingRepositoryIdErrorMsg);
        }
        if (transaction.isSync) {
            if (!foundActorIdColumn) {
                throw new Error(errorPrefix +
                    `ACTOR_ID must be provided for sync operations.`);
            }
            if (!foundActorRecordIdColumn) {
                throw new Error(errorPrefix +
                    `ACTOR_RECORD_ID must be provided for sync operations.`);
            }
            if (!foundSystemWideOperationIdColumn) {
                throw new Error(errorPrefix +
                    `SYSTEM_WIDE_OPERATION_ID must be provided for sync operations.`);
            }
        }
        for (const entityValues of jsonInsertValues.V) {
            if (entityValues.length !== jsonInsertValues.C.length) {
                throw new Error(errorPrefix +
                    `Number of columns (${jsonInsertValues.C.length}) does not match number of values (${entityValues.length}).
				`);
            }
            let repositoryId = entityValues[repositoryIdColumnQueryIndex];
            if (typeof repositoryId !== 'number'
                || !Number.isInteger(repositoryId)
                || repositoryId < 1) {
                throw new Error(missingRepositoryIdErrorMsg);
            }
            for (let i = 0; i < entityValues.length; i++) {
                switch (i) {
                    case repositoryIdColumnQueryIndex:
                        continue;
                }
                const value = entityValues[i];
                const columnIndex = jsonInsertValues.C[i];
                const dbColumn = dbEntity.columns[columnIndex];
                if (dbColumn.notNull && value === null) {
                    throw new Error(errorPrefix +
                        `Column '${dbColumn.name}' is NOT NULL
and cannot have NULL values.`);
                }
            }
            if (!context.isSaveOperation && !transaction.isSync) {
                // Save operation set Actor ealier (at the entity level, to be returned back to client)
                entityValues[actorIdColumn.index] = actor.id;
            }
        }
        return {
            actorIdColumn,
            sysWideOperationIdColumn
        };
    }
    /**
     *
     * All repository records must have ids when inserted.  Currently AP doesn't support
     * inserting from select and in the values provided id's must either be explicitly
     * specified or already provided. For all repository entities all ids must be
     * auto-generated.
     *
     * @param {DbEntity} dbEntity
     * @param {PortableQuery} portableQuery
     * @returns {Promise<void>}
     */
    async addInsertHistory(dbEntity, portableQuery, actor, systemWideOperationId, transaction, rootTransaction, context) {
        const jsonInsertValues = portableQuery.jsonQuery;
        let operationsByRepo = [];
        let repoTransHistories = [];
        const repositoryIdIndex = dbEntity.columnMap[repositoryEntity.REPOSITORY_ID].index;
        const actorIdIndex = dbEntity.columnMap[repositoryEntity.ACTOR_ID].index;
        const actorRecordIdIndex = dbEntity.columnMap[repositoryEntity.ACTOR_RECORD_ID].index;
        let repositoryIdColumnNumber;
        let actorIdColumnNumber;
        let actorRecordIdColumnNumber;
        for (const columnNumber in jsonInsertValues.C) {
            const columnIndex = jsonInsertValues.C[columnNumber];
            switch (columnIndex) {
                case repositoryIdIndex:
                    repositoryIdColumnNumber = columnNumber;
                    break;
                case actorIdIndex:
                    actorIdColumnNumber = columnNumber;
                    break;
                case actorRecordIdIndex:
                    actorRecordIdColumnNumber = columnNumber;
                    break;
            }
        }
        // Rows may belong to different repositories
        for (const row of jsonInsertValues.V) {
            const repositoryId = row[repositoryIdColumnNumber];
            // const repo           = await repoManager.getRepository(repositoryId)
            let repositoryTransactionHistory = repoTransHistories[repositoryId];
            if (!repositoryTransactionHistory) {
                repositoryTransactionHistory = await this.historyManager
                    .getNewRepositoryTransactionHistory(transaction.transactionHistory, repositoryId, context);
            }
            let operationHistory = operationsByRepo[repositoryId];
            if (!operationHistory) {
                operationHistory = this.repositoryTransactionHistoryDuo.startOperation(repositoryTransactionHistory, systemWideOperationId, ChangeType.INSERT_VALUES, dbEntity, actor, rootTransaction);
                operationsByRepo[repositoryId] = operationHistory;
            }
            const actorRecordId = row[actorRecordIdColumnNumber];
            const actorId = row[actorIdColumnNumber];
            const recordHistory = this.operationHistoryDuo.startRecordHistory(operationHistory, actorId, actorRecordId);
            for (const columnNumber in jsonInsertValues.C) {
                if (columnNumber === repositoryIdColumnNumber
                    || columnNumber === actorIdColumnNumber
                    || columnNumber === actorRecordIdColumnNumber) {
                    continue;
                }
                const columnIndex = jsonInsertValues.C[columnNumber];
                const dbColumn = dbEntity.columns[columnIndex];
                const newValue = row[columnNumber];
                this.recordHistoryDuo.addNewValue(recordHistory, dbColumn, newValue);
            }
        }
        // for (const repositoryId in operationsByRepo) {
        // 	const repoTransHistory = await
        // 		this.currentTransHistory.getRepositoryTransaction(
        // 			repositoryId, null, null, null, repoTransHistoryDuo);
        // 	repoTransHistory.endGroupMutation(operationsByRepo[repositoryId]);
        // }
    }
};
__decorate$1A([
    Inject()
], InsertManager.prototype, "airportDatabase", void 0);
__decorate$1A([
    Inject()
], InsertManager.prototype, "historyManager", void 0);
__decorate$1A([
    Inject()
], InsertManager.prototype, "operationHistoryDuo", void 0);
__decorate$1A([
    Inject()
], InsertManager.prototype, "recordHistoryDuo", void 0);
__decorate$1A([
    Inject()
], InsertManager.prototype, "repositoryTransactionHistoryDuo", void 0);
__decorate$1A([
    Inject()
], InsertManager.prototype, "sequenceGenerator", void 0);
InsertManager = __decorate$1A([
    Injected()
], InsertManager);

var __decorate$1z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let QueryManager = class QueryManager {
    async find(portableQuery, context, cachedSqlQueryId) {
        await this.ensureRepositoryPresenceAndCurrentState(context);
        return await this.storeDriver.find(portableQuery, {}, context, cachedSqlQueryId);
    }
    async findOne(portableQuery, context, cachedSqlQueryId) {
        await this.ensureRepositoryPresenceAndCurrentState(context);
        return await this.storeDriver.findOne(portableQuery, {}, context, cachedSqlQueryId);
    }
    search(portableQuery, context, cachedSqlQueryId) {
        // TODO: checking for presence of a repository in in an observable
        // await this.ensureRepositoryPresenceAndCurrentState(context)
        return this.storeDriver.search(portableQuery, {}, context, cachedSqlQueryId);
    }
    searchOne(portableQuery, context, cachedSqlQueryId) {
        // TODO: checking for presence of a repository in in an observable
        // await this.ensureRepositoryPresenceAndCurrentState(context)
        return this.storeDriver.searchOne(portableQuery, {}, context, cachedSqlQueryId);
    }
    async ensureRepositoryPresenceAndCurrentState(context) {
        if (context.repository && context.repository.source && context.repository.uuId) {
            await this.repositoryLoader.loadRepository(context.repository.source, context.repository.uuId, context);
        }
    }
};
__decorate$1z([
    Inject()
], QueryManager.prototype, "repositoryLoader", void 0);
__decorate$1z([
    Inject()
], QueryManager.prototype, "storeDriver", void 0);
QueryManager = __decorate$1z([
    Injected()
], QueryManager);

var __decorate$1y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TransactionManager = class TransactionManager extends AbstractMutationManager {
    /**
     * Initializes the EntityManager at server load time.
     * @returns {Promise<void>}
     */
    async initialize(dbName, context) {
        return await this.storeDriver.initialize(dbName, context);
        // await this.dataStore.initialize(dbName)
        // await this.repositoryManager.initialize();
    }
    getInProgressTransactionById(transactionId) {
        return this.terminalStore.getTransactionManager()
            .transactionInProgressMap.get(transactionId);
    }
    isServer(context) {
        return this.storeDriver.isServer(context);
    }
    async transactInternal(transactionalCallback, context) {
        await this.transact({
            application: INTERNAL_APP,
            domain: INTERNAL_DOMAIN,
            methodName: null,
            objectName: null
        }, transactionalCallback, context);
    }
    async transact(credentials, transactionalCallback, context) {
        if (context.transaction) {
            // Nested transact() calls in internal operations
            // do not create nested transactions 
            if (!context.nestedTransactionDepth) {
                context.nestedTransactionDepth = 1;
            }
            else {
                context.nestedTransactionDepth++;
            }
            await transactionalCallback(context.transaction, context);
            return;
        }
        const transaction = await this.startTransaction(credentials, context);
        try {
            await transactionalCallback(transaction, context);
            await this.commit(credentials, context);
        }
        catch (e) {
            console.error(e);
            await this.rollback(credentials, context);
            throw e;
        }
    }
    async startTransaction(credentials, context) {
        const transactionManagerStore = this.terminalStore.getTransactionManager();
        let parentTransaction;
        if (credentials.transactionId) {
            parentTransaction = transactionManagerStore
                .transactionInProgressMap.get(credentials.transactionId);
            if (!parentTransaction) {
                throw new Error(`
Recieved a startTransaction call (@Api call) with parent transaction id:
	${credentials.transactionId}
But, there is no such transaction in progress.`);
            }
            if (parentTransaction.id !==
                credentials.transactionId) {
                throw new Error(`
In-progress transaction id does not match the passed in transaction id:
${credentials.transactionId}`);
            }
            this.checkForCircularDependencies(parentTransaction, credentials);
        }
        else {
            /*
             * NOTE: Current policy is to NOT limit the number of transactions
             * a domain can initiate.  In the future, specifically for the
             * client-side Turbase, it may make sence to limit the number
             * of transactions to 1 per tab.  This can be accomplished by
             * generating a unique id on the nested client iframe of an
             * application.
             */
            /*
throw new Error(`
    Domain:
        ${credentials.domain}
    Application:
        ${credentials.application}
initialized multiple transactions at the same time.
Only one concurrent transaction is allowed per application.`)
            */
            if (!this.isServer(context)
                && transactionManagerStore.transactionInProgressMap.size > 0) {
                // Delay the start of the transaction
                return new Promise((resolve, reject) => {
                    // Add the transaction to the queue of pending transactions
                    transactionManagerStore.pendingTransactionQueue.unshift({
                        credentials,
                        reject,
                        resolve
                    });
                });
            }
        }
        const transaction = await this.internalStartTransaction(credentials, parentTransaction, context);
        if (!parentTransaction) {
            transaction.numberOfOperations = 0;
        }
        return transaction;
    }
    async internalStartTransaction(credentials, parentTransaction, context) {
        const transactionManagerStore = this.terminalStore.getTransactionManager();
        const transaction = await this.storeDriver
            .setupTransaction(context, parentTransaction);
        await this.storeDriver.startTransaction(transaction, context);
        transaction.credentials = credentials;
        await this.setupTransaction(credentials, transaction, parentTransaction, transactionManagerStore, context);
        return transaction;
    }
    async rollback(credentials, context) {
        const transaction = await this.getTransactionFromContextOrCredentials(credentials, context);
        let parentTransaction = transaction.parentTransaction;
        await transaction.rollback(null, context);
        if (await this.clearTransaction(transaction, parentTransaction, credentials, context)) {
            await this.resumeParentOrPendingTransaction(parentTransaction, context);
        }
    }
    async getTransactionFromContextOrCredentials(credentials, context) {
        let transaction = context.transaction;
        if (!transaction) {
            if (!credentials.transactionId) {
                throw new Error(`
No Transaction Id is passed in Credentials for a transactional operation.
				`);
            }
            const transactionManagerStore = this.terminalStore
                .getTransactionManager();
            transaction = transactionManagerStore.transactionInProgressMap.get(credentials.transactionId);
            if (!transaction) {
                throw new Error(`
Could not find Transaction: ${credentials.transactionId} in Transactons in-progress.
NOTE: nested/child transactions must be commited or rolled back before their
parent transactions.
				`);
            }
            context.transaction = transaction;
        }
        let ancestorTransaction = transaction;
        while (ancestorTransaction = ancestorTransaction.parentTransaction)
            ;
        context.rootTransaction = ancestorTransaction;
        return transaction;
    }
    async resumeParentOrPendingTransaction(parentTransaction, context) {
        const transactionManagerStore = this.terminalStore
            .getTransactionManager();
        if (parentTransaction) {
            await this.setupTransaction(parentTransaction.credentials, parentTransaction, parentTransaction.parentTransaction, transactionManagerStore, context);
        }
        else if (transactionManagerStore.pendingTransactionQueue.length) {
            const pendingTransaction = transactionManagerStore.pendingTransactionQueue.pop();
            const transaction = await this.internalStartTransaction(pendingTransaction.credentials, null, context);
            pendingTransaction.resolve(transaction);
        }
    }
    async commit(credentials, context) {
        const transaction = await this.getTransactionFromContextOrCredentials(credentials, context);
        let parentTransaction = transaction.parentTransaction;
        try {
            if (parentTransaction) {
                if (!context.doNotRecordHistory) {
                    this.copyTransactionHistoryToParentTransaction(transaction, parentTransaction);
                }
            }
            else {
                // This is the root transaction, save it's history, along with any nested transactions
                if (!context.doNotRecordHistory) {
                    await this.saveRepositoryHistory(transaction, context);
                }
            }
            this.activeQueries.rerunQueries();
            await transaction.commit(null, context);
            let transactionHistory = transaction.transactionHistory;
            if (!context.doNotRecordHistory) {
                if (!parentTransaction && transactionHistory.allRecordHistory.length) {
                    await this.synchronizationOutManager.synchronizeOut(transactionHistory.repositoryTransactionHistories);
                }
            }
        }
        finally {
            if (await this.clearTransaction(transaction, parentTransaction, credentials, context)) {
                // Right now transactions are tied to @Api() calls,
                // If an @Api() fails to commit the parent @Api() call should resume
                // it's transaction or the next 
                await this.resumeParentOrPendingTransaction(parentTransaction, context);
            }
        }
    }
    copyTransactionHistoryToParentTransaction(transaction, parentTransaction) {
        let childTransactionHistory = transaction.transactionHistory;
        let parentTransactionHistory = parentTransaction.transactionHistory;
        for (const operationHistory of childTransactionHistory.allOperationHistory) {
            const repositoryId = operationHistory.repositoryTransactionHistory.repository.id;
            const parentRepositoryTransactionRecord = parentTransactionHistory
                .repositoryTransactionHistoryMap[repositoryId];
            if (parentRepositoryTransactionRecord) {
                operationHistory.repositoryTransactionHistory = parentRepositoryTransactionRecord;
            }
            else {
                parentTransactionHistory.repositoryTransactionHistoryMap[repositoryId]
                    = operationHistory.repositoryTransactionHistory;
                parentTransactionHistory.repositoryTransactionHistories
                    .push(operationHistory.repositoryTransactionHistory);
            }
        }
        parentTransactionHistory.allOperationHistory = parentTransactionHistory
            .allOperationHistory.concat(childTransactionHistory.allOperationHistory);
        parentTransactionHistory.allRecordHistory = parentTransactionHistory
            .allRecordHistory.concat(childTransactionHistory.allRecordHistory);
        parentTransactionHistory.allRecordHistoryNewValues = parentTransactionHistory
            .allRecordHistoryNewValues.concat(childTransactionHistory.allRecordHistoryNewValues);
        parentTransactionHistory.allRecordHistoryOldValues = parentTransactionHistory
            .allRecordHistoryOldValues.concat(childTransactionHistory.allRecordHistoryOldValues);
    }
    checkForCircularDependencies(transaction, credentials) {
        if (credentials.domain === INTERNAL_DOMAIN) {
            return;
        }
        do {
            if (this.isSameSource(transaction, credentials)) {
                let callHerarchy = this.getApiName(credentials);
                let hierarchyTransaction = transaction;
                do {
                    callHerarchy = `${this.getApiName(hierarchyTransaction.initiator)} ->
${callHerarchy}`;
                } while (hierarchyTransaction = hierarchyTransaction.parentTransaction);
                throw new Error(`Circular API call detected:
				
${callHerarchy}

				`);
            }
        } while (transaction = transaction.parentTransaction);
    }
    async setupTransaction(credentials, transaction, parentTransaction, transactionManagerStore, context) {
        context.transaction = transaction;
        credentials.transactionId = transaction.id;
        if (!context.doNotRecordHistory) {
            transaction.transactionHistory = this.transactionHistoryDuo.getNewRecord();
        }
        transactionManagerStore.transactionInProgressMap.set(transaction.id, transaction);
        if (parentTransaction) {
            transactionManagerStore.transactionInProgressMap.delete(parentTransaction.id);
        }
        else {
            transactionManagerStore.rootTransactionInProgressMap.set(transaction.id, transaction);
        }
    }
    isSameSource(transaction, credentials) {
        const initiator = transaction.initiator;
        return initiator.domain === credentials.domain
            && initiator.application === credentials.application
            && initiator.objectName === credentials.objectName
            && initiator.methodName === credentials.methodName;
    }
    getApiName(nameContainer) {
        return `${nameContainer.domain}.${nameContainer.application}.${nameContainer.objectName}.${nameContainer.methodName}`;
    }
    async clearTransaction(transaction, parentTransaction, credentials, context) {
        if (context.nestedTransactionDepth) {
            context.nestedTransactionDepth--;
            return false;
        }
        const transactionManagerStore = this.terminalStore
            .getTransactionManager();
        transactionManagerStore.transactionInProgressMap.delete(transaction.id);
        if (!parentTransaction) {
            transactionManagerStore.rootTransactionInProgressMap.delete(transaction.id);
        }
        context.transaction = null;
        credentials.transactionId = null;
        return true;
    }
    async saveRepositoryHistory(transaction, context) {
        let transactionHistory = transaction.transactionHistory;
        if (!transactionHistory.allRecordHistory.length) {
            return false;
        }
        let applicationMap = transactionHistory.applicationMap;
        const transactionHistoryIds = await this.idGenerator.generateTransactionHistoryIds(transactionHistory.repositoryTransactionHistories.length, transactionHistory.allOperationHistory.length, transactionHistory.allRecordHistory.length);
        applicationMap.ensureEntity(Q$4.TransactionHistory.__driver__.dbEntity, true);
        transactionHistory.id = transactionHistoryIds.transactionHistoryId;
        await this.doInsertValues(transaction, Q$4.TransactionHistory, [transactionHistory], context);
        applicationMap.ensureEntity(Q$4.RepositoryTransactionHistory.__driver__.dbEntity, true);
        transactionHistory.repositoryTransactionHistories.forEach((repositoryTransactionHistory, index) => {
            repositoryTransactionHistory.id = transactionHistoryIds.repositoryHistoryIds[index];
            repositoryTransactionHistory.transactionHistory = transactionHistory;
        });
        await this.doInsertValues(transaction, Q$4.RepositoryTransactionHistory, transactionHistory.repositoryTransactionHistories, context);
        applicationMap.ensureEntity(Q$4.OperationHistory.__driver__.dbEntity, true);
        transactionHistory.allOperationHistory.forEach((operationHistory, index) => {
            operationHistory.id = transactionHistoryIds.operationHistoryIds[index];
        });
        await this.doInsertValues(transaction, Q$4.OperationHistory, transactionHistory.allOperationHistory, context);
        applicationMap.ensureEntity(Q$4.RecordHistory.__driver__.dbEntity, true);
        transactionHistory.allRecordHistory.forEach((recordHistory, index) => {
            recordHistory.id = transactionHistoryIds.recordHistoryIds[index];
        });
        await this.doInsertValues(transaction, Q$4.RecordHistory, transactionHistory.allRecordHistory, context);
        if (transactionHistory.allRecordHistoryNewValues.length) {
            applicationMap.ensureEntity(Q$4.RecordHistoryNewValue.__driver__.dbEntity, true);
            await this.doInsertValues(transaction, Q$4.RecordHistoryNewValue, transactionHistory.allRecordHistoryNewValues, context);
        }
        if (transactionHistory.allRecordHistoryOldValues.length) {
            applicationMap.ensureEntity(Q$4.RecordHistoryOldValue.__driver__.dbEntity, true);
            await this.doInsertValues(transaction, Q$4.RecordHistoryOldValue, transactionHistory.allRecordHistoryOldValues, context);
        }
        return true;
    }
};
__decorate$1y([
    Inject()
], TransactionManager.prototype, "activeQueries", void 0);
__decorate$1y([
    Inject()
], TransactionManager.prototype, "idGenerator", void 0);
__decorate$1y([
    Inject()
], TransactionManager.prototype, "storeDriver", void 0);
__decorate$1y([
    Inject()
], TransactionManager.prototype, "synchronizationOutManager", void 0);
__decorate$1y([
    Inject()
], TransactionManager.prototype, "terminalStore", void 0);
__decorate$1y([
    Inject()
], TransactionManager.prototype, "transactionHistoryDuo", void 0);
TransactionManager = __decorate$1y([
    Injected()
], TransactionManager);

var __decorate$1x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let UpdateManager = class UpdateManager {
    async updateValues(portableQuery, actor, transaction, rootTransaction, context) {
        const dbEntity = this.airportDatabase.applications[portableQuery.applicationIndex]
            .currentVersion[0].applicationVersion.entities[portableQuery.tableIndex];
        const errorPrefix = `Error updating '${dbEntity.name}'
`;
        const internalFragments = {
            SET: []
        };
        let recordHistoryMap;
        let repositorySheetSelectInfo;
        let systemWideOperationId;
        if (!dbEntity.isLocal && !transaction.isSync) {
            systemWideOperationId = await getSysWideOpId(this.airportDatabase, this.sequenceGenerator);
            // TODO: For entity queries an additional query really shouldn't be needed
            // Specifically for entity queries, we got the new values, just record them
            // This will require an additional operation on the first update
            // where the original values of the record are saved
            // This eats up more disk space but saves on operations that need
            // to be performed (one less query)
            [recordHistoryMap, repositorySheetSelectInfo]
                = await this.addUpdateHistory(portableQuery, actor, systemWideOperationId, errorPrefix, transaction, rootTransaction, context);
            internalFragments.SET.push({
                column: repositorySheetSelectInfo.systemWideOperationIdColumn,
                value: systemWideOperationId
            });
        }
        const numUpdatedRows = await transaction
            .updateWhere(portableQuery, internalFragments, context);
        if (!dbEntity.isLocal && !transaction.isSync) {
            const previousDbEntity = context.dbEntity;
            context.dbEntity = dbEntity;
            // TODO: Entity based updates already have all of the new values being
            // updated, detect the type of update and if entity just pull out
            // the new values from them
            await this.addNewValueHistory(portableQuery.jsonQuery, recordHistoryMap, systemWideOperationId, repositorySheetSelectInfo, errorPrefix, transaction, context);
            context.dbEntity = previousDbEntity;
        }
        return numUpdatedRows;
    }
    async addUpdateHistory(portableQuery, actor, systemWideOperationId, errorPrefix, transaction, rootTransaction, context) {
        if (!context.dbEntity.isRepositoryEntity) {
            throw new Error(errorPrefix +
                `Cannot add update history for a non-RepositoryEntity`);
        }
        const qEntity = this.airportDatabase
            .qApplications[context.dbEntity.applicationVersion.application.index][context.dbEntity.name];
        const jsonUpdate = portableQuery.jsonQuery;
        const getSheetSelectFromSetClauseResult = this.applicationUtils.getSheetSelectFromSetClause(context.dbEntity, qEntity, jsonUpdate.S, errorPrefix);
        const sheetQuery = new SheetQuery(null);
        const jsonSelectClause = sheetQuery.nonDistinctSelectClauseToJSON(getSheetSelectFromSetClauseResult.selectClause, this.queryUtils, this.fieldUtils, this.relationManager);
        const jsonSelect = {
            S: jsonSelectClause,
            F: [jsonUpdate.U],
            W: jsonUpdate.W,
        };
        const portableSelect = {
            applicationIndex: portableQuery.applicationIndex,
            tableIndex: portableQuery.tableIndex,
            jsonQuery: jsonSelect,
            queryResultType: QueryResultType.SHEET,
            parameterMap: portableQuery.parameterMap,
            // values: portableQuery.values,
        };
        const recordsToUpdate = await transaction.find(portableSelect, {}, context);
        const { recordsByRepositoryId, repositoryIdSet } = this.groupRecordsByRepository(recordsToUpdate, getSheetSelectFromSetClauseResult);
        const repositoryIds = Array.from(repositoryIdSet);
        const recordHistoryMapByRecordId = {};
        for (const repositoryId of repositoryIds) {
            // const repository                         = repositories.get(repositoryId)
            const recordHistoryMapForRepository = {};
            recordHistoryMapByRecordId[repositoryId] = recordHistoryMapForRepository;
            const repositoryTransactionHistory = await this.historyManager.getNewRepositoryTransactionHistory(transaction.transactionHistory, repositoryId, context);
            const operationHistory = this.repositoryTransactionHistoryDuo.startOperation(repositoryTransactionHistory, systemWideOperationId, ChangeType.UPDATE_ROWS, context.dbEntity, actor, rootTransaction);
            const recordsForRepositoryId = recordsByRepositoryId[repositoryId];
            for (const recordToUpdate of recordsForRepositoryId) {
                const actorId = recordToUpdate[getSheetSelectFromSetClauseResult.actorIdColumnIndex];
                const recordHistoryMapForActor = ensureChildMap(recordHistoryMapForRepository, actorId);
                const actorRecordId = recordToUpdate[getSheetSelectFromSetClauseResult.actorRecordIdColumnIndex];
                const recordHistory = this.operationHistoryDuo.startRecordHistory(operationHistory, actorId, actorRecordId);
                recordHistoryMapForActor[actorRecordId] = recordHistory;
                for (let i = 0; i < recordToUpdate.length; i++) {
                    switch (i) {
                        case getSheetSelectFromSetClauseResult.actorIdColumnIndex:
                        case getSheetSelectFromSetClauseResult.actorRecordIdColumnIndex:
                        case getSheetSelectFromSetClauseResult.repositoryIdColumnIndex:
                            continue;
                    }
                    const dbColumn = getSheetSelectFromSetClauseResult
                        .selectClause[i].dbColumn;
                    const value = recordToUpdate[i];
                    this.recordHistoryDuo.addOldValue(recordHistory, dbColumn, value);
                }
            }
        }
        return [recordHistoryMapByRecordId, getSheetSelectFromSetClauseResult];
    }
    async addNewValueHistory(jsonUpdate, recordHistoryMapByRecordId, systemWideOperationId, repositorySheetSelectInfo, errorPrefix, transaction, context) {
        const qEntity = this.airportDatabase.qApplications[context.dbEntity.applicationVersion.application.index][context.dbEntity.name];
        const sheetQuery = new SheetQuery({
            from: [
                qEntity
            ],
            select: [],
            where: qEntity[repositoryEntity.systemWideOperationId]
                .equals(systemWideOperationId)
        });
        let portableSelect = this.queryFacade.getPortableQuery(sheetQuery, QueryResultType.SHEET, context);
        const resultSetIndexByColumnIndex = new Map();
        const selectDbColumns = [];
        let i = 0;
        for (const qField of repositorySheetSelectInfo.selectClause) {
            const dbColumn = qField.dbColumn;
            selectDbColumns.push(dbColumn);
            resultSetIndexByColumnIndex.set(dbColumn.index, i);
            i++;
        }
        const internalFragments = {
            SELECT: selectDbColumns
        };
        const updatedRecords = await transaction.find(portableSelect, internalFragments, context);
        const { recordsByRepositoryId, repositoryIdSet } = this.groupRecordsByRepository(updatedRecords, repositorySheetSelectInfo);
        for (const repositoryId of repositoryIdSet) {
            const recordsForRepositoryId = recordsByRepositoryId[repositoryId];
            for (const updatedRecord of recordsForRepositoryId) {
                const repositoryId = updatedRecord[resultSetIndexByColumnIndex.get(repositorySheetSelectInfo.repositoryIdColumnIndex)];
                const actorId = updatedRecord[resultSetIndexByColumnIndex.get(repositorySheetSelectInfo.actorIdColumnIndex)];
                const actorRecordId = updatedRecord[resultSetIndexByColumnIndex.get(repositorySheetSelectInfo.actorRecordIdColumnIndex)];
                const recordHistory = recordHistoryMapByRecordId[repositoryId][actorId][actorRecordId];
                for (const columnName in jsonUpdate.S) {
                    const dbColumn = context.dbEntity.columnMap[columnName];
                    const value = updatedRecord[resultSetIndexByColumnIndex.get(dbColumn.index)];
                    if (value === undefined) {
                        throw new Error(errorPrefix + `Values cannot be 'undefined'.`);
                    }
                    if (dbColumn.notNull && value === null) {
                        throw new Error(errorPrefix + `Column '${dbColumn.entity.name}'.'${dbColumn.name}' is NOT NULL
						and cannot have NULL values.`);
                    }
                    this.recordHistoryDuo.addNewValue(recordHistory, dbColumn, value);
                }
            }
        }
    }
    groupRecordsByRepository(records, repositorySheetSelectInfo) {
        const recordsByRepositoryId = {};
        const repositoryIdSet = new Set();
        for (const recordToUpdate of records) {
            const repositoryId = recordToUpdate[repositorySheetSelectInfo.repositoryIdColumnIndex];
            repositoryIdSet.add(repositoryId);
            const recordsForRepositoryId = ensureChildArray(recordsByRepositoryId, repositoryId);
            recordsForRepositoryId.push(recordToUpdate);
        }
        return {
            recordsByRepositoryId,
            repositoryIdSet
        };
    }
};
__decorate$1x([
    Inject()
], UpdateManager.prototype, "airportDatabase", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "applicationUtils", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "fieldUtils", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "historyManager", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "operationHistoryDuo", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "queryFacade", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "queryUtils", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "recordHistoryDuo", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "relationManager", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "repositoryTransactionHistoryDuo", void 0);
__decorate$1x([
    Inject()
], UpdateManager.prototype, "sequenceGenerator", void 0);
UpdateManager = __decorate$1x([
    Injected()
], UpdateManager);

var __decorate$1w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let CascadeGraphVerifier = class CascadeGraphVerifier {
    verify(root, context) {
        if (!(root instanceof Array)) {
            root = [root];
        }
        // TODO: validate the rules specified in the graph
        // The graph will be defined via a @Save({
        //	...RULES
        //})
        // decorator
        return root;
    }
};
CascadeGraphVerifier = __decorate$1w([
    Injected()
], CascadeGraphVerifier);

var __decorate$1v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/*
 * Takes a (potentially) interconnected entity graph and returns
 * an array of entities to be operated on, in a order that is valid
 * for insertion (with all needed new ids being inserted in an order
 * that will work).
 */
let DependencyGraphResolver = class DependencyGraphResolver {
    getOperationsInOrder(entities, context) {
        const unorderedDependencies = this.getEntitiesToPersist(entities, [], [], context);
        this.resolveCircularDependencies(unorderedDependencies, context);
        const orderedDependencies = this.orderEntitiesToPersist(unorderedDependencies, context);
        const operationNodes = this.optimizePersistOperations(orderedDependencies, context);
        return this.ensureUpdatesAreGroupedCorrectly(operationNodes, context);
    }
    getEntitiesToPersist(entities, operatedOnEntities, operatedOnPassThroughs, context, dependsOn, dependency, deleteByCascade = false) {
        let allProcessedNodes = [];
        const dbEntity = context.dbEntity;
        for (const entity of entities) {
            /*
             * A passed in graph has either entities to be saved or
             * entity stubs that are needed structurally to get to
             * other entities (or parentIds in case part of an id
             * actually resides in a nested object that that object
             * has no associated operations or child entities of
             * it's own).
             */
            const { isCreate, isDelete, isParentId, isPassThrough, isStub, isUpdate } = this.entityStateManager
                .getEntityStateTypeAsFlags(entity, dbEntity);
            if (isStub) {
                // No processing is needed
                continue;
            }
            const operationUniqueId = this.entityStateManager.getOperationUniqueId(entity);
            if (deleteByCascade && (isCreate || isUpdate)) {
                throw new Error(`Cannot do a Create or Update operation on an entity that will be
deleted by cascading rules.  Entity: ${dbEntity.name}.
Entity "${this.entityStateManager.getUniqueIdFieldName()}":  ${operationUniqueId}`);
            }
            let dependencyGraphNode;
            if (isPassThrough) {
                if (operatedOnPassThroughs[operationUniqueId]) {
                    continue;
                }
                else {
                    operatedOnPassThroughs[operationUniqueId] = true;
                }
            }
            else {
                dependencyGraphNode = operatedOnEntities[operationUniqueId];
                let isExistingNode = false;
                if (dependencyGraphNode) {
                    isExistingNode = true;
                }
                else if (!isParentId && !deleteByCascade) {
                    dependencyGraphNode = {
                        circleTraversedFor: {},
                        dbEntity,
                        dependsOnByOUID: [],
                        dependsOn: [],
                        entity,
                        isCreate,
                        isDelete
                    };
                    allProcessedNodes.push(dependencyGraphNode);
                    operatedOnEntities[operationUniqueId] = dependencyGraphNode;
                }
                if (!isParentId && !isDelete) {
                    if (dependsOn && !isDelete) {
                        const dependsOnOUID = this.entityStateManager.getOperationUniqueId(dependsOn.entity);
                        if (!dependencyGraphNode.dependsOnByOUID[dependsOnOUID]
                            && this.entityStateManager
                                .getOperationUniqueId(dependencyGraphNode.entity) !== dependsOnOUID) {
                            dependencyGraphNode.dependsOnByOUID[dependsOnOUID] = dependsOn;
                            dependencyGraphNode.dependsOn.push(dependsOn);
                        }
                    }
                    if (dependency) {
                        if (!dependencyGraphNode.dependsOnByOUID[operationUniqueId]
                            && this.entityStateManager
                                .getOperationUniqueId(dependency.entity) !== operationUniqueId) {
                            dependency.dependsOnByOUID[operationUniqueId] = dependencyGraphNode;
                            dependency.dependsOn.push(dependencyGraphNode);
                        }
                    }
                }
                if (isExistingNode) {
                    continue;
                }
            }
            for (const dbProperty of context.dbEntity.properties) {
                let relatedEntities;
                let propertyValue = entity[dbProperty.name];
                if (!propertyValue || typeof propertyValue !== 'object'
                    || !(dbProperty.relation && dbProperty.relation.length)) {
                    continue;
                }
                let fromDependencyForChild = null;
                let isDependency = false;
                let childDeleteByCascade = deleteByCascade || isDelete;
                const dbRelation = dbProperty.relation[0];
                switch (dbRelation.relationType) {
                    // Relation is an entity that this entity depends on
                    case EntityRelationType.MANY_TO_ONE:
                        childDeleteByCascade = false;
                        // TODO: see if there is a cleaner way to escape nested Actor and Repository records
                        if (dbEntity.isRepositoryEntity && (dbProperty.name === 'repository'
                            || dbProperty.name === 'actor')
                            && !propertyValue[this.entityStateManager.getStateFieldName()]) {
                            continue;
                        }
                        const parentState = this.entityStateManager
                            .getEntityStateTypeAsFlags(propertyValue, dbRelation.relationEntity);
                        if (parentState.isParentId) {
                            continue;
                        }
                        if (parentState.isDelete) {
                            if (isPassThrough) {
                                // Automatically delete all contained records
                                this.entityStateManager.markForDeletion(entity);
                            }
                            else if (!isDelete) {
                                throw new Error(`Cannot delete an entity without removing all references to it.
								Found a reference in ${dbEntity.name}.${dbProperty.name}.
								Entity "${this.entityStateManager.getUniqueIdFieldName()}":  ${operationUniqueId}`);
                            }
                            else {
                                // Prune this entry
                                if (!deleteByCascade) {
                                    if (dependency) {
                                        dependency.dependsOn.pop();
                                    }
                                    allProcessedNodes.pop();
                                }
                                deleteByCascade = true;
                            }
                        }
                        if (parentState.isCreate) {
                            isDependency = true;
                        }
                        // Do not persist actor or repository, they
                        // are created separately
                        relatedEntities = [propertyValue];
                        break;
                    // Relation is an array of entities that depend in this entity
                    case EntityRelationType.ONE_TO_MANY:
                        if (isCreate) {
                            fromDependencyForChild = dependencyGraphNode;
                        }
                        // Nested deletions wil be automatically pruned in recursive calls
                        relatedEntities = propertyValue;
                        break;
                }
                if (relatedEntities) {
                    const dbEntity = dbRelation.relationEntity;
                    const previousDbEntity = context.dbEntity;
                    context.dbEntity = dbEntity;
                    const childDependencyLinkedNodes = this.getEntitiesToPersist(relatedEntities, operatedOnEntities, operatedOnPassThroughs, context, fromDependencyForChild, !isParentId && !isDelete && isDependency ? dependencyGraphNode : null, childDeleteByCascade);
                    allProcessedNodes = allProcessedNodes.concat(childDependencyLinkedNodes);
                    context.dbEntity = previousDbEntity;
                }
            } // for properties
        } // for entities
        return allProcessedNodes;
    }
    resolveCircularDependencies(unorderedDependencies, context) {
        for (const node of unorderedDependencies) {
            const nodeOUID = this.entityStateManager.getOperationUniqueId(node.entity);
            this.resolveCircularDependenciesForNode(node, nodeOUID, node, context);
        }
    }
    resolveCircularDependenciesForNode(node, nodeOUID, currentlyTraversedNode, context, nodePath = []) {
        if (!currentlyTraversedNode.dependsOn
            || currentlyTraversedNode.circleTraversedFor[nodeOUID]) {
            return;
        }
        currentlyTraversedNode.circleTraversedFor[nodeOUID] = true;
        for (let i = currentlyTraversedNode.dependsOn.length - 1; i >= 0; i--) {
            const dependency = currentlyTraversedNode.dependsOn[i];
            const dependencyOUID = this.entityStateManager
                .getOperationUniqueId(dependency.entity);
            if (dependencyOUID === nodeOUID) {
                let entityPath = [];
                for (let pathNode of nodePath) {
                    let entityLongName = pathNode.dbEntity.applicationVersion.application.name + ':' + pathNode.dbEntity.name;
                    entityPath.push(entityLongName);
                }
                let entityLongName = dependency.dbEntity.applicationVersion.application.name + ':' + dependency.dbEntity.name;
                entityPath.push(entityLongName);
                entityLongName = nodePath[0].dbEntity.applicationVersion.application.name + ':' + nodePath[0].dbEntity.name;
                throw new Error(`Found a circular dependency in
					${entityPath.join(' -> ')}
					`);
            }
            nodePath.push(dependency);
            this.resolveCircularDependenciesForNode(node, nodeOUID, dependency, context, nodePath);
            nodePath.pop();
        }
    }
    orderEntitiesToPersist(unorderedDependencies, context) {
        let orderedNodes = [];
        let processedNodes = [];
        while (orderedNodes.length < unorderedDependencies.length) {
            for (const node of unorderedDependencies) {
                const entityUid = this.entityStateManager
                    .getOperationUniqueId(node.entity);
                if (processedNodes[entityUid]) {
                    continue;
                }
                let nodeProcessed = true;
                for (const dependency of node.dependsOn) {
                    const dependencyUid = this.entityStateManager
                        .getOperationUniqueId(dependency.entity);
                    // If a dependency is not yet processed (and is possibly has
                    // other dependencies of it's own)
                    if (!processedNodes[dependencyUid]) {
                        nodeProcessed = false;
                        break;
                    }
                }
                if (nodeProcessed) {
                    processedNodes[entityUid] = node;
                    orderedNodes.push(node);
                }
            }
        }
        return orderedNodes;
    }
    // Group alike operations together, where possible
    optimizePersistOperations(orderedDependencies, context) {
        let operationNodes = [];
        let processedNodes = [];
        let operationsByApplicationIndex = [];
        for (const node of orderedDependencies) {
            const dbEntity = node.dbEntity;
            const applicationOperationNodes = ensureChildArray(operationsByApplicationIndex, dbEntity.applicationVersion.application.index);
            let entityOperations = applicationOperationNodes[dbEntity.index];
            if (!entityOperations) {
                entityOperations = {
                    create: [],
                    delete: [],
                    update: []
                };
                applicationOperationNodes[dbEntity.index] = entityOperations;
            }
            let operations = [];
            if (node.isCreate) {
                operations = entityOperations.create;
            }
            else if (node.isDelete) {
                operations = entityOperations.delete;
            }
            else {
                operations = entityOperations.update;
            }
            let operation;
            if (!operations.length) {
                operation = {
                    dbEntity,
                    entities: [],
                    isCreate: node.isCreate,
                    isDelete: node.isDelete,
                };
                operations.push(operation);
                operationNodes.push(operation);
            }
            else {
                operation = operations[operations.length - 1];
            }
            // For each node traverse its dependencies
            // if it has dependencies that haven't been processed yet
            // then it can't be combined with an earlier alike operation
            // on the same entity
            let canBeCombined = true;
            for (const dependency of node.dependsOn) {
                const dependencyUid = this.entityStateManager
                    .getOperationUniqueId(dependency.entity);
                this.entityStateManager.getOperationUniqueId(dependency.entity);
                if (!processedNodes[dependencyUid]) {
                    canBeCombined = false;
                    break;
                }
            }
            if (!canBeCombined && operation.entities.length) {
                operation = {
                    dbEntity,
                    entities: [],
                    isCreate: node.isCreate,
                    isDelete: node.isDelete,
                };
                operations.push(operation);
                operationNodes.push(operation);
            }
            operation.entities.push(node.entity);
        }
        return operationNodes;
    }
    /**
     *
     * @param operationNodes
     * @param context
     */
    ensureUpdatesAreGroupedCorrectly(operationNodes, context) {
        // TODO: group related updates ONLY if all updates field values are
        // the same
        // throw new Error('Not Implemented.')
        return operationNodes;
    }
};
__decorate$1v([
    Inject()
], DependencyGraphResolver.prototype, "entityStateManager", void 0);
DependencyGraphResolver = __decorate$1v([
    Injected()
], DependencyGraphResolver);

var __decorate$1u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Takes a serialized object tree and reconstructs a (potentially)
 * interlinked object graph.
 */
let EntityGraphReconstructor = class EntityGraphReconstructor {
    restoreEntityGraph(root, context) {
        const entitiesByOperationIndex = [];
        const processedEntitySet = new Set();
        const rootCopy = this.linkEntityGraph(root, entitiesByOperationIndex, processedEntitySet, context);
        for (let i = 1; i < entitiesByOperationIndex.length; i++) {
            const entity = entitiesByOperationIndex[i];
            if (!entity) {
                throw new Error(`Missing entity for
"${this.entityStateManager.getUniqueIdFieldName()}": ${i}`);
            }
        }
        context.lastOUID = entitiesByOperationIndex.length - 1;
        return rootCopy;
    }
    linkEntityGraph(currentEntities, entitiesByOperationIndex, processedEntitySet, context) {
        const dbEntity = context.dbEntity;
        const results = [];
        for (const entity of currentEntities) {
            if (!entity) {
                throw new Error(`Null root entities and @OneToMany arrays with null entities are not allowed`);
            }
            const operationUniqueId = this.entityStateManager.getOperationUniqueId(entity);
            if (!operationUniqueId || typeof operationUniqueId !== 'number'
                || operationUniqueId < 1) {
                throw new Error(`Invalid entity Unique Id Field
"${this.entityStateManager.getUniqueIdFieldName()}": ${operationUniqueId}.`);
            }
            const previouslyFoundEntity = entitiesByOperationIndex[operationUniqueId];
            if (processedEntitySet.has(entity)) {
                if (!previouslyFoundEntity) {
                    throw new Error(`Entity has been processed but is not found by operationUniqueId`);
                }
                results.push(previouslyFoundEntity);
                continue;
            }
            processedEntitySet.add(entity);
            /*
             * A passed in graph has either entities to be saved or
             * entity stubs that are needed structurally to get to
             * other entities.
             */
            const { isParentId, isStub } = this.entityStateManager
                .getEntityStateTypeAsFlags(entity, dbEntity);
            let entityCopy;
            if (previouslyFoundEntity) {
                if (!this.entityStateManager.isStub(previouslyFoundEntity)) {
                    if (!isStub) {
                        throw new Error(`More than 1 non-Stub object found in input
for "${this.entityStateManager.getUniqueIdFieldName()}": ${operationUniqueId}`);
                    }
                }
                else {
                    if (!isStub) {
                        this.entityStateManager.copyEntityState(entity, previouslyFoundEntity);
                    }
                }
                entityCopy = previouslyFoundEntity;
            }
            else {
                entityCopy = {};
                entityCopy[this.entityStateManager.getUniqueIdFieldName()]
                    = operationUniqueId;
                entityCopy[this.entityStateManager.getStateFieldName()]
                    = this.entityStateManager.getEntityState(entity);
                this.entityStateManager.copyEntityState(entity, entityCopy);
                entitiesByOperationIndex[operationUniqueId]
                    = entityCopy;
            }
            for (const dbProperty of dbEntity.properties) {
                let propertyValue = entity[dbProperty.name];
                if (propertyValue === undefined) {
                    continue;
                }
                if (dbProperty.relation && dbProperty.relation.length) {
                    const dbRelation = dbProperty.relation[0];
                    let relatedEntities = propertyValue;
                    let isManyToOne = false;
                    this.assertRelationValueIsAnObject(propertyValue, dbProperty);
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            isManyToOne = true;
                            this.assertManyToOneNotArray(propertyValue, dbProperty);
                            relatedEntities = [propertyValue];
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            this.assertOneToManyIsArray(propertyValue, dbProperty);
                            if (isParentId) {
                                throw new Error(`Parent Ids may not contain any @OneToMany relations`);
                            }
                            break;
                        default:
                            throw new Error(`Unexpected relation type ${dbRelation.relationType}
for ${dbEntity.name}.${dbProperty.name}`);
                    } // switch dbRelation.relationType
                    const previousDbEntity = context.dbEntity;
                    const previousDbApplication = previousDbEntity.applicationVersion.application;
                    const propertyDbApplication = dbRelation.relationEntity.applicationVersion.application;
                    if (propertyDbApplication.domain.name !== 'air'
                        && previousDbApplication.fullName !== propertyDbApplication.fullName) {
                        // If a child entity is in a different application it won't be processed
                        // the calling application should call the API of the other application
                        // explicitly so that the application logic may be run
                        continue;
                    }
                    context.dbEntity = dbRelation.relationEntity;
                    let propertyCopyValue;
                    if (propertyValue) {
                        propertyCopyValue = this.linkEntityGraph(relatedEntities, entitiesByOperationIndex, processedEntitySet, context);
                        if (isManyToOne) {
                            propertyCopyValue = propertyCopyValue[0];
                            if (isParentId) {
                                if (!this.entityStateManager.isParentId(propertyCopyValue)) {
                                    throw new Error(`Parent Ids may only contain @ManyToOne relations
that are themselves Parent Ids.`);
                                }
                            }
                        }
                        else {
                            if (isParentId) {
                                throw new Error(`Parent Ids may NOT contain @OneToMany colletions.`);
                            }
                        } // if (isManyToOne
                        // if !isManyToOne - nothing to do
                    } // if (propertyValue
                    propertyValue = propertyCopyValue;
                    context.dbEntity = previousDbEntity;
                } // if (dbProperty.relation
                else {
                    if ((isParentId || isStub) && !dbProperty.isId) {
                        // TODO: can a ParentId comprise of fields that are not part of it's own Id
                        // but are a part of Parent's Id?
                        throw new Error(`Deletes, ParentIds and Stubs may only contain @Id properties or relations.`);
                    }
                } // else (dbProperty.relation
                entityCopy[dbProperty.name] = propertyValue;
            } // for (const dbProperty
            results.push(entityCopy);
        } // for (const entity
        return results;
    }
    assertRelationValueIsAnObject(relationValue, dbProperty) {
        if (relationValue !== null && relationValue !== undefined &&
            (typeof relationValue != 'object' || relationValue instanceof Date)) {
            throw new Error(`Unexpected value in relation property: ${dbProperty.name}, 
				of entity ${dbProperty.entity.name}`);
        }
    }
    assertManyToOneNotArray(relationValue, dbProperty) {
        if (relationValue instanceof Array) {
            throw new Error(`@ManyToOne relation cannot be an array. Relation property: ${dbProperty.name}, 
of entity ${dbProperty.entity.name}`);
        }
    }
    assertOneToManyIsArray(relationValue, dbProperty) {
        if (relationValue !== null
            && relationValue !== undefined
            && !(relationValue instanceof Array)) {
            throw new Error(`@OneToMany relation must be an array. Relation property: ${dbProperty.name}, 
of entity ${dbProperty.entity.name}\``);
        }
    }
};
__decorate$1u([
    Inject()
], EntityGraphReconstructor.prototype, "entityStateManager", void 0);
EntityGraphReconstructor = __decorate$1u([
    Injected()
], EntityGraphReconstructor);

var __decorate$1t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let OperationContextLoader = class OperationContextLoader {
    async ensure(context) {
    }
    ensureSync(context) {
    }
};
OperationContextLoader = __decorate$1t([
    Injected()
], OperationContextLoader);

var __decorate$1s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 11/15/2016.
 */
let OperationManager = class OperationManager {
    /**
     * Transactional context must have been started by the time this method is called.
     *
     * @param qEntity
     * @param entity
     */
    async performSave(entities, actor, transaction, rootTransaction, context) {
        let entityGraph;
        context.isSaveOperation = true;
        if (context.internal) {
            if (entities instanceof Array) {
                entityGraph = entities;
            }
            else {
                entityGraph = [entities];
            }
        }
        else {
            const verifiedTree = this.cascadeGraphVerifier
                .verify(entities, context);
            entityGraph = this.entityGraphReconstructor
                .restoreEntityGraph(verifiedTree, context);
        }
        await this.structuralEntityValidator.validate(entityGraph, [], context);
        const operations = this.dependencyGraphResolver
            .getOperationsInOrder(entityGraph, context);
        const rootDbEntity = context.dbEntity;
        let saveActor = {
            id: actor.id,
            uuId: actor.uuId,
            user: actor.user ? {
                id: actor.user.id
            } : null
        };
        let newRepository;
        if (context.newRepository) {
            newRepository = {
                id: context.newRepository.id,
                createdAt: context.newRepository.createdAt,
                uuId: context.newRepository.uuId,
                ageSuitability: context.newRepository.ageSuitability,
                source: context.newRepository.source,
                ownerActor: {
                    id: actor.id,
                    uuId: actor.uuId,
                    user: actor.user ? {
                        id: actor.user.id
                    } : null
                }
            };
        }
        const saveResult = {
            actor: saveActor,
            created: {},
            newRepository,
            deleted: {},
            updated: {},
        };
        for (const operation of operations) {
            context.dbEntity = operation.dbEntity;
            if (operation.isCreate) {
                await this.internalCreate(operation.entities, actor, transaction, rootTransaction, saveResult, context, true);
            }
            else if (operation.isDelete) {
                await this.internalDelete(operation.entities, actor, transaction, rootTransaction, saveResult, context);
            }
            else {
                await this.internalUpdate(operation.entities, actor, transaction, rootTransaction, saveResult, context);
            }
        }
        context.dbEntity = rootDbEntity;
        return saveResult;
    }
    async internalCreate(entities, actor, transaction, rootTransaction, saveResult, context, ensureGeneratedValues) {
        const qEntity = this.airportDatabase.qApplications[context.dbEntity.applicationVersion.application.index][context.dbEntity.name];
        let rawInsert = {
            insertInto: qEntity,
            columns: this.qMetadataUtils.getAllInsertableColumns(qEntity),
            values: []
        };
        let columnIndexesInValues = [];
        rawInsert.columns.forEach((qField, index) => {
            columnIndexesInValues[qField.dbColumn.index] = index;
        });
        for (const entity of entities) {
            let valuesFragment = [];
            for (const dbProperty of context.dbEntity.properties) {
                let newValue = entity[dbProperty.name];
                if (newValue === undefined) {
                    newValue = null;
                }
                if (dbProperty.relation && dbProperty.relation.length) {
                    const dbRelation = dbProperty.relation[0];
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            this.applicationUtils.forEachColumnOfRelation(dbRelation, entity, (dbColumn, columnValue, _propertyNameChains) => {
                                if (dbColumn.isGenerated) {
                                    return;
                                }
                                valuesFragment[columnIndexesInValues[dbColumn.index]]
                                    = columnValue === undefined ? null : columnValue;
                            }, false);
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            break;
                        default:
                            throw new Error(`Unknown relationType '${dbRelation.relationType}' 
						for '${context.dbEntity.name}.${dbProperty.name}'.`);
                    }
                }
                else {
                    let column = dbProperty.propertyColumns[0].column;
                    if (!column.isGenerated) {
                        valuesFragment[columnIndexesInValues[column.index]] = newValue;
                    }
                }
            }
            rawInsert.values.push(valuesFragment);
        }
        const insertValues = new InsertValues(rawInsert);
        if (rawInsert.values.length) {
            const generatedColumns = context.dbEntity.columns.filter(column => column.isGenerated);
            if (generatedColumns.length && ensureGeneratedValues) {
                const portableQuery = this.queryFacade
                    .getPortableQuery(insertValues, null, context);
                const idsAndGeneratedValues = await this.insertManager
                    .insertValuesGetIds(portableQuery, actor, transaction, rootTransaction, context);
                for (let i = 0; i < entities.length; i++) {
                    const entity = entities[i];
                    const entitySaveResult = {};
                    saveResult.created[this.entityStateManager.getOperationUniqueId(entity)] = entitySaveResult;
                    for (const generatedColumn of generatedColumns) {
                        // Return index for generated column values is: DbColumn.index
                        const generatedPropertyName = generatedColumn.propertyColumns[0].property.name;
                        const generatedPropertyValue = idsAndGeneratedValues[i][generatedColumn.index];
                        entity[generatedPropertyName] = generatedPropertyValue;
                        entitySaveResult[generatedPropertyName] = generatedPropertyValue;
                    }
                }
            }
            else {
                const portableQuery = this.queryFacade
                    .getPortableQuery(insertValues, null, context);
                await this.insertManager.insertValues(portableQuery, actor, transaction, rootTransaction, context, ensureGeneratedValues);
                for (let i = 0; i < entities.length; i++) {
                    const entity = entities[i];
                    saveResult.created[this.entityStateManager.getOperationUniqueId(entity)] = true;
                }
            }
        }
    }
    /**
     * On an update operation, can a nested create contain an update?
     * Via:
     *  OneToMany:
     *    Yes, if the child entity is itself in the update cache
     *  ManyToOne:
     *    Cascades do not travel across ManyToOne
     */
    async internalUpdate(entities, actor, transaction, rootTransaction, saveResult, context) {
        const qEntity = this.airportDatabase.qApplications[context.dbEntity.applicationVersion.application.index][context.dbEntity.name];
        for (const entity of entities) {
            const setFragment = {};
            const idWhereFragments = [];
            let runUpdate = false;
            const originalEntity = this.entityStateManager.getOriginalValues(entity);
            if (!originalEntity) {
                continue;
            }
            for (const dbProperty of context.dbEntity.properties) {
                const updatedValue = entity[dbProperty.name];
                if (!dbProperty.relation || !dbProperty.relation.length) {
                    const originalValue = originalEntity[dbProperty.name];
                    if (dbProperty.isId) {
                        // For an id property, the value is guaranteed to be the same (and not empty) -
                        // cannot entity-update id fields
                        idWhereFragments.push(qEntity[dbProperty.name]
                            .equals(updatedValue));
                    }
                    else if (!this.utils.valuesEqual(originalValue, updatedValue)) {
                        setFragment[dbProperty.name] = updatedValue;
                        saveResult.updated[this.entityStateManager.getOperationUniqueId(entity)] = true;
                        runUpdate = true;
                    }
                }
                else {
                    const dbRelation = dbProperty.relation[0];
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            let propertyOriginalValue = originalEntity[dbProperty.name];
                            this.applicationUtils.forEachColumnOfRelation(dbRelation, entity, (_dbColumn, value, propertyNameChains) => {
                                let originalColumnValue = propertyOriginalValue;
                                let columnValue = value;
                                let valuePropertyNameChain = value;
                                for (const childPropertyName of propertyNameChains[0]) {
                                    if (originalColumnValue instanceof Object
                                        && originalColumnValue[childPropertyName]) {
                                        originalColumnValue = originalColumnValue[childPropertyName];
                                    }
                                    else {
                                        originalColumnValue = null;
                                    }
                                    if (columnValue instanceof Object
                                        && columnValue[childPropertyName]) {
                                        columnValue = columnValue[childPropertyName];
                                        valuePropertyNameChain.push(childPropertyName);
                                    }
                                    else {
                                        columnValue = null;
                                    }
                                }
                                if (dbProperty.isId) {
                                    let idQProperty = qEntity;
                                    for (const propertyNameLink of propertyNameChains[0]) {
                                        idQProperty = idQProperty[propertyNameLink];
                                    }
                                    // For an id property, the value is guaranteed to be the same (and not
                                    // empty) - cannot entity-update id fields
                                    idWhereFragments.push(idQProperty.equals(value));
                                }
                                else if (!this.utils.valuesEqual(originalColumnValue, columnValue)) {
                                    let currentSetFragment = setFragment;
                                    for (let i = 0; i < valuePropertyNameChain.length - 1; i++) {
                                        const childPropertyName = valuePropertyNameChain[i];
                                        if (!currentSetFragment[childPropertyName]) {
                                            currentSetFragment[childPropertyName] = {};
                                        }
                                        currentSetFragment = currentSetFragment[childPropertyName];
                                    }
                                    currentSetFragment[valuePropertyNameChain.length - 1] = columnValue;
                                    saveResult.updated[this.entityStateManager.getOperationUniqueId(entity)] = true;
                                    runUpdate = true;
                                }
                            }, dbProperty.isId);
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            break;
                        default:
                            throw new Error(`Unknown relationType '${dbRelation.relationType}' 
						for '${context.dbEntity.name}.${dbProperty.name}'.`);
                    }
                }
            }
            if (runUpdate) {
                let whereFragment;
                if (idWhereFragments.length > 1) {
                    whereFragment = and(...idWhereFragments);
                }
                else {
                    whereFragment = idWhereFragments[0];
                }
                const rawUpdate = {
                    update: qEntity,
                    set: setFragment,
                    where: whereFragment
                };
                const update = new UpdateProperties(rawUpdate);
                const portableQuery = this.queryFacade.getPortableQuery(update, null, context);
                await this.updateManager.updateValues(portableQuery, actor, transaction, rootTransaction, context);
            }
        }
    }
    async internalDelete(entities, actor, transaction, rootTransaction, saveResult, context) {
        const dbEntity = context.dbEntity;
        const qEntity = this.airportDatabase.qApplications[dbEntity.applicationVersion.application.index][dbEntity.name];
        const idWhereFragments = [];
        const valuesMapByColumn = [];
        let entityIdWhereClauses = [];
        for (const entity of entities) {
            for (let propertyName in entity) {
                if (!entity.hasOwnProperty(propertyName)) {
                    continue;
                }
                const dbProperty = dbEntity.propertyMap[propertyName];
                // Skip transient fields
                if (!dbProperty) {
                    continue;
                }
                const deletedValue = entity[propertyName];
                let dbRelation;
                if (dbProperty.relation && dbProperty.relation.length) {
                    dbRelation = dbProperty.relation[0];
                }
                if (!dbRelation) {
                    if (dbProperty.isId) {
                        // For an id property, the value is guaranteed to be the same (and not empty) -
                        // cannot entity-update id fields
                        idWhereFragments.push(qEntity[propertyName].equals(deletedValue));
                    }
                }
                else {
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            this.applicationUtils.forEachColumnOfRelation(dbRelation, dbEntity, (dbColumn, value, propertyNameChains) => {
                                if (dbProperty.isId && valuesMapByColumn[dbColumn.index] === undefined) {
                                    let idQProperty = qEntity;
                                    for (const propertyNameLink of propertyNameChains[0]) {
                                        idQProperty = idQProperty[propertyNameLink];
                                    }
                                    // For an id property, the value is guaranteed to be the same (and not
                                    // empty) - cannot entity-update id fields
                                    idWhereFragments.push(idQProperty.equals(value));
                                }
                            }, false);
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            break;
                        default:
                            throw new Error(`Unknown relationType '${dbRelation.relationType}' 
						for '${dbEntity.name}.${dbProperty.name}'.`);
                    }
                }
            }
            if (idWhereFragments.length > 1) {
                entityIdWhereClauses.push(and(...idWhereFragments));
            }
            else {
                entityIdWhereClauses.push(idWhereFragments[0]);
            }
            saveResult.deleted[this.entityStateManager.getOperationUniqueId(entity)] = true;
        }
        let where;
        if (entityIdWhereClauses.length === 1) {
            where = entityIdWhereClauses[0];
        }
        else {
            where = or(...entityIdWhereClauses);
        }
        let rawDelete = {
            deleteFrom: qEntity,
            where
        };
        let deleteWhere = new Delete(rawDelete);
        let portableQuery = this.queryFacade.getPortableQuery(deleteWhere, null, context);
        await this.deleteManager.deleteWhere(portableQuery, actor, transaction, rootTransaction, context);
    }
};
__decorate$1s([
    Inject()
], OperationManager.prototype, "airportDatabase", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "applicationUtils", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "cascadeGraphVerifier", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "deleteManager", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "dependencyGraphResolver", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "entityGraphReconstructor", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "entityStateManager", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "insertManager", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "qMetadataUtils", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "queryFacade", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "structuralEntityValidator", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "updateManager", void 0);
__decorate$1s([
    Inject()
], OperationManager.prototype, "utils", void 0);
OperationManager = __decorate$1s([
    Injected()
], OperationManager);

var __decorate$1r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let StructuralEntityValidator = class StructuralEntityValidator {
    async validate(records, operatedOnEntityIndicator, context, fromOneToMany = false, parentRelationProperty = null, rootRelationRecord = null, parentRelationRecord = null) {
        const dbEntity = context.dbEntity;
        if (!dbEntity.idColumns.length) {
            throw new Error(`Cannot run 'save' for entity '${dbEntity.name}' with no @Id(s).
					Please use non-entity operations (like 'insert' or 'updateWhere') instead.`);
        }
        let haveRootRelationRecord = !!rootRelationRecord;
        for (const record of records) {
            if (!haveRootRelationRecord) {
                rootRelationRecord = record;
            }
            const { isCreate, isParentId, isStub } = this.entityStateManager.getEntityStateTypeAsFlags(record, dbEntity);
            if (isParentId) {
                // No processing is needed (already covered by id check)
                continue;
            }
            const operationUniqueId = this.entityStateManager.getOperationUniqueId(record);
            const entityOperatedOn = !!operatedOnEntityIndicator[operationUniqueId];
            if (entityOperatedOn) {
                continue;
            }
            operatedOnEntityIndicator[operationUniqueId] = true;
            let newRepositoryNeeded = false;
            for (const dbProperty of dbEntity.properties) {
                let propertyValue = record[dbProperty.name];
                if (propertyValue === undefined && !isStub) {
                    propertyValue = null;
                    record[dbProperty.name] = propertyValue;
                }
                /*
                 * It is possible for the @Id's of an entity to be in
                 * a @ManyToOne, so we need to check
                 */
                if (dbProperty.relation && dbProperty.relation.length) {
                    const dbRelation = dbProperty.relation[0];
                    let relatedEntities = null;
                    let relationIsOneToMany = false;
                    let isRelationNullable = true;
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            // Id columns are for the parent (currently processed) entity and must be
                            // checked as part of this entity
                            if (dbProperty.isId) {
                                let isMissingRepositoryProperty = false;
                                this.applicationUtils.forEachColumnOfRelation(dbRelation, record, (dbColumn, columnValue, _propertyNameChains) => {
                                    if (dbColumn.notNull) {
                                        isRelationNullable = false;
                                    }
                                    if (this.isRepositoryColumnAndNewRepositoryNeed(dbEntity, dbProperty, dbColumn, isCreate, record, columnValue, context)) {
                                        isMissingRepositoryProperty = true;
                                    }
                                }, false);
                                if (isMissingRepositoryProperty) {
                                    if (!context.newRepository) {
                                        await this.repositoryManager.createRepository(context.actor, context);
                                        newRepositoryNeeded = true;
                                    }
                                    record[dbProperty.name] = context.newRepository;
                                }
                            }
                            if (fromOneToMany) {
                                const parentOneToManyElems = parentRelationProperty.relation[0].oneToManyElems;
                                const parentMappedBy = parentOneToManyElems ? parentOneToManyElems.mappedBy : null;
                                const mappedBy = dbRelation.manyToOneElems ? dbRelation.manyToOneElems.mappedBy : null;
                                // NOTE: 'actor' or the 'repository' property may be automatically populated
                                // in the entity by this.validateRelationColumn
                                if (parentMappedBy === dbProperty.name
                                    || mappedBy === parentRelationProperty.name) {
                                    // Always fix to the parent record
                                    record[dbProperty.name] = parentRelationRecord;
                                    // if (!propertyValue && !entity[dbProperty.name]) {
                                    // 	// The @ManyToOne side of the relationship is missing, add it
                                    // 	entity[dbProperty.name] = parentRelationEntity
                                    // }
                                }
                            }
                            if (propertyValue) {
                                if (propertyValue) {
                                    relatedEntities = [propertyValue];
                                }
                                else if (!isRelationNullable) {
                                    throw new Error(`Non-nullable relation ${dbEntity.name}.${dbProperty.name} does not have value assigned`);
                                }
                                else {
                                    console.warn(`Probably OK: Nullable @ManyToOne ${dbEntity.name}.${dbProperty.name} does not have anything assigned.`);
                                }
                            }
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            relationIsOneToMany = true;
                            relatedEntities = propertyValue;
                            break;
                        default:
                            throw new Error(`Unexpected relation type ${dbRelation.relationType}
for ${dbEntity.name}.${dbProperty.name}`);
                    } // switch dbRelation.relationType
                    if (relatedEntities && relatedEntities.length) {
                        const previousDbEntity = context.dbEntity;
                        context.dbEntity = dbRelation.relationEntity;
                        this.validate(relatedEntities, operatedOnEntityIndicator, context, relationIsOneToMany, dbProperty, rootRelationRecord, record);
                        context.dbEntity = previousDbEntity;
                    }
                } // if (dbProperty.relation // If is a relation property
                else {
                    const dbColumn = dbProperty.propertyColumns[0].column;
                    if (dbProperty.isId) {
                        const isIdColumnEmpty = this.applicationUtils.isIdEmpty(propertyValue);
                        this.ensureIdValue(dbEntity, dbProperty, dbColumn, isCreate, isIdColumnEmpty);
                    }
                    else {
                        if (isStub || isParentId) {
                            if (propertyValue !== undefined) {
                                throw new Error(`Unexpected non-@Id value Stub|ParentId|Deleted record.
Property: ${dbEntity.name}.${dbProperty.name}, with "${this.entityStateManager.getUniqueIdFieldName()}":  ${operationUniqueId}`);
                            }
                        }
                    }
                    this.ensureNonRelationalValue(dbProperty, dbColumn, propertyValue);
                } // else (dbProperty.relation  // If not a relation property
            } // for (const dbProperty of dbEntity.properties)
            this.ensureRepositoryValidity(record, rootRelationRecord, parentRelationRecord, dbEntity, parentRelationProperty, isCreate, fromOneToMany, newRepositoryNeeded, context);
        } // for (const record of entities)
    }
    ensureRepositoryValidity(record, rootRelationRecord, parentRelationRecord, dbEntity, parentRelationProperty, isCreate, fromOneToMany, newRepositoryNeeded, context) {
        if (!dbEntity.isRepositoryEntity) {
            return;
        }
        if (!parentRelationRecord) {
            const originalValues = this.entityStateManager.getOriginalValues(record);
            if (newRepositoryNeeded && originalValues && originalValues.repository
                && originalValues.actor && originalValues.actorRecordId) {
                const repositoryEntity = record;
                repositoryEntity.originalRepository = originalValues.repository;
                this.entityStateManager.markAsStub(repositoryEntity.originalRepository);
                repositoryEntity.originalActor = originalValues.actor;
                this.entityStateManager.markAsStub(repositoryEntity.originalActor);
                repositoryEntity.originalActorRecordId = originalValues.actorRecordId;
            }
            return;
        }
        if (newRepositoryNeeded) {
            throw new Error(`Error creating a new repository in a nested record:
In Entity: ${dbEntity.name}
That is a child of ${parentRelationProperty.entity.name} via ${parentRelationProperty.entity.name}.${parentRelationProperty.name}
->
When creating a new repository the top level record should be of the newly created repository.
`);
        }
        // One to many get traversed as well, if it's in the input graph/tree
        // it is assumed to be part of the same repository
        // if (fromOneToMany) {
        // 	return
        // }
        let repositoryEntity = record;
        // If the repositories of parent record and child record match
        if (rootRelationRecord.repository.id === repositoryEntity.repository.id) {
            // no further checks needed
            return;
        }
        if (isCreate) {
            throw new Error(`A newly created ${dbEntity.name} via ${dbEntity.name} record for repository id ${repositoryEntity.repository.id} (UUID: ${repositoryEntity.repository.id})
is being assigned to repository id ${repositoryEntity.repository.id} (UUID: ${repositoryEntity.repository.id})
	This is because it is being referenced via ${parentRelationProperty.entity.name}.${parentRelationProperty.name},
	from a record of repository id ${repositoryEntity.repository.id} (UUID: ${repositoryEntity.repository.id})
	
	If you are manually creating a copy of a record in another repository, there is no need,
	AIRport automatically copies all records refrenced via @ManyToOne()s into the created/modified
	repository.

	Otherwise, did you mean to set this record's repository to the same one as the referencing record?`);
        }
        // If it doesn't then it is a reference to another repository - switch
        // the record to the parent repository and set the originalRepositoryValue
        repositoryEntity.originalRepository = repositoryEntity.repository;
        repositoryEntity.repository = rootRelationRecord.repository;
        // Aslo set originalActor and originalActorRecordId to look up the original record
        repositoryEntity.originalActor = repositoryEntity.actor;
        repositoryEntity.originalActorRecordId = repositoryEntity.actorRecordId;
        // reset 'actor' and clear 'actorRecordId' to prevents unique constraint
        // violation if multiple databases flip to the same exact record (independently)
        repositoryEntity.actor = context.actor;
        delete repositoryEntity.actorRecordId;
        // Flip the state of this record to EntityState.CREATE this record now
        // has to be created in the referencing repository
        repositoryEntity[this.entityStateManager.getStateFieldName()] = EntityState$1.CREATE;
        // NOTE: If the child record is not provided and it's an optional
        // @ManyToOne() it will be treated as if no record is there.  That is
        // probaby the only correct way to handle it and a warning is
        // shown to the user in this case
    }
    isRepositoryColumnAndNewRepositoryNeed(dbEntity, dbProperty, dbColumn, isCreate, entity, columnValue, context) {
        if (!dbColumn.idIndex && dbColumn.idIndex !== 0) {
            return;
        }
        const isIdColumnEmpty = this.applicationUtils.isIdEmpty(columnValue);
        if (!dbEntity.isRepositoryEntity) {
            this.ensureIdValue(dbEntity, dbProperty, dbColumn, isCreate, isIdColumnEmpty);
            return false;
        }
        if (!isIdColumnEmpty) {
            if (isCreate) {
                if (this.applicationUtils.isActorId(dbColumn.name)) {
                    throw new Error(`Actor cannot be passed in for create Operations`);
                }
            }
            return false;
        }
        if (!isCreate) {
            throw new Error(`Ids must be populated in entities for non-Create operations`);
        }
        if (this.applicationUtils.isRepositoryId(dbColumn.name)) {
            // Repository was not provided - use context's 'newRepository'
            return true;
        }
        else if (this.applicationUtils.isActorId(dbColumn.name)) {
            // Use context's 'actor'
            entity[dbProperty.name] = context.actor;
            return false;
        }
        else if (this.applicationUtils.isActorRecordId(dbColumn.name)) {
            return false;
        }
        throw new Error(`Unexpected @Id column '${dbColumn.name}' in a Repository Entity.`);
    }
    ensureIdValue(dbEntity, dbProperty, dbColumn, isCreate, isIdColumnEmpty) {
        if (dbColumn.isGenerated) {
            if (isCreate && !isIdColumnEmpty) {
                throw new Error(`@GeneratedValue() @Id() ${dbEntity.name}.${dbProperty.name},
column:  ${dbColumn.name}
must NOT have a value for entity Insert operation.`);
            }
            else if (!isCreate && isIdColumnEmpty) {
                throw new Error(`@GeneratedValue() @Id() ${dbEntity.name}.${dbProperty.name} 
column:  ${dbColumn.name}
must have a value for entity non-Insert operations.`);
            }
        }
        else if (isIdColumnEmpty) {
            throw new Error(`non-@GeneratedValue() @Id() ${dbEntity.name}.${dbProperty.name},
column:  ${dbColumn.name}
must always have a value for all entity operations.`);
        }
    }
    ensureNonRelationalValue(dbProperty, dbColumn, value) {
        if (value === undefined || value === null) {
            return;
        }
        switch (dbColumn.type) {
            case SQLDataType.ANY:
                break;
            case SQLDataType.BOOLEAN:
                if (typeof value !== 'boolean') {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
            case SQLDataType.DATE:
                if (typeof value !== 'object' || !(value instanceof Date)) {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
            case SQLDataType.JSON:
                if (typeof value !== 'object' || value instanceof Date) {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
            case SQLDataType.NUMBER:
                if (typeof value !== 'number') {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
            case SQLDataType.STRING:
                if (typeof value !== 'string') {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
        }
    }
    throwUnexpectedProperty(dbProperty, dbColumn, value) {
        throw new Error(`Unexpected property value '${value.toString()}' in property '${dbProperty.entity.name}.${dbProperty.name}'
		(column: '${dbColumn.name}').`);
    }
};
__decorate$1r([
    Inject()
], StructuralEntityValidator.prototype, "applicationUtils", void 0);
__decorate$1r([
    Inject()
], StructuralEntityValidator.prototype, "entityStateManager", void 0);
__decorate$1r([
    Inject()
], StructuralEntityValidator.prototype, "repositoryManager", void 0);
StructuralEntityValidator = __decorate$1r([
    Injected()
], StructuralEntityValidator);

var __decorate$1q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// TODO: figure out if this is needed - originally written for deserializing
// Client-side query parameters.  Since then moved to Isolates and generic
// API calls.  Probably should be used in go-tower to deserialize all of the
// method argiments passed it (and won't be tied to a query of any kind, API
// interface is generic, unless already known to contain entity objects.)
let QueryParameterDeserializer = class QueryParameterDeserializer {
    deserialize(parameters, query, entityStateManager) {
        if (parameters.length !== query.jsonQuery.parameters.length) {
            throw new Error(`Wrong number of parameters for ${query.dbEntity.name}.${query.jsonQuery.queryName}
            Received:  ${parameters.length}
            Expecting: ${query.jsonQuery.parameters.length}
            `);
        }
        const deserializedParameters = [];
        for (let i = 0; i < parameters.length; i++) {
            const deserializedParameter = this.deserializeParameter(parameters[i], query.jsonQuery.parameters[i], i + 1, query, entityStateManager);
            deserializedParameters.push(deserializedParameter);
        }
        return deserializedParameters;
    }
    deserializeParameter(parameter, jsonQueryParameter, parameterIndex, query, entityStateManager) {
        switch (jsonQueryParameter.type) {
            case SQLDataType.BOOLEAN:
                this.checkTypeOfParameter(parameter, 'boolean', parameterIndex, query);
                break;
            case SQLDataType.DATE:
                if (!(parameter instanceof Object)
                    || parameter[entityStateManager.getStateFieldName()] !== EntityState.RESULT_DATE
                    || !parameter.value) {
                    throw new Error(`Invalid Serialized Date format for:
                    ${query.dbEntity.name}.${query.jsonQuery.queryName}
                    parameter #: ${parameterIndex}
        got: ${JSON.stringify(parameter)}
                    `);
                }
                try {
                    return new Date(parameter);
                }
                catch (e) {
                    throw new Error(`Invalid Serialized Date format for:
                    ${query.dbEntity.name}.${query.jsonQuery.queryName}
                    parameter #: ${parameterIndex}
        got: ${JSON.stringify(parameter)}
                    `);
                }
                break;
            case SQLDataType.NUMBER:
                this.checkTypeOfParameter(parameter, 'number', parameterIndex, query);
                break;
            case SQLDataType.STRING:
                this.checkTypeOfParameter(parameter, 'string', parameterIndex, query);
                break;
            default:
                throw new Error(`Unsupported parameter type for:
                ${query.dbEntity.name}.${query.jsonQuery.queryName}
                parameter #: ${parameterIndex}
    got: ${jsonQueryParameter.type}
                `);
        }
        return parameter;
    }
    checkTypeOfParameter(parameter, expectedParameterType, parameterIndex, query) {
        const typeOfParameter = typeof parameter;
        if (typeOfParameter !== expectedParameterType) {
            throw new Error(`Expecting a '${expectedParameterType}' parameter for:
            ${query.dbEntity.name}.${query.jsonQuery.queryName}
            parameter #: ${parameterIndex}
got: ${typeOfParameter}
            `);
        }
    }
};
QueryParameterDeserializer = __decorate$1q([
    Injected()
], QueryParameterDeserializer);

var __decorate$1p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// TODO: figure out if this is needed - originally written for serializing
// query resuts returned to the client.  Since then moved to Isolates and
// generic API calls.  Probably should be used in go-tower to serialize
// the values returned (and won't be tied to a query of any kind, API
// interface is generic, unless already known to contain entity objects.)
let QueryResultsSerializer = class QueryResultsSerializer {
    serialize(entity, dbEntity, entityStateManager, applicationUtils) {
        const operation = {
            lookupTable: [],
            sequence: 0,
            stubLookupTable: []
        };
        let serializedEntity;
        if (entity instanceof Array) {
            serializedEntity = entity.map(anEntity => this.doSerialize(anEntity, dbEntity, operation, entityStateManager, applicationUtils));
        }
        else {
            serializedEntity = this.doSerialize(entity, dbEntity, operation, entityStateManager, applicationUtils);
        }
        for (let i = 1; i < operation.lookupTable.length; i++) {
            delete operation.lookupTable[i][entityStateManager.getUniqueIdFieldName()];
        }
        return serializedEntity;
    }
    doSerialize(entity, dbEntity, operation, entityStateManager, applicationUtils) {
        // TODO: add support for non-create operations
        let operationUniqueId = entityStateManager.getOperationUniqueId(entity);
        if (operationUniqueId) {
            return operation.stubLookupTable[operationUniqueId];
        }
        operationUniqueId = ++operation.sequence;
        let entityStub = {};
        entityStub[entityStateManager.getUniqueIdFieldName()] = operationUniqueId;
        entityStub[entityStateManager.getStateFieldName()] = EntityState$1.STUB;
        operation.stubLookupTable[operationUniqueId] = entityStub;
        let entityCopy = {};
        operation.lookupTable[operationUniqueId] = entity;
        entityCopy[entityStateManager.getUniqueIdFieldName()] = operationUniqueId;
        // TODO: Test this - used to be assigned to EntitState.RESULT, which is removed
        entityCopy[entityStateManager.getStateFieldName()]
            = entity[entityStateManager.getStateFieldName()];
        for (const dbProperty of dbEntity.properties) {
            let property = entity[dbProperty.name];
            if (applicationUtils.isEmpty(property)) {
                continue;
            }
            let propertyCopy;
            if (dbProperty.relation) {
                const dbRelation = dbProperty.relation[0];
                if (property instanceof Array) {
                    propertyCopy = property.map(manyObject => {
                        this.doSerialize(manyObject, dbRelation.relationEntity, operation, entityStateManager, applicationUtils);
                    });
                }
                else {
                    propertyCopy = this.doSerialize(property, dbRelation.relationEntity, operation, entityStateManager, applicationUtils);
                }
            }
            else {
                switch (dbProperty.propertyColumns[0].column.type) {
                    case SQLDataType.JSON:
                        // 	if (property instanceof Array) {
                        // 		propertyCopy = {
                        // 			value: property
                        // 		}
                        // 		propertyCopy[entityStateManager.getStateFieldName()]
                        // 			= EntityState.RESULT_JSON_ARRAY
                        // 	} else {
                        // 		propertyCopy = property
                        // 		propertyCopy[entityStateManager.getStateFieldName()]
                        // 			= EntityState.RESULT_JSON
                        // 	}
                        throw new Error(`@Json() properties cannot be serialized.`);
                    case SQLDataType.DATE:
                        propertyCopy = {
                            value: property.toISOString()
                        };
                        propertyCopy[entityStateManager.getStateFieldName()]
                            = EntityState$1.DATE;
                        break;
                    case SQLDataType.ANY:
                    case SQLDataType.BOOLEAN:
                    case SQLDataType.NUMBER:
                    case SQLDataType.STRING:
                        propertyCopy = property;
                        break;
                    default:
                        throw new Error(`Unsupported data type for property ${dbEntity.applicationVersion.application.name}.${dbEntity.name}.${dbProperty.name}`);
                }
            }
            entityCopy[dbProperty.name] = propertyCopy;
        }
        return entityCopy;
    }
};
QueryResultsSerializer = __decorate$1p([
    Injected()
], QueryResultsSerializer);

/**
 * Created by Papa on 6/30/2016.
 */
new Date().getTime();

var __decorate$1o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Domain = class Domain {
};
__decorate$1o([
    Id(),
    DbNumber()
], Domain.prototype, "id", void 0);
__decorate$1o([
    DbString()
], Domain.prototype, "name", void 0);
__decorate$1o([
    OneToMany()
], Domain.prototype, "applications", void 0);
Domain = __decorate$1o([
    Entity(),
    Table()
], Domain);

var __decorate$1n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Application = class Application {
    constructor() {
        this.versions = [];
        this.currentVersion = [];
    }
};
__decorate$1n([
    Id(),
    DbNumber(),
    Column()
], Application.prototype, "index", void 0);
__decorate$1n([
    ManyToOne(),
    JoinColumn()
], Application.prototype, "domain", void 0);
__decorate$1n([
    Column(),
    DbString()
], Application.prototype, "scope", void 0);
__decorate$1n([
    Column(),
    DbString()
], Application.prototype, "name", void 0);
__decorate$1n([
    Column(),
    DbString()
], Application.prototype, "fullName", void 0);
__decorate$1n([
    Column(),
    DbString()
], Application.prototype, "status", void 0);
__decorate$1n([
    Column(),
    DbString()
], Application.prototype, "signature", void 0);
__decorate$1n([
    OneToMany()
], Application.prototype, "versions", void 0);
__decorate$1n([
    OneToMany()
], Application.prototype, "currentVersion", void 0);
Application = __decorate$1n([
    Entity(),
    Table()
], Application);

var __decorate$1m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let VersionedApplicationObject = class VersionedApplicationObject {
};
__decorate$1m([
    ManyToOne(),
    JoinColumn()
], VersionedApplicationObject.prototype, "deprecatedSinceVersion", void 0);
__decorate$1m([
    ManyToOne(),
    JoinColumn()
], VersionedApplicationObject.prototype, "removedInVersion", void 0);
__decorate$1m([
    ManyToOne(),
    JoinColumn()
], VersionedApplicationObject.prototype, "sinceVersion", void 0);
VersionedApplicationObject = __decorate$1m([
    MappedSuperclass()
], VersionedApplicationObject);

var __decorate$1l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationColumn = class ApplicationColumn extends VersionedApplicationObject {
    constructor() {
        super(...arguments);
        this.propertyColumns = [];
        this.manyRelationColumns = [];
        this.oneRelationColumns = [];
    }
};
__decorate$1l([
    DbNumber(),
    Id()
], ApplicationColumn.prototype, "id", void 0);
__decorate$1l([
    Column(),
    DbNumber()
], ApplicationColumn.prototype, "index", void 0);
__decorate$1l([
    Column(),
    DbNumber()
], ApplicationColumn.prototype, "idIndex", void 0);
__decorate$1l([
    Column(),
    DbBoolean()
], ApplicationColumn.prototype, "isGenerated", void 0);
__decorate$1l([
    Column(),
    DbNumber()
], ApplicationColumn.prototype, "allocationSize", void 0);
__decorate$1l([
    Column(),
    DbString()
], ApplicationColumn.prototype, "name", void 0);
__decorate$1l([
    Column(),
    DbBoolean()
], ApplicationColumn.prototype, "notNull", void 0);
__decorate$1l([
    Column(),
    DbNumber()
], ApplicationColumn.prototype, "precision", void 0);
__decorate$1l([
    Column(),
    DbNumber()
], ApplicationColumn.prototype, "scale", void 0);
__decorate$1l([
    Column(),
    DbString()
], ApplicationColumn.prototype, "type", void 0);
__decorate$1l([
    ManyToOne(),
    JoinColumn()
], ApplicationColumn.prototype, "entity", void 0);
__decorate$1l([
    OneToMany()
], ApplicationColumn.prototype, "propertyColumns", void 0);
__decorate$1l([
    OneToMany()
], ApplicationColumn.prototype, "manyRelationColumns", void 0);
__decorate$1l([
    OneToMany()
], ApplicationColumn.prototype, "oneRelationColumns", void 0);
ApplicationColumn = __decorate$1l([
    Entity(),
    Table()
], ApplicationColumn);

var __decorate$1k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationCurrentVersion = class ApplicationCurrentVersion {
};
__decorate$1k([
    Id(),
    ManyToOne(),
    JoinColumn()
], ApplicationCurrentVersion.prototype, "application", void 0);
__decorate$1k([
    Id(),
    ManyToOne(),
    JoinColumn()
], ApplicationCurrentVersion.prototype, "applicationVersion", void 0);
ApplicationCurrentVersion = __decorate$1k([
    Entity(),
    Table()
], ApplicationCurrentVersion);

var __decorate$1j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationEntity = class ApplicationEntity extends VersionedApplicationObject {
    constructor() {
        super(...arguments);
        //
        // One-to-Many's
        //
        this.columns = [];
        // TODO: implement if needed
        // @OneToMany()
        // @JoinColumns([
        // 	{name: "APPLICATION_VERSION_ID"},
        // 	{name: "TABLE_INDEX", referencedColumnName: "INDEX"}
        // ])
        // @WhereJoinTable((
        // 	otm: QApplicationEntity,
        // 	mto: QApplicationColumn
        // ) => mto.idIndex.isNotNull())
        // idColumns: IApplicationColumn[];
        this.operations = [];
        this.properties = [];
        this.relations = [];
        this.relationReferences = [];
        this.columnMap = {};
        this.idColumns = [];
        this.idColumnMap = {};
        this.propertyMap = {};
    }
};
__decorate$1j([
    DbNumber(),
    Id()
], ApplicationEntity.prototype, "id", void 0);
__decorate$1j([
    Column(),
    DbNumber()
], ApplicationEntity.prototype, "index", void 0);
__decorate$1j([
    Column(),
    DbBoolean()
], ApplicationEntity.prototype, "isLocal", void 0);
__decorate$1j([
    Column(),
    DbBoolean()
], ApplicationEntity.prototype, "isRepositoryEntity", void 0);
__decorate$1j([
    Column(),
    DbString()
], ApplicationEntity.prototype, "name", void 0);
__decorate$1j([
    Column(),
    Json()
], ApplicationEntity.prototype, "tableConfig", void 0);
__decorate$1j([
    ManyToOne(),
    JoinColumn()
], ApplicationEntity.prototype, "applicationVersion", void 0);
__decorate$1j([
    OneToMany()
], ApplicationEntity.prototype, "columns", void 0);
__decorate$1j([
    OneToMany()
], ApplicationEntity.prototype, "operations", void 0);
__decorate$1j([
    OneToMany()
], ApplicationEntity.prototype, "properties", void 0);
__decorate$1j([
    OneToMany()
], ApplicationEntity.prototype, "relations", void 0);
__decorate$1j([
    OneToMany()
], ApplicationEntity.prototype, "relationReferences", void 0);
__decorate$1j([
    Transient()
], ApplicationEntity.prototype, "columnMap", void 0);
__decorate$1j([
    Transient()
], ApplicationEntity.prototype, "idColumns", void 0);
__decorate$1j([
    Transient()
], ApplicationEntity.prototype, "idColumnMap", void 0);
__decorate$1j([
    Transient()
], ApplicationEntity.prototype, "propertyMap", void 0);
ApplicationEntity = __decorate$1j([
    Entity(),
    Table()
], ApplicationEntity);

var __decorate$1i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationOperation = class ApplicationOperation extends VersionedApplicationObject {
};
__decorate$1i([
    Id(),
    GeneratedValue(),
    DbNumber()
], ApplicationOperation.prototype, "id", void 0);
__decorate$1i([
    Column(),
    DbNumber()
], ApplicationOperation.prototype, "type", void 0);
__decorate$1i([
    ManyToOne(),
    JoinColumn()
], ApplicationOperation.prototype, "entity", void 0);
__decorate$1i([
    Column(),
    DbString()
], ApplicationOperation.prototype, "name", void 0);
__decorate$1i([
    Column(),
    Json()
], ApplicationOperation.prototype, "rule", void 0);
ApplicationOperation = __decorate$1i([
    Entity(),
    Table()
], ApplicationOperation);

var __decorate$1h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationProperty = class ApplicationProperty extends VersionedApplicationObject {
    constructor() {
        super(...arguments);
        this.propertyColumns = [];
        this.relation = [];
    }
};
__decorate$1h([
    DbNumber(),
    Id()
], ApplicationProperty.prototype, "id", void 0);
__decorate$1h([
    DbNumber(),
    Column()
], ApplicationProperty.prototype, "index", void 0);
__decorate$1h([
    DbString(),
    Column()
], ApplicationProperty.prototype, "name", void 0);
__decorate$1h([
    DbBoolean(),
    Column()
], ApplicationProperty.prototype, "isId", void 0);
__decorate$1h([
    ManyToOne(),
    JoinColumn()
], ApplicationProperty.prototype, "entity", void 0);
__decorate$1h([
    OneToMany()
], ApplicationProperty.prototype, "propertyColumns", void 0);
__decorate$1h([
    OneToMany()
], ApplicationProperty.prototype, "relation", void 0);
ApplicationProperty = __decorate$1h([
    Entity(),
    Table()
], ApplicationProperty);

var __decorate$1g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Many-to-Many between Columns and properties
 */
let ApplicationPropertyColumn = class ApplicationPropertyColumn extends VersionedApplicationObject {
};
__decorate$1g([
    Id(),
    ManyToOne(),
    JoinColumn()
], ApplicationPropertyColumn.prototype, "column", void 0);
__decorate$1g([
    Id(),
    ManyToOne(),
    JoinColumn()
], ApplicationPropertyColumn.prototype, "property", void 0);
ApplicationPropertyColumn = __decorate$1g([
    Entity()
    // TODO: rename table name to APPLICATION_PROPERTY_COLUMNS
    ,
    Table()
], ApplicationPropertyColumn);

var __decorate$1f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationReference = class ApplicationReference extends VersionedApplicationObject {
};
__decorate$1f([
    Id(),
    ManyToOne(),
    JoinColumn()
], ApplicationReference.prototype, "ownApplicationVersion", void 0);
__decorate$1f([
    Id(),
    ManyToOne(),
    JoinColumn()
], ApplicationReference.prototype, "referencedApplicationVersion", void 0);
__decorate$1f([
    Column(),
    DbNumber()
], ApplicationReference.prototype, "index", void 0);
ApplicationReference = __decorate$1f([
    Entity(),
    Table()
], ApplicationReference);

var __decorate$1e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationRelation = class ApplicationRelation extends VersionedApplicationObject {
    constructor() {
        super(...arguments);
        this.manyRelationColumns = [];
        this.oneRelationColumns = [];
    }
};
__decorate$1e([
    DbNumber(),
    Id()
], ApplicationRelation.prototype, "id", void 0);
__decorate$1e([
    DbNumber(),
    Column()
], ApplicationRelation.prototype, "index", void 0);
__decorate$1e([
    ManyToOne(),
    JoinColumn()
], ApplicationRelation.prototype, "property", void 0);
__decorate$1e([
    Json(),
    Column()
], ApplicationRelation.prototype, "foreignKey", void 0);
__decorate$1e([
    Json(),
    Column()
], ApplicationRelation.prototype, "manyToOneElems", void 0);
__decorate$1e([
    Json(),
    Column()
], ApplicationRelation.prototype, "oneToManyElems", void 0);
__decorate$1e([
    DbString(),
    Column()
], ApplicationRelation.prototype, "relationType", void 0);
__decorate$1e([
    Column()
], ApplicationRelation.prototype, "isId", void 0);
__decorate$1e([
    ManyToOne(),
    JoinColumn()
], ApplicationRelation.prototype, "entity", void 0);
__decorate$1e([
    ManyToOne(),
    JoinColumn()
], ApplicationRelation.prototype, "relationEntity", void 0);
__decorate$1e([
    OneToMany()
], ApplicationRelation.prototype, "manyRelationColumns", void 0);
__decorate$1e([
    OneToMany()
], ApplicationRelation.prototype, "oneRelationColumns", void 0);
ApplicationRelation = __decorate$1e([
    Entity(),
    Table()
], ApplicationRelation);

var __decorate$1d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationRelationColumn = class ApplicationRelationColumn extends VersionedApplicationObject {
};
__decorate$1d([
    Id()
], ApplicationRelationColumn.prototype, "id", void 0);
__decorate$1d([
    ManyToOne(),
    JoinColumn()
], ApplicationRelationColumn.prototype, "manyColumn", void 0);
__decorate$1d([
    ManyToOne(),
    JoinColumn()
], ApplicationRelationColumn.prototype, "oneColumn", void 0);
__decorate$1d([
    ManyToOne(),
    JoinColumn()
], ApplicationRelationColumn.prototype, "manyRelation", void 0);
__decorate$1d([
    ManyToOne(),
    JoinColumn()
], ApplicationRelationColumn.prototype, "oneRelation", void 0);
__decorate$1d([
    ManyToOne(),
    JoinColumn()
], ApplicationRelationColumn.prototype, "parentRelation", void 0);
ApplicationRelationColumn = __decorate$1d([
    Entity(),
    Table()
], ApplicationRelationColumn);

var __decorate$1c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationVersion = class ApplicationVersion {
    constructor() {
        this.entities = [];
        this.references = [];
        this.referencedBy = [];
        this.entityMapByName = {};
        this.referencesMapByName = {};
        this.referencedByMapByName = {};
    }
};
__decorate$1c([
    DbNumber(),
    Id(),
    SequenceGenerator$1()
], ApplicationVersion.prototype, "id", void 0);
__decorate$1c([
    Column(),
    DbNumber()
], ApplicationVersion.prototype, "integerVersion", void 0);
__decorate$1c([
    Column(),
    DbString()
], ApplicationVersion.prototype, "versionString", void 0);
__decorate$1c([
    Column(),
    DbNumber()
], ApplicationVersion.prototype, "majorVersion", void 0);
__decorate$1c([
    Column(),
    DbNumber()
], ApplicationVersion.prototype, "minorVersion", void 0);
__decorate$1c([
    Column(),
    DbNumber()
], ApplicationVersion.prototype, "patchVersion", void 0);
__decorate$1c([
    Column(),
    Json()
], ApplicationVersion.prototype, "jsonApplication", void 0);
__decorate$1c([
    ManyToOne(),
    JoinColumn()
], ApplicationVersion.prototype, "application", void 0);
__decorate$1c([
    OneToMany()
], ApplicationVersion.prototype, "entities", void 0);
__decorate$1c([
    OneToMany()
], ApplicationVersion.prototype, "references", void 0);
__decorate$1c([
    OneToMany()
], ApplicationVersion.prototype, "referencedBy", void 0);
__decorate$1c([
    Transient()
], ApplicationVersion.prototype, "entityMapByName", void 0);
__decorate$1c([
    Transient()
], ApplicationVersion.prototype, "referencesMapByName", void 0);
__decorate$1c([
    Transient()
], ApplicationVersion.prototype, "referencedByMapByName", void 0);
ApplicationVersion = __decorate$1c([
    Entity(),
    Table()
], ApplicationVersion);

const __constructors__$2 = {
    Application: Application,
    ApplicationColumn: ApplicationColumn,
    ApplicationCurrentVersion: ApplicationCurrentVersion,
    ApplicationEntity: ApplicationEntity,
    ApplicationOperation: ApplicationOperation,
    ApplicationProperty: ApplicationProperty,
    ApplicationPropertyColumn: ApplicationPropertyColumn,
    ApplicationReference: ApplicationReference,
    ApplicationRelation: ApplicationRelation,
    ApplicationRelationColumn: ApplicationRelationColumn,
    ApplicationVersion: ApplicationVersion,
    Domain: Domain,
    VersionedApplicationObject: VersionedApplicationObject
};
const Q_APPLICATION$2 = {
    __constructors__: __constructors__$2,
    domain: 'air',
    name: '@airport/airspace'
};
const Q$2 = Q_APPLICATION$2;
function duoDiSet$2(dbEntityId) {
    return duoDiSet$5(Q$2.__dbApplication__, dbEntityId);
}
DEPENDENCY_INJECTION.db().eventuallyGet(AIRPORT_DATABASE).then((airportDatabase) => {
    airportDatabase.setQApplication(Q_APPLICATION$2);
});

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$2 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q$2);
    }
}
class BaseApplicationDao extends SQDIDao$2 {
    constructor() {
        super(10);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(10);
    }
}
BaseApplicationDao.Find = new DaoQueryDecorators();
BaseApplicationDao.FindOne = new DaoQueryDecorators();
BaseApplicationDao.Search = new DaoQueryDecorators();
BaseApplicationDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationColumnDao extends SQDIDao$2 {
    constructor() {
        super(4);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(4);
    }
}
BaseApplicationColumnDao.Find = new DaoQueryDecorators();
BaseApplicationColumnDao.FindOne = new DaoQueryDecorators();
BaseApplicationColumnDao.Search = new DaoQueryDecorators();
BaseApplicationColumnDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationCurrentVersionDao extends SQDIDao$2 {
    constructor() {
        super(9);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(9);
    }
}
BaseApplicationCurrentVersionDao.Find = new DaoQueryDecorators();
BaseApplicationCurrentVersionDao.FindOne = new DaoQueryDecorators();
BaseApplicationCurrentVersionDao.Search = new DaoQueryDecorators();
BaseApplicationCurrentVersionDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationEntityDao extends SQDIDao$2 {
    constructor() {
        super(6);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(6);
    }
}
BaseApplicationEntityDao.Find = new DaoQueryDecorators();
BaseApplicationEntityDao.FindOne = new DaoQueryDecorators();
BaseApplicationEntityDao.Search = new DaoQueryDecorators();
BaseApplicationEntityDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationOperationDao extends SQDIDao$2 {
    constructor() {
        super(5);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(5);
    }
}
BaseApplicationOperationDao.Find = new DaoQueryDecorators();
BaseApplicationOperationDao.FindOne = new DaoQueryDecorators();
BaseApplicationOperationDao.Search = new DaoQueryDecorators();
BaseApplicationOperationDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationPropertyDao extends SQDIDao$2 {
    constructor() {
        super(2);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(2);
    }
}
BaseApplicationPropertyDao.Find = new DaoQueryDecorators();
BaseApplicationPropertyDao.FindOne = new DaoQueryDecorators();
BaseApplicationPropertyDao.Search = new DaoQueryDecorators();
BaseApplicationPropertyDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationPropertyColumnDao extends SQDIDao$2 {
    constructor() {
        super(3);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(3);
    }
}
BaseApplicationPropertyColumnDao.Find = new DaoQueryDecorators();
BaseApplicationPropertyColumnDao.FindOne = new DaoQueryDecorators();
BaseApplicationPropertyColumnDao.Search = new DaoQueryDecorators();
BaseApplicationPropertyColumnDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationReferenceDao extends SQDIDao$2 {
    constructor() {
        super(7);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(7);
    }
}
BaseApplicationReferenceDao.Find = new DaoQueryDecorators();
BaseApplicationReferenceDao.FindOne = new DaoQueryDecorators();
BaseApplicationReferenceDao.Search = new DaoQueryDecorators();
BaseApplicationReferenceDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationRelationDao extends SQDIDao$2 {
    constructor() {
        super(1);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(1);
    }
}
BaseApplicationRelationDao.Find = new DaoQueryDecorators();
BaseApplicationRelationDao.FindOne = new DaoQueryDecorators();
BaseApplicationRelationDao.Search = new DaoQueryDecorators();
BaseApplicationRelationDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationRelationColumnDao extends SQDIDao$2 {
    constructor() {
        super(0);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(0);
    }
}
BaseApplicationRelationColumnDao.Find = new DaoQueryDecorators();
BaseApplicationRelationColumnDao.FindOne = new DaoQueryDecorators();
BaseApplicationRelationColumnDao.Search = new DaoQueryDecorators();
BaseApplicationRelationColumnDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationVersionDao extends SQDIDao$2 {
    constructor() {
        super(8);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(8);
    }
}
BaseApplicationVersionDao.Find = new DaoQueryDecorators();
BaseApplicationVersionDao.FindOne = new DaoQueryDecorators();
BaseApplicationVersionDao.Search = new DaoQueryDecorators();
BaseApplicationVersionDao.SearchOne = new DaoQueryDecorators();
class BaseDomainDao extends SQDIDao$2 {
    constructor() {
        super(11);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$2(11);
    }
}
BaseDomainDao.Find = new DaoQueryDecorators();
BaseDomainDao.FindOne = new DaoQueryDecorators();
BaseDomainDao.Search = new DaoQueryDecorators();
BaseDomainDao.SearchOne = new DaoQueryDecorators();

// Application Q object Dependency Injection readiness detection Duo
class SQDIDuo extends Duo {
    constructor(dbEntityId) {
        super(dbEntityId, Q$2);
    }
}
class BaseApplicationVersionDuo extends SQDIDuo {
    static diSet() {
        return duoDiSet$2(8);
    }
    constructor() {
        super(8);
    }
}

var __decorate$1b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DomainDao = class DomainDao extends BaseDomainDao {
    async findByIdIn(domainIds) {
        let d;
        return await this.db.find.tree({
            select: {},
            from: [
                d = Q$2.Domain
            ],
            where: d.id.in(domainIds)
        });
    }
    async findMapByNameWithNames(domainNames) {
        let d;
        const domains = await this.db.find.tree({
            select: {},
            from: [d = Q$2.Domain],
            where: d.name.in(domainNames)
        });
        const domainMapByNameWithNames = new Map();
        for (const domain of domains) {
            domainMapByNameWithNames.set(domain.name, domain);
        }
        return domainMapByNameWithNames;
    }
    async findOneByName(name) {
        let d;
        return await this.db.findOne.tree({
            select: {},
            from: [d = Q$2.Domain],
            where: d.name.equals(name)
        });
    }
    async findByNames(names) {
        let d;
        return await this.db.find.tree({
            select: {},
            from: [d = Q$2.Domain],
            where: d.name.in(names)
        });
    }
    async findByName(name) {
        let d;
        return await this.db.findOne.tree({
            select: {},
            from: [d = Q$2.Domain],
            where: d.name.equals(name)
        });
    }
    async checkAndInsertIfNeeded(domains, context) {
        const existingDomains = await this.findByIdIn(domains.map(domain => domain.id));
        const existingDomainMap = new Map();
        for (const existingDomain of existingDomains) {
            existingDomainMap.set(existingDomain.id, existingDomain);
        }
        const newDomains = [];
        for (const domain of domains) {
            if (!existingDomainMap.has(domain.id)) {
                newDomains.push(domain);
            }
        }
        if (!newDomains.length) {
            return;
        }
        let d;
        const values = [];
        for (const domain of newDomains) {
            values.push([
                domain.id, domain.name
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: d = Q$2.Domain,
            columns: [
                d.id,
                d.name,
            ],
            values
        }, context);
    }
    async insert(domains) {
        let d;
        const values = [];
        for (const domain of domains) {
            values.push([
                domain.name
            ]);
        }
        const ids = await this.db.insertValuesGenerateIds({
            insertInto: d = Q$2.Domain,
            columns: [
                d.name
            ],
            values
        });
        for (let i = 0; i < domains.length; i++) {
            let domain = domains[i];
            domain.id = ids[i][0];
        }
    }
};
DomainDao = __decorate$1b([
    Injected()
], DomainDao);

var __decorate$1a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationColumnDao = class ApplicationColumnDao extends BaseApplicationColumnDao {
    async findAllForEntities(entityIds) {
        let c;
        return this.db.find.tree({
            select: {},
            from: [
                c = Q$2.ApplicationColumn
            ],
            where: c.entity.id.in(entityIds)
        });
    }
    async insert(applicationColumns, context) {
        let sc;
        const values = [];
        for (const applicationColumn of applicationColumns) {
            values.push([
                applicationColumn.id, applicationColumn.index,
                undefinedToNull(applicationColumn.idIndex),
                applicationColumn.isGenerated,
                undefinedToNull(applicationColumn.allocationSize),
                applicationColumn.name,
                applicationColumn.notNull,
                undefinedToNull(applicationColumn.precision),
                undefinedToNull(applicationColumn.scale),
                applicationColumn.type,
                applicationColumn.entity.id,
                applicationColumn.deprecatedSinceVersion ? applicationColumn.deprecatedSinceVersion.id : null,
                applicationColumn.removedInVersion ? applicationColumn.removedInVersion.id : null,
                applicationColumn.sinceVersion ? applicationColumn.sinceVersion.id : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: sc = Q$2.ApplicationColumn,
            columns: [
                sc.id,
                sc.index,
                sc.idIndex,
                sc.isGenerated,
                sc.allocationSize,
                sc.name,
                sc.notNull,
                sc.precision,
                sc.scale,
                sc.type,
                sc.entity.id,
                sc.deprecatedSinceVersion.id,
                sc.removedInVersion.id,
                sc.sinceVersion.id
            ],
            values
        }, context);
    }
};
ApplicationColumnDao = __decorate$1a([
    Injected()
], ApplicationColumnDao);

var __decorate$19 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationDao = class ApplicationDao extends BaseApplicationDao {
    async findAllActive() {
        return this.db.find.tree({
            select: {},
            from: [
                Q$2.Application
            ]
        });
    }
    async findAllWithJson() {
        let a;
        return this.db.find.tree({
            select: {
                ...ALL_FIELDS,
                // currentVersion: {
                // 	applicationVersion: {
                // 		id: Y,
                // 		jsonApplication: Y
                // 	}
                // }
                versions: {
                    id: Y,
                    jsonApplication: Y
                }
            },
            from: [
                a = Q$2.Application,
                // cv = a.currentVersion.innerJoin(),
                // av = cv.applicationVersion.innerJoin()
                a.versions.innerJoin()
            ]
        });
    }
    async findMapByVersionIds(applicationVersionIds) {
        const applicationMapByIndex = new Map();
        let s, sv;
        const applications = await this.db.find.tree({
            select: {
                index: Y,
                domain: {
                    id: Y,
                    name: Y
                },
                name: Y,
                fullName: Y,
                versions: {
                    id: Y,
                    majorVersion: Y,
                    minorVersion: Y,
                    patchVersion: Y
                }
            },
            from: [
                s = Q$2.Application,
                sv = s.versions.innerJoin()
            ],
            where: sv.id.in(applicationVersionIds)
        });
        for (const application of applications) {
            for (const applicationVersion of application.versions) {
                applicationMapByIndex.set(applicationVersion.id, application);
            }
        }
        return applicationMapByIndex;
    }
    async findMaxIndex() {
        const s = Q$2.Application;
        return await this.airportDatabase.findOne.field({
            select: max(s.index),
            from: [
                s
            ]
        });
    }
    async findMaxVersionedMapByApplicationAndDomainNames(applicationDomainNames, applicationNames) {
        const maxVersionedMapByApplicationAndDomainNames = new Map();
        let sv;
        let s;
        let d;
        let sMaV;
        let sMiV;
        const applicationLookupRecords = await this.airportDatabase.find.tree({
            from: [
                sMiV = tree({
                    from: [
                        sMaV = tree({
                            from: [
                                s = Q$2.Application,
                                sv = s.versions.innerJoin(),
                                d = s.domain.innerJoin()
                            ],
                            select: {
                                index: s.index,
                                domainId: d.id,
                                domainName: d.name,
                                name: s.name,
                                majorVersion: max(sv.majorVersion),
                                minorVersion: sv.minorVersion,
                                patchVersion: sv.patchVersion,
                            },
                            where: and(d.name.in(applicationDomainNames), s.name.in(applicationNames)),
                            groupBy: [
                                s.index,
                                d.id,
                                d.name,
                                s.name,
                                sv.minorVersion,
                                sv.patchVersion,
                            ]
                        })
                    ],
                    select: {
                        index: sMaV.index,
                        domainId: sMaV.domainId,
                        domainName: sMaV.domainName,
                        name: sMaV.name,
                        majorVersion: sMaV.majorVersion,
                        minorVersion: max(sMaV.minorVersion),
                        patchVersion: sMaV.patchVersion,
                    },
                    groupBy: [
                        sMaV.index,
                        sMaV.domainId,
                        sMaV.domainName,
                        sMaV.name,
                        sMaV.majorVersion,
                        sMaV.patchVersion
                    ]
                })
            ],
            select: {
                index: sMiV.index,
                domain: {
                    id: sMiV.domainId,
                    name: sMiV.domainName
                },
                name: sMiV.name,
                majorVersion: sMiV.majorVersion,
                minorVersion: sMiV.minorVersion,
                patchVersion: max(sMiV.patchVersion),
            },
            groupBy: [
                sMiV.index,
                sMiV.domainId,
                sMiV.domainName,
                sMiV.name,
                sMiV.majorVersion,
                sMiV.minorVersion
            ]
        });
        for (const applicationLookupRecord of applicationLookupRecords) {
            ensureChildJsMap(maxVersionedMapByApplicationAndDomainNames, applicationLookupRecord.domain.name)
                .set(applicationLookupRecord.name, applicationLookupRecord);
        }
        return maxVersionedMapByApplicationAndDomainNames;
    }
    async setStatusByIndexes(indexes, status) {
        let s;
        await this.db.updateWhere({
            update: s = Q$2.Application,
            set: {
                status
            },
            where: s.index.in(indexes)
        });
    }
    async findMapByFullNames(fullApplicationNames) {
        const mapByFullName = new Map();
        let s;
        const records = await this.db.find.tree({
            select: {},
            from: [
                s = Q$2.Application
            ],
            where: s.fullName.in(fullApplicationNames)
        });
        for (const record of records) {
            mapByFullName.set(record.fullName, record);
        }
        return mapByFullName;
    }
    async findByDomainNamesAndApplicationNames(domainNames, applicationNames) {
        let s;
        let d;
        return await this.db.find.tree({
            select: {
                index: Y,
                domain: {
                    id: Y,
                    name: Y
                },
                fullName: Y,
                name: Y
            },
            from: [
                s = Q$2.Application,
                d = s.domain.innerJoin()
            ],
            where: and(d.name.in(domainNames), s.name.in(applicationNames))
        });
    }
    async findByIndex(index) {
        let a;
        return await this.db.findOne.tree({
            select: {
                ...ALL_FIELDS,
                domain: {}
            },
            from: [
                a = Q$2.Application,
                a.domain.innerJoin()
            ],
            where: a.index.equals(index)
        });
    }
    async insert(applications, context) {
        let a;
        const values = [];
        for (const application of applications) {
            values.push([
                application.index, application.domain.id, application.scope,
                application.fullName, application.name,
                // application.packageName,
                application.status, application.signature
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: a = Q$2.Application,
            columns: [
                a.index,
                a.domain.id,
                a.scope,
                a.fullName,
                a.name,
                // a.packageName,
                a.status,
                a.signature
            ],
            values
        }, context);
    }
};
ApplicationDao = __decorate$19([
    Injected()
], ApplicationDao);

var __decorate$18 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationEntityDao = class ApplicationEntityDao extends BaseApplicationEntityDao {
    async findAllForApplicationVersions(applicationVersionIds) {
        let se;
        return await this.db.find.tree({
            select: {},
            from: [
                se = Q$2.ApplicationEntity
            ],
            where: se.applicationVersion.id.in(applicationVersionIds)
        });
    }
    async insert(applicationEntities, context) {
        let se;
        const values = [];
        for (const applicationEntity of applicationEntities) {
            values.push([
                applicationEntity.id, applicationEntity.index,
                applicationEntity.isLocal, applicationEntity.isRepositoryEntity,
                applicationEntity.name, applicationEntity.tableConfig,
                applicationEntity.applicationVersion.id,
                applicationEntity.deprecatedSinceVersion ? applicationEntity.deprecatedSinceVersion.id : null,
                applicationEntity.removedInVersion ? applicationEntity.removedInVersion.id : null,
                applicationEntity.sinceVersion ? applicationEntity.sinceVersion.id : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: se = Q$2.ApplicationEntity,
            columns: [
                se.id,
                se.index,
                se.isLocal,
                se.isRepositoryEntity,
                se.name,
                se.tableConfig,
                se.applicationVersion.id,
                se.deprecatedSinceVersion.id,
                se.removedInVersion.id,
                se.sinceVersion.id
            ],
            values
        }, context);
    }
};
ApplicationEntityDao = __decorate$18([
    Injected()
], ApplicationEntityDao);

var __decorate$17 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationPropertyColumnDao = class ApplicationPropertyColumnDao extends BaseApplicationPropertyColumnDao {
    async findAllForColumns(columnIds) {
        let rc;
        return this.db.find.tree({
            select: {},
            from: [
                rc = Q$2.ApplicationPropertyColumn
            ],
            where: rc.column.id.in(columnIds)
        });
    }
    async insert(applicationPropertyColumns, context) {
        let spc;
        const values = [];
        for (const applicationPropertyColumn of applicationPropertyColumns) {
            values.push([
                applicationPropertyColumn.column.id, applicationPropertyColumn.property.id,
                applicationPropertyColumn.deprecatedSinceVersion ? applicationPropertyColumn.deprecatedSinceVersion.id : null,
                applicationPropertyColumn.removedInVersion ? applicationPropertyColumn.removedInVersion.id : null,
                applicationPropertyColumn.sinceVersion ? applicationPropertyColumn.sinceVersion.id : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: spc = Q$2.ApplicationPropertyColumn,
            columns: [
                spc.column.id,
                spc.property.id,
                spc.deprecatedSinceVersion.id,
                spc.removedInVersion.id,
                spc.sinceVersion.id
            ],
            values
        }, context);
    }
};
ApplicationPropertyColumnDao = __decorate$17([
    Injected()
], ApplicationPropertyColumnDao);

var __decorate$16 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationPropertyDao = class ApplicationPropertyDao extends BaseApplicationPropertyDao {
    async findAllForEntities(entityIds) {
        let p;
        return this.db.find.tree({
            select: {},
            from: [
                p = Q$2.ApplicationProperty
            ],
            where: p.entity.id.in(entityIds)
        });
    }
    async insert(applicationProperties, context) {
        let sp;
        const values = [];
        for (const applicationProperty of applicationProperties) {
            values.push([
                applicationProperty.id, applicationProperty.index,
                applicationProperty.name, applicationProperty.isId,
                applicationProperty.entity.id,
                applicationProperty.deprecatedSinceVersion ? applicationProperty.deprecatedSinceVersion.id : null,
                applicationProperty.removedInVersion ? applicationProperty.removedInVersion.id : null,
                applicationProperty.sinceVersion ? applicationProperty.sinceVersion.id : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: sp = Q$2.ApplicationProperty,
            columns: [
                sp.id,
                sp.index,
                sp.name,
                sp.isId,
                sp.entity.id,
                sp.deprecatedSinceVersion.id,
                sp.removedInVersion.id,
                sp.sinceVersion.id
            ],
            values
        }, context);
    }
};
ApplicationPropertyDao = __decorate$16([
    Injected()
], ApplicationPropertyDao);

var __decorate$15 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationReferenceDao = class ApplicationReferenceDao extends BaseApplicationReferenceDao {
    async findAllForApplicationVersions(applicationVersionIds) {
        let sr;
        return await this.db.find.tree({
            select: {},
            from: [
                sr = Q$2.ApplicationReference
            ],
            where: sr.ownApplicationVersion.id.in(applicationVersionIds)
        });
    }
    async insert(applicationReferences, context) {
        let sr;
        const values = [];
        for (const applicationReference of applicationReferences) {
            values.push([
                applicationReference.ownApplicationVersion.id,
                applicationReference.referencedApplicationVersion.id,
                applicationReference.index,
                applicationReference.deprecatedSinceVersion ? applicationReference.deprecatedSinceVersion.id : null,
                applicationReference.removedInVersion ? applicationReference.removedInVersion.id : null,
                applicationReference.sinceVersion ? applicationReference.sinceVersion.id : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: sr = Q$2.ApplicationReference,
            columns: [
                sr.ownApplicationVersion.id,
                sr.referencedApplicationVersion.id,
                sr.index,
                sr.deprecatedSinceVersion.id,
                sr.removedInVersion.id,
                sr.sinceVersion.id
            ],
            values
        }, context);
    }
};
ApplicationReferenceDao = __decorate$15([
    Injected()
], ApplicationReferenceDao);

var __decorate$14 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationRelationColumnDao = class ApplicationRelationColumnDao extends BaseApplicationRelationColumnDao {
    async findAllForColumns(columnIds) {
        let rc;
        return this.db.find.tree({
            select: {},
            from: [
                rc = Q$2.ApplicationRelationColumn
            ],
            where: or(rc.oneColumn.id.in(columnIds), rc.manyColumn.id.in(columnIds))
        });
    }
    async insert(applicationRelationColumns, context) {
        let src;
        const values = [];
        for (const applicationRelationColumn of applicationRelationColumns) {
            values.push([
                applicationRelationColumn.id,
                applicationRelationColumn.manyColumn ? applicationRelationColumn.manyColumn.id : null,
                applicationRelationColumn.oneColumn ? applicationRelationColumn.oneColumn.id : null,
                applicationRelationColumn.manyRelation ? applicationRelationColumn.manyRelation.id : null,
                applicationRelationColumn.oneRelation ? applicationRelationColumn.oneRelation.id : null,
                applicationRelationColumn.parentRelation ? applicationRelationColumn.parentRelation.id : null,
                applicationRelationColumn.deprecatedSinceVersion ? applicationRelationColumn.deprecatedSinceVersion.id : null,
                applicationRelationColumn.removedInVersion ? applicationRelationColumn.removedInVersion.id : null,
                applicationRelationColumn.sinceVersion ? applicationRelationColumn.sinceVersion.id : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: src = Q$2.ApplicationRelationColumn,
            columns: [
                src.id,
                src.manyColumn.id,
                src.oneColumn.id,
                src.manyRelation.id,
                src.oneRelation.id,
                src.parentRelation.id,
                src.deprecatedSinceVersion.id,
                src.removedInVersion.id,
                src.sinceVersion.id
            ],
            values
        }, context);
    }
};
ApplicationRelationColumnDao = __decorate$14([
    Injected()
], ApplicationRelationColumnDao);

var __decorate$13 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationRelationDao = class ApplicationRelationDao extends BaseApplicationRelationDao {
    async findAllForProperties(propertyIds) {
        let r;
        return this.db.find.tree({
            select: {},
            from: [
                r = Q$2.ApplicationRelation
            ],
            where: r.property.id.in(propertyIds)
        });
    }
    async insert(applicationRelations, context) {
        let sr;
        const values = [];
        for (const applicationRelation of applicationRelations) {
            values.push([
                applicationRelation.id, applicationRelation.index,
                applicationRelation.property.id,
                undefinedToNull(applicationRelation.foreignKey),
                undefinedToNull(applicationRelation.manyToOneElems),
                undefinedToNull(applicationRelation.oneToManyElems),
                applicationRelation.relationType, applicationRelation.isId,
                applicationRelation.entity.id, applicationRelation.relationEntity.id,
                applicationRelation.deprecatedSinceVersion ? applicationRelation.deprecatedSinceVersion.id : null,
                applicationRelation.removedInVersion ? applicationRelation.removedInVersion.id : null,
                applicationRelation.sinceVersion ? applicationRelation.sinceVersion.id : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: sr = Q$2.ApplicationRelation,
            columns: [
                sr.id,
                sr.index,
                sr.property.id,
                sr.foreignKey,
                sr.manyToOneElems,
                sr.oneToManyElems,
                sr.relationType,
                sr.isId,
                sr.entity.id,
                sr.relationEntity.id,
                sr.deprecatedSinceVersion.id,
                sr.removedInVersion.id,
                sr.sinceVersion.id
            ],
            values
        }, context);
    }
};
ApplicationRelationDao = __decorate$13([
    Injected()
], ApplicationRelationDao);

var __decorate$12 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationVersionDao = class ApplicationVersionDao extends BaseApplicationVersionDao {
    /*
    async findAllLatestForApplicationIndexes(
        applicationIndexes: ApplicationIndex[]
    ): Promise<IApplicationVersion[]> {
        let sv: QApplicationVersion

        return await this.db.find.tree({
            from: [
                sv = Q.ApplicationVersion
            ],
            select: {},
            where: and(
                sv.id.in(this.idsForMaxVersionSelect()),
                sv.application.index.in(applicationIndexes)
            )
        })
    }
    */
    async findAllActiveOrderByApplicationIndexAndId() {
        let sv;
        // let s: QApplication
        return await this.db.find.tree({
            from: [
                sv = Q$2.ApplicationVersion,
                // s = sv.application.innerJoin()
            ],
            select: {},
            orderBy: [
                sv.application.index.asc(),
                sv.id.desc()
            ]
        });
    }
    async findByDomainNamesAndApplicationNames(domainNames, applicationNames) {
        let sv;
        let s;
        let d;
        return await this.db.find.tree({
            select: {
                id: Y,
                integerVersion: Y,
                application: {
                    domain: {
                        name: Y
                    },
                    fullName: Y,
                    name: Y
                }
            },
            from: [
                sv = Q$2.ApplicationVersion,
                s = sv.application.innerJoin(),
                d = s.domain.innerJoin()
            ],
            where: and(d.name.in(domainNames), s.name.in(applicationNames))
        });
    }
    /*
    async findMaxVersionedMapByApplicationAndDomainNames(
        applicationDomainNames: DomainName[],
        applicationNames: ApplicationName[]
    ): Promise<Map<DomainName, Map<ApplicationName, IApplicationVersion>>> {
        const maxVersionedMapByApplicationAndDomainNames
                  : Map<DomainName, Map<ApplicationName, IApplicationVersion>>
                  = new Map()

        let sv: QApplicationVersion
        let s: QApplication
        let d: QDomain

        const maxApplicationVersions: IApplicationVersion[] = <any>await this.db.find.tree({
            select: {
                integerVersion: Y,
                majorVersion: Y,
                minorVersion: Y,
                patchVersion: Y,
                application: {
                    index: Y,
                    name: Y,
                    domain: {
                        id: Y,
                        name: Y
                    }
                },
                id: Y
            },
            from: [
                sv = Q.ApplicationVersion,
                s = sv.application.innerJoin(),
                d = s.domain.innerJoin()
            ],
            where: and(
                sv.id.in(this.idsForMaxVersionSelect()),
                d.name.in(applicationDomainNames),
                s.name.in(applicationNames)
            ),
        })

        for (const maxApplicationVersion of maxApplicationVersions) {
            const application = maxApplicationVersion.application
            this.utils.ensureChildJsMap(
                maxVersionedMapByApplicationAndDomainNames, application.domain.name)
                .set(application.name, maxApplicationVersion)
        }


        return maxVersionedMapByApplicationAndDomainNames
    }

    private idsForMaxVersionSelect(): RawFieldQuery<IQNumberField> {
        let svMax
        let sv2: QApplicationVersion

        return field({
            from: [
                svMax = tree({
                    from: [
                        sv2 = Q.ApplicationVersion
                    ],
                    select: distinct({
                        integerVersion: max(sv2.integerVersion),
                        id: sv2.id,
                        applicationIndex: sv2.application.index
                    })
                })
            ],
            select: svMax.id
        })
    }
*/
    async insert(applicationVersions, context) {
        let sv;
        const values = [];
        for (const applicationVersion of applicationVersions) {
            values.push([
                applicationVersion.id, applicationVersion.integerVersion,
                applicationVersion.versionString, applicationVersion.majorVersion,
                applicationVersion.minorVersion, applicationVersion.patchVersion,
                applicationVersion.application.index, applicationVersion.jsonApplication
            ]);
        }
        await this.db.insertValuesGenerateIds({
            insertInto: sv = Q$2.ApplicationVersion,
            columns: [
                sv.id,
                sv.integerVersion,
                sv.versionString,
                sv.majorVersion,
                sv.minorVersion,
                sv.patchVersion,
                sv.application.index,
                sv.jsonApplication
            ],
            values
        }, context);
    }
};
ApplicationVersionDao = __decorate$12([
    Injected()
], ApplicationVersionDao);

var __decorate$11 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationVersionDuo = class ApplicationVersionDuo extends BaseApplicationVersionDuo {
};
ApplicationVersionDuo = __decorate$11([
    Injected()
], ApplicationVersionDuo);

const trafficPattern = lib$1('traffic-pattern');
const DOMAIN_DAO = trafficPattern.token({
    class: DomainDao,
    interface: 'IDomainDao',
    token: 'DOMAIN_DAO'
});
const APPLICATION_COLUMN_DAO = trafficPattern.token({
    class: ApplicationColumnDao,
    interface: 'IApplicationColumnDao',
    token: 'APPLICATION_COLUMN_DAO'
});
const APPLICATION_DAO = trafficPattern.token({
    class: ApplicationDao,
    interface: 'IApplicationDao',
    token: 'APPLICATION_DAO'
});
const APPLICATION_ENTITY_DAO = trafficPattern.token({
    class: ApplicationEntityDao,
    interface: 'IApplicationEntityDao',
    token: 'APPLICATION_ENTITY_DAO'
});
const APPLICATION_PROPERTY_COLUMN_DAO = trafficPattern.token({
    class: ApplicationPropertyColumnDao,
    interface: 'IApplicationPropertyColumnDao',
    token: 'APPLICATION_PROPERTY_COLUMN_DAO'
});
const APPLICATION_PROPERTY_DAO = trafficPattern.token({
    class: ApplicationPropertyDao,
    interface: 'IApplicationPropertyDao',
    token: 'APPLICATION_PROPERTY_DAO'
});
const APPLICATION_REFERENCE_DAO = trafficPattern.token({
    class: ApplicationReferenceDao,
    interface: 'IApplicationReferenceDao',
    token: 'APPLICATION_REFERENCE_DAO'
});
const APPLICATION_RELATION_COLUMN_DAO = trafficPattern.token({
    class: ApplicationRelationColumnDao,
    interface: 'IApplicationRelationColumnDao',
    token: 'APPLICATION_RELATION_COLUMN_DAO'
});
const APPLICATION_RELATION_DAO = trafficPattern.token({
    class: ApplicationRelationDao,
    interface: 'IApplicationRelationDao',
    token: 'APPLICATION_RELATION_DAO'
});
const APPLICATION_VERSION_DAO = trafficPattern.token({
    class: ApplicationVersionDao,
    interface: 'IApplicationVersionDao',
    token: 'APPLICATION_VERSION_DAO'
});
trafficPattern.token({
    class: ApplicationVersionDuo,
    interface: 'IApplicationVersionDuo',
    token: 'APPLICATION_VERSION_DUO'
});

class AbstractFunctionAdaptor {
    getFunctionCalls(clause, innerValue, qEntityMapByAlias, sqlValueProvider, context) {
        clause.appliedFunctions.forEach((appliedFunction) => {
            innerValue = this.getFunctionCall(appliedFunction, innerValue, qEntityMapByAlias, sqlValueProvider, context);
        });
        return innerValue;
    }
}

class AbstractEntityOrderByParser {
    constructor(rootSelectClauseFragment, airportDatabase, qValidator, relationManager, orderBy) {
        this.rootSelectClauseFragment = rootSelectClauseFragment;
        this.airportDatabase = airportDatabase;
        this.qValidator = qValidator;
        this.relationManager = relationManager;
        this.orderBy = orderBy;
    }
    getCommonOrderByFragment(orderByFields) {
        return orderByFields.map((orderByField) => {
            switch (orderByField.so) {
                case SortOrder.ASCENDING:
                    return `${orderByField.fa} ASC`;
                case SortOrder.DESCENDING:
                    return `${orderByField.fa} DESC`;
            }
        })
            .join(', ');
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * Will hierarchically order the results of the query using breadth-first processing.
 * Within a given entity will take into account the sort order specified in the Order By
 * clause.
 */
class EntityOrderByParser extends AbstractEntityOrderByParser {
    /**
     * Using the following algorithm
     * http://stackoverflow.com/questions/2549541/performing-breadth-first-search-recursively
     * :
     BinarySearchTree.prototype.breadthFirst = function() {
      var result = '',
      queue = [],
      current = this.root;
      if (!current) return null;
      queue.push(current);
      while (current = queue.shift()) {
            result += current.value + ' ';
            current.left && queue.push(current.left);
            current.right && queue.push(current.right);
        }
      return result;
     }
     *
     * @param joinTree
     * @param qEntityMapByAlias
     * @returns {string}
     */
    getOrderByFragment(joinTree, qEntityMapByAlias, context) {
        let orderByFragments = [];
        let orderBy = [];
        if (this.orderBy) {
            orderBy = this.orderBy.slice();
        }
        const selectFragmentQueue = [];
        let currentSelectFragment = this.rootSelectClauseFragment;
        selectFragmentQueue.push(currentSelectFragment);
        const joinNodeQueue = [];
        let currentJoinNode = joinTree;
        joinNodeQueue.push(currentJoinNode);
        // Perform breadth-first select clause traversal
        while ((currentSelectFragment = selectFragmentQueue.shift())
            && (currentJoinNode = joinNodeQueue.shift())) {
            const tableAlias = this.relationManager.getAlias(currentJoinNode.jsonRelation);
            const dbEntity = qEntityMapByAlias[tableAlias].__driver__.dbEntity;
            const currentEntityOrderBy = [];
            orderBy = orderBy.filter((orderByField) => {
                const orderByDbEntity = this.airportDatabase.applications[orderByField.si]
                    .currentVersion[0].applicationVersion.entities[orderByField.ti];
                const dbColumn = orderByDbEntity.columns[orderByField.ci];
                if (this.isForParentNode(currentJoinNode, orderByField)) {
                    throw new Error(`Found out of order entry in Order By 
					[${orderByDbEntity.applicationVersion.application.name} - ${orderByDbEntity.name}.${dbColumn.name}].
					Entries must be ordered hierarchically, in breadth-first order.`);
                }
                if (orderByField.si !== dbEntity.applicationVersion.application.index || orderByField.ti !== dbEntity.index) {
                    return true;
                }
                this.qValidator.validateReadProperty(dbColumn);
                orderByField.fa = `${tableAlias}.${dbColumn.name}`;
                currentEntityOrderBy.push(orderByField);
                return false;
            });
            // NOTE: Order by Ids is necessary to correctly reconstruct 
            // the entity graph
            const allColumnsToSortBy = [];
            const idColumnsToSortBy = [];
            // By now the select clause is guaranteed to have:
            // Either all ID columns defined on the entity (if @Id columns are defined)
            // Or ALL of the columns on the entity (if no @Id columns are defined)
            for (const propertyName in currentSelectFragment) {
                const dbProperty = dbEntity.propertyMap[propertyName];
                if (dbProperty.relation && dbProperty.relation.length) {
                    for (const dbPropertyColumn of dbProperty.propertyColumns) {
                        const dbColumn = dbPropertyColumn.column;
                        allColumnsToSortBy.push(dbColumn.name);
                        if (dbProperty.isId) {
                            idColumnsToSortBy.push(dbColumn.name);
                        }
                    }
                    if (!currentJoinNode.childNodes.length) {
                        continue;
                    }
                    const dbRelation = dbProperty.relation[0];
                    const dbEntity = dbRelation.relationEntity;
                    const matchingNodes = currentJoinNode.childNodes.filter(childNode => {
                        const jsonRelation = childNode.jsonRelation;
                        return jsonRelation.si === dbEntity.applicationVersion.application.index
                            && jsonRelation.ti === dbEntity.index;
                    });
                    if (!matchingNodes.length) {
                        return;
                    }
                    selectFragmentQueue.push(this.rootSelectClauseFragment[propertyName]);
                    const childJoinNode = currentJoinNode.getEntityRelationChildNode(dbRelation);
                    joinNodeQueue.push(childJoinNode);
                }
                else {
                    const dbColumn = dbProperty.propertyColumns[0].column;
                    allColumnsToSortBy.push(dbColumn.name);
                    // Tentatively add column to the list of columnIndexes to sort by
                    if (dbProperty.isId) {
                        idColumnsToSortBy.push(dbColumn.name);
                    }
                }
            }
            let entityOrderByFragments = this.buildOrderByFragmentForEntity(tableAlias, allColumnsToSortBy, idColumnsToSortBy, currentEntityOrderBy, qEntityMapByAlias);
            orderByFragments = orderByFragments.concat(entityOrderByFragments);
        }
        if (orderBy.length) {
            throw new Error(`
			Found entries in Order By for tables not found in select clause.  
			Entries must be ordered hierarchically, in breadth-first order.`);
        }
        return orderByFragments.join(', ');
    }
    buildOrderByFragmentForEntity(tableAlias, allColumnsToSortBy, idColumnsToSortBy, currentEntityOrderBy, qEntityMapByAlias) {
        const finalOrderByColumnsFragments = [];
        const inputOrderByPropertyNameSet = {};
        const dbEntity = qEntityMapByAlias[tableAlias].__driver__.dbEntity;
        // First add the fields specified in the Order By clause for this entity
        currentEntityOrderBy.forEach((orderByField) => {
            finalOrderByColumnsFragments.push(orderByField);
            const columnName = dbEntity.columns[orderByField.ci].name;
            inputOrderByPropertyNameSet[columnName] = true;
        });
        if (idColumnsToSortBy.length) {
            // Then if the ID column is present in the result set, just order by id
            for (const idColumnName of idColumnsToSortBy) {
                if (!inputOrderByPropertyNameSet[idColumnName]) {
                    finalOrderByColumnsFragments.push({
                        fa: `${tableAlias}.${idColumnName}`,
                        so: SortOrder.ASCENDING
                    });
                }
            }
        }
        else {
            allColumnsToSortBy.forEach((columnName) => {
                if (!inputOrderByPropertyNameSet[columnName]) {
                    finalOrderByColumnsFragments.push({
                        fa: `${tableAlias}.${columnName}`,
                        so: SortOrder.ASCENDING
                    });
                }
            });
        }
        return this.getCommonOrderByFragment(finalOrderByColumnsFragments);
    }
    isForParentNode(joinTreeNode, orderByField) {
        do {
            joinTreeNode = joinTreeNode.parentNode;
            if (!joinTreeNode) {
                return false;
            }
            if (orderByField.si === joinTreeNode.jsonRelation.si
                && orderByField.ti === joinTreeNode.jsonRelation.ti) {
                return true;
            }
        } while (joinTreeNode.parentNode);
        return false;
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * Will order the results exactly as specified in the Order By clause
 */
class ExactOrderByParser {
    constructor(validator) {
        this.validator = validator;
    }
    getOrderByFragment(rootSelectClauseFragment, orderBy) {
        return orderBy.map((orderByField) => {
            this.validator.validateAliasedFieldAccess(orderByField.fa);
            switch (orderByField.so) {
                case SortOrder.ASCENDING:
                    return `${orderByField.fa} ASC`;
                case SortOrder.DESCENDING:
                    return `${orderByField.fa} DESC`;
            }
        })
            .join(', ');
    }
}

/**
 * Created by Papa on 11/8/2016.
 */
/**
 * Will hierarchically order the results of the query using breadth-first processing.
 * Within a given sub-select facade will take into account the sort order specified in the Order
 * By clause.
 */
class MappedOrderByParser {
    constructor(validator) {
        this.validator = validator;
    }
    /**
     * Using the following algorithm
     * http://stackoverflow.com/questions/2549541/performing-breadth-first-search-recursively
     * :
     BinarySearchTree.prototype.breadthFirst = function() {
      var result = '',
      queue = [],
      current = this.root;

      if (!current) return null;
      queue.push(current);

      while (current = queue.shift()) {
            result += current.value + ' ';
            current.left && queue.push(current.left);
            current.right && queue.push(current.right);
        }
      return result;
     }
     *
     * @param joinTree
     * @param qEntityMapByAlias
     * @returns {string}
     */
    getOrderByFragment(rootSelectClauseFragment, originalOrderBy) {
        let orderByFragments = [];
        let orderBy = [];
        if (originalOrderBy) {
            orderBy = originalOrderBy.slice();
        }
        let selectFragmentQueue = [];
        let currentSelectFragment = rootSelectClauseFragment;
        selectFragmentQueue.push(currentSelectFragment);
        // Breadth first traversal using a queue
        while (currentSelectFragment = selectFragmentQueue.shift()) {
            let currentSelectFragmentFieldSet = {};
            for (let propertyName in currentSelectFragment) {
                let field = currentSelectFragment[propertyName];
                if (!field.appliedFunctions) {
                    selectFragmentQueue.push(field);
                    continue;
                }
                currentSelectFragmentFieldSet[field.fa] = true;
            }
            let currentEntityOrderBy = [];
            // First add the fields specified in the query Order By clause for this entity, in the
            // order they are specified
            orderBy = orderBy.filter((orderByField) => {
                if (!currentSelectFragmentFieldSet[orderByField.fa]) {
                    return true;
                }
                delete currentSelectFragmentFieldSet[orderByField.fa];
                currentEntityOrderBy.push(orderByField);
                return false;
            });
            // Then add all the rest of the fields for this entity, we are maintaining the tree
            // structure of the result
            for (let alias in currentSelectFragmentFieldSet) {
                currentEntityOrderBy.push({
                    fa: alias,
                    so: SortOrder.ASCENDING
                });
            }
            let entityOrderByFragments = this.buildOrderByFragmentForEntity(currentEntityOrderBy);
            orderByFragments = orderByFragments.concat(entityOrderByFragments);
        }
        if (orderBy.length) {
            throw new Error(`Found entries in Order By for tables not found in select clause.  Entries must be ordered hierarchically, in breadth-first order.`);
        }
        return orderByFragments.join(', ');
    }
    buildOrderByFragmentForEntity(orderByFields) {
        return orderByFields.map((orderByField) => {
            this.validator.validateAliasedFieldAccess(orderByField.fa);
            switch (orderByField.so) {
                case SortOrder.ASCENDING:
                    return `${orderByField.fa} ASC`;
                case SortOrder.DESCENDING:
                    return `${orderByField.fa} DESC`;
            }
        });
    }
}

// For MtO mapping in bridged queries
class GraphMtoMapper {
    constructor() {
        // Map of all objects that have a given MtO reference
        // [] MtO reference Application Entity Index
        // [] MtO reference Entity Index
        this.mtoStubReferenceMap = [];
    }
    addMtoReference(mtoStubReference, mtoEntityIdValue) {
        const mtoDbEntity = mtoStubReference.mtoDbEntity;
        let mtoEntitiesForTypeMap = ensureChildMap(ensureChildArray(this.mtoStubReferenceMap, mtoDbEntity.applicationVersion.application.index), mtoDbEntity.index);
        let mtosForEntity = ensureChildMap(mtoEntitiesForTypeMap, mtoEntityIdValue);
        mtosForEntity[mtoStubReference.mtoRelationField] = mtoStubReference;
    }
    populateMtos(entityMap) {
        for (const applicationIndex in this.mtoStubReferenceMap) {
            const mtoEntitiesForApplicationMap = this.mtoStubReferenceMap[applicationIndex];
            for (const entityIndex in mtoEntitiesForApplicationMap) {
                const mtoEntitiesForTypeMap = mtoEntitiesForApplicationMap[entityIndex];
                for (let mtoEntityId in mtoEntitiesForTypeMap) {
                    let mtosForEntity = mtoEntitiesForTypeMap[mtoEntityId];
                    for (let mtoPropertyName in mtosForEntity) {
                        let mtoStubReference = mtosForEntity[mtoPropertyName];
                        let otmDbEntity = mtoStubReference.otmDbEntity;
                        if (!entityMap[otmDbEntity.applicationVersion.application.index]) {
                            continue;
                        }
                        let otmEntitiesForTypeMap = entityMap[otmDbEntity.applicationVersion.application.index][otmDbEntity.index];
                        if (!otmEntitiesForTypeMap) {
                            continue;
                        }
                        let otmEntity = otmEntitiesForTypeMap[mtoStubReference.otmEntityId];
                        if (!otmEntity) {
                            continue;
                        }
                        mtoStubReference.mtoParentObject[mtoStubReference.mtoRelationField] = otmEntity;
                    }
                }
            }
        }
    }
}

// For OtM mapping in bridged queries
class GraphOtmMapper {
    constructor() {
        // Map of MtO referred objects by OtM references
        // [] OTM Reference Entity Application Index
        // [] OTM Reference Entity Index
        this.mtoEntityReferenceMap = [];
        // Map of objects with OtM references by
        // [] OtM reference Application Entity Index
        // [] OtM reference Entity Index
        this.otmEntityReferenceMap = [];
    }
    addMtoReference(mtoStubReference, mtoEntityId, dbEntity, context) {
        // If the @OneToMany({ mappedBy: ... }) is missing, there is nothing to map to
        if (!mtoStubReference.otmEntityField) {
            return;
        }
        // Add into mtoEntityReferenceMap
        const otmDbEntity = mtoStubReference.otmDbEntity;
        let mtoEntityReferenceMapForEntity = ensureChildMap(ensureChildArray(this.mtoEntityReferenceMap, otmDbEntity.applicationVersion.application.index), otmDbEntity.index);
        // TODO: MappedEntityArray is not serializable, make it so before using
        // let mtoEntityReferenceMapForEntity: {
        // 	[otmReferenceId: string]: { [otmProperty: string]: MappedEntityArray<any> }
        // }                 = ensureChildMap(
        // 	ensureChildArray(this.mtoEntityReferenceMap, otmDbEntity.applicationVersion.application.index),
        // 	otmDbEntity.index
        // )
        // let mapForOtmEntity: { [otmProperty: string]: MappedEntityArray<any> } = mtoEntityReferenceMapForEntity[mtoStubReference.otmEntityId]
        let mapForOtmEntity = mtoEntityReferenceMapForEntity[mtoStubReference.otmEntityId];
        if (!mapForOtmEntity) {
            mapForOtmEntity = {};
            mtoEntityReferenceMapForEntity[mtoStubReference.otmEntityId] = mapForOtmEntity;
        }
        // let mtoCollection: MappedEntityArray<any> = mapForOtmEntity[mtoStubReference.otmEntityField]
        let mtoCollection = mapForOtmEntity[mtoStubReference.otmEntityField];
        if (!mtoCollection) {
            // mtoCollection = newMappedEntityArray<any>(this.applicationUtils, dbEntity)
            mtoCollection = [];
            mapForOtmEntity[mtoStubReference.otmEntityField]
                = mtoCollection;
        }
        // mtoCollection.put(mtoStubReference.mtoParentObject)
        mtoCollection.push(mtoStubReference.mtoParentObject);
    }
    addOtmReference(otmStubReference, otmEntityIdValue) {
        // Add into otoEntityReferenceMap
        const otmDbEntity = otmStubReference.otmDbEntity;
        let mtoEntityReferenceMapForEntity = ensureChildMap(ensureChildArray(this.otmEntityReferenceMap, otmDbEntity.applicationVersion.application.index), otmDbEntity.index);
        let otmRecordByPropertyName = mtoEntityReferenceMapForEntity[otmEntityIdValue];
        if (!otmRecordByPropertyName) {
            otmRecordByPropertyName = {};
            mtoEntityReferenceMapForEntity[otmEntityIdValue] = otmRecordByPropertyName;
        }
        otmRecordByPropertyName[otmStubReference.otmPropertyName] = otmStubReference.otmObject;
    }
    populateOtms(entityMap, keepMappedEntityArrays) {
        for (const applicationIndex in this.mtoEntityReferenceMap) {
            const mtoEntityReferenceMapForApplication = this.mtoEntityReferenceMap[applicationIndex];
            for (const entityIndex in mtoEntityReferenceMapForApplication) {
                const mtoEntityReferenceMapForEntity = mtoEntityReferenceMapForApplication[entityIndex];
                // If there are no entities of this type in query results, just keep the stubs
                if (!entityMap[applicationIndex]) {
                    continue;
                }
                let entityOfTypeMap = entityMap[applicationIndex][entityIndex];
                // If there are no entities of this type in query results, just keep the stubs
                if (!entityOfTypeMap) {
                    continue;
                }
                // If there are no OTM for this type in query results, no mapping needs to happen
                if (!this.otmEntityReferenceMap[applicationIndex]) {
                    continue;
                }
                let entityWithOtmMap = this.otmEntityReferenceMap[applicationIndex][entityIndex];
                // If there are no OTM for this type in query results, no mapping needs to happen
                if (!entityWithOtmMap) {
                    continue;
                }
                for (let otmEntityId in mtoEntityReferenceMapForEntity) {
                    let referencedEntitiesByPropertyMap = mtoEntityReferenceMapForEntity[otmEntityId];
                    let otmRecordByPropertyName = entityWithOtmMap[otmEntityId];
                    // If there are no OtMs for this entity, no mapping needs to happen
                    if (!otmRecordByPropertyName) {
                        continue;
                    }
                    for (let otmProperty in referencedEntitiesByPropertyMap) {
                        let otmEntity = otmRecordByPropertyName[otmProperty];
                        // If OtM entity doesn't have this collection, no mapping needs to happen
                        if (!otmEntity) {
                            continue;
                        }
                        let referencedEntityMap = referencedEntitiesByPropertyMap[otmProperty];
                        let otmCollection = otmEntity[otmProperty];
                        // If @OneToMany isn't set yet
                        if (!otmCollection) {
                            otmEntity[otmProperty] = referencedEntityMap;
                        }
                        else {
                            otmCollection.putAll(referencedEntityMap);
                        }
                        if (!keepMappedEntityArrays) {
                            otmRecordByPropertyName[otmProperty] = otmEntity[otmProperty].slice();
                        }
                    }
                }
            }
        }
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
class AbstractObjectResultParser {
    constructor(applicationUtils, entityStateManager, utils) {
        this.applicationUtils = applicationUtils;
        this.entityStateManager = entityStateManager;
        this.utils = utils;
    }
    addManyToOneStub(resultObject, propertyName, relationInfos, context) {
        let manyToOneStub = {};
        this.entityStateManager.isStub(manyToOneStub);
        resultObject[propertyName] = manyToOneStub;
        let haveAllIds = true;
        relationInfos.forEach((relationInfo) => {
            if (this.applicationUtils.isIdEmpty(relationInfo.value)) {
                haveAllIds = false;
                return;
            }
            let lastObject;
            let currentObject = manyToOneStub;
            let currentIndex = 1;
            const propertyNameChain = relationInfo.propertyNameChains[0];
            while (currentIndex < propertyNameChain.length) {
                // If there is no object in context, create one
                if (!currentObject) {
                    currentObject = {};
                    this.entityStateManager.markAsStub(currentObject);
                    lastObject[propertyNameChain[currentIndex - 1]] = currentObject;
                }
                // If it's not a leaf (more objects in the chain exist)
                if (currentIndex < propertyNameChain.length - 1) {
                    lastObject = currentObject;
                    currentObject = lastObject[propertyNameChain[currentIndex]];
                }
                else {
                    // Otherwise, just assign the value
                    currentObject[propertyNameChain[currentIndex]] = relationInfo.value;
                }
                currentIndex++;
            }
        });
        return haveAllIds;
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * The goal of this parser to to bridge all entity references and arrive at an
 * inter-connected graph (where possible).
 */
class EntityGraphResultParser extends AbstractObjectResultParser {
    constructor(config, rootDbEntity, applicationUtils, entityStateManager, utils) {
        super(applicationUtils, entityStateManager, utils);
        this.config = config;
        this.rootDbEntity = rootDbEntity;
        // Keys can only be strings or numbers | TODO: change to JS Maps, if needed
        this.entityMapByApplicationAndTableIndexes = [];
        // One-To-Many & MtO temp stubs (before entityId is available)
        this.otmStubBuffer = [];
        this.mtoStubBuffer = [];
        // Used in ENTITY_FLATTENED queries
        this.currentResultRow = [];
        this.otmMapper = new GraphOtmMapper();
        this.mtoMapper = new GraphMtoMapper();
    }
    addEntity(entityAlias, dbEntity, context) {
        return this.applicationUtils.getNewEntity(dbEntity);
    }
    addProperty(entityAlias, resultObject, dataType, propertyName, propertyValue) {
        resultObject[propertyName] = propertyValue;
        return this.utils.objectExists(propertyValue);
    }
    bufferManyToOneStub(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, relationInfos, context) {
        const oneToManyStubAdded = this.addManyToOneStub(resultObject, propertyName, relationInfos, context);
        if (oneToManyStubAdded) {
            const relatedEntityId = this.applicationUtils.getIdKey(resultObject[propertyName], relationDbEntity);
            this.bufferManyToOne(dbEntity, propertyName, relationDbEntity, relatedEntityId);
        }
    }
    bufferBlankManyToOneStub(entityAlias, resultObject, propertyName) {
        resultObject[propertyName] = null;
        // Nothing to do for bridged parser - bridging will map blanks, where possible
    }
    bufferManyToOneObject(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, childResultObject, context) {
        resultObject[propertyName] = childResultObject;
        const relatedEntityId = this.applicationUtils.getIdKey(resultObject[propertyName], relationDbEntity);
        this.bufferManyToOne(dbEntity, propertyName, relationDbEntity, relatedEntityId);
    }
    bufferBlankManyToOneObject(entityAlias, resultObject, propertyName) {
        resultObject[propertyName] = null;
        // Nothing to do for bridged parser - bridging will map blanks, where possible
    }
    bufferOneToManyStub(otmDbEntity, otmPropertyName) {
        this.bufferOneToMany(otmDbEntity, otmPropertyName);
    }
    bufferOneToManyCollection(entityAlias, resultObject, otmDbEntity, propertyName, relationDbEntity, childResultObject, context) {
        this.bufferOneToMany(otmDbEntity, propertyName);
        // TODO: MappedEntityArray is not serializable, make it so before using
        // let childResultsArray = newMappedEntityArray(this.applicationUtils, relationDbEntity)
        // childResultsArray.put(childResultObject)
        // resultObject[propertyName] = childResultsArray
        resultObject[propertyName] = [childResultObject];
    }
    bufferBlankOneToMany(entityAlias, resultObject, otmEntityName, propertyName, relationDbEntity, context) {
        // TODO: MappedEntityArray is not serializable, make it so before using
        // resultObject[propertyName] = newMappedEntityArray<any>(this.applicationUtils, relationDbEntity)
        resultObject[propertyName] = [];
    }
    flushEntity(entityAlias, dbEntity, selectClauseFragment, entityIdValue, resultObject, context) {
        if (!entityIdValue) {
            throw new Error(`No Id provided for entity 
			'${dbEntity.applicationVersion.application.name}.${dbEntity.name}'`);
        }
        let currentEntity = this.getEntityToFlush(dbEntity, selectClauseFragment, entityIdValue, resultObject, context);
        this.flushRelationStubBuffers(entityIdValue, currentEntity, dbEntity, context);
        return currentEntity;
    }
    flushRow() {
        // Nothing to do, bridged queries don't rely on rows changing
    }
    bridge(parsedResults, selectClauseFragment, context) {
        this.mtoMapper.populateMtos(this.entityMapByApplicationAndTableIndexes);
        this.otmMapper.populateOtms(this.entityMapByApplicationAndTableIndexes, !this.config || this.config.mapped);
        // merge any out of order entity references (there shouldn't be any)
        // TODO: MappedEntityArray is not serializable, make it so before using
        // let resultMEA = newMappedEntityArray(this.applicationUtils, this.rootDbEntity)
        // resultMEA.putAll(parsedResults)
        // if (!this.config || this.config.mapped) {
        // 	return resultMEA
        // }
        // return resultMEA.toArray()
        return parsedResults;
    }
    bufferManyToOne(dbEntity, propertyName, relationDbEntity, relatedEntityId) {
        let otmEntityField;
        for (const dbRelation of relationDbEntity.relations) {
            switch (dbRelation.relationType) {
                case EntityRelationType.ONE_TO_MANY:
                    break;
                case EntityRelationType.MANY_TO_ONE:
                    continue;
                default:
                    throw new Error(`Unknown EntityRelationType: ${dbRelation.relationType}`);
            }
            if (dbRelation.oneToManyElems && dbRelation.oneToManyElems.mappedBy) {
                if (dbEntity.id === dbRelation.relationEntity.id
                    || dbRelation.oneToManyElems.mappedBy === propertyName) {
                    otmEntityField = dbRelation.property.name;
                }
            }
        }
        this.mtoStubBuffer.push({
            otmEntityId: relatedEntityId,
            otmDbEntity: relationDbEntity,
            otmEntityField: otmEntityField,
            mtoDbEntity: dbEntity,
            mtoRelationField: propertyName,
            mtoParentObject: null
        });
    }
    bufferOneToMany(otmDbEntity, otmPropertyName) {
        this.otmStubBuffer.push({
            otmDbEntity: otmDbEntity,
            otmPropertyName: otmPropertyName,
            otmObject: null
        });
    }
    getEntityToFlush(dbEntity, selectClauseFragment, idValue, resultObject, context) {
        if (!idValue) {
            throw new Error(`Entity ID not specified for entity 
			'${dbEntity.applicationVersion.application.name}.${dbEntity.name}'.`);
        }
        let entityMapForName = ensureChildMap(ensureChildArray(this.entityMapByApplicationAndTableIndexes, dbEntity.applicationVersion.application.index), dbEntity.index);
        let existingEntity = entityMapForName[idValue];
        let currentEntity = this.mergeEntities(existingEntity, resultObject, dbEntity, selectClauseFragment, context);
        entityMapForName[idValue] = currentEntity;
        return currentEntity;
    }
    // Must merge the one-to-many relationships returned as part of the result tree
    /**
     * Merge entities with of the same class and with the same Id
     *
     * @param source
     * @param target
     * @param qEntity
     * @param selectClauseFragment
     * @param entityPropertyTypeMap
     * @param entityRelationMap
     * @returns {any}
     */
    mergeEntities(source, target, dbEntity, selectClauseFragment, context) {
        if (!source || target === source) {
            return target;
        }
        const id = this.applicationUtils.getIdKey(target, dbEntity);
        for (let propertyName in selectClauseFragment) {
            if (selectClauseFragment[propertyName] === undefined) {
                continue;
            }
            const dbProperty = dbEntity.propertyMap[propertyName];
            // Merge properties (conflicts detected at query parsing time):
            if (!dbProperty.relation || !dbProperty.relation.length) {
                // If source property doesn't exist
                if (this.applicationUtils.isEmpty(source[propertyName])) {
                    // set the source property to value of target
                    source[propertyName] = target[propertyName];
                }
                // Else if target property doesn't exist, keep the source value
                // Else, assume that properties must be the same
            }
            // Merge relations
            else {
                const childSelectClauseFragment = selectClauseFragment[propertyName];
                // For stubs (conflicts detected at query parsing time)
                if (childSelectClauseFragment == null) {
                    // For Many-to-One stubs, assume they are are the same and don't detect
                    // conflicts, just merge
                    source[propertyName] = target[propertyName];
                    // Don't process One-to-Many stubs yet (not all related MTOs may have been
                    // collected).
                }
                // For actual objects
                else {
                    const dbRelation = dbProperty.relation[0];
                    const childDbEntity = dbRelation.relationEntity;
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            // Many-to-One (conflicts detected at query parsing time)
                            // If source is missing this mapping and target has it
                            if (source[propertyName] === undefined && target[propertyName] !== undefined) {
                                // set the source property to value of target
                                source[propertyName] = target[propertyName];
                            }
                            // Else if target property doesn't exist, keep the source value
                            // Assume that the child objects have already been merged themselves and
                            // don't process
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            let sourceArray = source[propertyName];
                            const targetArray = target[propertyName];
                            // Because parseQueryResult is depth-first, all child objects have already
                            // been processed
                            // TODO: this will probably fail, since the merged in array should always
                            // have only one entity in it because it is created for a single result set
                            // row.
                            if (this.config && this.config.strict) {
                                if ((!sourceArray && targetArray)
                                    || (!targetArray && sourceArray)
                                    || sourceArray.length != targetArray.length) {
                                    throw new Error(`One-to-Many child arrays don't match for 
									'${dbEntity.name}.${dbProperty.name}', Id: ${id}`);
                                }
                            }
                            const sourceSet = {};
                            if (sourceArray) {
                                sourceArray.forEach((sourceChild) => {
                                    const sourceChildIdValue = this.applicationUtils.getIdKey(sourceChild, childDbEntity);
                                    sourceSet[sourceChildIdValue] = sourceChild;
                                });
                            }
                            else {
                                sourceArray = [];
                                source[propertyName] = sourceArray;
                            }
                            if (targetArray) {
                                targetArray.forEach((targetChild) => {
                                    const targetChildIdValue = this.applicationUtils.getIdKey(targetChild, childDbEntity);
                                    if (this.config && this.config.strict && !sourceSet[targetChildIdValue]) {
                                        throw new Error(`One-to-Many child arrays don't match for 
										'${dbEntity.name}.${dbProperty.name}', Id: ${id}`);
                                    }
                                    // If target child array has a value that source doesn't
                                    if (!sourceSet[targetChildIdValue]) {
                                        // add it to source (preserve order)
                                        sourceArray.put(targetChild);
                                    }
                                });
                            }
                            // So instead just do
                            // sourceArray.putAll(targetArray);
                            break;
                        default:
                            throw new Error(`Unknown relation type '${dbRelation.relationType}' for 
							'${dbEntity.name}.${dbProperty.name}'`);
                    }
                }
            }
        }
        return source;
    }
    flushRelationStubBuffers(entityIdValue, currentEntity, dbEntity, context) {
        let otmStubBuffer = this.otmStubBuffer;
        this.otmStubBuffer = [];
        otmStubBuffer.forEach((otmStub) => {
            otmStub.otmObject = currentEntity;
            this.otmMapper.addOtmReference(otmStub, entityIdValue);
        });
        let mtoStubBuffer = this.mtoStubBuffer;
        this.mtoStubBuffer = [];
        mtoStubBuffer.forEach((mtoStub) => {
            mtoStub.mtoParentObject = currentEntity;
            this.otmMapper.addMtoReference(mtoStub, entityIdValue, dbEntity, context);
            this.mtoMapper.addMtoReference(mtoStub, entityIdValue);
        });
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * The goal of this Parser is to determine which objects in the current row are the same
 * as they were in the previous row.  If the objects are the same this parser will merge
 * them.
 */
class TreeResultParser extends AbstractObjectResultParser {
    constructor() {
        super(...arguments);
        this.currentRowObjectMap = {};
        this.objectEqualityMap = {};
        this.lastRowObjectMap = {};
        this.currentObjectOneToManys = {};
    }
    addProperty(entityAlias, resultObject, dataType, propertyName, propertyValue) {
        resultObject[propertyName] = propertyValue;
        if (this.isDifferentOrDoesntExist(entityAlias, resultObject, propertyName)) {
            return this.utils.objectExists(propertyValue);
        }
        // Both last and current objects must exist here
        let lastObject = this.lastRowObjectMap[entityAlias];
        // Both of the properties are truthy
        switch (dataType) {
            case SQLDataType.DATE:
                this.objectEqualityMap[entityAlias] = (lastObject[propertyName].getTime() === resultObject[propertyName].getTime());
                break;
            default:
                this.objectEqualityMap[entityAlias] = (lastObject[propertyName] === resultObject[propertyName]);
                break;
        }
        return true;
    }
    flushRow() {
        this.lastRowObjectMap = this.currentRowObjectMap;
        this.currentRowObjectMap = {};
    }
    isDifferentOrDoesntExist(entityAlias, resultObject, propertyName) {
        // If we already know that this is a new facade, no need to keep on checking
        if (!this.objectEqualityMap[entityAlias]) {
            return true;
        }
        let lastObject = this.lastRowObjectMap[entityAlias];
        // If there was no last facade
        if (!lastObject) {
            this.objectEqualityMap[entityAlias] = false;
            return true;
        }
        if (!resultObject) {
            return true;
        }
        // Types are guaranteed to be the same, so:
        // If the last property is not there or is falsy
        if (!lastObject[propertyName]) {
            this.objectEqualityMap[entityAlias] = !resultObject[propertyName];
            return true;
        } // If the current property is not there or is falsy
        else if (!resultObject[propertyName]) {
            this.objectEqualityMap[entityAlias] = !lastObject[propertyName];
            return true;
        }
        return false;
    }
    addOneToManyCollection(entityAlias, resultObject, propertyName) {
        let currentOtmCollection = resultObject[propertyName];
        this.currentObjectOneToManys[propertyName] = currentOtmCollection;
        if (this.isDifferentOrDoesntExist(entityAlias, resultObject, propertyName)) {
            return;
        }
        let lastObject = this.lastRowObjectMap[entityAlias];
        let lastOtmCollection = lastObject[propertyName];
        // Now both arrays are guaranteed to exist
        // TODO: verify assumption below:
        // For @OneToMany collections, if existence of last child facade changes it must be a
        // new facade
        if (!lastOtmCollection.length) {
            if (currentOtmCollection.length) {
                this.objectEqualityMap[entityAlias] = false;
            }
        }
        else if (!currentOtmCollection.length) {
            if (lastOtmCollection.length) {
                this.objectEqualityMap[entityAlias] = false;
            }
        }
        // Otherwise if it still exists
    }
    mergeEntity(entityAlias, resultObject) {
        let isSameObjectAsLastRow = this.objectEqualityMap[entityAlias];
        this.objectEqualityMap[entityAlias] = true;
        let oneToManys = this.currentObjectOneToManys;
        this.currentObjectOneToManys = {};
        // If it's a new facade
        if (!isSameObjectAsLastRow) {
            return resultObject;
        }
        // All equality checks have passed - this is the same exact facade as last time
        resultObject = this.lastRowObjectMap[entityAlias];
        this.currentRowObjectMap[entityAlias] = resultObject;
        // All @ManyToOnes have been merged automatically (because they are entities
        // themselves)
        // For @OneToManys:
        // If the current one it the same as the last one of the ones in the last entity then
        // it's the same otherwise its new and should be added to the collection
        for (let oneToManyProperty in oneToManys) {
            let currentOneToMany = oneToManys[oneToManyProperty];
            if (currentOneToMany && currentOneToMany.length) {
                // There will always be only one current record, since this is done per result
                // set row
                let currentMto = currentOneToMany[0];
                let existingOneToMany = resultObject[oneToManyProperty];
                if (!existingOneToMany || !existingOneToMany.length) {
                    resultObject[oneToManyProperty] = currentOneToMany;
                }
                // Otherwise if the last facade doesn't match then its a new one
                else if (existingOneToMany[existingOneToMany.length - 1] !== currentMto) {
                    existingOneToMany.push(currentMto);
                }
            }
        }
        return resultObject;
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * The goal of this Parser is to determine which objects in the current row are the same
 * as they were in the previous row.  If the objects are the same this parser will merge
 * them.
 */
class EntityTreeResultParser extends TreeResultParser {
    constructor() {
        super(...arguments);
        this.currentRowObjectMap = {};
        this.objectEqualityMap = {};
        this.lastRowObjectMap = {};
        this.currentObjectOneToManys = {};
    }
    addEntity(entityAlias, dbEntity, context) {
        let resultObject = this.applicationUtils.getNewEntity(dbEntity);
        this.currentRowObjectMap[entityAlias] = resultObject;
        if (this.objectEqualityMap[entityAlias] !== undefined) {
            this.objectEqualityMap[entityAlias] = true;
        }
        return resultObject;
    }
    bufferManyToOneStub(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, relationInfos, context) {
        this.addManyToOneStub(resultObject, propertyName, relationInfos, context);
        this.addManyToOneReference(entityAlias, resultObject, propertyName);
    }
    bufferBlankManyToOneStub(entityAlias, resultObject, propertyName) {
        resultObject[propertyName] = null;
        this.addManyToOneReference(entityAlias, resultObject, propertyName);
    }
    bufferManyToOneObject(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, childResultObject, context) {
        resultObject[propertyName] = childResultObject;
        if (this.isDifferentOrDoesntExist(entityAlias, resultObject, propertyName)) {
            return;
        }
        // Both last and current objects must exist here
        let lastObject = this.lastRowObjectMap[entityAlias];
        // @ManyToOne objects will have been merged by now, just check if its the same facade
        this.objectEqualityMap[entityAlias] = lastObject[propertyName] === resultObject[propertyName];
    }
    bufferBlankManyToOneObject(entityAlias, resultObject, propertyName) {
        resultObject[propertyName] = null;
        this.addManyToOneReference(entityAlias, null, propertyName);
    }
    bufferOneToManyStub(otmDbEntity, otmPropertyName) {
        throw new Error(`@OneToMany stubs not allowed in QueryResultType.HIERARCHICAL`);
    }
    bufferOneToManyCollection(entityAlias, resultObject, otmDbEntity, propertyName, relationDbEntity, childResultObject, context) {
        resultObject[propertyName] = [childResultObject];
        this.addOneToManyCollection(entityAlias, resultObject, propertyName);
    }
    bufferBlankOneToMany(entityAlias, resultObject, otmEntityName, propertyName, relationDbEntity, context) {
        resultObject[propertyName] = [];
        this.addOneToManyCollection(entityAlias, resultObject, propertyName);
    }
    flushEntity(entityAlias, dbEntity, selectClauseFragment, entityId, resultObject, context) {
        return this.mergeEntity(entityAlias, resultObject);
    }
    bridge(parsedResults, selectClauseFragment, context) {
        // Nothing to be done, hierarchical queries are not bridged
        return parsedResults;
    }
    addManyToOneReference(entityAlias, resultObject, propertyName) {
        if (this.isDifferentOrDoesntExist(entityAlias, resultObject, propertyName)) {
            return;
        }
        // Both last and current objects must exist here
        let lastMtoStub = this.lastRowObjectMap[entityAlias][propertyName];
        let currentMtoStub = resultObject[propertyName];
        this.objectEqualityMap[entityAlias] = this.utils.valuesEqual(lastMtoStub, currentMtoStub, true);
    }
}

var __decorate$10 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ObjectResultParserFactory = class ObjectResultParserFactory {
    getObjectResultParser(queryResultType, config, rootDbEntity) {
        switch (queryResultType) {
            case QueryResultType.ENTITY_GRAPH:
            case QueryResultType.MAPPED_ENTITY_GRAPH:
                return new EntityGraphResultParser(config, rootDbEntity, this.applicationUtils, this.entityStateManager, this.utils);
            case QueryResultType.ENTITY_TREE:
            case QueryResultType.MAPPED_ENTITY_TREE:
                return new EntityTreeResultParser(this.applicationUtils, this.entityStateManager, this.utils);
            default:
                throw new Error(`ObjectQueryParser not supported for QueryResultType: ${queryResultType}`);
        }
    }
};
__decorate$10([
    Inject()
], ObjectResultParserFactory.prototype, "applicationUtils", void 0);
__decorate$10([
    Inject()
], ObjectResultParserFactory.prototype, "entityStateManager", void 0);
__decorate$10([
    Inject()
], ObjectResultParserFactory.prototype, "utils", void 0);
ObjectResultParserFactory = __decorate$10([
    Injected()
], ObjectResultParserFactory);

/**
 * Created by Papa on 11/8/2016.
 */
class TreeQueryResultParser extends TreeResultParser {
    addEntity(entityAlias) {
        let resultObject = {};
        this.currentRowObjectMap[entityAlias] = resultObject;
        return resultObject;
    }
    bufferOneToManyCollection(entityAlias, resultObject, propertyName, childResultObject) {
        resultObject[propertyName] = [childResultObject];
        this.addOneToManyCollection(entityAlias, resultObject, propertyName);
    }
    flushEntity(entityAlias, resultObject) {
        return this.mergeEntity(entityAlias, resultObject);
    }
}

var __decorate$$ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 10/2/2016.
 */
var ClauseType;
(function (ClauseType) {
    ClauseType["MAPPED_SELECT_CLAUSE"] = "MAPPED_SELECT_CLAUSE";
    ClauseType["NON_MAPPED_SELECT_CLAUSE"] = "NON_MAPPED_SELECT_CLAUSE";
    ClauseType["WHERE_CLAUSE"] = "WHERE_CLAUSE";
    ClauseType["FUNCTION_CALL"] = "FUNCTION_CALL";
})(ClauseType || (ClauseType = {}));
let SQLWhereBase = class SQLWhereBase {
    constructor(dbEntity, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        this.dbEntity = dbEntity;
        this.dialect = dialect;
        this.airportDatabase = airportDatabase;
        this.applicationUtils = applicationUtils;
        this.entityStateManager = entityStateManager;
        this.qMetadataUtils = qMetadataUtils;
        this.qValidator = qValidator;
        this.sqlQueryAdapter = sqlQueryAdapter;
        this.storeDriver = storeDriver;
        this.subStatementSqlGenerator = subStatementSqlGenerator;
        this.utils = utils;
        this.context = context;
        this.parameterReferences = [];
        this.fieldMap = new ApplicationMap();
        this.qEntityMapByAlias = {};
        this.jsonRelationMapByAlias = {};
    }
    getParameters(parameterMap, //,
    context) {
        // let populatedParameterMap: {[parameterAlias: string]: boolean} = {};
        return this.parameterReferences
            /*
             .parameterReferences.filter(( parameterReference ) => {
             if (!populatedParameterMap[parameterReference]) {
             populatedParameterMap[parameterReference] = true;
             return true;
             }
             return false;
             })
             */
            .map((parameterReference) => {
            let parameter = parameterMap[parameterReference];
            if (!parameter) {
                const isReference = parameterReference === null || ['number', 'string'].indexOf(typeof parameterReference) > -1;
                if (isReference) {
                    // if (!valuesArray) {
                    return parameterReference;
                    // } else if (typeof parameterReference === 'number') {
                    // 	return sqlAdaptor.getValue(valuesArray[parameterReference])
                    // }
                }
                throw new Error(`No parameter found for alias '${parameterReference}'`);
            }
            return this.sqlQueryAdapter.getParameterValue(parameter);
        });
    }
    getFunctionCallValue(rawValue, context) {
        return this.getFieldValue(rawValue, ClauseType.FUNCTION_CALL, null, context);
    }
    getFieldFunctionValue(aField, defaultCallback, context) {
        let aValue = aField.v;
        if (this.isParameterReference(aValue)) {
            let stringValue = aValue;
            this.parameterReferences.push(stringValue);
            aValue = this.sqlQueryAdapter.getParameterReference(this.parameterReferences, stringValue);
        }
        else {
            aValue = this.getFieldValue(aValue, ClauseType.FUNCTION_CALL, defaultCallback, context);
        }
        aValue = this.sqlQueryAdapter.getFunctionAdaptor()
            .getFunctionCalls(aField, aValue, this.qEntityMapByAlias, this, context);
        this.qValidator.addFunctionAlias(aField.fa);
        return aValue;
    }
    getFieldValue(clauseField, clauseType, defaultCallback, context) {
        let columnName;
        if (!clauseField) {
            throw new Error(`Missing Clause Field definition`);
        }
        if (clauseField instanceof Array) {
            return clauseField
                .map((clauseFieldMember) => this.getFieldValue(clauseFieldMember, clauseType, defaultCallback, context))
                .join(', ');
        }
        if (clauseType !== ClauseType.MAPPED_SELECT_CLAUSE && !clauseField.ot) {
            throw new Error(`Object Type is not defined in JSONClauseField`);
        }
        const aField = clauseField;
        let qEntity;
        switch (clauseField.ot) {
            case JSONClauseObjectType.FIELD_FUNCTION:
                return this.getFieldFunctionValue(aField, defaultCallback, context);
            case JSONClauseObjectType.DISTINCT_FUNCTION:
                throw new Error(`Distinct function cannot be nested.`);
            case JSONClauseObjectType.EXISTS_FUNCTION: {
                if (clauseType !== ClauseType.WHERE_CLAUSE) {
                    throw new Error(`Exists can only be used as a top function in a WHERE clause.`);
                }
                const { parameterReferences, subQuerySql } = this.subStatementSqlGenerator.getTreeQuerySql(aField.v, this.dialect, context);
                if (parameterReferences.length) {
                    this.parameterReferences = this.parameterReferences.concat(parameterReferences);
                }
                return `EXISTS(${subQuerySql})`;
            }
            case JSONClauseObjectType.FIELD: {
                qEntity = this.qEntityMapByAlias[aField.ta];
                this.qValidator.validateReadQEntityProperty(aField.si, aField.ti, aField.ci);
                columnName = this.getEntityPropertyColumnName(qEntity, aField.ci, context);
                this.addField(aField.si, aField.ti, aField.ci);
                return this.getComplexColumnFragment(aField, columnName, context);
            }
            case JSONClauseObjectType.FIELD_QUERY: {
                let jsonFieldSqlSubQuery = aField.fieldSubQuery;
                if (aField.S) {
                    jsonFieldSqlSubQuery = aField;
                }
                const { parameterReferences, subQuerySql } = this.subStatementSqlGenerator.getFieldQuerySql(jsonFieldSqlSubQuery, this.dialect, this.qEntityMapByAlias, context);
                if (parameterReferences.length) {
                    this.parameterReferences = this.parameterReferences.concat(parameterReferences);
                }
                this.qValidator.addSubQueryAlias(aField.fa);
                return `(${subQuerySql})`;
            }
            case JSONClauseObjectType.MANY_TO_ONE_RELATION: {
                qEntity = this.qEntityMapByAlias[aField.ta];
                this.qValidator.validateReadQEntityManyToOneRelation(aField.si, aField.ti, aField.ci);
                columnName = this.getEntityManyToOneColumnName(qEntity, aField.ci, context);
                this.addField(aField.si, aField.ti, aField.ci);
                return this.getComplexColumnFragment(aField, columnName, context);
            }
            // must be a nested object
            default: {
                if (clauseType !== ClauseType.MAPPED_SELECT_CLAUSE) ;
                return defaultCallback();
            }
        }
    }
    applyOperator(operator, rValue) {
        switch (operator) {
            case SqlOperator.EQUALS:
                return ` = ${rValue}`;
            case SqlOperator.GREATER_THAN:
                return ` > ${rValue}`;
            case SqlOperator.GREATER_THAN_OR_EQUALS:
                return ` >= ${rValue}`;
            case SqlOperator.IS_NOT_NULL:
                return ` IS NOT NULL`;
            case SqlOperator.IS_NULL:
                return ` IS NULL`;
            case SqlOperator.IN:
                return ` IN (${rValue})`;
            case SqlOperator.LESS_THAN:
                return ` < ${rValue}`;
            case SqlOperator.LESS_THAN_OR_EQUALS:
                return ` <= ${rValue}`;
            case SqlOperator.NOT_EQUALS:
                return ` != ${rValue}`;
            case SqlOperator.NOT_IN:
                return ` NOT IN (${rValue})`;
            case SqlOperator.LIKE:
                return ` LIKE ${rValue}`;
            default:
                throw new Error(`Unsupported operator ${operator}`);
        }
    }
    getWHEREFragment(operation, nestingPrefix, context) {
        let whereFragment = '';
        if (!operation) {
            throw new Error(`An operation is missing in WHERE or HAVING clause`);
        }
        nestingPrefix = `${nestingPrefix}\t`;
        switch (operation.c) {
            case OperationCategory.LOGICAL:
                return this.getLogicalWhereFragment(operation, nestingPrefix, context);
            case OperationCategory.BOOLEAN:
            case OperationCategory.DATE:
            case OperationCategory.NUMBER:
            case OperationCategory.STRING:
            case OperationCategory.UNTYPED:
                let valueOperation = operation;
                let lValueSql = this.getFieldValue(valueOperation.l, ClauseType.WHERE_CLAUSE, null, context);
                let rValueSql = this.getFieldValue(valueOperation.r, ClauseType.WHERE_CLAUSE, null, context);
                let rValueWithOperator = this.applyOperator(valueOperation.o, rValueSql);
                whereFragment += `${lValueSql}${rValueWithOperator}`;
                break;
            case OperationCategory.FUNCTION:
                let functionOperation = operation;
                whereFragment = this.getFieldValue(functionOperation.ob, ClauseType.WHERE_CLAUSE, null, context);
                // exists function and maybe others
                break;
        }
        return whereFragment;
    }
    getEntityPropertyColumnName(qEntity, columnIndex, context) {
        const dbEntity = this.qMetadataUtils.getDbEntity(qEntity);
        return dbEntity.columns[columnIndex].name;
    }
    addFieldFromColumn(dbColumn) {
        const dbEntity = dbColumn.propertyColumns[0].property.entity;
        this.addField(dbEntity.applicationVersion.id, dbEntity.index, dbColumn.index);
    }
    addField(applicationIndex, tableIndex, columnIndex) {
        this.fieldMap.ensure(applicationIndex, tableIndex)
            .ensure(columnIndex);
    }
    warn(warning) {
        console.log(warning);
    }
    getSimpleColumnFragment(tableAlias, columnName) {
        return `${tableAlias}.${columnName}`;
    }
    getComplexColumnFragment(value, columnName, context) {
        let selectSqlFragment = `${value.ta}.${columnName}`;
        selectSqlFragment = this.sqlQueryAdapter.getFunctionAdaptor()
            .getFunctionCalls(value, selectSqlFragment, this.qEntityMapByAlias, this, context);
        return selectSqlFragment;
    }
    getEntityManyToOneColumnName(qEntity, columnIndex, context) {
        return this.getEntityPropertyColumnName(qEntity, columnIndex, context);
    }
    getLogicalWhereFragment(operation, nestingPrefix, context) {
        let operator;
        switch (operation.o) {
            case SqlOperator.AND:
                operator = 'AND';
                break;
            case SqlOperator.OR:
                operator = 'OR';
                break;
            case SqlOperator.NOT:
                const whereFragment = this.getWHEREFragment(operation.v, nestingPrefix, context);
                return ` NOT (${whereFragment})`;
            default:
                throw new Error(`Unknown logical operator: ${operation.o}`);
        }
        let childOperations = operation.v;
        if (!(childOperations instanceof Array)) {
            throw new Error(`Expecting an array of child operations as a value for operator ${operator}, 
				in the WHERE Clause.`);
        }
        let whereFragment = childOperations.map((childOperation) => {
            return this.getWHEREFragment(childOperation, nestingPrefix, context);
        })
            .join(`\n${nestingPrefix}${operator} `);
        return `( ${whereFragment} )`;
    }
    isParameterReference(value) {
        if (value === null) {
            return false;
        }
        if (value === undefined || value === '' || value === NaN) {
            throw new Error(`Invalid query value: ${value}`);
        }
        switch (typeof value) {
            case 'boolean':
            case 'number':
                throw new Error(`Unexpected primitive instance, expecting parameter alias.`);
            case 'string':
                return true;
        }
        if (value instanceof Date) {
            throw new Error(`Unexpected date instance, expecting parameter alias.`);
        }
        return false;
    }
};
SQLWhereBase = __decorate$$([
    Injected()
], SQLWhereBase);

/**
 * Created by Papa on 10/2/2016.
 */
class SQLNoJoinQuery extends SQLWhereBase {
    constructor(dbEntity, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        super(dbEntity, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.relationManager = relationManager;
    }
    getTableFragment(fromRelation, context, addAs = true) {
        if (!fromRelation) {
            throw new Error(`Expecting exactly one table in UPDATE/DELETE clause`);
        }
        if (fromRelation.ri || fromRelation.jt) {
            throw new Error(`Table in UPDATE/DELETE clause cannot be joined`);
        }
        const firstDbEntity = this.airportDatabase.applications[fromRelation.si]
            .currentVersion[0].applicationVersion.entities[fromRelation.ti];
        let tableName = this.storeDriver.getEntityTableName(firstDbEntity, context);
        if (fromRelation.si !== this.dbEntity.applicationVersion.application.index
            || fromRelation.ti !== this.dbEntity.index) {
            throw new Error(`Unexpected table in UPDATE/DELETE clause: 
			'${tableName}',
			expecting: '${this.dbEntity.applicationVersion.application.name}.${this.dbEntity.name}'`);
        }
        const firstQEntity = new QEntity(firstDbEntity, this.applicationUtils, this.relationManager);
        const tableAlias = this.relationManager.getAlias(fromRelation);
        this.qEntityMapByAlias[tableAlias] = firstQEntity;
        let fromFragment = `\t${tableName}`;
        if (addAs) {
            fromFragment += ` AS ${tableAlias}`;
        }
        return fromFragment;
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
class SQLDelete extends SQLNoJoinQuery {
    constructor(jsonDelete, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        super(airportDatabase.applications[jsonDelete.DF.si].currentVersion[0]
            .applicationVersion.entities[jsonDelete.DF.ti], dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.jsonDelete = jsonDelete;
    }
    toSQL(context) {
        let fromFragment = this.getTableFragment(this.jsonDelete.DF, context);
        let whereFragment = '';
        let jsonQuery = this.jsonDelete;
        if (jsonQuery.W) {
            whereFragment = this.getWHEREFragment(jsonQuery.W, '', context);
            whereFragment = `
WHERE
${whereFragment}`;
            // TODO: following might be needed for some RDBMS, does not work for SqLite
            // Replace the root entity alias reference with the table name
            // let tableAlias = this.relationManager.getAlias(this.jsonDelete.DF)
            // let tableName = this.storeDriver.getEntityTableName(this.qEntityMapByAlias[tableAlias].__driver__.dbEntity, context)
            // whereFragment = whereFragment.replace(new RegExp(`${tableAlias}`, 'g'), tableName)
        }
        return `DELETE
FROM
${fromFragment}${whereFragment}`;
    }
}

/**
 * Created by Papa on 11/17/2016.
 */
class SQLInsertValues extends SQLNoJoinQuery {
    constructor(jsonInsertValues, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context
    // repository?: IRepository
    ) {
        super(airportDatabase.applications[jsonInsertValues.II.si].currentVersion[0]
            .applicationVersion.entities[jsonInsertValues.II.ti], dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.jsonInsertValues = jsonInsertValues;
    }
    toSQL(context) {
        if (!this.jsonInsertValues.II) {
            throw new Error(`Expecting exactly one table in INSERT INTO clause`);
        }
        this.qValidator.validateInsertQEntity(this.dbEntity);
        let tableFragment = this.getTableFragment(this.jsonInsertValues.II, context, false);
        let columnsFragment = this.getColumnsFragment(this.dbEntity, this.jsonInsertValues.C);
        let valuesFragment = this.getValuesFragment(this.jsonInsertValues.V, context);
        return `INSERT INTO
${tableFragment} ${columnsFragment}
VALUES
${valuesFragment}
`;
    }
    getColumnsFragment(dbEntity, columns) {
        if (!columns.length) {
            return '';
        }
        const columnNames = columns.map(columnIndex => dbEntity.columns[columnIndex].name);
        return `( ${columnNames.join(', \n')} )`;
    }
    getValuesFragment(valuesClauseFragment, context) {
        let allValuesFragment = valuesClauseFragment.map((valuesArray) => {
            let valuesFragment = valuesArray.map((value) => {
                if (value === null || ['number', 'string'].indexOf(typeof value) > -1) {
                    this.parameterReferences.push(value);
                    return this.sqlQueryAdapter.getParameterReference(this.parameterReferences, value);
                }
                else if (value === undefined) {
                    throw new Error(`An 'undefined' value was provided when inserting into: ${this.dbEntity.applicationVersion.application.name}.${this.dbEntity.name}`);
                }
                else {
                    const fieldValue = this.getFieldValue(value, ClauseType.WHERE_CLAUSE, null, context);
                    return `\n${fieldValue}\n`;
                }
            });
            return `(${valuesFragment.join(',')})`;
        });
        return allValuesFragment.join(',\n');
    }
}

/**
 * Created by Papa on 8/20/2016.
 */
var SQLDialect;
(function (SQLDialect) {
    SQLDialect["MYSQL"] = "MYSQL";
    SQLDialect["POSTGRESQL"] = "POSTGRESQL";
    SQLDialect["SQLITE"] = "SQLITE";
})(SQLDialect || (SQLDialect = {}));
class EntityDefaults {
    constructor() {
        this.map = {};
    }
    getForAlias(alias) {
        let defaultsForAlias = this.map[alias];
        if (!defaultsForAlias) {
            defaultsForAlias = {};
            this.map[alias] = defaultsForAlias;
        }
        return defaultsForAlias;
    }
}
/**
 * String based SQL query.
 */
class SQLQuery extends SQLWhereBase {
    constructor(jsonQuery, dbEntity, dialect, queryResultType, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        super(dbEntity, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.jsonQuery = jsonQuery;
        this.queryResultType = queryResultType;
        this.relationManager = relationManager;
        this.entityDefaults = new EntityDefaults();
    }
    getFieldMap() {
        return this.fieldMap;
    }
    getEntityApplicationRelationFromJoin(leftQEntity, rightQEntity, entityRelation, parentRelation, currentAlias, parentAlias, joinTypeString, errorPrefix, context) {
        const allJoinOnColumns = [];
        const leftDbEntity = leftQEntity.__driver__.dbEntity;
        const rightDbEntity = rightQEntity.__driver__.dbEntity;
        const dbRelation = leftDbEntity.relations[entityRelation.ri];
        let relationColumns;
        switch (dbRelation.relationType) {
            case EntityRelationType.MANY_TO_ONE:
                relationColumns = dbRelation.manyRelationColumns;
                break;
            case EntityRelationType.ONE_TO_MANY:
                if (dbRelation.oneRelationColumns && dbRelation.oneRelationColumns.length) {
                    relationColumns = dbRelation.oneRelationColumns;
                }
                else {
                    const matchingRelations = dbRelation.relationEntity.relations.filter(manySideRelation => manySideRelation.relationEntity.id == leftDbEntity.id
                        && manySideRelation.manyToOneElems
                        && manySideRelation.manyToOneElems !== true
                        && manySideRelation.manyToOneElems.mappedBy === dbRelation.property.name);
                    if (matchingRelations.length) {
                        relationColumns = matchingRelations[0].manyRelationColumns;
                    }
                }
                break;
            default:
                throw new Error(`Unknown relation type ${dbRelation.relationType} 
on '${leftDbEntity.applicationVersion.application.name}.${leftDbEntity.name}.${dbRelation.property.name}'.`);
        }
        for (const relationColumn of relationColumns) {
            let ownColumnName;
            let referencedColumnName;
            switch (dbRelation.relationType) {
                case EntityRelationType.MANY_TO_ONE:
                    ownColumnName = relationColumn.manyColumn.name;
                    referencedColumnName = relationColumn.oneColumn.name;
                    break;
                case EntityRelationType.ONE_TO_MANY:
                    ownColumnName = relationColumn.oneColumn.name;
                    referencedColumnName = relationColumn.manyColumn.name;
                    break;
                default:
                    throw new Error(`Unknown relation type ${dbRelation.relationType} 
on '${leftDbEntity.applicationVersion.application.name}.${leftDbEntity.name}.${dbRelation.property.name}'.`);
            }
            allJoinOnColumns.push({
                leftColumn: ownColumnName,
                rightColumn: referencedColumnName
            });
        }
        let onClause = allJoinOnColumns.map(joinOnColumn => ` ${parentAlias}.${joinOnColumn.leftColumn} = ${currentAlias}.${joinOnColumn.rightColumn}`)
            .join('\n\t\t\tAND');
        if (entityRelation.joinWhereClause) {
            const whereClause = this.getWHEREFragment(entityRelation.joinWhereClause, '\t\t', context);
            const joinWhereOperator = entityRelation.joinWhereClauseOperator === SqlOperator.AND ? 'AND' : 'OR';
            onClause = `${onClause}
			${joinWhereOperator} ${whereClause}`;
        }
        const tableName = this.storeDriver.getEntityTableName(rightDbEntity, context);
        const fromFragment = `\n\t${joinTypeString} ${tableName} ${currentAlias}\n\t\tON ${onClause}`;
        return fromFragment;
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
class SQLUpdate extends SQLNoJoinQuery {
    constructor(jsonUpdate, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        super(airportDatabase.applications[jsonUpdate.U.si].currentVersion[0]
            .applicationVersion.entities[jsonUpdate.U.ti], dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.jsonUpdate = jsonUpdate;
    }
    toSQL(internalFragments, context) {
        if (!this.jsonUpdate.U) {
            throw new Error(`Expecting exactly one table in UPDATE clause`);
        }
        let updateFragment = this.getTableFragment(this.jsonUpdate.U, context);
        let setFragment = this.getSetFragment(this.jsonUpdate.S, context);
        if (internalFragments.SET && internalFragments.SET.length) {
            setFragment += ',' + internalFragments.SET.map(internalSetFragment => `
	${internalSetFragment.column.name} = ${internalSetFragment.value}`)
                .join(',');
        }
        let whereFragment = '';
        let jsonQuery = this.jsonUpdate;
        if (jsonQuery.W) {
            whereFragment = this.getWHEREFragment(jsonQuery.W, '', context);
            whereFragment = `WHERE
${whereFragment}`;
            // TODO: following might be needed for some RDBMS, does not work for SqLite
            // Replace the root entity alias reference with the table name
            // let tableAlias = this.relationManager.getAlias(this.jsonUpdate.U)
            // let tableName  = this.storeDriver.getEntityTableName(this.qEntityMapByAlias[tableAlias].__driver__.dbEntity, context)
            // whereFragment  = whereFragment.replace(new RegExp(`${tableAlias}`, 'g'), tableName)
        }
        return `UPDATE
${updateFragment}
SET
${setFragment}
${whereFragment}`;
    }
    getSetFragment(setClauseFragment, context) {
        let setFragments = [];
        for (let columnName in setClauseFragment) {
            let value = setClauseFragment[columnName];
            // Skip undefined values
            if (value === undefined) {
                continue;
            }
            this.qValidator.validateUpdateColumn(this.dbEntity.columnMap[columnName]);
            this.addSetFragment(columnName, value, setFragments, context);
        }
        return setFragments.join(', \n');
    }
    addSetFragment(columnName, value, setFragments, context) {
        let fieldValue;
        if (typeof value === 'number') {
            this.parameterReferences.push(value);
            fieldValue = this.sqlQueryAdapter.getParameterReference(this.parameterReferences, value);
        }
        else {
            fieldValue = this.getFieldValue(value, ClauseType.WHERE_CLAUSE, null, context);
        }
        setFragments.push(`\t${columnName} = ${fieldValue}`);
    }
    isManyToOneRelation(value) {
        return typeof value === 'object'
            && value.ot === JSONClauseObjectType.MANY_TO_ONE_RELATION;
    }
    addManyToOneMappings(parentMapping) {
        let mappings = [];
        const value = parentMapping.value;
        if (typeof value === 'object' &&
            (!value.ot
                || value.ot === JSONClauseObjectType.MANY_TO_ONE_RELATION)) {
            for (const key in value) {
                if (key === 'ot'
                    && value[key] === JSONClauseObjectType.MANY_TO_ONE_RELATION) {
                    continue;
                }
                const mapping = {
                    tableIndex: parentMapping.tableIndex,
                    propertyChain: parentMapping.propertyChain.concat([key]),
                    value: value[key]
                };
                const childMappings = this.addManyToOneMappings(mapping);
                mappings = mappings.concat(childMappings);
            }
        }
        else {
            mappings.push(parentMapping);
        }
        return mappings;
    }
}

class SqlFunctionField {
    constructor(jsonClauseField) {
        this.jsonClauseField = jsonClauseField;
        // Test
    }
    getValue(sqlValueProvider, context) {
        return sqlValueProvider.getFieldFunctionValue(this.jsonClauseField, null, context);
    }
}

/**
 * Created by Papa on 10/28/2016.
 */
class NonEntitySQLQuery extends SQLQuery {
    constructor(jsonQuery, dialect, queryResultType, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context) {
        super(jsonQuery, null, dialect, queryResultType, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context);
    }
    addQEntityMapByAlias(sourceMap) {
        for (let alias in sourceMap) {
            this.qEntityMapByAlias[alias] = sourceMap[alias];
        }
    }
    toSQL(internalFragments, context) {
        let jsonQuery = this.jsonQuery;
        let joinNodeMap = {};
        this.joinTrees = this.buildFromJoinTree(jsonQuery.F, joinNodeMap, context);
        let selectFragment = this.getSELECTFragment(false, jsonQuery.S, internalFragments, context);
        let fromFragment = this.getFROMFragments(this.joinTrees, context);
        let whereFragment = '';
        if (jsonQuery.W) {
            whereFragment = `
WHERE
	${this.getWHEREFragment(jsonQuery.W, '', context)}`;
        }
        let groupByFragment = '';
        if (jsonQuery.GB && jsonQuery.GB.length) {
            groupByFragment = `
GROUP BY
	${this.getGroupByFragment(jsonQuery.GB)}`;
        }
        let havingFragment = '';
        if (jsonQuery.H) {
            havingFragment = `
HAVING
	${this.getWHEREFragment(jsonQuery.H, '', context)}`;
        }
        let orderByFragment = '';
        if (jsonQuery.OB && jsonQuery.OB.length) {
            orderByFragment = `
ORDER BY
	${this.orderByParser.getOrderByFragment(jsonQuery.S, jsonQuery.OB)}`;
        }
        let offsetFragment = '';
        if (jsonQuery.O) {
            offsetFragment = this.sqlQueryAdapter.getOffsetFragment(jsonQuery.O);
        }
        let limitFragment = '';
        if (jsonQuery.L) {
            offsetFragment = this.sqlQueryAdapter.getLimitFragment(jsonQuery.L);
        }
        return `SELECT
	${selectFragment}
FROM
${fromFragment}${whereFragment}${groupByFragment}${havingFragment}${orderByFragment}${offsetFragment}${limitFragment}`;
    }
    buildFromJoinTree(joinRelations, joinNodeMap, context) {
        let jsonTrees = [];
        let jsonTree;
        // For entity queries it is possible to have a query with no from clause, in this case
        // make the query entity the root tree node
        if (joinRelations.length < 1) {
            throw new Error(`FROM clause must have entries for non-Entity queries`);
        }
        let firstRelation = joinRelations[0];
        switch (firstRelation.rt) {
            case JSONRelationType.SUB_QUERY_ROOT:
            case JSONRelationType.ENTITY_ROOT:
                break;
            default:
                throw new Error(`First table in FROM clause cannot be joined`);
        }
        let alias = this.relationManager.getAlias(firstRelation);
        this.qValidator.validateReadFromEntity(firstRelation);
        let firstEntity = this.relationManager.createRelatedQEntity(firstRelation, context);
        this.qEntityMapByAlias[alias] = firstEntity;
        jsonTree = new JoinTreeNode(firstRelation, [], null);
        jsonTrees.push(jsonTree);
        joinNodeMap[alias] = jsonTree;
        for (let i = 1; i < joinRelations.length; i++) {
            let rightEntity;
            let joinRelation = joinRelations[i];
            if (!joinRelation.jt) {
                throw new Error(`Table ${i + 1} in FROM clause is missing joinType`);
            }
            this.qValidator.validateReadFromEntity(joinRelation);
            alias = this.relationManager.getAlias(joinRelation);
            switch (joinRelation.rt) {
                case JSONRelationType.SUB_QUERY_ROOT:
                    let view = this.addFieldsToView(joinRelation, alias, context);
                    this.qEntityMapByAlias[alias] = view;
                    continue;
                case JSONRelationType.ENTITY_ROOT:
                    // Non-Joined table
                    let nonJoinedEntity = this.relationManager.createRelatedQEntity(joinRelation, context);
                    this.qEntityMapByAlias[alias] = nonJoinedEntity;
                    let anotherTree = new JoinTreeNode(joinRelation, [], null);
                    if (joinNodeMap[alias]) {
                        throw new Error(`Alias '${alias}' used more than once in the FROM clause.`);
                    }
                    jsonTrees.push(anotherTree);
                    joinNodeMap[alias] = anotherTree;
                    continue;
                case JSONRelationType.ENTITY_APPLICATION_RELATION:
                    if (!joinRelation.ri) {
                        throw new Error(`Table ${i + 1} in FROM clause is missing relationPropertyName`);
                    }
                    rightEntity = this.relationManager.createRelatedQEntity(joinRelation, context);
                    break;
                case JSONRelationType.SUB_QUERY_JOIN_ON:
                    if (!joinRelation.joinWhereClause) {
                        this.warn(`View ${i + 1} in FROM clause is missing joinWhereClause`);
                    }
                    rightEntity = this.addFieldsToView(joinRelation, alias, context);
                    break;
                case JSONRelationType.ENTITY_JOIN_ON:
                    if (!joinRelation.joinWhereClause) {
                        this.warn(`Table ${i + 1} in FROM clause is missing joinWhereClause`);
                    }
                    rightEntity = this.relationManager.createRelatedQEntity(joinRelation, context);
                    break;
                default:
                    throw new Error(`Unknown JSONRelationType ${joinRelation.rt}`);
            }
            let parentAlias = this.relationManager.getParentAlias(joinRelation);
            if (!joinNodeMap[parentAlias]) {
                throw new Error(`Missing parent entity for alias ${parentAlias}, on table ${i + 1} in FROM clause. 
					NOTE: sub-queries in FROM clause cannot reference parent FROM tables.`);
            }
            let leftNode = joinNodeMap[parentAlias];
            let rightNode = new JoinTreeNode(joinRelation, [], leftNode);
            leftNode.addChildNode(rightNode);
            this.qValidator.validateReadFromEntity(joinRelation);
            this.qEntityMapByAlias[alias] = rightEntity;
            if (!rightEntity) {
                throw new Error(`Could not find entity ${joinRelation.ti} for table ${i + 1} in FROM clause`);
            }
            if (joinNodeMap[alias]) {
                throw new Error(`Alias '${alias}' used more than once in the FROM clause.`);
            }
            joinNodeMap[alias] = rightNode;
        }
        return jsonTrees;
    }
    addFieldsToView(viewJoinRelation, viewAlias, context) {
        let view = new QTree(viewJoinRelation.fromClausePosition, null);
        this.addFieldsToViewForSelect(view, viewAlias, viewJoinRelation.subQuery.S, 'f', null, context);
        return view;
    }
    /**
     * Just build the shell fields for the external API of the view, don't do anything else.
     * @param view
     * @param select
     * @param fieldPrefix
     */
    addFieldsToViewForSelect(view, viewAlias, select, fieldPrefix, forFieldQueryAlias, context) {
        let fieldIndex = 0;
        let hasDistinctClause = false;
        for (let fieldName in select) {
            let alias = `${fieldPrefix}${++fieldIndex}`;
            let fieldJson = select[fieldName];
            // If its a nested select
            if (!fieldJson.ot) {
                this.addFieldsToViewForSelect(view, viewAlias, fieldJson, `${alias}_`, null, context);
            }
            else {
                let aliasToSet = forFieldQueryAlias ? forFieldQueryAlias : alias;
                hasDistinctClause = hasDistinctClause && this.addFieldToViewForSelect(view, viewAlias, fieldPrefix, fieldJson, aliasToSet, forFieldQueryAlias, context);
            }
        }
        if (fieldIndex > 1) {
            if (hasDistinctClause) {
                throw new Error(`DISTINCT clause must be the only property at its level`);
            }
            if (forFieldQueryAlias) {
                throw new Error(`Field queries can have only one field in SELECT clause`);
            }
        }
    }
    addFieldToViewForSelect(view, viewAlias, fieldPrefix, fieldJson, alias, forFieldQueryAlias = null, context) {
        let hasDistinctClause = false;
        let dbEntity;
        let dbProperty;
        let dbColumn;
        switch (fieldJson.ot) {
            case JSONClauseObjectType.FIELD_FUNCTION:
                view[alias] = new SqlFunctionField(fieldJson);
                throw new Error('Not implemented');
            case JSONClauseObjectType.EXISTS_FUNCTION:
                throw new Error(`Exists function cannot be used in SELECT clause.`);
            case JSONClauseObjectType.FIELD:
                dbEntity = this.airportDatabase.applications[fieldJson.si].currentVersion[0]
                    .applicationVersion.entities[fieldJson.ti];
                dbProperty = dbEntity.properties[fieldJson.pi];
                dbColumn = dbEntity.columns[fieldJson.ci];
                switch (fieldJson.dt) {
                    case SQLDataType.BOOLEAN:
                        view[alias] = new QBooleanField(dbColumn, dbProperty, view);
                        break;
                    case SQLDataType.DATE:
                        view[alias] = new QDateField(dbColumn, dbProperty, view);
                        break;
                    case SQLDataType.NUMBER:
                        view[alias] = new QNumberField(dbColumn, dbProperty, view);
                        break;
                    case SQLDataType.STRING:
                        view[alias] = new QStringField(dbColumn, dbProperty, view);
                        break;
                    // case SQLDataType.ANY:
                    // 	view[alias] = new QUntypedField(dbColumn, dbProperty,
                    // 		view as IQEntityInternal<any>)
                    // 	break
                    default:
                        throw new Error(`Unknown SQLDataType: ${fieldJson.dt}.`);
                }
                break;
            case JSONClauseObjectType.FIELD_QUERY:
                let fieldQuery = fieldJson;
                this.addFieldToViewForSelect(view, viewAlias, fieldPrefix, fieldQuery.S, alias, alias, context);
                break;
            case JSONClauseObjectType.DISTINCT_FUNCTION:
                this.addFieldsToViewForSelect(view, viewAlias, fieldJson.v, fieldPrefix, forFieldQueryAlias, context);
                hasDistinctClause = true;
                break;
            case JSONClauseObjectType.MANY_TO_ONE_RELATION:
                throw new Error(`@ManyToOne fields cannot be directly in a select clause.
					Please select a non-relational field within the relation.`);
            // let relation =
            // <QField<any>><any>QMetadataUtils.getRelationByColumnIndex(this.dbFacade.getQEntityByIndex(fieldJson.ti),
            // fieldJson.ci); view[alias] = relation.getInstance(view); break;
            default:
                throw new Error(`Unexpected type property on JSONClauseField: ${fieldJson.ot}.`);
        }
        return hasDistinctClause;
    }
    getFieldSelectFragment(value, clauseType, nestedObjectCallBack, fieldIndex, context) {
        let columnSelectSqlFragment = this.getFieldValue(value, clauseType, 
        // Nested object processing
        nestedObjectCallBack, context);
        if (value.fa !== undefined) {
            columnSelectSqlFragment += ` as ${value.fa}`;
        }
        if (fieldIndex === 0) {
            return `\n\t${columnSelectSqlFragment}`;
        }
        else {
            return `,\n\t${columnSelectSqlFragment}`;
        }
    }
    getFROMFragments(joinTrees, context) {
        return joinTrees.map(joinTree => this.getFROMFragment(null, joinTree, context))
            .join('\n');
    }
    getFROMFragment(parentTree, currentTree, context) {
        let fromFragment = '\t';
        let currentRelation = currentTree.jsonRelation;
        let currentAlias = this.relationManager.getAlias(currentRelation);
        let qEntity = this.qEntityMapByAlias[currentAlias];
        if (!parentTree) {
            switch (currentRelation.rt) {
                case JSONRelationType.ENTITY_ROOT:
                    fromFragment += `${this.storeDriver.getEntityTableName(qEntity.__driver__.dbEntity, context)} ${currentAlias}`;
                    break;
                case JSONRelationType.SUB_QUERY_ROOT:
                    let viewRelation = currentRelation;
                    const { parameterReferences, subQuerySql } = this.subStatementSqlGenerator.getTreeQuerySql(viewRelation.subQuery, this.dialect, context);
                    if (parameterReferences.length) {
                        this.parameterReferences = this.parameterReferences.concat(parameterReferences);
                    }
                    fromFragment += `(${subQuerySql}) ${currentAlias}`;
                    break;
                default:
                    throw new Error(`Top level FROM entries must be Entity or Sub-Query root`);
            }
        }
        else {
            let parentRelation = parentTree.jsonRelation;
            let parentAlias = this.relationManager.getAlias(parentRelation);
            let leftEntity = this.qEntityMapByAlias[parentAlias];
            let rightEntity = this.qEntityMapByAlias[currentAlias];
            let joinTypeString;
            switch (currentRelation.jt) {
                case JoinType.FULL_JOIN:
                    joinTypeString = 'FULL JOIN';
                    break;
                case JoinType.INNER_JOIN:
                    joinTypeString = 'INNER JOIN';
                    break;
                case JoinType.LEFT_JOIN:
                    joinTypeString = 'LEFT JOIN';
                    break;
                case JoinType.RIGHT_JOIN:
                    joinTypeString = 'RIGHT JOIN';
                default:
                    throw new Error(`Unsupported join type: ${currentRelation.jt}`);
            }
            let errorPrefix = 'Error building FROM: ';
            let joinOnClause;
            switch (currentRelation.rt) {
                case JSONRelationType.ENTITY_JOIN_ON:
                    let joinRelation = currentRelation;
                    joinOnClause = this.getWHEREFragment(joinRelation.joinWhereClause, '\t', context);
                    fromFragment += `\t${joinTypeString} ${this.storeDriver.getEntityTableName(qEntity.__driver__.dbEntity, context)} ${currentAlias} ON\n${joinOnClause}`;
                    break;
                case JSONRelationType.ENTITY_APPLICATION_RELATION:
                    fromFragment += this.getEntityApplicationRelationFromJoin(leftEntity, rightEntity, currentRelation, parentRelation, currentAlias, parentAlias, joinTypeString, errorPrefix, context);
                    break;
                case JSONRelationType.SUB_QUERY_JOIN_ON:
                    let viewJoinRelation = currentRelation;
                    const { parameterReferences, subQuerySql } = this.subStatementSqlGenerator.getTreeQuerySql(viewJoinRelation.subQuery, this.dialect, context);
                    if (parameterReferences.length) {
                        this.parameterReferences = this.parameterReferences.concat(parameterReferences);
                    }
                    joinOnClause = this.getWHEREFragment(viewJoinRelation.joinWhereClause, '\t', context);
                    fromFragment += `${joinTypeString} (${subQuerySql}) ${currentAlias} ON\n${joinOnClause}`;
                    break;
                default:
                    throw new Error(`Nested FROM entries must be Entity JOIN ON
					or Application Relation, or Sub-Query JOIN ON`);
            }
        }
        for (let i = 0; i < currentTree.childNodes.length; i++) {
            let childTreeNode = currentTree.childNodes[i];
            fromFragment += this.getFROMFragment(currentTree, childTreeNode, context);
        }
        return fromFragment;
    }
    getGroupByFragment(groupBy) {
        return groupBy.map((groupByField) => {
            this.qValidator.validateAliasedFieldAccess(groupByField.fa);
            return `${groupByField.fa}`;
        })
            .join(', ');
    }
    getOrderByFragment(orderBy) {
        return orderBy.map((orderByField) => {
            this.qValidator.validateAliasedFieldAccess(orderByField.fa);
            switch (orderByField.so) {
                case SortOrder.ASCENDING:
                    return `${orderByField.fa} ASC`;
                case SortOrder.DESCENDING:
                    return `${orderByField.fa} DESC`;
            }
        })
            .join(', ');
    }
}

/**
 * Created by Papa on 10/29/2016.
 */
class FieldSQLQuery extends NonEntitySQLQuery {
    constructor(jsonQuery, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context) {
        super(jsonQuery, dialect, QueryResultType.FIELD, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context);
        this.orderByParser = new ExactOrderByParser(qValidator);
    }
    async parseQueryResults(results, internalFragments, queryResultType, context, bridgedQueryConfiguration) {
        let parsedResults = [];
        if (!results || !results.length) {
            return parsedResults;
        }
        parsedResults = [];
        results.forEach((result) => {
            let parsedResult = this.parseQueryResult(this.jsonQuery.S, result, [0]);
            parsedResults.push(parsedResult);
        });
        return parsedResults;
    }
    getSELECTFragment(nested, selectClauseFragment, internalFragments, context) {
        if (!selectClauseFragment) {
            throw new Error(`SELECT clause is not defined for a Field Query`);
        }
        {
            let distinctClause = selectClauseFragment;
            if (distinctClause.ot == JSONClauseObjectType.DISTINCT_FUNCTION) {
                let distinctSelect = this.getSELECTFragment(nested, distinctClause.appliedFunctions[0].p[0], internalFragments, context);
                return `DISTINCT ${distinctSelect}`;
            }
        }
        let field = selectClauseFragment;
        let fieldIndex = 0;
        let selectSqlFragment = this.getFieldSelectFragment(field, ClauseType.NON_MAPPED_SELECT_CLAUSE, null, fieldIndex++, context);
        return selectSqlFragment;
    }
    parseQueryResult(selectClauseFragment, resultRow, nextFieldIndex) {
        let field = selectClauseFragment;
        let propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, field.fa, nextFieldIndex[0], field.dt, null);
        nextFieldIndex[0]++;
        return propertyValue;
    }
}

/**
 * Created by Papa on 10/28/2016.
 */
class TreeSQLQuery extends NonEntitySQLQuery {
    constructor(jsonQuery, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context) {
        super(jsonQuery, dialect, QueryResultType.TREE, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context);
        this.queryParser = new TreeQueryResultParser(applicationUtils, entityStateManager, utils);
        this.orderByParser = new MappedOrderByParser(qValidator);
    }
    /**
     * Entities get merged if they are right next to each other in the result set.  If they
     * are not, they are treated as separate entities - hence, your sort order matters.
     *
     * @param results
     * @returns {any[]}
     */
    async parseQueryResults(results, internalFragments, queryResultType, context, bridgedQueryConfiguration) {
        let parsedResults = [];
        if (!results || !results.length) {
            return parsedResults;
        }
        parsedResults = [];
        results.forEach((result) => {
            let aliasCache = new AliasCache();
            let parsedResult = this.parseQueryResult(this.jsonQuery.S, result, [0], aliasCache, aliasCache.getFollowingAlias());
            {
                parsedResults.push(parsedResult);
            }
            this.queryParser.flushRow();
        });
        return parsedResults;
    }
    getSELECTFragment(nested, selectClauseFragment, internalFragments, context) {
        const distinctClause = selectClauseFragment;
        if (distinctClause.ot == JSONClauseObjectType.DISTINCT_FUNCTION) {
            if (nested) {
                throw new Error(`Cannot have DISTINCT specified in a nested select clause`);
            }
            const distinctSelect = this.getSELECTFragment(nested, distinctClause.appliedFunctions[0].p[0], internalFragments, context);
            return `DISTINCT ${distinctSelect}`;
        }
        let numProperties = 0;
        for (let propertyName in selectClauseFragment) {
            if (propertyName === '*') {
                throw new Error(`'*' operator isn't yet implemented in mapped queries`);
            }
            numProperties++;
        }
        if (numProperties === 0) {
            if (nested) {
                throw new Error(`Mapped query must have fields in a nested-select clause`);
            }
            else {
                return '*';
            }
        }
        let fieldIndex = 0;
        let selectSqlFragment = '';
        for (let propertyName in selectClauseFragment) {
            const value = selectClauseFragment[propertyName];
            // Skip undefined values
            if (value === undefined) {
                continue;
            }
            if (value instanceof SqlFunctionField) {
                selectSqlFragment += value.getValue(this, context);
                continue;
            }
            selectSqlFragment += this.getFieldSelectFragment(value, ClauseType.MAPPED_SELECT_CLAUSE, () => {
                return this.getSELECTFragment(true, value, internalFragments, context);
            }, fieldIndex++, context);
        }
        return selectSqlFragment;
    }
    parseQueryResult(selectClauseFragment, resultRow, nextFieldIndex, aliasCache, entityAlias) {
        // Return blanks, primitives and Dates directly
        if (!resultRow || !(resultRow instanceof Object) || resultRow instanceof Date) {
            return resultRow;
        }
        {
            let distinctClause = selectClauseFragment;
            if (distinctClause.ot == JSONClauseObjectType.DISTINCT_FUNCTION) {
                return this.parseQueryResult(distinctClause.appliedFunctions[0].p[0], resultRow, nextFieldIndex, aliasCache, entityAlias);
            }
        }
        let resultObject = this.queryParser.addEntity(entityAlias);
        for (let propertyName in selectClauseFragment) {
            if (selectClauseFragment[propertyName] === undefined) {
                continue;
            }
            let jsonClauseField = selectClauseFragment[propertyName];
            let dataType = jsonClauseField.dt;
            // Must be a sub-query
            if (!dataType) {
                let childResultObject = this.parseQueryResult(jsonClauseField, resultRow, nextFieldIndex, aliasCache, aliasCache.getFollowingAlias());
                this.queryParser.bufferOneToManyCollection(entityAlias, resultObject, propertyName, childResultObject);
            }
            else {
                let propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, jsonClauseField.fa, nextFieldIndex[0], dataType, null);
                this.queryParser.addProperty(entityAlias, resultObject, dataType, propertyName, propertyValue);
            }
            nextFieldIndex[0]++;
        }
        return this.queryParser.flushEntity(entityAlias, resultObject);
    }
}

var __decorate$_ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SubStatementSqlGenerator = class SubStatementSqlGenerator {
    getTreeQuerySql(jsonTreeQuery, dialect, context) {
        let mappedSqlQuery = new TreeSQLQuery(jsonTreeQuery, dialect, this.airportDatabase, this.applicationUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this.storeDriver, this, this.utils, context);
        const subQuerySql = mappedSqlQuery.toSQL({}, context);
        const parameterReferences = mappedSqlQuery.parameterReferences;
        return {
            parameterReferences,
            subQuerySql
        };
    }
    getFieldQuerySql(jsonFieldSqlSubQuery, dialect, qEntityMapByAlias, context) {
        let fieldSqlQuery = new FieldSQLQuery(jsonFieldSqlSubQuery, dialect, this.airportDatabase, this.applicationUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this.storeDriver, this, this.utils, context);
        fieldSqlQuery.addQEntityMapByAlias(qEntityMapByAlias);
        const subQuerySql = fieldSqlQuery.toSQL({}, context);
        const parameterReferences = fieldSqlQuery.parameterReferences;
        return {
            parameterReferences,
            subQuerySql
        };
    }
};
__decorate$_([
    Inject()
], SubStatementSqlGenerator.prototype, "airportDatabase", void 0);
__decorate$_([
    Inject()
], SubStatementSqlGenerator.prototype, "applicationUtils", void 0);
__decorate$_([
    Inject()
], SubStatementSqlGenerator.prototype, "entityStateManager", void 0);
__decorate$_([
    Inject()
], SubStatementSqlGenerator.prototype, "qMetadataUtils", void 0);
__decorate$_([
    Inject()
], SubStatementSqlGenerator.prototype, "qValidator", void 0);
__decorate$_([
    Inject()
], SubStatementSqlGenerator.prototype, "relationManager", void 0);
__decorate$_([
    Inject()
], SubStatementSqlGenerator.prototype, "sqlQueryAdapter", void 0);
__decorate$_([
    Inject()
], SubStatementSqlGenerator.prototype, "storeDriver", void 0);
__decorate$_([
    Inject()
], SubStatementSqlGenerator.prototype, "utils", void 0);
SubStatementSqlGenerator = __decorate$_([
    Injected()
], SubStatementSqlGenerator);

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * Represents SQL String query with Entity tree Select clause.
 */
class EntitySQLQuery extends SQLQuery {
    constructor(jsonQuery, dbEntity, dialect, queryResultType, airportDatabase, applicationUtils, entityStateManager, objectResultParserFactory, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context, graphQueryConfiguration) {
        super(jsonQuery, dbEntity, dialect, queryResultType, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.objectResultParserFactory = objectResultParserFactory;
        this.graphQueryConfiguration = graphQueryConfiguration;
        this.columnAliases = new AliasCache();
        if (graphQueryConfiguration && this.graphQueryConfiguration.strict !== undefined) {
            throw new Error(`"strict" configuration is not yet implemented for 
			QueryResultType.ENTITY_GRAPH`);
        }
        this.finalSelectTree = this.setupSelectFields(this.jsonQuery.S, dbEntity, context);
        this.orderByParser = new EntityOrderByParser(this.finalSelectTree, airportDatabase, qValidator, relationManager, jsonQuery.OB);
    }
    toSQL(internalFragments, context) {
        let joinNodeMap = {};
        this.joinTree = this.buildFromJoinTree(this.jsonQuery.F, joinNodeMap, context);
        let selectFragment = this.getSELECTFragment(this.dbEntity, this.finalSelectTree, this.joinTree, context);
        let fromFragment = this.getFROMFragment(null, this.joinTree, context);
        let whereFragment = '';
        let jsonQuery = this.jsonQuery;
        if (jsonQuery.W) {
            whereFragment = `
WHERE
${this.getWHEREFragment(jsonQuery.W, '', context)}`;
        }
        let orderByFragment = '';
        if (jsonQuery.OB && jsonQuery.OB.length) {
            orderByFragment = `
ORDER BY
${this.orderByParser.getOrderByFragment(this.joinTree, this.qEntityMapByAlias, context)}`;
        }
        return `SELECT
	${selectFragment}
FROM
${fromFragment}${whereFragment}${orderByFragment}`;
    }
    /**
     * If bridging is not applied:
     *
     * Entities get merged if they are right next to each other in the result set.  If they
     * are not, they are treated as separate entities - hence, your sort order matters.
     *
     * If bridging is applied - all entities get merged - your sort order does not matter.
     * Might as well disallow sort order for bridged queries (or re-sort in memory)?
     *
     * @param results
     * @returns {any[]}
     */
    async parseQueryResults(results, internalFragments, queryResultType, context, bridgedQueryConfiguration) {
        this.queryParser = this.objectResultParserFactory.getObjectResultParser(this.queryResultType, this.graphQueryConfiguration, this.dbEntity);
        let parsedResults = [];
        if (!results || !results.length) {
            return parsedResults;
        }
        parsedResults = [];
        let lastResult;
        for (let i = 0; i < results.length; i++) {
            let result = results[i];
            let entityAlias = this.relationManager.getAlias(this.joinTree.jsonRelation);
            this.columnAliases.reset();
            let parsedResult = this.parseQueryResult(this.finalSelectTree, entityAlias, this.joinTree, result, [0], context);
            if (!lastResult) {
                parsedResults.push(parsedResult);
            }
            else if (lastResult !== parsedResult) {
                parsedResults.push(parsedResult);
            }
            lastResult = parsedResult;
            this.queryParser.flushRow();
        }
        return this.queryParser.bridge(parsedResults, this.jsonQuery.S, context);
    }
    buildFromJoinTree(joinRelations, joinNodeMap, context) {
        let jsonTree;
        // For entity queries it is possible to have a query with no from clause, in this case
        // make the query entity the root tree node
        if (joinRelations.length < 1) {
            let onlyJsonRelation = {
                currentChildIndex: 0,
                ti: this.dbEntity.index,
                fromClausePosition: [],
                jt: null,
                ri: null,
                rt: JSONRelationType.ENTITY_ROOT,
                rep: 'r_',
                si: this.dbEntity.applicationVersion.id
            };
            joinRelations.push(onlyJsonRelation);
        }
        let firstRelation = joinRelations[0];
        switch (firstRelation.rt) {
            case JSONRelationType.ENTITY_ROOT:
                break;
            case JSONRelationType.SUB_QUERY_ROOT:
            case JSONRelationType.SUB_QUERY_JOIN_ON:
                throw new Error(`Entity query's FROM clause cannot contain sub-queries`);
            case JSONRelationType.ENTITY_JOIN_ON:
                throw new Error(`Entity queries cannot use JOIN ON`);
            default:
                throw new Error(`First table in FROM clause cannot be result of a join`);
        }
        // if (firstRelation.rt !== JSONRelationType.ENTITY_ROOT) {
        // 	throw new Error(`First table in FROM clause cannot be joined`)
        // }
        let alias = this.relationManager.getAlias(firstRelation);
        let firstEntity = this.relationManager.createRelatedQEntity(firstRelation, context);
        this.qEntityMapByAlias[alias] = firstEntity;
        this.jsonRelationMapByAlias[alias] = firstRelation;
        // In entity queries the first entity must always be the same as the query entity
        const firstDbEntity = firstEntity.__driver__.dbEntity;
        // if (firstEntity.constructor != this.rootQEntity.constructor) {
        if (firstDbEntity.applicationVersion.application.index !== this.dbEntity.applicationVersion.application.index || firstDbEntity.index !== this.dbEntity.index) {
            throw new Error(`ERROR: Unexpected first table in FROM clause: 
			'${firstDbEntity.applicationVersion.application.name}.${firstDbEntity.name}',
			expecting:
			'${this.dbEntity.applicationVersion.application.name}.${this.dbEntity.name}'`);
        }
        jsonTree = new JoinTreeNode(firstRelation, [], null);
        joinNodeMap[alias] = jsonTree;
        for (let i = 1; i < joinRelations.length; i++) {
            let joinRelation = joinRelations[i];
            switch (joinRelation.rt) {
                case JSONRelationType.ENTITY_ROOT:
                    throw new Error(`All Entity query tables after the first must be joined`);
                case JSONRelationType.SUB_QUERY_JOIN_ON:
                    throw new Error(`Entity queries FROM clause cannot contain sub-queries`);
                case JSONRelationType.ENTITY_JOIN_ON:
                    throw new Error(`Entity queries cannot use JOIN ON`);
            }
            if (!joinRelation.ri && joinRelation.ri !== 0) {
                throw new Error(`Table ${i + 1} in FROM clause is missing 
				relationPropertyName`);
            }
            let parentAlias = this.relationManager.getParentAlias(joinRelation);
            if (!joinNodeMap[parentAlias]) {
                throw new Error(`Missing parent entity for alias ${parentAlias}, 
				on table ${i + 1} in FROM clause`);
            }
            let leftNode = joinNodeMap[parentAlias];
            let rightNode = new JoinTreeNode(joinRelation, [], leftNode);
            leftNode.addChildNode(rightNode);
            alias = this.relationManager.getAlias(joinRelation);
            let rightEntity = this.relationManager.createRelatedQEntity(joinRelation, context);
            this.qEntityMapByAlias[alias] = rightEntity;
            this.jsonRelationMapByAlias[alias] = firstRelation;
            if (!rightEntity) {
                throw new Error(`Could not find entity ${joinRelation.ti} for 
				table ${i + 1} in FROM clause`);
            }
            if (joinNodeMap[alias]) {
                throw new Error(`Alias '${alias}' used more than once in the FROM clause.`);
            }
            joinNodeMap[alias] = rightNode;
        }
        return jsonTree;
    }
    parseQueryResult(selectClauseFragment, entityAlias, currentJoinNode, resultRow, nextColumnIndex, context) {
        // Return blanks, primitives and Dates directly
        if (!resultRow || !(resultRow instanceof Object) || resultRow instanceof Date) {
            return resultRow;
        }
        let numNonNullColumns = 0;
        let qEntity = this.qEntityMapByAlias[entityAlias];
        const dbEntity = qEntity.__driver__.dbEntity;
        let resultObject = this.queryParser.addEntity(entityAlias, dbEntity, context);
        for (let propertyName in selectClauseFragment) {
            const dbProperty = dbEntity.propertyMap[propertyName];
            if (!dbProperty.relation || !dbProperty.relation.length) {
                const columnAlias = this.columnAliases.getFollowingAlias();
                const defaultValue = this.entityDefaults.getForAlias(entityAlias)[propertyName];
                const dbColumn = dbProperty.propertyColumns[0].column;
                const propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, columnAlias, nextColumnIndex[0], dbColumn.type, defaultValue);
                if (this.queryParser.addProperty(entityAlias, resultObject, dbColumn.type, propertyName, propertyValue)) {
                    numNonNullColumns++;
                }
                nextColumnIndex[0]++;
            }
            else {
                const childSelectClauseFragment = selectClauseFragment[propertyName];
                const dbRelation = dbProperty.relation[0];
                const childDbEntity = dbRelation.relationEntity;
                if (childSelectClauseFragment === null || childSelectClauseFragment.__state__ === EntityState$1.STUB) {
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            let haveRelationValues = false;
                            let relationInfos = [];
                            this.applicationUtils.forEachColumnTypeOfRelation(dbRelation, (dbColumn, propertyNameChains) => {
                                const columnAlias = this.columnAliases.getFollowingAlias();
                                let value = this.sqlQueryAdapter.getResultCellValue(resultRow, columnAlias, nextColumnIndex[0], dbColumn.type, null);
                                relationInfos.push({
                                    propertyNameChains: propertyNameChains,
                                    sqlDataType: dbColumn.type,
                                    value
                                });
                                if (this.utils.objectExists(value)) {
                                    haveRelationValues = true;
                                    numNonNullColumns++;
                                }
                                nextColumnIndex[0]++;
                            });
                            if (haveRelationValues) {
                                this.queryParser.bufferManyToOneStub(entityAlias, dbEntity, resultObject, propertyName, childDbEntity, relationInfos, context);
                            }
                            else {
                                this.queryParser.bufferBlankManyToOneStub(entityAlias, resultObject, propertyName, relationInfos);
                            }
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            this.queryParser.bufferOneToManyStub(dbEntity, propertyName);
                            break;
                        default:
                            throw new Error(`Unknown relation type '${dbRelation.relationType}' for 
								'${dbEntity.name}.${dbProperty.name}'`);
                    }
                }
                else {
                    const childJoinNode = currentJoinNode.getEntityRelationChildNode(dbRelation);
                    const childEntityAlias = this.relationManager.getAlias(childJoinNode.jsonRelation);
                    const relationQEntity = this.qEntityMapByAlias[childEntityAlias];
                    const relationDbEntity = relationQEntity.__driver__.dbEntity;
                    let childResultObject = this.parseQueryResult(childSelectClauseFragment, childEntityAlias, childJoinNode, resultRow, nextColumnIndex, context);
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            if (childResultObject) {
                                this.queryParser.bufferManyToOneObject(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, childResultObject, context);
                            }
                            else {
                                this.queryParser.bufferBlankManyToOneObject(entityAlias, resultObject, propertyName);
                            }
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            if (childResultObject) {
                                this.queryParser.bufferOneToManyCollection(entityAlias, resultObject, dbEntity, propertyName, relationDbEntity, childResultObject, context);
                            }
                            else {
                                this.queryParser.bufferBlankOneToMany(entityAlias, resultObject, dbEntity.name, propertyName, relationDbEntity, context);
                            }
                            break;
                        default:
                            throw new Error(`Unknown relation type '${dbRelation.relationType}' for 
								'${dbEntity.name}.${dbProperty.name}'`);
                    }
                }
            }
        }
        if (numNonNullColumns === 0) {
            return null;
        }
        let idValue = this.applicationUtils.getIdKey(resultObject, dbEntity);
        return this.queryParser.flushEntity(entityAlias, dbEntity, selectClauseFragment, idValue, resultObject, context);
    }
    /**
     * Verify that the entity select clause is valid (has ids) and fill in clauses
     * that are blank (defined as {}).
     *
     *
     * {
     *  id1: Y,
     *  id2: {
     *    subId1: Y
     *  },
     *  other1: Y
     * }
     *
     * If no properties are specified all properties are included.
     *
     * @param selectClauseFragment
     * @param {DbEntity} dbEntity
     * @returns {any}
     */
    setupSelectFields(selectClauseFragment, dbEntity, context, parentDbProperty) {
        let retrieveAllOwnFields = true;
        let selectFragment;
        if (!selectClauseFragment || selectClauseFragment instanceof Array) {
            let ofProperty = '';
            if (parentDbProperty) {
                ofProperty = `(of '${parentDbProperty.entity.name}.${parentDbProperty.name}') `;
            }
            throw new Error(`'${dbEntity.name}' Entity SELECT clause ${ofProperty}must be specified as an Object.`);
        }
        else if (isID(selectFragment)) {
            selectFragment = {};
            retrieveAllOwnFields = false;
        }
        else {
            selectFragment = { ...selectClauseFragment };
        }
        let allFieldsSpecified = false;
        if (selectFragment.__allFields__ === true) {
            allFieldsSpecified = true;
            delete selectFragment.__allFields__;
        }
        const entityDefinitionHasIds = !!dbEntity.idColumns.length;
        for (const propertyName in selectFragment) {
            if (!allFieldsSpecified) {
                retrieveAllOwnFields = false;
            }
            const dbProperty = dbEntity.propertyMap[propertyName];
            if (!dbProperty) {
                throw new Error(`Entity property '${dbEntity.name}.${propertyName}' does not exist.`);
            }
            const value = selectFragment[propertyName];
            if (value === undefined || value === null || isN(value)) {
                if (dbProperty.isId) {
                    throw new Error(`@Id properties cannot be excluded from entity queries.`);
                }
                if (!entityDefinitionHasIds) {
                    throw new Error(`Cannot exclude property '${propertyName}' from select clause 
					for '${dbEntity.name}' Entity - entity has no @Id so all properties must be included.`);
                }
                delete selectFragment[propertyName];
                continue;
            }
            // Need to differentiate between properties that contain only
            // foreign key ids and properties
            if (dbProperty.relation && dbProperty.relation.length) {
                selectFragment[propertyName] = this.setupSelectFields(value, dbProperty.relation[0].relationEntity, context, dbProperty);
                // } else {
                // 	//  At least one non-relational field is in the original select clause
                // 	retrieveAllOwnFields = false
            }
            else if (!isY(value)) {
                selectFragment[propertyName] = Y;
            }
        }
        //  For {} select causes, entities with no @Id, retrieve the entire object.
        // Otherwise make sure all @Id columns are specified.
        for (const dbProperty of dbEntity.properties) {
            if (entityDefinitionHasIds && !dbProperty.isId && !retrieveAllOwnFields) {
                continue;
            }
            const allowDefaults = entityDefinitionHasIds && !dbProperty.isId;
            if (dbProperty.relation && dbProperty.relation.length) {
                const dbRelation = dbProperty.relation[0];
                switch (dbRelation.relationType) {
                    case EntityRelationType.ONE_TO_MANY:
                        break;
                    case EntityRelationType.MANY_TO_ONE:
                        // If select fragment for the child entity is already defined, do not overwrite it
                        if (selectFragment[dbProperty.name]) {
                            break;
                        }
                        const manyToOneRelation = {};
                        this.entityStateManager.markAsStub(manyToOneRelation);
                        selectFragment[dbProperty.name] = manyToOneRelation;
                        // applicationUtils.addRelationToEntitySelectClause(dbRelation, selectFragment,
                        // allowDefaults)
                        break;
                    default:
                        throw new Error(`Unknown relation type: '${dbRelation.relationType}' 
						on '${dbEntity.name}.${dbProperty.name}'.`);
                }
            }
            else {
                const value = selectFragment[dbProperty.name];
                if (value !== undefined && value !== null) {
                    if (!allowDefaults && !isY(value)) {
                        throw new Error(`${entityDefinitionHasIds ? '@Id properties' : 'Entities without @Id'} 
						cannot have default SELECT values.`);
                    }
                }
                else {
                    selectFragment[dbProperty.name] = Y;
                }
            }
        }
        return selectFragment;
    }
    getSELECTFragment(dbEntity, selectClauseFragment, joinTree, context, parentProperty) {
        const tableAlias = this.relationManager.getAlias(joinTree.jsonRelation);
        let selectSqlFragments = [];
        this.entityStateManager.isStub(selectClauseFragment);
        const defaults = this.entityDefaults.getForAlias(tableAlias);
        for (let propertyName in selectClauseFragment) {
            if (propertyName === '__state__') {
                continue;
            }
            const value = selectClauseFragment[propertyName];
            if (!isY(value)) {
                defaults[propertyName] = value;
            }
            const dbProperty = dbEntity.propertyMap[propertyName];
            if (dbProperty.relation && dbProperty.relation.length) {
                const dbRelation = dbProperty.relation[0];
                if (this.entityStateManager.isStub(selectClauseFragment[propertyName])) {
                    for (const relationColumn of dbRelation.manyRelationColumns) {
                        const dbColumn = relationColumn.manyColumn;
                        this.addFieldFromColumn(dbColumn);
                        const columnSelect = this.getSimpleColumnFragment(tableAlias, dbColumn.name);
                        selectSqlFragments.push(`${columnSelect} ${this.columnAliases.getFollowingAlias()}`);
                    }
                }
                else {
                    const subSelectFragments = this.getSELECTFragment(dbRelation.relationEntity, selectClauseFragment[propertyName], joinTree.getEntityRelationChildNode(dbRelation), context, dbProperty);
                    selectSqlFragments = selectSqlFragments.concat(subSelectFragments);
                }
            }
            else {
                const dbColumn = dbProperty.propertyColumns[0].column;
                this.addFieldFromColumn(dbColumn);
                const columnSelect = this.getSimpleColumnFragment(tableAlias, dbColumn.name);
                selectSqlFragments.push(`${columnSelect} ${this.columnAliases.getFollowingAlias()}`);
            }
        }
        return selectSqlFragments;
    }
    getFROMFragment(parentTree, currentTree, context) {
        let fromFragment = '\t';
        let currentRelation = currentTree.jsonRelation;
        let currentAlias = this.relationManager.getAlias(currentRelation);
        let qEntity = this.qEntityMapByAlias[currentAlias];
        let tableName = this.storeDriver.getEntityTableName(qEntity.__driver__.dbEntity, context);
        if (!parentTree) {
            fromFragment += `${tableName} ${currentAlias}`;
        }
        else {
            let parentRelation = parentTree.jsonRelation;
            let parentAlias = this.relationManager.getAlias(parentRelation);
            let leftEntity = this.qEntityMapByAlias[parentAlias];
            let rightEntity = this.qEntityMapByAlias[currentAlias];
            let joinTypeString;
            switch (currentRelation.jt) {
                case JoinType.FULL_JOIN:
                    throw new Error(`Full Joins are not allowed in Entity queries.`);
                case JoinType.INNER_JOIN:
                    joinTypeString = 'INNER JOIN';
                    break;
                case JoinType.LEFT_JOIN:
                    joinTypeString = 'LEFT JOIN';
                    break;
                case JoinType.RIGHT_JOIN:
                    throw new Error(`Right Joins are not allowed in Entity queries.`);
                default:
                    throw new Error(`Unsupported join type: ${currentRelation.jt}`);
            }
            let errorPrefix = 'Error building FROM: ';
            switch (currentRelation.rt) {
                case JSONRelationType.ENTITY_APPLICATION_RELATION:
                    fromFragment += this.getEntityApplicationRelationFromJoin(leftEntity, rightEntity, currentRelation, parentRelation, currentAlias, parentAlias, joinTypeString, errorPrefix, context);
                    break;
                default:
                    throw new Error(`Only Entity application relations are allowed in Entity query FROM clause.`);
            }
        }
        for (let i = 0; i < currentTree.childNodes.length; i++) {
            let childTreeNode = currentTree.childNodes[i];
            fromFragment += this.getFROMFragment(currentTree, childTreeNode, context);
        }
        return fromFragment;
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * Represents SQL String query with flat (aka traditional) Select clause.
 */
class SheetSQLQuery extends NonEntitySQLQuery {
    constructor(jsonQuery, dialect, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context) {
        super(jsonQuery, dialect, QueryResultType.SHEET, airportDatabase, applicationUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context);
        this.orderByParser = new ExactOrderByParser(qValidator);
    }
    async parseQueryResults(results, internalFragments, queryResultType, context, bridgedQueryConfiguration) {
        let parsedResults = [];
        if (!results || !results.length) {
            return parsedResults;
        }
        parsedResults = [];
        results.forEach((result) => {
            let parsedResult = this.parseQueryResult(this.jsonQuery.S, result, [0], internalFragments);
            parsedResults.push(parsedResult);
        });
        return parsedResults;
    }
    getSELECTFragment(nested, selectClauseFragment, internalFragments, context) {
        if (!selectClauseFragment) {
            throw new Error(`SELECT clause is not defined for a Flat Query`);
        }
        {
            let distinctClause = selectClauseFragment;
            if (distinctClause.ot == JSONClauseObjectType.DISTINCT_FUNCTION) {
                let distinctSelect = this.getSELECTFragment(nested, distinctClause.appliedFunctions[0].p[0], internalFragments, context);
                return `DISTINCT ${distinctSelect}`;
            }
        }
        if (!(selectClauseFragment instanceof Array)) {
            throw new Error(`SELECT clause for a Flat Query must be an Array`);
        }
        let fieldIndex = 0;
        let selectSqlFragment = selectClauseFragment.map((field) => {
            return this.getFieldSelectFragment(field, ClauseType.NON_MAPPED_SELECT_CLAUSE, null, fieldIndex++, context);
        })
            .join('');
        const selectClause = internalFragments.SELECT;
        if (selectClause && selectClause.length) {
            if (fieldIndex) {
                selectSqlFragment += '\n\t,';
            }
            selectSqlFragment += selectClause
                .map(dbColumn => `${dbColumn.name}`)
                .join('\n\t,');
        }
        return selectSqlFragment;
    }
    parseQueryResult(selectClauseFragment, resultRow, nextFieldIndex, internalFragments) {
        const resultsFromSelect = selectClauseFragment.map((field) => {
            let propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, field.fa, nextFieldIndex[0], field.dt, null);
            nextFieldIndex[0]++;
            return propertyValue;
        });
        const selectClause = internalFragments.SELECT;
        if (selectClause && selectClause.length) {
            for (const dbColumn of selectClause) {
                let propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, dbColumn.name, nextFieldIndex[0], dbColumn.type, null);
                resultsFromSelect.push(propertyValue);
                nextFieldIndex[0]++;
            }
        }
        return resultsFromSelect;
    }
}

var __decorate$Z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ActiveQueries = class ActiveQueries {
    constructor() {
        this.queries = new Map();
    }
    add(portableQuery, cachedSqlQuery) {
        this.queries.set(portableQuery, cachedSqlQuery);
    }
    remove(portableQuery) {
        this.queries.delete(portableQuery);
    }
    markQueriesToRerun(applicationMap) {
        this.queries.forEach((cachedSqlQuery) => {
            if (applicationMap.intersects(cachedSqlQuery.sqlQuery.getFieldMap())) {
                cachedSqlQuery.rerun = true;
            }
        });
    }
    rerunQueries( //
    ) {
        // Add a bit of a wait to let any query-subscribed screens that are closing after
        // a mutation operation to un-subscribe from those queries.
        setTimeout(() => {
            this.queries.forEach((cachedSqlQuery) => {
                if (cachedSqlQuery.rerun) {
                    cachedSqlQuery.rerun = false;
                    cachedSqlQuery.runQuery();
                }
            });
        }, 100);
    }
};
ActiveQueries = __decorate$Z([
    Injected()
], ActiveQueries);

var __decorate$Y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 9/2/2016.
 */
let IdGenerator = class IdGenerator {
    constructor() {
        this.transactionHistoryIdColumns = [];
    }
    async init() {
        this.populateTransactionHistoryIdColumns().then();
    }
    populateTransactionHistoryIdColumns() {
        return new Promise((resolve, _reject) => {
            this.doPopulateTransactionHistoryIdColumns(resolve);
        });
    }
    doPopulateTransactionHistoryIdColumns(resolve) {
        if (Q$4.__dbApplication__ && Q$4.__dbApplication__.currentVersion) {
            const transactionHistoryDbEntity = this.getHoldingPatternDbEntity('TransactionHistory');
            const repoTransHistoryDbEntity = this.getHoldingPatternDbEntity('RepositoryTransactionHistory');
            const operationHistoryDbEntity = this.getHoldingPatternDbEntity('OperationHistory');
            const recordHistoryDbEntity = this.getHoldingPatternDbEntity('RecordHistory');
            this.transactionHistoryIdColumns.push(transactionHistoryDbEntity.idColumns[0]);
            this.transactionHistoryIdColumns.push(repoTransHistoryDbEntity.idColumns[0]);
            this.transactionHistoryIdColumns.push(operationHistoryDbEntity.idColumns[0]);
            this.transactionHistoryIdColumns.push(recordHistoryDbEntity.idColumns[0]);
            resolve();
        }
        else {
            setTimeout(() => {
                this.doPopulateTransactionHistoryIdColumns(resolve);
            }, 100);
        }
    }
    async generateTransactionHistoryIds(numRepositoryTransHistories, numOperationTransHistories, numRecordHistories) {
        let generatedSequenceNumbers = await this.sequenceGenerator
            .generateSequenceNumbers(this.transactionHistoryIdColumns, [
            1,
            numRepositoryTransHistories,
            numOperationTransHistories,
            numRecordHistories
        ]);
        return {
            operationHistoryIds: generatedSequenceNumbers[2],
            recordHistoryIds: generatedSequenceNumbers[3],
            repositoryHistoryIds: generatedSequenceNumbers[1],
            transactionHistoryId: generatedSequenceNumbers[0][0]
        };
    }
    async generateEntityIds() {
    }
    getHoldingPatternDbEntity(holdingPatternEntityName) {
        return Q$4.__dbApplication__.currentVersion[0].applicationVersion
            .entityMapByName[holdingPatternEntityName];
    }
};
__decorate$Y([
    Inject()
], IdGenerator.prototype, "sequenceGenerator", void 0);
IdGenerator = __decorate$Y([
    Injected()
], IdGenerator);

/**
 * Created by Papa on 6/28/2016.
 */
var CurrentState;
(function (CurrentState) {
    CurrentState["CREATED"] = "CREATED";
    CurrentState["DELETED"] = "DELETED";
    CurrentState["UPDATED"] = "UPDATED";
})(CurrentState || (CurrentState = {}));

var __decorate$X = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 9/9/2016.
 */
let SqlDriver = class SqlDriver {
    supportsLocalTransactions(context) {
        return true;
    }
    getEntityTableName(dbEntity, context) {
        return this.getTableName(dbEntity.applicationVersion.application, dbEntity, context);
    }
    getTableName(application, table, context) {
        let theTableName = table.name;
        if (table.tableConfig && table.tableConfig.name) {
            theTableName = table.tableConfig.name;
        }
        let fullApplicationName;
        if (application.fullName) {
            fullApplicationName = application.fullName;
        }
        else {
            fullApplicationName = this.dbApplicationUtils.getFullApplicationName(application);
        }
        return this.composeTableName(fullApplicationName, theTableName, context);
    }
    async internalSetupTransaction(transaction, context) {
        await this.ensureContext(context);
    }
    async tearDownTransaction(transaction, context) {
        if (transaction.childTransaction) {
            this.tearDownTransaction(transaction.childTransaction, context);
        }
        if (transaction.parentTransaction) {
            transaction.parentTransaction.childTransaction = null;
            transaction.parentTransaction = null;
        }
    }
    async startTransaction(transaction, context) {
        await this.ensureContext(context);
        try {
            await this.internalStartTransaction(transaction);
        }
        catch (e) {
            await this.tearDownTransaction(transaction, context);
            console.error(e);
            throw e;
        }
    }
    async commit(transaction, context) {
        await this.ensureContext(context);
        try {
            await this.internalCommit(transaction);
        }
        catch (e) {
            console.error(e);
            try {
                await this.internalRollback(transaction);
            }
            catch (rollbackError) {
                console.error(rollbackError);
            }
            throw e;
        }
        finally {
            await this.tearDownTransaction(transaction, context);
        }
    }
    async rollback(transaction, context) {
        await this.ensureContext(context);
        try {
            await this.internalRollback(transaction);
        }
        catch (e) {
            console.error(e);
            // Do not re-throw the exception, rollback is final (at least for now)
        }
        finally {
            await this.tearDownTransaction(transaction, context);
        }
    }
    async insertValues(portableQuery, context, cachedSqlQueryId) {
        const splitValues = this.splitValues(portableQuery.jsonQuery.V, context);
        let numVals = 0;
        for (const V of splitValues) {
            let sqlInsertValues = new SQLInsertValues({
                ...portableQuery.jsonQuery,
                V
            }, this.getDialect(context), this.airportDatabase, this.applicationUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementQueryGenerator, this.utils, context);
            let sql = sqlInsertValues.toSQL(context);
            let parameters = sqlInsertValues.getParameters(portableQuery.parameterMap, context);
            numVals += await this.executeNative(sql, parameters, context);
        }
        return numVals;
    }
    async deleteWhere(portableQuery, context) {
        let fieldMap = new SyncApplicationMap();
        let sqlDelete = new SQLDelete(portableQuery.jsonQuery, this.getDialect(context), this.airportDatabase, this.applicationUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementQueryGenerator, this.utils, context);
        let sql = sqlDelete.toSQL(context);
        let parameters = sqlDelete.getParameters(portableQuery.parameterMap, context);
        let numberOfAffectedRecords = await this.executeNative(sql, parameters, context);
        this.activeQueries.markQueriesToRerun(fieldMap);
        return numberOfAffectedRecords;
    }
    async updateWhere(portableQuery, internalFragments, context) {
        let sqlUpdate = new SQLUpdate(portableQuery.jsonQuery, this.getDialect(context), this.airportDatabase, this.applicationUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementQueryGenerator, this.utils, context);
        let sql = sqlUpdate.toSQL(internalFragments, context);
        let parameters = sqlUpdate.getParameters(portableQuery.parameterMap, context);
        return await this.executeNative(sql, parameters, context);
    }
    async find(portableQuery, internalFragments, context, cachedSqlQueryId) {
        if (context.transaction) {
            return await context.transaction.find(portableQuery, internalFragments, context, cachedSqlQueryId);
        }
        context = await this.ensureContext(context);
        const sqlQuery = this.getSQLQuery(portableQuery, context);
        const sql = sqlQuery.toSQL(internalFragments, context);
        const parameters = sqlQuery.getParameters(portableQuery.parameterMap, context);
        let results = await this.findNative(sql, parameters, context);
        results = await sqlQuery.parseQueryResults(results, internalFragments, portableQuery.queryResultType, context);
        // FIXME: convert to MappedEntityArray if needed
        return results;
    }
    getSQLQuery(portableQuery, context) {
        let jsonQuery = portableQuery.jsonQuery;
        let dialect = this.getDialect(context);
        let resultType = portableQuery.queryResultType;
        const QueryResType = QueryResultType;
        switch (resultType) {
            case QueryResType.ENTITY_GRAPH:
            case QueryResType.ENTITY_TREE:
            case QueryResType.MAPPED_ENTITY_GRAPH:
            case QueryResType.MAPPED_ENTITY_TREE:
                const dbEntity = this.airportDatabase.applications[portableQuery.applicationIndex]
                    .currentVersion[0].applicationVersion.entities[portableQuery.tableIndex];
                return new EntitySQLQuery(jsonQuery, dbEntity, dialect, resultType, this.airportDatabase, this.applicationUtils, this.entityStateManager, this.objectResultParserFactory, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementQueryGenerator, this.utils, context);
            case QueryResType.FIELD:
                return new FieldSQLQuery(jsonQuery, dialect, this.airportDatabase, this.applicationUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementQueryGenerator, this.utils, context);
            case QueryResType.SHEET:
                return new SheetSQLQuery(jsonQuery, dialect, this.airportDatabase, this.applicationUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementQueryGenerator, this.utils, context);
            case QueryResType.TREE:
                return new TreeSQLQuery(jsonQuery, dialect, this.airportDatabase, this.applicationUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementQueryGenerator, this.utils, context);
            case QueryResType.RAW:
            default:
                throw new Error(`Unknown QueryResultType: ${resultType}`);
        }
    }
    async findOne(portableQuery, internalFragments, context, cachedSqlQueryId) {
        let results = await this.find(portableQuery, internalFragments, context);
        if (results.length > 1) {
            throw new Error(`Expecting a single result, got ${results.length}`);
        }
        if (results.length == 1) {
            return results[0];
        }
        return null;
    }
    search(portableQuery, internalFragments, context, cachedSqlQueryId) {
        let resultsSubject = new Subject();
        // TODO: Remove the query for the list of cached queries, that are checked every
        //    time a mutation operation is run
        // let resultsSubject                 = new Subject<EntityArray>(() => {
        // 	if (resultsSubject.subscriptions.length < 1) {
        // 					// Remove the query for the list of cached queries, that are checked every
        // 					// time a mutation operation is run
        // 					this.activeQueries.remove(portableQuery)
        // 	}
        // })
        let cachedSqlQuery = {
            resultsSubject: resultsSubject,
            runQuery: () => {
                this.find(portableQuery, internalFragments, context)
                    .then((results) => {
                    // FIXME: convert to MappedEntityArray if needed
                    resultsSubject.next(results);
                });
            }
        };
        // this.queries.add(portableQuery, cachedSqlQuery);
        cachedSqlQuery.runQuery();
        return resultsSubject;
    }
    searchOne(portableQuery, internalFragments, context, cachedSqlQueryId) {
        let resultsSubject = new Subject();
        // TODO: Remove the query for the list of cached queries, that are checked every
        //       time a mutation operation is run
        // let resultsSubject                 = new Subject<E>(() => {
        // 	if (resultsSubject.subscriptions.length < 1) {
        // 					// Remove the query for the list of cached queries, that are checked every
        // 					// time a mutation operation is run
        // 					this.activeQueries.remove(portableQuery)
        // 	}
        // });
        let cachedSqlQuery = {
            resultsSubject: resultsSubject,
            runQuery: () => {
                this.findOne(portableQuery, internalFragments, context)
                    .then((result) => {
                    resultsSubject.next(result);
                });
            }
        };
        // this.queries.add(portableQuery, cachedSqlQuery);
        cachedSqlQuery.runQuery();
        return resultsSubject;
    }
    warn(message) {
        console.log(message);
    }
    splitValues(values, context) {
        const valuesInRow = values[0].length;
        const numValues = values.length * valuesInRow;
        if (numValues <= this.maxValues) {
            return [values];
        }
        let numRowsPerBatch = Math.floor(this.maxValues / valuesInRow);
        const splitValues = [];
        for (let i = 0; i < values.length; i += numRowsPerBatch) {
            const aSplitValues = values.slice(i, i + numRowsPerBatch);
            splitValues.push(aSplitValues);
        }
        return splitValues;
    }
    async ensureContext(context) {
        context = doEnsureContext(context);
        await this.operationContextLoader.ensure(context);
        return context;
    }
};
__decorate$X([
    Inject()
], SqlDriver.prototype, "activeQueries", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "airportDatabase", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "applicationUtils", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "dbApplicationUtils", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "entityStateManager", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "objectResultParserFactory", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "operationContextLoader", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "qMetadataUtils", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "qValidator", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "relationManager", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "transactionManager", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "sqlQueryAdapter", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "subStatementQueryGenerator", void 0);
__decorate$X([
    Inject()
], SqlDriver.prototype, "utils", void 0);
SqlDriver = __decorate$X([
    Injected()
], SqlDriver);

class SqlTransaction {
    constructor(driver, parentTransaction) {
        this.driver = driver;
        this.parentTransaction = parentTransaction;
        this.isSync = false;
        this.initiator = {
            application: '',
            domain: '',
            methodName: '',
            objectName: ''
        };
        this.__container__ = driver.__container__;
        this.id = v4();
        this.type = driver.type;
        if (parentTransaction) {
            parentTransaction.childTransaction = this;
        }
    }
    async query(queryType, query, params = [], context, saveTransaction = false) {
        return this.driver.query(queryType, query, params, context, saveTransaction);
    }
    async doesTableExist(applicationName, tableName, context) {
        return await this.driver.doesTableExist(applicationName, tableName, context);
    }
    async dropTable(applicationName, tableName, context) {
        return await this.driver.dropTable(applicationName, tableName, context);
    }
    getEntityTableName(dbEntity, context) {
        return this.driver.getEntityTableName(dbEntity, context);
    }
    getTableName(application, table, context) {
        return this.driver.getTableName(application, table, context);
    }
    async initialize(dbName, context) {
        // Nothing to do
    }
    search(portableQuery, internalFragments, context, cachedSqlQueryId) {
        return this.driver.search(portableQuery, internalFragments, context, cachedSqlQueryId);
    }
    searchOne(portableQuery, internalFragments, context, cachedSqlQueryId) {
        return this.driver.searchOne(portableQuery, internalFragments, context, cachedSqlQueryId);
    }
    async startTransaction(transaction, context) {
        throw new Error(`Nested transactions are not supported`);
    }
    async setupTransaction(context, parentTransaction) {
        throw new Error(`Nested transactions are not supported`);
    }
    async tearDownTransaction(transaction, context) {
        throw new Error(`Nested transactions are not supported`);
    }
    async commit(transaction, context) {
        await this.driver.commit(this, context);
    }
    async rollback(transaction, context) {
        await this.driver.rollback(this, context);
    }
    async deleteWhere(portableQuery, context) {
        return await this.driver.deleteWhere(portableQuery, context);
    }
    async find(portableQuery, internalFragments, context, cachedSqlQueryId) {
        return await this.driver.find(portableQuery, internalFragments, context, cachedSqlQueryId);
    }
    async findOne(portableQuery, internalFragments, context, cachedSqlQueryId) {
        return await this.driver.findOne(portableQuery, internalFragments, context, cachedSqlQueryId);
    }
    async findNative(sqlQuery, parameters, context) {
        return await this.driver.findNative(sqlQuery, parameters, context);
    }
    async insertValues(portableQuery, context, cachedSqlQueryId) {
        return await this.driver.insertValues(portableQuery, context, cachedSqlQueryId);
    }
    async updateWhere(portableQuery, internalFragments, context) {
        return await this.driver.updateWhere(portableQuery, internalFragments, context);
    }
    isValueValid(value, sqlDataType, context) {
        return this.driver.isValueValid(value, sqlDataType, context);
    }
}

var __decorate$W = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let QValidator = class QValidator {
    validateInsertQEntity(dbEntity) {
    }
    validateReadFromEntity(relation) {
    }
    validateReadProperty(dbColumn) {
    }
    validateUpdateProperty(propertyName, dbEntity) {
    }
    validateUpdateColumn(dbColumn) {
    }
    validateReadQEntityProperty(applicationIndex, tableIndex, columnIndex) {
    }
    validateReadQEntityManyToOneRelation(applicationIndex, tableIndex, columnIndex) {
    }
    addFunctionAlias(functionAlias) {
    }
    addSubQueryAlias(subQueryAlias) {
    }
    validateAliasedFieldAccess(fieldAlias) {
    }
};
QValidator = __decorate$W([
    Injected()
], QValidator);

const fuelHydrantSystem = lib$1('fuel-hydrant-system');
const ACTIVE_QUERIES = fuelHydrantSystem.token({
    class: ActiveQueries,
    interface: 'IActiveQueries',
    token: 'ACTIVE_QUERIES'
});
const SUB_STATEMENT_SQL_GENERATOR = fuelHydrantSystem.token({
    class: SubStatementSqlGenerator,
    interface: 'ISubStatementSqlGenerator',
    token: 'SUB_STATEMENT_SQL_GENERATOR'
});
const ID_GENERATOR = fuelHydrantSystem.token({
    class: IdGenerator,
    interface: 'IIdGenerator',
    token: 'ID_GENERATOR'
});
const OBJECT_RESULT_PARSER_FACTORY = fuelHydrantSystem.token({
    class: ObjectResultParserFactory,
    interface: 'IObjectResultParserFactory',
    token: 'OBJECT_RESULT_PARSER_FACTORY'
});
const Q_VALIDATOR = fuelHydrantSystem.token({
    class: QValidator,
    interface: 'IValidator',
    token: 'Q_VALIDATOR'
});
const SQL_QUERY_ADAPTOR = fuelHydrantSystem.token({
    class: null,
    interface: 'ISQLQueryAdaptor',
    token: 'SQL_QUERY_ADAPTOR'
});
const ABSTRACT_SQL_DRIVER = fuelHydrantSystem.token({
    class: SqlDriver,
    interface: 'class SqlDriver',
    token: 'ABSTRACT_SQL_DRIVER'
});
ID_GENERATOR.setDependencies({
    sequenceGenerator: SEQUENCE_GENERATOR
});
OBJECT_RESULT_PARSER_FACTORY.setDependencies({
    applicationUtils: APPLICATION_UTILS,
    entityStateManager: ENTITY_STATE_MANAGER,
    utils: UTILS
});
ABSTRACT_SQL_DRIVER.setDependencies({
    activeQueries: ACTIVE_QUERIES,
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: APPLICATION_UTILS,
    dbApplicationUtils: DB_APPLICATION_UTILS,
    entityStateManager: ENTITY_STATE_MANAGER,
    objectResultParserFactory: OBJECT_RESULT_PARSER_FACTORY,
    operationContextLoader: OPERATION_CONTEXT_LOADER,
    qMetadataUtils: Q_METADATA_UTILS,
    qValidator: Q_VALIDATOR,
    relationManager: RELATION_MANAGER,
    transactionManager: TRANSACTION_MANAGER,
    sqlQueryAdapter: SQL_QUERY_ADAPTOR,
    subStatementQueryGenerator: SUB_STATEMENT_SQL_GENERATOR,
    utils: UTILS
});
SUB_STATEMENT_SQL_GENERATOR.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: APPLICATION_UTILS,
    entityStateManager: ENTITY_STATE_MANAGER,
    qMetadataUtils: Q_METADATA_UTILS,
    qValidator: Q_VALIDATOR,
    relationManager: RELATION_MANAGER,
    sqlQueryAdapter: SQL_QUERY_ADAPTOR,
    storeDriver: STORE_DRIVER,
    utils: UTILS
});

var __decorate$V = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DebugSynchronizationAdapter = class DebugSynchronizationAdapter {
    async getTransactionsForRepository(repositorySource, repositoryUuId, sinceSyncTimestamp) {
        const response = await this.nonhubClient.getRepositoryTransactions(repositorySource, repositoryUuId, sinceSyncTimestamp);
        const messages = [];
        // NOTE: syncTimestamp is populated here because file sharing mechanisms
        // (IPFS) won't be able to modify the messages themselves
        for (const fragment of response) {
            if (fragment.repositoryUuId !== repositoryUuId) {
                console.error(`Got a reponse fragment for repository ${fragment.repositoryUuId}.
    Expecting message fragments for repository: ${repositoryUuId}`);
                continue;
            }
            for (const message of fragment.messages) {
                message.syncTimestamp = fragment.syncTimestamp;
                messages.push(message);
            }
        }
        return messages;
    }
    async sendTransactions(repositorySource, messagesByRepository) {
        let allSent = true;
        for (const [repositoryUuid, messages] of messagesByRepository) {
            try {
                if (!await this.sendTransactionsForRepository(repositorySource, repositoryUuid, messages)) {
                    allSent = false;
                }
            }
            catch (e) {
                console.error(e);
                allSent = false;
            }
        }
        return allSent;
    }
    async sendTransactionsForRepository(repositorySource, repositoryUuId, messages) {
        if (!messages || !messages.length) {
            return false;
        }
        const syncTimestamp = await this.nonhubClient.sendRepositoryTransactions(repositorySource, repositoryUuId, messages);
        if (!syncTimestamp) {
            return false;
        }
        for (const message of messages) {
            message.syncTimestamp = syncTimestamp;
        }
        return true;
    }
};
__decorate$V([
    Inject()
], DebugSynchronizationAdapter.prototype, "nonhubClient", void 0);
DebugSynchronizationAdapter = __decorate$V([
    Injected()
], DebugSynchronizationAdapter);

var __decorate$U = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SynchronizationAdapterLoader = class SynchronizationAdapterLoader {
    async load(synchronizationSource) {
        switch (synchronizationSource) {
            case 'IPFS': {
                throw new Error(`Not Implemented`);
            }
            case 'localhost:9000': {
                return this.debugSynchronizationAdapter;
            }
            default:
                throw new Error(`Unexpected synchronization source: ${synchronizationSource}`);
        }
    }
};
__decorate$U([
    Inject()
], SynchronizationAdapterLoader.prototype, "debugSynchronizationAdapter", void 0);
SynchronizationAdapterLoader = __decorate$U([
    Injected()
], SynchronizationAdapterLoader);

var __decorate$T = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SyncInActorChecker = class SyncInActorChecker {
    async ensureActors(message) {
        try {
            let actorUuids = [];
            let messageActorIndexMap = new Map();
            for (let i = 0; i < message.actors.length; i++) {
                const actor = message.actors[i];
                if (typeof actor.uuId !== 'string' || actor.uuId.length !== 36) {
                    throw new Error(`Invalid 'terminal.uuid'`);
                }
                this.checkActorApplication(actor, message);
                this.checkActorTerminal(actor, message);
                this.checkActorUser(actor, message);
                actorUuids.push(actor.uuId);
                messageActorIndexMap.set(actor.uuId, i);
                // Make sure id field is not in the input
                delete actor.id;
            }
            const actors = await this.actorDao.findByUuIds(actorUuids);
            for (const actor of actors) {
                const messageUserIndex = messageActorIndexMap.get(actor.uuId);
                message.actors[messageUserIndex] = actor;
            }
            const missingActors = message.actors
                .filter(messageActor => !messageActor.id);
            if (missingActors.length) {
                await this.actorDao.insert(missingActors);
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    checkActorApplication(actor, message) {
        if (typeof actor.application !== 'number') {
            throw new Error(`Expecting "in-message index" (number)
			in 'actor.terminal'`);
        }
        const application = message.applications[actor.application];
        if (!application) {
            throw new Error(`Did not find actor.application with "in-message index" ${actor.application}`);
        }
        actor.application = application;
    }
    checkActorTerminal(actor, message) {
        if (typeof actor.terminal !== 'number') {
            throw new Error(`Expecting "in-message index" (number)
			in 'actor.terminal'`);
        }
        const terminal = message.terminals[actor.terminal];
        if (!terminal) {
            throw new Error(`Did not find actor.terminal with "in-message index" ${actor.terminal}`);
        }
        actor.terminal = terminal;
    }
    checkActorUser(actor, message) {
        if (typeof actor.user !== 'number') {
            throw new Error(`Expecting "in-message index" (number)
			in 'actor.user'`);
        }
        const user = message.users[actor.user];
        if (!user) {
            throw new Error(`Did not find actor.user with "in-message index" ${actor.user}`);
        }
        actor.user = user;
    }
};
__decorate$T([
    Inject()
], SyncInActorChecker.prototype, "actorDao", void 0);
SyncInActorChecker = __decorate$T([
    Injected()
], SyncInActorChecker);

var __decorate$S = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SyncInApplicationChecker = class SyncInApplicationChecker {
    async ensureApplications(message) {
        try {
            let applicationCheckMap = await this.checkApplicationsAndDomains(message);
            for (let i = 0; i < message.applications.length; i++) {
                let application = message.applications[i];
                message.applications[i] = applicationCheckMap
                    .get(application.domain.name).get(application.name)
                    .application;
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    async checkApplicationsAndDomains(message) {
        const { allApplicationNames, domainCheckMap, domainNames, applicationCheckMap } = this.getNames(message);
        const applications = await this.applicationDao
            .findByDomainNamesAndApplicationNames(domainNames, allApplicationNames);
        for (let application of applications) {
            let domainName = application.domain.name;
            let applicationName = application.name;
            for (let [_, applicationCheck] of applicationCheckMap.get(domainName)) {
                if (applicationCheck.applicationName === applicationName) {
                    let domainCheck = domainCheckMap.get(domainName);
                    domainCheck.found = true;
                    domainCheck.domain = application.domain;
                    applicationCheck.found = true;
                    applicationCheck.application = application;
                }
            }
        }
        let domainsToCreate = [];
        for (let [name, domainCheck] of domainCheckMap) {
            if (domainCheck.found) {
                continue;
            }
            let domain = {
                id: null,
                name
            };
            domainCheck.domain = domain;
            domainsToCreate.push(domain);
        }
        if (domainsToCreate.length) {
            await this.domainDao.insert(domainsToCreate);
        }
        let applicationsToCreate = [];
        for (let [domainName, applicationChecksByName] of applicationCheckMap) {
            for (let [name, applicationCheck] of applicationChecksByName) {
                if (applicationCheck.found) {
                    continue;
                }
                let domain = domainCheckMap.get(domainName).domain;
                let application = {
                    domain,
                    index: null,
                    name,
                    scope: 'private',
                    status: ApplicationStatus.STUB,
                    signature: 'localhost'
                };
                applicationCheck.application = application;
                applicationsToCreate.push(application);
            }
        }
        if (applicationsToCreate.length) {
            await this.applicationDao.insert(applicationsToCreate);
        }
        return applicationCheckMap;
    }
    getNames(message) {
        if (!message.applications || !(message.applications instanceof Array)) {
            throw new Error(`Did not find applications in RepositorySynchronizationMessage.`);
        }
        const domainCheckMap = new Map();
        const applicationCheckMap = new Map();
        for (let application of message.applications) {
            if (typeof application !== 'object') {
                throw new Error(`Invalid ApplicationVersion.application`);
            }
            if (!application.name || typeof application.name !== 'string') {
                throw new Error(`Invalid ApplicationVersion.Application.name`);
            }
            const domain = application.domain;
            if (typeof domain !== 'object') {
                throw new Error(`Invalid ApplicationVersion.Application.Domain`);
            }
            if (!domain.name || typeof domain.name !== 'string') {
                throw new Error(`Invalid ApplicationVersion.Application.Domain.name`);
            }
            let applicationChecksForDomain = applicationCheckMap.get(domain.name);
            if (!applicationChecksForDomain) {
                applicationChecksForDomain = new Map();
                applicationCheckMap.set(domain.name, applicationChecksForDomain);
            }
            if (!applicationChecksForDomain.has(application.name)) {
                applicationChecksForDomain.set(application.name, {
                    applicationName: application.name,
                });
            }
            let domainCheck = domainCheckMap.get(domain.name);
            if (!domainCheck) {
                domainCheckMap.set(domain.name, {
                    domainName: domain.name
                });
            }
        }
        const domainNames = [];
        const allApplicationNames = [];
        for (const [domainName, applicationChecksForDomainMap] of applicationCheckMap) {
            domainNames.push(domainName);
            for (let [applicationName, _] of applicationChecksForDomainMap) {
                allApplicationNames.push(applicationName);
            }
        }
        return {
            allApplicationNames,
            domainCheckMap,
            domainNames,
            applicationCheckMap
        };
    }
};
__decorate$S([
    Inject()
], SyncInApplicationChecker.prototype, "applicationDao", void 0);
__decorate$S([
    Inject()
], SyncInApplicationChecker.prototype, "domainDao", void 0);
SyncInApplicationChecker = __decorate$S([
    Injected()
], SyncInApplicationChecker);

var __decorate$R = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SyncInApplicationVersionChecker = class SyncInApplicationVersionChecker {
    async ensureApplicationVersions(message) {
        try {
            let applicationCheckMap = await this.checkVersionsApplicationsDomains(message);
            for (let i = 0; i < message.applicationVersions.length; i++) {
                const applicationVersion = message.applicationVersions[i];
                message.applicationVersions[i] = applicationCheckMap
                    .get(applicationVersion.application.domain.name).get(applicationVersion.application.name)
                    .applicationVersion;
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    async checkVersionsApplicationsDomains(message) {
        const { allApplicationNames, domainNames, applicationVersionCheckMap } = this.getNames(message);
        const applicationVersions = await this.applicationVersionDao.findByDomainNamesAndApplicationNames(domainNames, allApplicationNames);
        let lastDomainName;
        let lastApplicationName;
        for (let applicationVersion of applicationVersions) {
            let domainName = applicationVersion.application.domain.name;
            let applicationName = applicationVersion.application.name;
            if (lastDomainName !== domainName
                && lastApplicationName !== applicationName) {
                let applicationVersionNumber = applicationVersion.integerVersion;
                for (let [_, applicationCheck] of applicationVersionCheckMap.get(domainName)) {
                    if (applicationCheck.applicationName === applicationName) {
                        applicationCheck.found = true;
                        if (applicationCheck.applicationVersionNumber > applicationVersionNumber) {
                            throw new Error(`Installed application ${applicationName} for domain ${domainName}
	is at a lower version ${applicationVersionNumber} than needed in message ${applicationCheck.applicationVersionNumber}.`);
                        }
                        applicationCheck.applicationVersion = applicationVersion;
                    }
                }
                lastDomainName = domainName;
                lastApplicationName = applicationName;
            }
        }
        for (const [domainName, applicationChecks] of applicationVersionCheckMap) {
            for (let [_, applicationCheck] of applicationChecks) {
                if (!applicationCheck.found) {
                    // TODO: download and install the application
                    throw new Error(`Application ${applicationCheck.applicationName} for domain ${domainName} is not installed.`);
                }
            }
        }
        return applicationVersionCheckMap;
    }
    getNames(message) {
        if (!message.applicationVersions || !(message.applicationVersions instanceof Array)) {
            throw new Error(`Did not find applicationVersions in RepositorySynchronizationMessage.`);
        }
        const applicationVersionCheckMap = new Map();
        for (let applicationVersion of message.applicationVersions) {
            if (!applicationVersion.integerVersion || typeof applicationVersion.integerVersion !== 'number') {
                throw new Error(`Invalid ApplicationVersion.integerVersion.`);
            }
            const application = message.applications[applicationVersion.application];
            if (typeof application !== 'object') {
                throw new Error(`Invalid ApplicationVersion.application`);
            }
            applicationVersion.application = application;
            const domain = application.domain;
            let applicationChecksForDomain = applicationVersionCheckMap.get(domain.name);
            if (!applicationChecksForDomain) {
                applicationChecksForDomain = new Map();
                applicationVersionCheckMap.set(domain.name, applicationChecksForDomain);
            }
            if (!applicationChecksForDomain.has(application.name)) {
                applicationChecksForDomain.set(application.name, {
                    applicationName: application.name,
                    applicationVersionNumber: applicationVersion.integerVersion
                });
            }
        }
        const domainNames = [];
        const allApplicationNames = [];
        for (const [domainName, applicationChecksForDomainMap] of applicationVersionCheckMap) {
            domainNames.push(domainName);
            for (let [applicationName, _] of applicationChecksForDomainMap) {
                allApplicationNames.push(applicationName);
            }
        }
        return {
            allApplicationNames,
            domainNames,
            applicationVersionCheckMap
        };
    }
};
__decorate$R([
    Inject()
], SyncInApplicationVersionChecker.prototype, "applicationVersionDao", void 0);
SyncInApplicationVersionChecker = __decorate$R([
    Injected()
], SyncInApplicationVersionChecker);

var __decorate$Q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SyncInChecker = class SyncInChecker {
    /**
     * Check the message and load all required auxiliary entities.
     */
    async checkMessage(message) {
        // FIXME: replace as many DB lookups as possible with Terminal State lookups
        if (!await this.syncInUserChecker.ensureUsers(message)) {
            return false;
        }
        if (!await this.syncInTerminalChecker.ensureTerminals(message)) {
            return false;
        }
        if (!await this.syncInApplicationChecker.ensureApplications(message)) {
            return false;
        }
        if (!await this.syncInActorChecker.ensureActors(message)) {
            return false;
        }
        if (!await this.syncInRepositoryChecker.ensureRepositories(message)) {
            return false;
        }
        if (!await this.syncInApplicationVersionChecker.ensureApplicationVersions(message)) {
            return false;
        }
        if (!await this.syncInDataChecker.checkData(message)) {
            return false;
        }
        return true;
    }
};
__decorate$Q([
    Inject()
], SyncInChecker.prototype, "syncInActorChecker", void 0);
__decorate$Q([
    Inject()
], SyncInChecker.prototype, "syncInApplicationChecker", void 0);
__decorate$Q([
    Inject()
], SyncInChecker.prototype, "syncInApplicationVersionChecker", void 0);
__decorate$Q([
    Inject()
], SyncInChecker.prototype, "syncInDataChecker", void 0);
__decorate$Q([
    Inject()
], SyncInChecker.prototype, "syncInRepositoryChecker", void 0);
__decorate$Q([
    Inject()
], SyncInChecker.prototype, "syncInTerminalChecker", void 0);
__decorate$Q([
    Inject()
], SyncInChecker.prototype, "syncInUserChecker", void 0);
SyncInChecker = __decorate$Q([
    Injected()
], SyncInChecker);

var __decorate$P = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SyncInDataChecker = class SyncInDataChecker {
    /**
     * Every dataMessage.data.repoTransHistories array must be sorted before entering
     * this method.
     *
     * @param {IDataToTM[]} dataMessagesWithCompatibleApplications
     * @returns {DataCheckResults}
     */
    async checkData(message) {
        const history = message.history;
        try {
            if (!history || typeof history !== 'object') {
                throw new Error(`Invalid RepositorySynchronizationMessage.history`);
            }
            if (typeof history.uuId !== 'string' || history.uuId.length !== 36) {
                return false;
            }
            if (!history.operationHistory || !(history.operationHistory instanceof Array)) {
                return false;
            }
            if (!history.saveTimestamp || typeof history.saveTimestamp !== 'number') {
                throw new Error(`Invalid RepositorySynchronizationMessage.history.saveTimestamp`);
            }
            if (history.transactionHistory) {
                throw new Error(`RepositorySynchronizationMessage.history.transactionHistory cannot be specified`);
            }
            if (history.repositoryTransactionType) {
                throw new Error(`RepositorySynchronizationMessage.history.repositoryTransactionType cannot be specified`);
            }
            if (history.syncTimestamp) {
                throw new Error(`RepositorySynchronizationMessage.history.syncTimestamp cannot be specified`);
            }
            // Repository is already set in SyncInRepositoryChecker
            history.repositoryTransactionType = RepositoryTransactionType.REMOTE;
            history.syncTimestamp = message.syncTimestamp;
            delete history.id;
            const applicationEntityMap = await this.populateApplicationEntityMap(message);
            await this.checkOperationHistories(message, applicationEntityMap);
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    async populateApplicationEntityMap(message) {
        const applicationVersionsByIds = this.terminalStore.getAllApplicationVersionsByIds();
        const applicationEntityMap = new Map();
        for (const messageApplicationVersion of message.applicationVersions) {
            const applicationVersion = applicationVersionsByIds[messageApplicationVersion.id];
            for (const applicationEntity of applicationVersion.entities) {
                let entitiesForDomain = applicationEntityMap.get(applicationVersion.application.domain.name);
                if (!entitiesForDomain) {
                    entitiesForDomain = new Map();
                    applicationEntityMap.set(applicationVersion.application.domain.name, entitiesForDomain);
                }
                let entitiesForApplication = entitiesForDomain.get(applicationVersion.application.name);
                if (!entitiesForApplication) {
                    entitiesForApplication = new Map();
                    entitiesForDomain.set(applicationVersion.application.name, entitiesForApplication);
                }
                entitiesForApplication.set(applicationEntity.index, applicationEntity);
            }
        }
        return applicationEntityMap;
    }
    async checkOperationHistories(message, applicationEntityMap) {
        const history = message.history;
        if (!(history.operationHistory instanceof Array) || !history.operationHistory.length) {
            throw new Error(`Invalid RepositorySynchronizationMessage.history.operationHistory`);
        }
        const systemWideOperationIds = getSysWideOpIds(history.operationHistory.length, this.airportDatabase, this.sequenceGenerator);
        let orderNumber = 0;
        for (let i = 0; i < history.operationHistory.length; i++) {
            const operationHistory = history.operationHistory[i];
            if (typeof operationHistory !== 'object') {
                throw new Error(`Invalid operationHistory`);
            }
            if (operationHistory.orderNumber) {
                throw new Error(`RepositorySynchronizationMessage.history -> operationHistory.orderNumber cannot be specified,
				the position of orderHistory record determines it's order`);
            }
            operationHistory.orderNumber = ++orderNumber;
            switch (operationHistory.changeType) {
                case ChangeType.DELETE_ROWS:
                case ChangeType.INSERT_VALUES:
                case ChangeType.UPDATE_ROWS:
                    break;
                default:
                    throw new Error(`Invalid operationHistory.changeType: ${operationHistory.changeType}`);
            }
            if (typeof operationHistory.entity !== 'object') {
                throw new Error(`Invalid operationHistory.entity`);
            }
            if (typeof operationHistory.entity.applicationVersion !== 'number') {
                throw new Error(`Expecting "in-message index" (number)
					in 'operationHistory.entity.applicationVersion'`);
            }
            const actor = message.actors[operationHistory.actor];
            if (!actor) {
                throw new Error(`Cannot find Actor for "in-message id" RepositorySynchronizationMessage.history.actor`);
            }
            operationHistory.actor = actor;
            const applicationVersion = message.applicationVersions[operationHistory.entity.applicationVersion];
            if (!applicationVersion) {
                throw new Error(`Invalid index into message.applicationVersions [${operationHistory.entity.applicationVersion}],
				in operationHistory.entity.applicationVersion`);
            }
            const applicationEntity = applicationEntityMap.get(applicationVersion.application.domain.name)
                .get(applicationVersion.application.name).get(operationHistory.entity.index);
            if (!applicationEntity) {
                throw new Error(`Invalid operationHistory.entity.index: ${operationHistory.entity.index}`);
            }
            operationHistory.entity = applicationEntity;
            if (operationHistory.repositoryTransactionHistory) {
                throw new Error(`RepositorySynchronizationMessage.history -> operationHistory.repositoryTransactionHistory cannot be specified`);
            }
            operationHistory.repositoryTransactionHistory = history;
            if (operationHistory.systemWideOperationId) {
                throw new Error(`RepositorySynchronizationMessage.history -> operationHistory.systemWideOperationId cannot be specified`);
            }
            operationHistory.systemWideOperationId = systemWideOperationIds[i];
            delete operationHistory.id;
            let actorIdColumnMapByIndex = new Map();
            let repositoryIdColumnMapByIndex = new Map();
            for (const column of operationHistory.entity.columns) {
                switch (column.name) {
                    case repositoryEntity.ORIGINAL_ACTOR_ID:
                        actorIdColumnMapByIndex.set(column.index, column);
                        break;
                    case repositoryEntity.ORIGINAL_REPOSITORY_ID:
                        repositoryIdColumnMapByIndex.set(column.index, column);
                        break;
                }
                if (/.*_AID_[\d]+$/.test(column.name)
                    && column.manyRelationColumns.length) {
                    actorIdColumnMapByIndex.set(column.index, column);
                }
                if (/.*_RID_[\d]+$/.test(column.name)
                    && column.manyRelationColumns.length) {
                    repositoryIdColumnMapByIndex.set(column.index, column);
                }
            }
            await this.checkRecordHistories(operationHistory, actorIdColumnMapByIndex, repositoryIdColumnMapByIndex, message);
        }
    }
    async checkRecordHistories(operationHistory, actorIdColumnMapByIndex, repositoryIdColumnMapByIndex, message) {
        const recordHistories = operationHistory.recordHistory;
        if (!(recordHistories instanceof Array) || !recordHistories.length) {
            throw new Error(`Inalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory`);
        }
        for (const recordHistory of recordHistories) {
            if (!recordHistory.actorRecordId || typeof recordHistory.actorRecordId !== 'number') {
                throw new Error(`Invalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory.actorRecordId`);
            }
            switch (operationHistory.changeType) {
                case ChangeType.INSERT_VALUES:
                    if (recordHistory.actor) {
                        throw new Error(`Cannot specify RepositorySynchronizationMessage.history -> operationHistory.recordHistory.actor
for ChangeType.INSERT_VALUES`);
                    }
                    recordHistory.actor = operationHistory.actor;
                    break;
                case ChangeType.DELETE_ROWS:
                case ChangeType.UPDATE_ROWS: {
                    // If no actor is present on record level its the same actor that created the repositoryTransactionHistory
                    if (recordHistory.actor === undefined) {
                        recordHistory.actor = operationHistory.actor;
                    }
                    else {
                        const actor = message.actors[recordHistory.actor];
                        if (!actor) {
                            throw new Error(`Did find Actor for "in-message id" in RepositorySynchronizationMessage.history -> operationHistory.actor`);
                        }
                        recordHistory.actor = actor;
                    }
                    break;
                }
            }
            if (recordHistory.operationHistory) {
                throw new Error(`RepositorySynchronizationMessage.history -> operationHistory.recordHistory.operationHistory cannot be specified`);
            }
            this.checkNewValues(recordHistory, actorIdColumnMapByIndex, repositoryIdColumnMapByIndex, operationHistory, message);
            this.checkOldValues(recordHistory, actorIdColumnMapByIndex, repositoryIdColumnMapByIndex, operationHistory, message);
            recordHistory.operationHistory = operationHistory;
            delete recordHistory.id;
        }
    }
    checkNewValues(recordHistory, actorIdColumnMapByIndex, repositoryIdColumnMapByIndex, operationHistory, message) {
        switch (operationHistory.changeType) {
            case ChangeType.DELETE_ROWS:
                if (recordHistory.newValues) {
                    throw new Error(`Cannot specify RepositorySynchronizationMessage.history -> operationHistory.recordHistory.newValues
for ChangeType.DELETE_ROWS`);
                }
                return;
            case ChangeType.INSERT_VALUES:
            case ChangeType.UPDATE_ROWS:
                if (!(recordHistory.newValues instanceof Array) || !recordHistory.newValues.length) {
                    throw new Error(`Must specify RepositorySynchronizationMessage.history -> operationHistory.recordHistory.newValues
for ChangeType.INSERT_VALUES|UPDATE_ROWS`);
                }
                break;
        }
        for (const newValue of recordHistory.newValues) {
            if (newValue.recordHistory) {
                throw new Error(`Cannot specify RepositorySynchronizationMessage.history -> operationHistory.recordHistory.newValues.recordHistory`);
            }
            newValue.recordHistory = recordHistory;
            if (typeof newValue.columnIndex !== 'number') {
                throw new Error(`Invalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory.newValues.columnIndex`);
            }
            if (typeof newValue.newValue === undefined) {
                throw new Error(`Invalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory.newValues.newValue`);
            }
        }
        for (const newValue of recordHistory.newValues) {
            const actorIdColumn = actorIdColumnMapByIndex.get(newValue.columnIndex);
            if (actorIdColumn) {
                const originalActor = message.actors[newValue.newValue];
                if (!originalActor) {
                    throw new Error(`Invalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory.newValues.newValue
Value is for ${actorIdColumn.name} and could find RepositorySynchronizationMessage.actors[${newValue.newValue}]`);
                }
                newValue.newValue = originalActor.id;
            }
            const repositoryIdColumn = repositoryIdColumnMapByIndex.get(newValue.columnIndex);
            if (repositoryIdColumn) {
                if (newValue.newValue === -1) {
                    newValue.newValue = message.history.repository.id;
                }
                else {
                    const originalRepository = message.referencedRepositories[newValue.newValue];
                    if (!originalRepository) {
                        throw new Error(`Invalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory.newValues.newValue
	Value is for ${repositoryIdColumn.name} and could find RepositorySynchronizationMessage.referencedRepositories[${newValue.newValue}]`);
                    }
                    newValue.newValue = originalRepository.id;
                }
            }
        }
    }
    checkOldValues(recordHistory, actorIdColumnMapByIndex, repositoryIdColumnMapByIndex, operationHistory, message) {
        switch (operationHistory.changeType) {
            case ChangeType.DELETE_ROWS:
            case ChangeType.INSERT_VALUES:
                if (recordHistory.oldValues) {
                    throw new Error(`Cannot specify RepositorySynchronizationMessage.history -> operationHistory.recordHistory.oldValues
for ChangeType.DELETE_ROWS|INSERT_VALUES`);
                }
                return;
            case ChangeType.UPDATE_ROWS:
                if (!(recordHistory.newValues instanceof Array) || !recordHistory.oldValues.length) {
                    throw new Error(`Must specify RepositorySynchronizationMessage.history -> operationHistory.recordHistory.oldValues
for ChangeType.UPDATE_ROWS`);
                }
                break;
        }
        for (const oldValue of recordHistory.oldValues) {
            if (oldValue.recordHistory) {
                throw new Error(`Cannot specify RepositorySynchronizationMessage.history -> operationHistory.recordHistory.newValues.recordHistory`);
            }
            oldValue.recordHistory = recordHistory;
            if (typeof oldValue.columnIndex !== 'number') {
                throw new Error(`Invalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory.oldValues.columnIndex`);
            }
            if (typeof oldValue.oldValue === undefined) {
                throw new Error(`Invalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory.oldValues.oldValue`);
            }
        }
        for (const oldValue of recordHistory.oldValues) {
            const actorIdColumn = actorIdColumnMapByIndex.get(oldValue.columnIndex);
            if (actorIdColumn) {
                const originalActor = message.actors[oldValue.oldValue];
                if (!originalActor) {
                    throw new Error(`Invalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory.oldValues.oldValue
Value is for ORIGINAL_ACTOR_ID and could find RepositorySynchronizationMessage.actors[${oldValue.oldValue}]`);
                }
                oldValue.oldValue = originalActor.id;
            }
            const repositoryIdColumn = repositoryIdColumnMapByIndex.get(oldValue.columnIndex);
            if (repositoryIdColumn) {
                const originalRepository = message.referencedRepositories[oldValue.oldValue];
                if (!originalRepository) {
                    throw new Error(`Invalid RepositorySynchronizationMessage.history -> operationHistory.recordHistory.oldValues.oldValue
Value is for ORIGINAL_REPOSITORY_ID and could find RepositorySynchronizationMessage.referencedRepositories[${oldValue.oldValue}]`);
                }
                oldValue.oldValue = originalRepository.id;
            }
        }
    }
};
__decorate$P([
    Inject()
], SyncInDataChecker.prototype, "airportDatabase", void 0);
__decorate$P([
    Inject()
], SyncInDataChecker.prototype, "sequenceGenerator", void 0);
__decorate$P([
    Inject()
], SyncInDataChecker.prototype, "terminalStore", void 0);
SyncInDataChecker = __decorate$P([
    Injected()
], SyncInDataChecker);

var __decorate$O = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SyncInRepositoryChecker = class SyncInRepositoryChecker {
    async ensureRepositories(message) {
        try {
            let repositoryUuids = [];
            let messageRepositoryIndexMap = new Map();
            for (let i = 0; i < message.referencedRepositories.length; i++) {
                this.checkRepository(message.referencedRepositories[i], i, repositoryUuids, messageRepositoryIndexMap, message);
            }
            const history = message.history;
            if (history.isRepositoryCreation) {
                if (typeof history.repository !== 'object') {
                    throw new Error(`Serialized RepositorySynchronizationMessage.history.repository should be an object
	if RepositorySynchronizationMessage.history.isRepositoryCreation === true`);
                }
                this.checkRepository(history.repository, null, repositoryUuids, messageRepositoryIndexMap, message);
            }
            else {
                if (typeof history.repository !== 'string') {
                    throw new Error(`Serialized RepositorySynchronizationMessage.history.repository should be a string
	if RepositorySynchronizationMessage.history.isRepositoryCreation === false`);
                }
                repositoryUuids.push(history.repository);
            }
            const repositories = await this.repositoryDao.findByUuIds(repositoryUuids);
            for (const repository of repositories) {
                const messageUserIndex = messageRepositoryIndexMap.get(repository.uuId);
                if (messageUserIndex || messageUserIndex === 0) {
                    message.referencedRepositories[messageUserIndex] = repository;
                }
                else {
                    // Populating ahead of potential insert is OK, object
                    // gets modified with required state on an insert
                    history.repository = repository;
                }
            }
            const missingRepositories = message.referencedRepositories
                .filter(messageRepository => !messageRepository.id);
            if (typeof history.repository !== 'object') {
                throw new Error(`Repository with UuId ${history.repository} is not
					present and cannot be synced
	This RepositorySynchronizationMessage is for an existing repository and that
	repository must already be loaded in this database for this message to be
	processed.`);
            }
            else if (!history.repository.id) {
                missingRepositories.push(history.repository);
            }
            if (missingRepositories.length) {
                await this.repositoryDao.insert(missingRepositories);
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    checkRepository(repository, repositoryIndex, repositoryUuids, messageRepositoryIndexMap, message) {
        if (typeof repository.ageSuitability !== 'number') {
            throw new Error(`Invalid 'repository.ageSuitability'`);
        }
        if (!repository.createdAt || typeof repository.createdAt !== 'string') {
            throw new Error(`Invalid 'repository.createdAt'`);
        }
        repository.createdAt = new Date(repository.createdAt);
        if (typeof repository.immutable !== 'boolean') {
            throw new Error(`Invalid 'repository.immutable'`);
        }
        if (!repository.source || typeof repository.source !== 'string') {
            throw new Error(`Invalid 'repository.source'`);
        }
        if (typeof repository.uuId !== 'string' || repository.uuId.length !== 36) {
            throw new Error(`Invalid 'repository.uuid'`);
        }
        if (typeof repository.owner !== 'number') {
            throw new Error(`Expecting "in-message index" (number)
				in 'repository.owner'`);
        }
        const user = message.users[repository.owner];
        if (!user) {
            throw new Error(`Did not find repository.owner (User) with "in-message index" ${repository.owner}`);
        }
        repository.owner = user;
        repositoryUuids.push(repository.uuId);
        if (typeof repositoryIndex === 'number') {
            messageRepositoryIndexMap.set(repository.uuId, repositoryIndex);
        }
        // Make sure id field is not in the input
        delete repository.id;
    }
};
__decorate$O([
    Inject()
], SyncInRepositoryChecker.prototype, "repositoryDao", void 0);
SyncInRepositoryChecker = __decorate$O([
    Injected()
], SyncInRepositoryChecker);

var __decorate$N = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SyncInTerminalChecker = class SyncInTerminalChecker {
    async ensureTerminals(message) {
        try {
            let terminalUuids = [];
            let messageTerminalIndexMap = new Map();
            for (let i = 0; i < message.terminals.length; i++) {
                const terminal = message.terminals[i];
                if (typeof terminal.owner !== 'number') {
                    throw new Error(`Expecting "in-message index" (number)
					in 'terminal.owner' of RepositorySynchronizationMessage.terminals`);
                }
                if (typeof terminal.uuId !== 'string' || terminal.uuId.length !== 36) {
                    throw new Error(`Invalid 'terminal.uuid' in RepositorySynchronizationMessage.terminals`);
                }
                if (terminal.isLocal !== undefined) {
                    throw new Error(`'terminal.isLocal' cannot defined in RepositorySynchronizationMessage.terminals`);
                }
                terminal.isLocal = false;
                const owner = message.users[terminal.owner];
                if (!owner) {
                    throw new Error(`Did not find user for terminal.owner with "in-message index" ${terminal.owner}
						for RepositorySynchronizationMessage.terminals`);
                }
                terminal.owner = owner;
                terminalUuids.push(terminal.uuId);
                messageTerminalIndexMap.set(terminal.uuId, i);
                // Make sure id field is not in the input
                delete terminal.id;
            }
            const terminals = await this.terminalDao.findByUuIds(terminalUuids);
            for (const terminal of terminals) {
                const messageUserIndex = messageTerminalIndexMap.get(terminal.uuId);
                message.terminals[messageUserIndex] = terminal;
            }
            const missingTerminals = message.terminals
                .filter(messageTerminal => !messageTerminal.id);
            if (missingTerminals.length) {
                await this.addMissingTerminals(missingTerminals);
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    async addMissingTerminals(missingTerminals) {
        for (const terminal of missingTerminals) {
            terminal.isLocal = false;
        }
        await this.terminalDao.insert(missingTerminals);
    }
};
__decorate$N([
    Inject()
], SyncInTerminalChecker.prototype, "terminalDao", void 0);
SyncInTerminalChecker = __decorate$N([
    Injected()
], SyncInTerminalChecker);

var __decorate$M = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SyncInUserChecker = class SyncInUserChecker {
    async ensureUsers(message) {
        try {
            let userUuids = [];
            let messageUserIndexMap = new Map();
            for (let i = 0; i < message.users.length; i++) {
                const user = message.users[i];
                if (typeof user.uuId !== 'string' || user.uuId.length !== 36) {
                    throw new Error(`Invalid 'user.uuid'`);
                }
                if (typeof user.username !== 'string' || user.username.length < 3) {
                    throw new Error(`Invalid 'user.username'`);
                }
                userUuids.push(user.uuId);
                messageUserIndexMap.set(user.uuId, i);
                // Make sure id field is not in the input
                delete user.id;
            }
            const users = await this.userDao.findByUuIds(userUuids);
            for (const user of users) {
                const messageUserIndex = messageUserIndexMap.get(user.uuId);
                message.users[messageUserIndex] = user;
            }
            const missingUsers = message.users.filter(messageUser => !messageUser.id);
            if (missingUsers.length) {
                await this.addMissingUsers(missingUsers);
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    async addMissingUsers(missingUsers) {
        for (const user of missingUsers) {
            if (!user.username || typeof user.username !== 'string') {
                throw new Error(`Invalid User.username ${user.username}`);
            }
        }
        await this.userDao.insert(missingUsers);
    }
};
__decorate$M([
    Inject()
], SyncInUserChecker.prototype, "userDao", void 0);
SyncInUserChecker = __decorate$M([
    Injected()
], SyncInUserChecker);

var __decorate$L = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SynchronizationConflict = class SynchronizationConflict {
};
__decorate$L([
    GeneratedValue(),
    Id(),
    DbNumber()
], SynchronizationConflict.prototype, "id", void 0);
__decorate$L([
    DbString()
], SynchronizationConflict.prototype, "type", void 0);
__decorate$L([
    DbBoolean()
], SynchronizationConflict.prototype, "acknowledged", void 0);
__decorate$L([
    ManyToOne(),
    JoinColumn()
], SynchronizationConflict.prototype, "repository", void 0);
__decorate$L([
    ManyToOne(),
    JoinColumn()
], SynchronizationConflict.prototype, "overwrittenRecordHistory", void 0);
__decorate$L([
    ManyToOne(),
    JoinColumn()
], SynchronizationConflict.prototype, "overwritingRecordHistory", void 0);
__decorate$L([
    OneToMany()
], SynchronizationConflict.prototype, "values", void 0);
SynchronizationConflict = __decorate$L([
    Entity(),
    Table()
], SynchronizationConflict);

var SynchronizationConflict_Type;
(function (SynchronizationConflict_Type) {
    SynchronizationConflict_Type["LOCAL_UPDATE_REMOTELY_DELETED"] = "LOCAL_UPDATE_REMOTELY_DELETED";
    SynchronizationConflict_Type["REMOTE_CREATE_REMOTELY_DELETED"] = "REMOTE_CREATE_REMOTELY_DELETED";
    SynchronizationConflict_Type["REMOTE_UPDATE_LOCALLY_DELETED"] = "REMOTE_UPDATE_LOCALLY_DELETED";
    SynchronizationConflict_Type["REMOTE_UPDATE_LOCALLY_UPDATED"] = "REMOTE_UPDATE_LOCALLY_UPDATED";
})(SynchronizationConflict_Type || (SynchronizationConflict_Type = {}));

var __decorate$K = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SynchronizationConflictValues = class SynchronizationConflictValues {
};
__decorate$K([
    Id(),
    ManyToOne(),
    JoinColumn()
], SynchronizationConflictValues.prototype, "synchronizationConflict", void 0);
__decorate$K([
    Id(),
    DbNumber()
], SynchronizationConflictValues.prototype, "columnIndex", void 0);
SynchronizationConflictValues = __decorate$K([
    Entity(),
    Table()
], SynchronizationConflictValues);

var DataOrigin;
(function (DataOrigin) {
    DataOrigin["LOCAL"] = "LOCAL";
    DataOrigin["REMOTE"] = "REMOTE";
})(DataOrigin || (DataOrigin = {}));

var ApplicationChangeStatus;
(function (ApplicationChangeStatus) {
    ApplicationChangeStatus["CHANGE_NEEDED"] = "CHANGE_NEEDED";
    ApplicationChangeStatus["CHANGE_COMPLETED"] = "CHANGE_COMPLETED";
})(ApplicationChangeStatus || (ApplicationChangeStatus = {}));

var __decorate$J = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Used to temporarily store updates during application remotely synced updates
 * to the local terminal.  Values are deleted right after the remote sync updates
 * are applied.
 */
let RecordUpdateStage = class RecordUpdateStage {
};
__decorate$J([
    Id(),
    GeneratedValue()
], RecordUpdateStage.prototype, "id", void 0);
__decorate$J([
    ManyToOne(),
    JoinColumn()
], RecordUpdateStage.prototype, "applicationVersion", void 0);
__decorate$J([
    ManyToOne()
    // FIXME: verify that these records don't make it into serialized
    // repository ledger (and hence, that using local ids is safe)
    ,
    JoinColumn()
], RecordUpdateStage.prototype, "entity", void 0);
__decorate$J([
    ManyToOne(),
    JoinColumn()
], RecordUpdateStage.prototype, "repository", void 0);
__decorate$J([
    ManyToOne(),
    JoinColumn()
], RecordUpdateStage.prototype, "actor", void 0);
__decorate$J([
    Column(),
    DbNumber()
], RecordUpdateStage.prototype, "actorRecordId", void 0);
__decorate$J([
    ManyToOne()
    // FIXME: verify that these records don't make it into serialized
    // repository ledger (and hence, that using local ids is safe)
    ,
    JoinColumn()
], RecordUpdateStage.prototype, "column", void 0);
__decorate$J([
    Column()
], RecordUpdateStage.prototype, "updatedValue", void 0);
RecordUpdateStage = __decorate$J([
    Entity(),
    Table()
], RecordUpdateStage);

const __constructors__$1 = {
    RecordUpdateStage: RecordUpdateStage,
    SynchronizationConflict: SynchronizationConflict,
    SynchronizationConflictValues: SynchronizationConflictValues
};
const Q_APPLICATION$1 = {
    __constructors__: __constructors__$1,
    domain: 'air',
    name: '@airport/moving-walkway'
};
const Q$1 = Q_APPLICATION$1;
function duoDiSet$1(dbEntityId) {
    return duoDiSet$5(Q$1.__dbApplication__, dbEntityId);
}
DEPENDENCY_INJECTION.db().eventuallyGet(AIRPORT_DATABASE).then((airportDatabase) => {
    airportDatabase.setQApplication(Q_APPLICATION$1);
});

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$1 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q$1);
    }
}
class BaseRecordUpdateStageDao extends SQDIDao$1 {
    constructor() {
        super(2);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$1(2);
    }
}
BaseRecordUpdateStageDao.Find = new DaoQueryDecorators();
BaseRecordUpdateStageDao.FindOne = new DaoQueryDecorators();
BaseRecordUpdateStageDao.Search = new DaoQueryDecorators();
BaseRecordUpdateStageDao.SearchOne = new DaoQueryDecorators();
class BaseSynchronizationConflictDao extends SQDIDao$1 {
    constructor() {
        super(1);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$1(1);
    }
}
BaseSynchronizationConflictDao.Find = new DaoQueryDecorators();
BaseSynchronizationConflictDao.FindOne = new DaoQueryDecorators();
BaseSynchronizationConflictDao.Search = new DaoQueryDecorators();
BaseSynchronizationConflictDao.SearchOne = new DaoQueryDecorators();
class BaseSynchronizationConflictValuesDao extends SQDIDao$1 {
    constructor() {
        super(0);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet$1(0);
    }
}
BaseSynchronizationConflictValuesDao.Find = new DaoQueryDecorators();
BaseSynchronizationConflictValuesDao.FindOne = new DaoQueryDecorators();
BaseSynchronizationConflictValuesDao.Search = new DaoQueryDecorators();
BaseSynchronizationConflictValuesDao.SearchOne = new DaoQueryDecorators();

var __decorate$I = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SynchronizationConflictDao = class SynchronizationConflictDao extends BaseSynchronizationConflictDao {
    async insert(synchronizationConflicts) {
        let sc;
        const values = [];
        for (const synchronizationConflict of synchronizationConflicts) {
            values.push([
                synchronizationConflict.type,
                synchronizationConflict.acknowledged,
                synchronizationConflict.repository.id,
                synchronizationConflict.overwrittenRecordHistory.id,
                synchronizationConflict.overwritingRecordHistory.id
            ]);
        }
        const ids = await this.db.insertValuesGenerateIds({
            insertInto: sc = Q$1.SynchronizationConflict,
            columns: [
                sc.type,
                sc.acknowledged,
                sc.repository.id,
                sc.overwrittenRecordHistory.id,
                sc.overwritingRecordHistory.id
            ],
            values
        });
        for (let i = 0; i < synchronizationConflicts.length; i++) {
            let synchronizationConflict = synchronizationConflicts[i];
            synchronizationConflict.id = ids[i][0];
        }
    }
};
SynchronizationConflictDao = __decorate$I([
    Injected()
], SynchronizationConflictDao);

var __decorate$H = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SynchronizationConflictValuesDao = class SynchronizationConflictValuesDao extends BaseSynchronizationConflictValuesDao {
    async insert(synchronizationConflictValues) {
        let scv;
        const values = [];
        for (const synchronizationConflictValue of synchronizationConflictValues) {
            values.push([
                synchronizationConflictValue.synchronizationConflict.id,
                synchronizationConflictValue.columnIndex
            ]);
        }
        await this.db.insertValues({
            insertInto: scv = Q$1.SynchronizationConflictValues,
            columns: [
                scv.synchronizationConflict.id,
                scv.columnIndex
            ],
            values
        });
    }
};
SynchronizationConflictValuesDao = __decorate$H([
    Injected()
], SynchronizationConflictValuesDao);

var __decorate$G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RecordUpdateStageDao = class RecordUpdateStageDao extends BaseRecordUpdateStageDao {
    async insertValues(values) {
        const rus = Q$1.RecordUpdateStage;
        const columns = [
            rus.applicationVersion.id,
            rus.entity.id,
            rus.repository.id,
            rus.actor.id,
            rus.actorRecordId,
            rus.column.id,
            rus.updatedValue
        ];
        return await this.db.insertValuesGenerateIds({
            insertInto: rus,
            columns,
            values
        }, {
            generateOnSync: true
        });
    }
    async updateEntityWhereIds(applicationIndex, applicationVersionId, tableIndex, idMap, updatedColumnIndexes) {
        const dbEntity = this.airportDatabase.applications[applicationIndex].currentVersion[0]
            .applicationVersion.entities[tableIndex];
        const qEntity = this.airportDatabase.qApplications[applicationIndex][dbEntity.name];
        const repositoryEquals = [];
        for (const [repositoryId, idsForRepository] of idMap) {
            const actorEquals = [];
            for (const [actorId, idsForActor] of idsForRepository) {
                actorEquals.push(and(qEntity['actor'].id.equals(actorId), qEntity['actorRecordId'].in(Array.from(idsForActor))));
            }
            repositoryEquals.push(and(qEntity['repository'].id.equals(repositoryId), or(...actorEquals)));
        }
        const setClause = {};
        for (const columnIndex of updatedColumnIndexes) {
            const column = dbEntity.columns[columnIndex];
            let columnRus = Q$1.RecordUpdateStage;
            let columnSetClause = field({
                from: [
                    columnRus
                ],
                select: columnRus.updatedValue,
                where: and(columnRus.applicationVersion.id.equals(applicationVersionId), columnRus.entity.id.equals(dbEntity.index), columnRus.repository.id.equals(qEntity.repository.id), columnRus.actor.id.equals(qEntity.actor.id), columnRus.actorRecordId.equals(qEntity.actorRecordId), columnRus.column.id.equals(column.index))
            });
            setClause[column.name] = columnSetClause;
        }
        await this.db.updateColumnsWhere({
            update: qEntity,
            set: setClause,
            where: or(...repositoryEquals)
        });
    }
    async delete( //
    ) {
        return await this.db.deleteWhere({
            deleteFrom: Q$1.RecordUpdateStage
        });
    }
};
RecordUpdateStageDao = __decorate$G([
    Injected()
], RecordUpdateStageDao);

const movingWalkway = lib$1('moving-walkway');
const RECORD_UPDATE_STAGE_DAO = movingWalkway.token({
    class: RecordUpdateStageDao,
    interface: 'IRecordUpdateStageDao',
    token: 'RECORD_UPDATE_STAGE_DAO'
});
const SYNCHRONIZATION_CONFLICT_DAO = movingWalkway.token({
    class: SynchronizationConflictDao,
    interface: 'ISynchronizationConflictDao',
    token: 'SYNCHRONIZATION_CONFLICT_DAO'
});
const SYNCHRONIZATION_CONFLICT_VALUES_DAO = movingWalkway.token({
    class: SynchronizationConflictValuesDao,
    interface: 'ISynchronizationConflictValuesDao',
    token: 'SYNCHRONIZATION_CONFLICT_VALUES_DAO'
});

var __decorate$F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Stage1SyncedInDataProcessor = class Stage1SyncedInDataProcessor {
    /**
     * In stage one:
     *
     *  1)  Unique create/update/delete statement datastructures are generated
     *  2)  Synchronization conflict datastructure is generated
     *
     * @param {Map<RepositoryId, ISyncRepoTransHistory[]>} repositoryTransactionHistoryMapByRepositoryId
     * @param {Map<Actor_Id, IActor>} actorMayById
     * @returns {Promise<void>}
     */
    async performStage1DataProcessing(repositoryTransactionHistoryMapByRepositoryId, actorMayById) {
        await this.populateSystemWideOperationIds(repositoryTransactionHistoryMapByRepositoryId);
        const changedRecordIds = new Map();
        // query for all local operations on records in a repository (since the earliest
        // received change time).  Get the
        // changes by repository ids or by the actual tables and records in those tables
        // that will be updated or deleted.
        for (const [repositoryId, repoTransHistoriesForRepo] of repositoryTransactionHistoryMapByRepositoryId) {
            const changedRecordsForRepo = {
                ids: new Map(),
                firstChangeTime: new Date().getTime() + 10000000000
            };
            changedRecordIds.set(repositoryId, changedRecordsForRepo);
            for (const repoTransHistory of repoTransHistoriesForRepo) {
                // determine the earliest change time of incoming history records
                const saveMillis = repoTransHistory.saveTimestamp;
                if (saveMillis
                    < changedRecordsForRepo.firstChangeTime) {
                    changedRecordsForRepo.firstChangeTime = repoTransHistory.saveTimestamp;
                }
                for (const operationHistory of repoTransHistory.operationHistory) {
                    // Collect the Actor related ids
                    const idsForEntity = ensureChildJsMap(changedRecordsForRepo.ids, operationHistory.entity.id);
                    for (const recordHistory of operationHistory.recordHistory) {
                        // Collect the Actor related ids
                        ensureChildJsSet(idsForEntity, recordHistory.actor.id)
                            .add(recordHistory.actorRecordId);
                        // add a map of new values
                        const newValueMap = new Map();
                        recordHistory.newValueMap = newValueMap;
                        for (const newValue of recordHistory.newValues) {
                            newValueMap.set(newValue.columnIndex, newValue);
                        }
                    }
                }
            }
        }
        const allRepoTransHistoryMapByRepoId = new Map();
        const allRemoteRecordDeletions = this.getDeletedRecordIdsAndPopulateAllHistoryMap(allRepoTransHistoryMapByRepoId, repositoryTransactionHistoryMapByRepositoryId);
        // find local history for the matching repositories and corresponding time period
        const localRepoTransHistoryMapByRepositoryId = await this.repositoryTransactionHistoryDao
            .findAllLocalChangesForRecordIds(changedRecordIds);
        const allLocalRecordDeletions = this.getDeletedRecordIdsAndPopulateAllHistoryMap(allRepoTransHistoryMapByRepoId, localRepoTransHistoryMapByRepositoryId, true);
        // Find all actors that modified the locally recorded history, which are not already
        // in the actorMapById collect actors not already in cache
        const newlyFoundActorSet = new Set();
        for (const [repositoryId, repositoryTransactionHistoriesForRepository] of localRepoTransHistoryMapByRepositoryId) {
            for (const repositoryTransactionHistory of repositoryTransactionHistoriesForRepository) {
                for (const operationHistory of repositoryTransactionHistory.operationHistory) {
                    const actorId = operationHistory.actor.id;
                    if (actorMayById.get(actorId) === undefined) {
                        newlyFoundActorSet.add(actorId);
                    }
                }
            }
        }
        if (newlyFoundActorSet.size) {
            // cache remaining actors
            const newActors = await this.actorDao.findWithDetailsAndGlobalIdsByIds(Array.from(newlyFoundActorSet));
            for (const newActor of newActors) {
                actorMayById.set(newActor.id, newActor);
            }
        }
        // sort all repository histories in processing order
        for (const [repositoryId, repoTransHistoriesForRepository] of allRepoTransHistoryMapByRepoId) {
            this.repositoryTransactionHistoryDuo
                .sortRepoTransHistories(repoTransHistoriesForRepository, actorMayById);
        }
        const recordCreations = new Map();
        const recordUpdates = new Map();
        const recordDeletions = new Map();
        const syncConflictMapByRepoId = new Map();
        // FIXME: add code to ensure that remote records coming in are performed only
        // by the actors that claim the operation AND that the records created are
        // created only by the actors that perform the operation (actorIds match)
        for (const [repositoryId, repoTransHistoriesForRepo] of allRepoTransHistoryMapByRepoId) {
            for (const repoTransHistory of repoTransHistoriesForRepo) {
                for (const operationHistory of repoTransHistory.operationHistory) {
                    switch (operationHistory.changeType) {
                        case ChangeType.INSERT_VALUES:
                            this.processCreation(repositoryId, operationHistory, repoTransHistory.isLocal, recordCreations, recordUpdates, recordDeletions, allRemoteRecordDeletions, allLocalRecordDeletions, syncConflictMapByRepoId);
                            break;
                        case ChangeType.UPDATE_ROWS:
                            this.processUpdate(repositoryId, operationHistory, repoTransHistory.isLocal, recordCreations, recordUpdates, allRemoteRecordDeletions, allLocalRecordDeletions, syncConflictMapByRepoId);
                            break;
                        case ChangeType.DELETE_ROWS:
                            this.processDeletion(repositoryId, operationHistory, recordCreations, recordUpdates, recordDeletions, allLocalRecordDeletions);
                            break;
                    }
                }
            }
        }
        return {
            recordCreations,
            recordDeletions,
            recordUpdates,
            syncConflictMapByRepoId
        };
    }
    async populateSystemWideOperationIds(repositoryTransactionHistoryMapByRepositoryId) {
        let numSystemWideOperationIds = 0;
        for (const [_, repoTransHistoriesForRepo] of repositoryTransactionHistoryMapByRepositoryId) {
            for (const repositoryTransactionHistory of repoTransHistoriesForRepo) {
                numSystemWideOperationIds += repositoryTransactionHistory
                    .operationHistory.length;
            }
        }
        const systemWideOperationIds = await getSysWideOpIds(numSystemWideOperationIds, this.airportDatabase, this.sequenceGenerator);
        let i = 0;
        for (const [_, repoTransHistoriesForRepo] of repositoryTransactionHistoryMapByRepositoryId) {
            for (const repositoryTransactionHistory of repoTransHistoriesForRepo) {
                for (const operationHistory of repositoryTransactionHistory.operationHistory) {
                    operationHistory.systemWideOperationId = systemWideOperationIds[i];
                    i++;
                }
            }
        }
    }
    ensureRecordHistoryId(recordHistory, actorRecordIdSetByActor, actorRecordId = recordHistory.actorRecordId) {
        ensureChildJsMap(actorRecordIdSetByActor, recordHistory.actor.id)
            .set(actorRecordId, recordHistory.id);
    }
    getDeletedRecordIdsAndPopulateAllHistoryMap(allRepoTransHistoryMapByRepoId, repositoryTransactionHistoryMapByRepoId, isLocal = false) {
        const recordDeletions = new Map();
        for (const [repositoryId, repoTransHistories] of repositoryTransactionHistoryMapByRepoId) {
            this.mergeArraysInMap(allRepoTransHistoryMapByRepoId, repositoryId, repoTransHistories);
            for (const repoTransHistory of repoTransHistories) {
                repoTransHistory.isLocal = isLocal;
                for (const operationHistory of repoTransHistory.operationHistory) {
                    switch (operationHistory.changeType) {
                        case ChangeType.DELETE_ROWS:
                            for (const recordHistory of operationHistory.recordHistory) {
                                this.ensureRecordHistoryId(recordHistory, this.syncInUtils
                                    .ensureRecordMapForRepoInTable(repositoryId, operationHistory, recordDeletions));
                            }
                            break;
                    }
                }
            }
        }
        return recordDeletions;
    }
    mergeArraysInMap(map, key, array) {
        let targetArray = map.get(key);
        if (!targetArray) {
            targetArray = array;
        }
        else {
            targetArray = targetArray.concat(array);
        }
        map.set(key, targetArray);
    }
    /*
    NOTE: local creates are not inputted into this processing.
     */
    processCreation(repositoryId, operationHistory, isLocal, recordCreations, recordUpdates, recordDeletions, allRemoteRecordDeletions, allLocalRecordDeletions, syncConflictMapByRepoId) {
        const recordUpdatesForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, recordUpdates);
        const recordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, recordDeletions);
        const allRemoteRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, allRemoteRecordDeletions);
        const allLocalRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, allLocalRecordDeletions);
        const insertsForEntityInRepo = this.syncInUtils.ensureRecordMapForRepoInTable(repositoryId, operationHistory, recordCreations);
        for (const recordHistory of operationHistory.recordHistory) {
            if (this.getRecord(recordHistory, insertsForEntityInRepo)) {
                throw new Error(`A record is being created more than once.
					${this.getRecordInfo(repositoryId, operationHistory, recordHistory)}
					This is not possible if every remote change is only processed once.
					`);
            }
            if (isLocal) {
                throw new Error(`Remotely mutated record is being created locally.
					${this.getRecordInfo(repositoryId, operationHistory, recordHistory)}
					This is not possible if changes are never sent to originating TMs.
					`);
            }
            if (this.hasRecordId(recordHistory, recordDeletesForRepoInTable)) {
                throw new Error(`
				Remotely created record is being deleted remotely before it's been created.
					${this.getRecordInfo(repositoryId, operationHistory, recordHistory)}
					This is not possible if all server clocks are synced.
					`);
            }
            if (this.getRecordHistoryId(recordHistory, allLocalRecordDeletesForRepoInTable)) {
                throw new Error(`Remotely created record is being deleted locally.
					${this.getRecordInfo(repositoryId, operationHistory, recordHistory)}
					This is not possible if every remote change is only processed once.
					`);
            }
            const remoteDeleteRecordHistoryId = this.getRecordHistoryId(recordHistory, allRemoteRecordDeletesForRepoInTable);
            if (remoteDeleteRecordHistoryId) {
                // remotely created record has been remotely deleted
                this.addSyncConflict(SynchronizationConflict_Type.REMOTE_CREATE_REMOTELY_DELETED, repositoryId, recordHistory, {
                    id: remoteDeleteRecordHistoryId
                }, syncConflictMapByRepoId);
                // If the record has been deleted, do not process the create
                continue;
            }
            const createdRecord = this.ensureColumnValueMap(recordHistory, insertsForEntityInRepo);
            if (this.getRecord(recordHistory, recordUpdatesForRepoInTable)) {
                throw new Error(`Remotely created record is being updated BEFORE it is created.
					${this.getRecordInfo(repositoryId, operationHistory, recordHistory)}
					This is not possible if all server clocks are synced.
					`);
            }
            // Record the creation of the record
            for (const newValue of recordHistory.newValues) {
                createdRecord.set(newValue.columnIndex, newValue.newValue);
            }
        }
    }
    /*
    NOTE: local updates to records NOT in incoming changes do not get inputted into
    this processing.
     */
    processUpdate(repositoryId, operationHistory, isLocal, recordCreations, recordUpdates, allRemoteRecordDeletions, allLocalRecordDeletions, syncConflictMapByRepoId) {
        const recordCreationsForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, recordCreations);
        const allRemoteRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, allRemoteRecordDeletions);
        const allLocalRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, allLocalRecordDeletions);
        const updatesForEntityInRepo = this.syncInUtils.ensureRecordMapForRepoInTable(repositoryId, operationHistory, recordUpdates);
        for (const recordHistory of operationHistory.recordHistory) {
            const localDeleteRecordHistoryId = this.getRecordHistoryId(recordHistory, allLocalRecordDeletesForRepoInTable);
            if (localDeleteRecordHistoryId) {
                if (!isLocal) {
                    // A remote update to a record has been locally deleted
                    this.addSyncConflict(SynchronizationConflict_Type.REMOTE_UPDATE_LOCALLY_DELETED, repositoryId, recordHistory, {
                        id: localDeleteRecordHistoryId
                    }, syncConflictMapByRepoId);
                }
                // else {a local update to a record has been locally deleted - nothing to do}
                // If the record has been deleted, do not process the update
                continue;
            }
            const remoteDeleteRecordHistoryId = this.getRecordHistoryId(recordHistory, allRemoteRecordDeletesForRepoInTable);
            if (remoteDeleteRecordHistoryId) {
                if (isLocal) {
                    // A local update for a record that has been deleted remotely
                    this.addSyncConflict(SynchronizationConflict_Type.LOCAL_UPDATE_REMOTELY_DELETED, repositoryId, recordHistory, {
                        id: remoteDeleteRecordHistoryId
                    }, syncConflictMapByRepoId);
                }
                // else {remote deletions do not cause conflicts for remotely updated records}
                // If the record has been deleted, do not process the update
                continue;
            }
            // If the record has been created, update the creation record instead
            let createdRecord = this.getRecord(recordHistory, recordCreationsForRepoInTable);
            if (createdRecord) {
                if (isLocal) {
                    throw new Error(`Remotely created records are being updated locally.
					${this.getRecordInfo(repositoryId, operationHistory, recordHistory)}
					This is not possible if every remote change is only processed once.
					`);
                }
                else {
                    // remotely created record is being updated remotely - normal flow
                    for (const newValue of recordHistory.newValues) {
                        createdRecord.set(newValue.columnIndex, newValue.newValue);
                    }
                }
                // No need to record updates, already taken into account in the create
                continue;
            }
            // record update
            let updatedRecord = this.ensureRecord(recordHistory, updatesForEntityInRepo);
            let synchronizationConflict;
            for (const newValue of recordHistory.newValues) {
                if (isLocal) {
                    const columnIndex = newValue.columnIndex;
                    const recordUpdate = updatedRecord.get(columnIndex);
                    if (recordUpdate) {
                        // remotely updated record value is being updated locally
                        if (!synchronizationConflict) {
                            synchronizationConflict = this.addSyncConflict(SynchronizationConflict_Type.REMOTE_UPDATE_LOCALLY_UPDATED, repositoryId, {
                                id: recordUpdate.recordHistoryId,
                            }, {
                                id: remoteDeleteRecordHistoryId
                            }, syncConflictMapByRepoId);
                            synchronizationConflict.values = [];
                        }
                        synchronizationConflict.values.push({
                            columnIndex,
                            synchronizationConflict
                        });
                        // no need to update since the value is already there
                        // Remove the update
                        updatedRecord.delete(newValue.columnIndex);
                    }
                }
                else {
                    // remotely updated record value is being updated remotely - normal flow
                    // replace the older update with the newer one
                    updatedRecord.set(newValue.columnIndex, {
                        newValue: newValue.newValue,
                        recordHistoryId: recordHistory.id
                    });
                }
            }
        }
    }
    /*
    NOTE: local deletes of records NOT in incoming changes do not get inputted into
    this processing.
     */
    processDeletion(repositoryId, operationHistory, recordCreations, recordUpdates, recordDeletions, allLocalRecordDeletions) {
        const recordCreationsForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, recordCreations);
        const recordUpdatesForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, recordUpdates);
        const allLocalRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryId, operationHistory, allLocalRecordDeletions);
        const deletesForEntityInRepo = this.syncInUtils.ensureRecordMapForRepoInTable(repositoryId, operationHistory, recordDeletions);
        for (const recordHistory of operationHistory.recordHistory) {
            let recordCreationsForActorInRepoInTable = this.getRecordsForActor(recordHistory, recordCreationsForRepoInTable);
            // If a remotely deleted record was also created remotely
            if (recordCreationsForActorInRepoInTable
                && recordCreationsForActorInRepoInTable.get(recordHistory.actorRecordId)) {
                // remote deletions do not cause conflicts for remotely created records
                // Remove the creation of the record
                recordCreationsForActorInRepoInTable.delete(recordHistory.actorRecordId);
                // No need to record a deletion for a record that was also created (remotely)
                continue;
            }
            let recordUpdatesForActorInRepoInTable = this.getRecordsForActor(recordHistory, recordUpdatesForRepoInTable);
            // If a remotely deleted record has been updated (remotely)
            if (recordUpdatesForActorInRepoInTable
                && recordUpdatesForActorInRepoInTable.get(recordHistory.actorRecordId)) {
                // remote deletions do not cause conflicts for remotely updated records
                // Remove record updates for deleted records
                recordUpdatesForActorInRepoInTable.delete(recordHistory.actorRecordId);
            }
            if (this.getRecordHistoryId(recordHistory, allLocalRecordDeletesForRepoInTable)) {
                // If the record has been deleted locally, no need to add another delete operation
                continue;
            }
            // record deletion
            ensureChildJsSet(deletesForEntityInRepo, recordHistory.actor.id)
                .add(recordHistory.actorRecordId);
        }
    }
    getRecordsForRepoInTable(repositoryId, operationHistory, recordMapByApplicationTableAndRepository) {
        const recordMapForApplication = recordMapByApplicationTableAndRepository
            .get(operationHistory.entity.applicationVersion.id);
        let recordMapForTable;
        if (recordMapForApplication) {
            recordMapForTable = recordMapForApplication.get(operationHistory.entity.id);
        }
        let recordMapForRepoInTable;
        if (recordMapForTable) {
            recordMapForRepoInTable = recordMapForTable.get(repositoryId);
        }
        return recordMapForRepoInTable;
    }
    getRecord(recordHistory, recordMapByActor) {
        let recordsForActor = this.getRecordsForActor(recordHistory, recordMapByActor);
        if (!recordsForActor) {
            return null;
        }
        return recordsForActor.get(recordHistory.actorRecordId);
    }
    hasRecordId(recordHistory, actorRecordIdSetByActor) {
        let actorRecordIdsForActor = this.getRecordsForActor(recordHistory, actorRecordIdSetByActor);
        if (!actorRecordIdsForActor) {
            return false;
        }
        return actorRecordIdsForActor.has(recordHistory.actorRecordId);
    }
    getRecordHistoryId(recordHistory, actorRecordIdSetByActor) {
        let actorRecordIdsForActor = this.getRecordsForActor(recordHistory, actorRecordIdSetByActor);
        if (!actorRecordIdsForActor) {
            return null;
        }
        return actorRecordIdsForActor.get(recordHistory.actorRecordId);
    }
    getRecordsForActor(recordHistory, recordMapByActor) {
        let recordsForActor;
        if (recordMapByActor) {
            recordsForActor = recordMapByActor.get(recordHistory.actor.id);
        }
        return recordsForActor;
    }
    getRecordInfo(repositoryId, operationHistory, recordHistory) {
        return `
		Application Version ID: ${operationHistory.entity.applicationVersion.id}
		Entity ID:         ${operationHistory.entity.id}
		Repository ID:     ${repositoryId}
		Actor ID:          ${recordHistory.actor.id}
		Actor Record ID:   ${recordHistory.actorRecordId}
		`;
    }
    addSyncConflict(synchronizationConflictType, repositoryId, overwrittenRecordHistory, overwritingRecordHistory, syncConflictMapByRepoId) {
        const syncConflict = this.createSynchronizationConflict(synchronizationConflictType, repositoryId, overwrittenRecordHistory, overwritingRecordHistory);
        ensureChildArray(syncConflictMapByRepoId, repositoryId).push(syncConflict);
        return syncConflict;
    }
    createSynchronizationConflict(synchronizationConflictType, repositoryId, overwrittenRecordHistory, overwritingRecordHistory) {
        return {
            id: null,
            overwrittenRecordHistory,
            overwritingRecordHistory,
            repository: {
                id: repositoryId
            },
            type: synchronizationConflictType
        };
    }
    ensureColumnValueMap(recordHistory, dataMap) {
        return ensureChildJsMap(ensureChildJsMap(dataMap, recordHistory.actor.id), recordHistory.actorRecordId);
    }
    ensureRecord(recordHistory, recordMapByActor) {
        return ensureChildJsMap(ensureChildJsMap(recordMapByActor, recordHistory.actor.id), recordHistory.actorRecordId);
    }
};
__decorate$F([
    Inject()
], Stage1SyncedInDataProcessor.prototype, "actorDao", void 0);
__decorate$F([
    Inject()
], Stage1SyncedInDataProcessor.prototype, "airportDatabase", void 0);
__decorate$F([
    Inject()
], Stage1SyncedInDataProcessor.prototype, "repositoryTransactionHistoryDao", void 0);
__decorate$F([
    Inject()
], Stage1SyncedInDataProcessor.prototype, "repositoryTransactionHistoryDuo", void 0);
__decorate$F([
    Inject()
], Stage1SyncedInDataProcessor.prototype, "sequenceGenerator", void 0);
__decorate$F([
    Inject()
], Stage1SyncedInDataProcessor.prototype, "syncInUtils", void 0);
Stage1SyncedInDataProcessor = __decorate$F([
    Injected()
], Stage1SyncedInDataProcessor);

var __decorate$E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Stage2SyncedInDataProcessor = class Stage2SyncedInDataProcessor {
    async applyChangesToDb(stage1Result, applicationsByApplicationVersionIdMap) {
        const context = {};
        await this.performCreates(stage1Result.recordCreations, applicationsByApplicationVersionIdMap, context);
        await this.performUpdates(stage1Result.recordUpdates, applicationsByApplicationVersionIdMap, context);
        await this.performDeletes(stage1Result.recordDeletions, applicationsByApplicationVersionIdMap, context);
    }
    /**
     * Remote changes come in with ApplicationVersionIds not ApplicationIndexes, so it makes
     * sense to keep this structure.  NOTE: only one version of a given application is
     * processed at one time:
     *
     *  Changes for a application version below the one in this Terminal must first be upgraded.
     *  Terminal itself must first be upgraded to newer application versions, before changes
     *  for that application version are processed.
     *
     *  To tie in a given ApplicationVersionId to its ApplicationIndex an additional mapping data
     *  structure is passed in.
     */
    async performCreates(recordCreations, applicationsByApplicationVersionIdMap, context) {
        for (const [applicationVersionId, creationInApplicationMap] of recordCreations) {
            for (const [tableIndex, creationInTableMap] of creationInApplicationMap) {
                const applicationIndex = applicationsByApplicationVersionIdMap
                    .get(applicationVersionId).index;
                const dbEntity = this.airportDatabase.applications[applicationIndex].currentVersion[0]
                    .applicationVersion.entities[tableIndex];
                const qEntity = this.airportDatabase.qApplications[applicationIndex][dbEntity.name];
                const columns = [
                    qEntity.repository.id,
                    qEntity.actor.id,
                    qEntity.actorRecordId
                ];
                const nonIdColumns = this.getNonIdColumnsInIndexOrder(dbEntity);
                let creatingColumns = true;
                let numInserts = 0;
                const values = [];
                for (const [repositoryId, creationForRepositoryMap] of creationInTableMap) {
                    for (const [actorId, creationForActorMap] of creationForRepositoryMap) {
                        for (const [actorRecordId, creationOfRowMap] of creationForActorMap) {
                            const rowValues = [
                                repositoryId,
                                actorId,
                                actorRecordId
                            ];
                            const columnIndexedValues = [];
                            for (const [columnIndex, columnValue] of creationOfRowMap) {
                                columnIndexedValues.push([columnIndex, columnValue]);
                            }
                            if (columnIndexedValues.length) {
                                numInserts++;
                            }
                            columnIndexedValues.sort((col1IndexAndValue, col2IndexAndValue) => {
                                return this.utils.compareNumbers(col1IndexAndValue[0], col2IndexAndValue[0]);
                            });
                            let currentNonIdColumnArrayIndex = 0;
                            for (const [columnIndex, columnValue] of columnIndexedValues) {
                                let nonIdColumn = nonIdColumns[currentNonIdColumnArrayIndex];
                                while (nonIdColumn.index < columnIndex) {
                                    if (creatingColumns) {
                                        columns.push(qEntity.__driver__.allColumns[nonIdColumn.index]);
                                    }
                                    rowValues.push(null);
                                    currentNonIdColumnArrayIndex++;
                                    nonIdColumn = nonIdColumns[currentNonIdColumnArrayIndex];
                                }
                                if (creatingColumns) {
                                    columns.push(qEntity.__driver__.allColumns[columnIndex]);
                                }
                                rowValues.push(columnValue);
                                currentNonIdColumnArrayIndex++;
                            }
                            if (columnIndexedValues.length) {
                                values.push(rowValues);
                            }
                            creatingColumns = false;
                        }
                    }
                }
                if (numInserts) {
                    const previousDbEntity = context.dbEntity;
                    context.dbEntity = qEntity
                        .__driver__.dbEntity;
                    try {
                        await this.databaseFacade.insertValues({
                            insertInto: qEntity,
                            columns,
                            values
                        }, context);
                    }
                    finally {
                        context.dbEntity = previousDbEntity;
                    }
                }
            }
        }
    }
    getNonIdColumnsInIndexOrder(dbEntity) {
        const nonIdColumns = [];
        for (const column of dbEntity.columns) {
            switch (column.name) {
                case repositoryEntity.ACTOR_ID:
                case repositoryEntity.ACTOR_RECORD_ID:
                case repositoryEntity.REPOSITORY_ID:
                    continue;
            }
            nonIdColumns.push(column);
        }
        nonIdColumns.sort((column1, column2) => {
            return this.utils.compareNumbers(column1.index, column2.index);
        });
        return nonIdColumns;
    }
    async performUpdates(recordUpdates, applicationsByApplicationVersionIdMap, context) {
        const finalUpdateMap = new Map();
        const recordUpdateStage = [];
        // Build the final update data structure
        for (const [applicationVersionId, applicationUpdateMap] of recordUpdates) {
            const finalApplicationUpdateMap = ensureChildJsMap(finalUpdateMap, applicationVersionId);
            for (const [tableIndex, tableUpdateMap] of applicationUpdateMap) {
                const finalTableUpdateMap = ensureChildJsMap(finalApplicationUpdateMap, tableIndex);
                for (const [repositoryId, repositoryUpdateMap] of tableUpdateMap) {
                    for (const [actorId, actorUpdates] of repositoryUpdateMap) {
                        for (const [actorRecordId, recordUpdateMap] of actorUpdates) {
                            const recordKeyMap = this.getRecordKeyMap(recordUpdateMap, finalTableUpdateMap);
                            ensureChildJsSet(ensureChildJsMap(recordKeyMap, repositoryId), actorId)
                                .add(actorRecordId);
                            for (const [columnIndex, columnUpdate] of recordUpdateMap) {
                                recordUpdateStage.push([
                                    applicationVersionId,
                                    tableIndex,
                                    repositoryId,
                                    actorId,
                                    actorRecordId,
                                    columnIndex,
                                    columnUpdate.newValue
                                ]);
                            }
                        }
                    }
                }
            }
        }
        if (!recordUpdateStage.length) {
            return;
        }
        await this.recordUpdateStageDao.insertValues(recordUpdateStage);
        // Perform the updates
        for (const [applicationVersionId, updateMapForApplication] of finalUpdateMap) {
            const application = applicationsByApplicationVersionIdMap.get(applicationVersionId);
            for (const [tableIndex, updateMapForTable] of updateMapForApplication) {
                await this.runUpdatesForTable(application.index, applicationVersionId, tableIndex, updateMapForTable);
            }
        }
        await this.recordUpdateStageDao.delete();
    }
    async performDeletes(recordDeletions, applicationsByApplicationVersionIdMap, context) {
        for (const [applicationVersionId, deletionInApplicationMap] of recordDeletions) {
            const application = applicationsByApplicationVersionIdMap.get(applicationVersionId);
            for (const [tableIndex, deletionInTableMap] of deletionInApplicationMap) {
                const dbEntity = this.airportDatabase.applications[application.index].currentVersion[0]
                    .applicationVersion.entities[tableIndex];
                const qEntity = this.airportDatabase.qApplications[application.index][dbEntity.name];
                let numClauses = 0;
                let repositoryWhereFragments = [];
                for (const [repositoryId, deletionForRepositoryMap] of deletionInTableMap) {
                    let actorWhereFragments = [];
                    for (const [actorId, actorRecordIdSet] of deletionForRepositoryMap) {
                        numClauses++;
                        actorWhereFragments.push(and(qEntity.actorRecordId.in(Array.from(actorRecordIdSet)), qEntity.actor.id.equals(actorId)));
                    }
                    repositoryWhereFragments.push(and(qEntity.repository.id.equals(repositoryId), or(...actorWhereFragments)));
                }
                if (numClauses) {
                    const previousDbEntity = context.dbEntity;
                    context.dbEntity = qEntity
                        .__driver__.dbEntity;
                    try {
                        await this.databaseFacade.deleteWhere({
                            deleteFrom: qEntity,
                            where: or(...repositoryWhereFragments)
                        }, context);
                    }
                    finally {
                        context.dbEntity = previousDbEntity;
                    }
                }
            }
        }
    }
    /**
     * Get the record key map (RecordKeyMap = RepositoryId -> Actor_Id
     * -> RepositoryEntity_ActorRecordId) for the recordUpdateMap (the specified combination
     * of columns/values being updated)
     * @param {Map<ColumnIndex, RecordUpdate>} recordUpdateMap
     * @param {ColumnUpdateKeyMap} finalTableUpdarecordKeyMapteMap
     * @returns {RecordKeyMap}
     */
    getRecordKeyMap(recordUpdateMap, // combination of columns/values
    // being updated
    finalTableUpdateMap) {
        const updatedColumns = [];
        for (const columnIndex of recordUpdateMap.keys()) {
            updatedColumns.push(columnIndex);
        }
        // Sort the updated columns by column index, to ensure that all records with the
        // same combination of updated columns are grouped
        updatedColumns.sort(this.utils.compareNumbers);
        // Navigate down the table UpdateKeyMap to find the matching combination of
        // columns being updated
        let columnValueUpdate;
        let updateKeyMap = finalTableUpdateMap;
        for (const columnIndex of updatedColumns) {
            columnValueUpdate = updateKeyMap.get(columnIndex);
            // If no update statements with the specified combination of columns exist yet
            if (!columnValueUpdate) {
                columnValueUpdate = {
                    childColumnUpdateKeyMap: new Map(),
                    recordKeyMap: new Map(),
                    updatedColumns: null,
                };
                updateKeyMap.set(columnIndex, columnValueUpdate);
            }
            // Navigate down
            updateKeyMap = columnValueUpdate.childColumnUpdateKeyMap;
        }
        columnValueUpdate.updatedColumns = updatedColumns;
        // Return the map of the records for the update statement of the specified combination
        // of columns/values
        return columnValueUpdate.recordKeyMap;
    }
    /**
     * Run all updates for a particular table.  One update per updated column combination
     * is run.
     *
     * @param {ApplicationIndex} applicationIndex
     * @param {TableIndex} tableIndex
     * @param {ColumnUpdateKeyMap} updateKeyMap
     * @returns {Promise<void>}
     */
    async runUpdatesForTable(applicationIndex, applicationVersionId, tableIndex, updateKeyMap) {
        for (const columnValueUpdate of updateKeyMap.values()) {
            const updatedColumns = columnValueUpdate.updatedColumns;
            if (updatedColumns) {
                await this.recordUpdateStageDao.updateEntityWhereIds(applicationIndex, applicationVersionId, tableIndex, columnValueUpdate.recordKeyMap, updatedColumns);
            }
            // Traverse down into nested column update combinations
            await this.runUpdatesForTable(applicationIndex, applicationVersionId, tableIndex, columnValueUpdate.childColumnUpdateKeyMap);
        }
    }
};
__decorate$E([
    Inject()
], Stage2SyncedInDataProcessor.prototype, "airportDatabase", void 0);
__decorate$E([
    Inject()
], Stage2SyncedInDataProcessor.prototype, "databaseFacade", void 0);
__decorate$E([
    Inject()
], Stage2SyncedInDataProcessor.prototype, "recordUpdateStageDao", void 0);
__decorate$E([
    Inject()
], Stage2SyncedInDataProcessor.prototype, "utils", void 0);
Stage2SyncedInDataProcessor = __decorate$E([
    Injected()
], Stage2SyncedInDataProcessor);

var __decorate$D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Synchronization in Manager implementation.
 */
let SynchronizationInManager = class SynchronizationInManager {
    async receiveMessages(messageMapByUuId, context) {
        const syncTimestamp = new Date().getTime();
        const existingRepositoryTransactionHistories = await this.repositoryTransactionHistoryDao
            .findWhereUuIdsIn([...messageMapByUuId.keys()]);
        for (const existingRepositoryTransactionHistory of existingRepositoryTransactionHistories) {
            messageMapByUuId.delete(existingRepositoryTransactionHistory.uuId);
        }
        if (!messageMapByUuId.size) {
            return;
        }
        let messagesToProcess = [];
        const orderedMessages = this.timeOrderMessages(messageMapByUuId);
        // Split up messages by type
        for (const message of orderedMessages) {
            if (!this.isValidLastChangeTime(syncTimestamp, message.syncTimestamp, 'Sync Timestamp')) {
                continue;
            }
            if (!this.isValidLastChangeTime(message.syncTimestamp, message.history.saveTimestamp, 'Sync Timestamp', 'Save Timestamp')) {
                continue;
            }
            let processMessage = true;
            await this.transactionManager.transactInternal(async (transaction) => {
                if (!await this.syncInChecker.checkMessage(message)) {
                    transaction.rollback(null, context);
                    processMessage = false;
                    return;
                }
            }, context);
            if (processMessage) {
                messagesToProcess.push(message);
            }
        }
        await this.transactionManager.transactInternal(async (transaction) => {
            transaction.isSync = true;
            await this.twoStageSyncedInDataProcessor.syncMessages(messagesToProcess, transaction);
        }, context);
    }
    timeOrderMessages(messageMapByUuId) {
        const messages = [...messageMapByUuId.values()];
        messages.sort((message1, message2) => {
            if (message1.syncTimestamp < message2.syncTimestamp) {
                return -1;
            }
            if (message1.syncTimestamp > message2.syncTimestamp) {
                return 1;
            }
            let history1 = message1.history;
            let history2 = message2.history;
            if (history1.saveTimestamp < history2.saveTimestamp) {
                return -1;
            }
            if (history1.saveTimestamp > history2.saveTimestamp) {
                return 1;
            }
            return 0;
        });
        return messages;
    }
    isValidLastChangeTime(syncTimestamp, remoteTimestamp, remoteFieldName, syncFieldName = 'Reception Time:') {
        if (syncTimestamp < remoteTimestamp) {
            console.error(`Message ${syncFieldName} is less than
			the ${remoteFieldName} in received message:
				${syncFieldName}:               ${syncTimestamp}
				${remoteFieldName}:           ${remoteTimestamp}
			`);
            return false;
        }
        return true;
    }
};
__decorate$D([
    Inject()
], SynchronizationInManager.prototype, "repositoryTransactionHistoryDao", void 0);
__decorate$D([
    Inject()
], SynchronizationInManager.prototype, "syncInChecker", void 0);
__decorate$D([
    Inject()
], SynchronizationInManager.prototype, "transactionManager", void 0);
__decorate$D([
    Inject()
], SynchronizationInManager.prototype, "twoStageSyncedInDataProcessor", void 0);
SynchronizationInManager = __decorate$D([
    Injected()
], SynchronizationInManager);

var __decorate$C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Result of comparing to versions of a given application.
 */
var ApplicationComparisonResult;
(function (ApplicationComparisonResult) {
    // Version specified in the message is lower than it's version in the receiving
    // Terminal (TM)
    ApplicationComparisonResult[ApplicationComparisonResult["MESSAGE_APPLICATION_VERSION_IS_LOWER"] = -1] = "MESSAGE_APPLICATION_VERSION_IS_LOWER";
    // Version of the application used i the message is the same as that in the receiving
    // Terminal (TM)
    ApplicationComparisonResult[ApplicationComparisonResult["MESSAGE_APPLICATION_VERSION_IS_EQUAL"] = 0] = "MESSAGE_APPLICATION_VERSION_IS_EQUAL";
    // Version specified in the message in higher than it's version in the receiving
    // Terminal (TM)
    ApplicationComparisonResult[ApplicationComparisonResult["MESSAGE_APPLICATION_VERSION_IS_HIGHER"] = 1] = "MESSAGE_APPLICATION_VERSION_IS_HIGHER";
})(ApplicationComparisonResult || (ApplicationComparisonResult = {}));
let SyncInUtils = class SyncInUtils {
    ensureRecordMapForRepoInTable(repositoryId, operationHistory, recordMapByApplicationTableAndRepository) {
        return ensureChildJsMap(ensureChildJsMap(ensureChildJsMap(recordMapByApplicationTableAndRepository, operationHistory.entity.applicationVersion.id), operationHistory.entity.index), repositoryId);
    }
};
SyncInUtils = __decorate$C([
    Injected()
], SyncInUtils);

var __decorate$B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TwoStageSyncedInDataProcessor = class TwoStageSyncedInDataProcessor {
    /**
     * Synchronize the data messages coming to Terminal (new data for this TM)
     */
    async syncMessages(messages, transaction) {
        this.aggregateHistoryRecords(messages, transaction);
        const { actorMapById, repositoryTransactionHistoryMapByRepositoryId, applicationsByApplicationVersionIdMap } = await this.getDataStructures(messages);
        await this.updateLocalData(repositoryTransactionHistoryMapByRepositoryId, actorMapById, applicationsByApplicationVersionIdMap);
    }
    aggregateHistoryRecords(messages, transaction) {
        const transactionHistory = transaction.transactionHistory;
        transactionHistory.transactionType = TransactionType.REMOTE_SYNC;
        // split messages by repository and record actor information
        for (const message of messages) {
            const repositoryTransactionHistory = message.history;
            transactionHistory.repositoryTransactionHistories.push(repositoryTransactionHistory);
            repositoryTransactionHistory.repositoryTransactionType = RepositoryTransactionType.REMOTE;
            transactionHistory.allOperationHistory = transactionHistory
                .allOperationHistory.concat(repositoryTransactionHistory.operationHistory);
            repositoryTransactionHistory.operationHistory.forEach((operationHistory) => {
                transactionHistory.allRecordHistory = transactionHistory
                    .allRecordHistory.concat(operationHistory.recordHistory);
                operationHistory.recordHistory.forEach((recordHistory) => {
                    if (recordHistory.newValues && recordHistory.newValues.length) {
                        transactionHistory.allRecordHistoryNewValues = transactionHistory
                            .allRecordHistoryNewValues.concat(recordHistory.newValues);
                    }
                    if (recordHistory.oldValues && recordHistory.oldValues.length) {
                        transactionHistory.allRecordHistoryOldValues = transactionHistory
                            .allRecordHistoryOldValues.concat(recordHistory.oldValues);
                    }
                });
            });
        }
    }
    async getDataStructures(messages) {
        const repositoryTransactionHistoryMapByRepositoryId = new Map();
        const applicationsByApplicationVersionIdMap = new Map();
        const actorMapById = new Map();
        const repoTransHistories = [];
        for (const message of messages) {
            repoTransHistories.push(message.history);
            repositoryTransactionHistoryMapByRepositoryId.set(message.history.repository.id, repoTransHistories);
            for (const actor of message.actors) {
                actorMapById.set(actor.id, actor);
            }
            for (const applicationVersion of message.applicationVersions) {
                applicationsByApplicationVersionIdMap.set(applicationVersion.id, applicationVersion.application);
            }
        }
        for (const [_, repoTransHistories] of repositoryTransactionHistoryMapByRepositoryId) {
            this.repositoryTransactionHistoryDuo
                .sortRepoTransHistories(repoTransHistories, actorMapById);
        }
        return {
            actorMapById,
            repositoryTransactionHistoryMapByRepositoryId,
            applicationsByApplicationVersionIdMap
        };
    }
    async updateLocalData(repositoryTransactionHistoryMapByRepositoryId, actorMayById, applicationsByApplicationVersionIdMap) {
        const stage1Result = await this.stage1SyncedInDataProcessor.performStage1DataProcessing(repositoryTransactionHistoryMapByRepositoryId, actorMayById);
        let allSyncConflicts = [];
        let allSyncConflictValues = [];
        for (const [_, synchronizationConflicts] of stage1Result.syncConflictMapByRepoId) {
            allSyncConflicts = allSyncConflicts.concat(synchronizationConflicts);
            for (const synchronizationConflict of synchronizationConflicts) {
                if (synchronizationConflict.values.length) {
                    allSyncConflictValues = allSyncConflictValues.concat(synchronizationConflict.values);
                }
            }
        }
        await this.stage2SyncedInDataProcessor.applyChangesToDb(stage1Result, applicationsByApplicationVersionIdMap);
        if (allSyncConflicts.length) {
            await this.synchronizationConflictDao.insert(allSyncConflicts);
        }
        if (allSyncConflictValues.length) {
            await this.synchronizationConflictValuesDao.insert(allSyncConflictValues);
        }
    }
};
__decorate$B([
    Inject()
], TwoStageSyncedInDataProcessor.prototype, "repositoryTransactionHistoryDuo", void 0);
__decorate$B([
    Inject()
], TwoStageSyncedInDataProcessor.prototype, "stage1SyncedInDataProcessor", void 0);
__decorate$B([
    Inject()
], TwoStageSyncedInDataProcessor.prototype, "stage2SyncedInDataProcessor", void 0);
__decorate$B([
    Inject()
], TwoStageSyncedInDataProcessor.prototype, "synchronizationConflictDao", void 0);
__decorate$B([
    Inject()
], TwoStageSyncedInDataProcessor.prototype, "synchronizationConflictValuesDao", void 0);
TwoStageSyncedInDataProcessor = __decorate$B([
    Injected()
], TwoStageSyncedInDataProcessor);

var __decorate$A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const WITH_ID = {};
const WITH_RECORD_HISTORY = {};
const WITH_INDEX = {};
let SyncOutDataSerializer = class SyncOutDataSerializer {
    async serialize(repositoryTransactionHistories) {
        let historiesToSend = [];
        const messages = [];
        for (const repositoryTransactionHistory of repositoryTransactionHistories) {
            if (repositoryTransactionHistory.repositoryTransactionType !== RepositoryTransactionType.LOCAL) {
                continue;
            }
            const message = await this.serializeMessage(repositoryTransactionHistory);
            historiesToSend.push(repositoryTransactionHistory);
            messages.push(message);
        }
        return {
            historiesToSend,
            messages
        };
    }
    async serializeMessage(repositoryTransactionHistory) {
        const lookups = {
            actorInMessageIndexesById: new Map(),
            applicationVersionInMessageIndexesById: new Map(),
            applicationVersions: [],
            lastInMessageActorIndex: -1,
            lastInMessageApplicationVersionIndex: -1,
            lastInMessageRepositoryIndex: -1,
            messageRepository: repositoryTransactionHistory.repository,
            repositoryInMessageIndexesById: new Map()
        };
        const inMessageUserLookup = {
            inMessageIndexesById: new Map(),
            lastInMessageIndex: -1
        };
        const message = {
            actors: [],
            applicationVersions: [],
            applications: [],
            history: null,
            // Repositories may reference records in other repositories
            referencedRepositories: [],
            users: [],
            terminals: []
        };
        message.history = this.serializeRepositoryTransactionHistory(repositoryTransactionHistory, message, lookups, inMessageUserLookup);
        // TODO: replace db lookups with TerminalState lookups where possible
        await this.serializeRepositories(repositoryTransactionHistory, message, lookups, inMessageUserLookup);
        const inMessageApplicationLookup = await this.serializeActorsUsersAndTerminals(message, lookups, inMessageUserLookup);
        await this.serializeApplicationsAndVersions(message, inMessageApplicationLookup, lookups);
        return message;
    }
    async serializeActorsUsersAndTerminals(message, lookups, inMessageUserLookup) {
        let actorIdsToFindBy = [];
        for (let actorId of lookups.actorInMessageIndexesById.keys()) {
            actorIdsToFindBy.push(actorId);
        }
        const actors = await this.actorDao.findWithDetailsAndGlobalIdsByIds(actorIdsToFindBy);
        this.serializeUsers(actors, message, inMessageUserLookup);
        const terminalInMessageIndexesById = this.serializeTerminals(actors, message, inMessageUserLookup);
        const inMessageApplicationLookup = {
            lastInMessageIndex: -1,
            inMessageIndexesById: new Map()
        };
        for (const actor of actors) {
            const applicationInMessageIndex = this.serializeApplication(actor.application, inMessageApplicationLookup, message);
            const actorInMessageIndex = lookups.actorInMessageIndexesById.get(actor.id);
            message.actors[actorInMessageIndex] = {
                ...WITH_ID,
                application: applicationInMessageIndex,
                terminal: terminalInMessageIndexesById.get(actor.terminal.id),
                user: inMessageUserLookup.inMessageIndexesById.get(actor.user.id),
                uuId: actor.uuId
            };
        }
        return inMessageApplicationLookup;
    }
    serializeTerminals(actors, message, inMessageUserLookup) {
        let lastInMessageTerminalIndex = -1;
        const terminalInMessageIndexesById = new Map();
        for (const actor of actors) {
            let terminal = actor.terminal;
            if (terminalInMessageIndexesById.has(terminal.id)) {
                continue;
            }
            const terminalInMessageIndex = ++lastInMessageTerminalIndex;
            terminalInMessageIndexesById.set(terminal.id, terminalInMessageIndex);
            message.terminals[terminalInMessageIndex] = {
                ...WITH_ID,
                uuId: terminal.uuId,
                owner: inMessageUserLookup.inMessageIndexesById.get(terminal.owner.id)
            };
        }
        return terminalInMessageIndexesById;
    }
    serializeUsers(actors, message, inMessageUserLookup) {
        for (const actor of actors) {
            this.addUserToMessage(actor.user, message, inMessageUserLookup);
            this.addUserToMessage(actor.terminal.owner, message, inMessageUserLookup);
        }
    }
    addUserToMessage(user, message, inMessageUserLookup) {
        let userInMessageIndex = this.getUserInMessageIndex(user, inMessageUserLookup);
        message.users[userInMessageIndex] = {
            ...WITH_ID,
            username: user.username,
            uuId: user.uuId
        };
        return userInMessageIndex;
    }
    getUserInMessageIndex(user, inMessageUserLookup) {
        if (inMessageUserLookup.inMessageIndexesById.has(user.id)) {
            return inMessageUserLookup.inMessageIndexesById.get(user.id);
        }
        let userInMessageIndex = ++inMessageUserLookup.lastInMessageIndex;
        inMessageUserLookup.inMessageIndexesById.set(user.id, userInMessageIndex);
        return userInMessageIndex;
    }
    async serializeRepositories(repositoryTransactionHistory, message, lookups, inMessageUserLookup) {
        let repositoryIdsToFindBy = [];
        for (let repositoryId of lookups.repositoryInMessageIndexesById.keys()) {
            repositoryIdsToFindBy.push(repositoryId);
        }
        repositoryIdsToFindBy.push(repositoryTransactionHistory.id);
        const repositories = await this.repositoryDao.findByIds(repositoryIdsToFindBy);
        for (const repository of repositories) {
            let userInMessageIndex = this.getUserInMessageIndex(repository.owner, inMessageUserLookup);
            if (lookups.repositoryInMessageIndexesById.has(repository.id)) {
                const repositoryInMessageIndex = lookups.repositoryInMessageIndexesById.get(repository.id);
                message.referencedRepositories[repositoryInMessageIndex] =
                    this.serializeRepository(repository, userInMessageIndex);
            }
            else {
                message.history.repository.owner = userInMessageIndex;
                message.history.repository.id = repository.id;
            }
        }
    }
    serializeApplicationsAndVersions(message, inMessageApplicationLookup, lookups) {
        for (let i = 0; i < lookups.applicationVersions.length; i++) {
            const applicationVersion = lookups.applicationVersions[i];
            const applicationInMessageIndex = this.serializeApplication(applicationVersion.application, inMessageApplicationLookup, message);
            message.applicationVersions[i] = {
                ...WITH_ID,
                application: applicationInMessageIndex,
                integerVersion: applicationVersion.integerVersion
            };
        }
    }
    serializeApplication(application, inMessageApplicationLookup, message) {
        let applicationInMessageIndex;
        if (inMessageApplicationLookup.inMessageIndexesById.has(application.index)) {
            applicationInMessageIndex = inMessageApplicationLookup
                .inMessageIndexesById.get(application.index);
        }
        else {
            applicationInMessageIndex = ++inMessageApplicationLookup.lastInMessageIndex;
            inMessageApplicationLookup.inMessageIndexesById
                .set(application.index, applicationInMessageIndex);
            message.applications[applicationInMessageIndex] = {
                ...WITH_INDEX,
                domain: {
                    ...WITH_ID,
                    name: application.domain.name
                },
                name: application.name
            };
        }
        return applicationInMessageIndex;
    }
    serializeRepositoryTransactionHistory(repositoryTransactionHistory, message, lookups, inMessageUserLookup) {
        repositoryTransactionHistory.operationHistory.sort((operationHistory1, operationHistory2) => {
            if (operationHistory1.orderNumber < operationHistory2.orderNumber) {
                return -1;
            }
            if (operationHistory1.orderNumber > operationHistory2.orderNumber) {
                return 1;
            }
            return 0;
        });
        const serializedOperationHistory = [];
        for (const operationHistory of repositoryTransactionHistory.operationHistory) {
            serializedOperationHistory.push(this.serializeOperationHistory(operationHistory, lookups));
        }
        return {
            ...WITH_ID,
            isRepositoryCreation: repositoryTransactionHistory.isRepositoryCreation,
            repository: this.serializeHistoryRepository(repositoryTransactionHistory, message, inMessageUserLookup),
            operationHistory: serializedOperationHistory,
            saveTimestamp: repositoryTransactionHistory.saveTimestamp,
            uuId: repositoryTransactionHistory.uuId
        };
    }
    serializeHistoryRepository(repositoryTransactionHistory, message, inMessageUserLookup) {
        if (repositoryTransactionHistory.isRepositoryCreation) {
            const repository = repositoryTransactionHistory.repository;
            let userInMessageIndex = this.addUserToMessage(repository.owner, message, inMessageUserLookup);
            return this.serializeRepository(repository, userInMessageIndex);
        }
        else {
            // When this repositoryTransactionHistory processed at sync-in 
            // the repository should already be loaded in the target database
            // if it's not then it's missing the repositoryTransactionHistory
            // with isRepositoryCreation === true
            return repositoryTransactionHistory.repository.uuId;
        }
    }
    serializeOperationHistory(operationHistory, lookups) {
        const dbEntity = operationHistory.entity;
        const serializedRecordHistory = [];
        for (const recordHistory of operationHistory.recordHistory) {
            serializedRecordHistory.push(this.serializeRecordHistory(operationHistory, recordHistory, dbEntity, lookups));
        }
        const entity = operationHistory.entity;
        // Should be populated - coming from TerminalStore
        // if (typeof entity !== 'object') {
        // 	throw new Error(`OperationHistory.entity must be populated`)
        // }
        // if (typeof entity.index !== 'number') {
        // 	throw new Error(`OperationHistory.entity.index must be present`)
        // }
        const applicationVersion = entity.applicationVersion;
        // Should be populated - coming from TerminalStore
        // if (typeof applicationVersion !== 'object') {
        // 	throw new Error(`OperationHistory.entity.applicationVersion must be populated`)
        // }
        // if (typeof applicationVersion.id !== 'number') {
        // 	throw new Error(`OperationHistory.entity.applicationVersion.id must be present`)
        // }
        let applicationVersionInMessageIndex;
        if (lookups.applicationVersionInMessageIndexesById.has(applicationVersion.id)) {
            applicationVersionInMessageIndex = lookups.applicationVersionInMessageIndexesById.get(applicationVersion.id);
        }
        else {
            applicationVersionInMessageIndex = ++lookups.lastInMessageApplicationVersionIndex;
            lookups.applicationVersionInMessageIndexesById.set(applicationVersion.id, applicationVersionInMessageIndex);
        }
        lookups.applicationVersions[applicationVersionInMessageIndex] = applicationVersion;
        return {
            ...WITH_ID,
            actor: this.getActorInMessageIndex(operationHistory.actor, lookups),
            changeType: operationHistory.changeType,
            entity: {
                ...WITH_ID,
                applicationVersion: applicationVersionInMessageIndex,
                index: operationHistory.entity.index
            },
            recordHistory: serializedRecordHistory
        };
    }
    serializeRecordHistory(operationHistory, recordHistory, dbEntity, lookups) {
        const dbColumMapByIndex = new Map();
        for (const dbColumn of dbEntity.columns) {
            dbColumMapByIndex.set(dbColumn.index, dbColumn);
        }
        const newValues = [];
        for (const newValue of recordHistory.newValues) {
            const dbColumn = dbColumMapByIndex.get(newValue.columnIndex);
            newValues.push(this.serializeNewValue(newValue, dbColumn, lookups));
        }
        const oldValues = [];
        for (const oldValue of recordHistory.oldValues) {
            const dbColumn = dbColumMapByIndex.get(oldValue.columnIndex);
            oldValues.push(this.serializeOldValue(oldValue, dbColumn, lookups));
        }
        const actor = recordHistory.actor;
        // Actor may be null if it's the same actor as for RepositoryTransactionHistory
        // if (typeof actor !== 'object') {
        // 	throw new Error(`RecordHistory.actor must be populated`)
        // }
        const baseObject = {
            ...WITH_ID,
        };
        if (actor.id !== operationHistory.actor.id) {
            baseObject.actor = this.getActorInMessageIndex(actor, lookups);
        }
        if (newValues.length) {
            baseObject.newValues = newValues;
        }
        if (oldValues.length) {
            baseObject.oldValues = oldValues;
        }
        return {
            ...baseObject,
            actorRecordId: recordHistory.actorRecordId,
        };
    }
    getActorInMessageIndex(actor, lookups) {
        if (!actor) {
            return null;
        }
        return this.getActorInMessageIndexById(actor.id, lookups);
    }
    getActorInMessageIndexById(actorId, lookups) {
        let actorInMessageIndex;
        if (lookups.actorInMessageIndexesById.has(actorId)) {
            actorInMessageIndex = lookups.actorInMessageIndexesById.get(actorId);
        }
        else {
            actorInMessageIndex = ++lookups.lastInMessageActorIndex;
            lookups.actorInMessageIndexesById.set(actorId, actorInMessageIndex);
        }
        return actorInMessageIndex;
    }
    serializeNewValue(newValue, dbColumn, lookups) {
        return this.serializeValue(newValue, dbColumn, lookups, 'newValue');
    }
    serializeOldValue(oldValue, dbColumn, lookups) {
        return this.serializeValue(oldValue, dbColumn, lookups, 'oldValue');
    }
    serializeValue(valueRecord, dbColumn, lookups, valueFieldName) {
        let value = valueRecord[valueFieldName];
        let serailizedValue = value;
        switch (dbColumn.name) {
            case repositoryEntity.ORIGINAL_ACTOR_ID: {
                serailizedValue = this.getActorInMessageIndexById(value, lookups);
                break;
            }
            case repositoryEntity.ORIGINAL_REPOSITORY_ID: {
                serailizedValue = this.getSerializedRepositoryId(value, lookups);
                break;
            }
        }
        if (/.*_AID_[\d]+$/.test(dbColumn.name)
            && dbColumn.manyRelationColumns.length) {
            serailizedValue = this.getActorInMessageIndexById(value, lookups);
        }
        if (/.*_RID_[\d]+$/.test(dbColumn.name)
            && dbColumn.manyRelationColumns.length) {
            serailizedValue = this.getSerializedRepositoryId(value, lookups);
        }
        return {
            ...WITH_RECORD_HISTORY,
            columnIndex: valueRecord.columnIndex,
            [valueFieldName]: serailizedValue
        };
    }
    getSerializedRepositoryId(value, lookups) {
        if (value === lookups.messageRepository.id) {
            return -1;
        }
        let serailizedValue = lookups.repositoryInMessageIndexesById.get(value);
        if (serailizedValue === undefined) {
            lookups.lastInMessageRepositoryIndex++;
            serailizedValue = lookups.lastInMessageRepositoryIndex;
            lookups.repositoryInMessageIndexesById.set(value, serailizedValue);
        }
        return serailizedValue;
    }
    serializeRepository(repository, owner) {
        return {
            ...WITH_ID,
            ageSuitability: repository.ageSuitability,
            createdAt: repository.createdAt,
            immutable: repository.immutable,
            owner,
            source: repository.source,
            uuId: repository.uuId
        };
    }
};
__decorate$A([
    Inject()
], SyncOutDataSerializer.prototype, "actorDao", void 0);
__decorate$A([
    Inject()
], SyncOutDataSerializer.prototype, "repositoryDao", void 0);
SyncOutDataSerializer = __decorate$A([
    Injected()
], SyncOutDataSerializer);

var __decorate$z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SynchronizationOutManager = class SynchronizationOutManager {
    async synchronizeOut(repositoryTransactionHistories) {
        await this.loadHistoryRepositories(repositoryTransactionHistories);
        const { historiesToSend, messages } = await this.syncOutDataSerializer.serialize(repositoryTransactionHistories);
        // await this.ensureGlobalRepositoryIdentifiers(repositoryTransactionHistories, messages)
        const groupMessageMap = this.groupMessagesBySourceAndRepository(messages, historiesToSend);
        for (const [repositorySource, messageMapForSource] of groupMessageMap) {
            const synchronizationAdapter = await this.synchronizationAdapterLoader.load(repositorySource);
            await synchronizationAdapter.sendTransactions(repositorySource, messageMapForSource);
        }
        await this.updateRepositoryTransactionHistories(messages, historiesToSend);
    }
    async loadHistoryRepositories(repositoryTransactionHistories) {
        const repositoryIdsToLookup = new Set();
        const repositoryMapById = new Map();
        for (const repositoryTransactionHistory of repositoryTransactionHistories) {
            repositoryIdsToLookup.add(repositoryTransactionHistory.repository.id);
        }
        if (!repositoryIdsToLookup.size) {
            return;
        }
        const repositories = await this.repositoryDao.findByIds([
            ...repositoryIdsToLookup.values()
        ]);
        for (const repository of repositories) {
            repositoryMapById.set(repository.id, repository);
        }
        for (const repositoryTransactionHistory of repositoryTransactionHistories) {
            repositoryTransactionHistory.repository =
                repositoryMapById.get(repositoryTransactionHistory.repository.id);
        }
    }
    async ensureGlobalRepositoryIdentifiers(repositoryTransactionHistories, messages) {
        const repositoryIdsToLookup = new Set();
        const repositoryMapById = new Map();
        for (const repositoryTransactionHistory of repositoryTransactionHistories) {
            const repository = repositoryTransactionHistory.repository;
            if (!repository.source || !repository.uuId) {
                repositoryIdsToLookup.add(repository.id);
            }
            else {
                repositoryMapById.set(repository.id, repository);
            }
        }
        if (!repositoryIdsToLookup.size) {
            return;
        }
        const repositories = await this.repositoryDao.findByIds([
            ...repositoryIdsToLookup.values()
        ]);
        for (const repository of repositories) {
            repositoryMapById.set(repository.id, repository);
        }
        for (const message of messages) {
            const repository = message.history.repository;
            if (!repository.source || !repository.uuId) {
                const foundRepository = repositoryMapById.get(repository.id);
                repository.source = foundRepository.source;
                repository.uuId = foundRepository.uuId;
                delete repository.id;
            }
        }
    }
    groupMessagesBySourceAndRepository(messages, historiesToSend) {
        const groupMessageMap = new Map();
        for (let i = 0; i < messages.length; i++) {
            const repository = historiesToSend[i].repository;
            ensureChildArray(ensureChildJsMap(groupMessageMap, repository.source), repository.uuId).push(messages[i]);
        }
        return groupMessageMap;
    }
    async updateRepositoryTransactionHistories(messages, repositoryTransactionHistories) {
        for (let i = 0; i < messages.length; i++) {
            const message = messages[i];
            const repositoryTransactionHistory = repositoryTransactionHistories[i];
            if (message.syncTimestamp) {
                repositoryTransactionHistory.syncTimestamp = message.syncTimestamp;
                await this.repositoryTransactionHistoryDao.updateSyncTimestamp(repositoryTransactionHistory);
            }
        }
    }
};
__decorate$z([
    Inject()
], SynchronizationOutManager.prototype, "repositoryDao", void 0);
__decorate$z([
    Inject()
], SynchronizationOutManager.prototype, "repositoryTransactionHistoryDao", void 0);
__decorate$z([
    Inject()
], SynchronizationOutManager.prototype, "synchronizationAdapterLoader", void 0);
__decorate$z([
    Inject()
], SynchronizationOutManager.prototype, "syncOutDataSerializer", void 0);
SynchronizationOutManager = __decorate$z([
    Injected()
], SynchronizationOutManager);

var __decorate$y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NonhubClient = class NonhubClient {
    constructor() {
        // encryptionKey = process.env.ENCRYPTION_KEY
        this.serverLocationProtocol = 'http://';
    }
    async getRepositoryTransactions(location, repositoryUuId, sinceSyncTimestamp = null) {
        try {
            const response = await this.sendMessage(location + '/read', {
                repositoryUuId,
                syncTimestamp: sinceSyncTimestamp
            });
            if (response.error) {
                console.error(response.error);
                return [];
            }
            return response.fragments;
        }
        catch (e) {
            console.error(e);
            return [];
        }
    }
    async sendRepositoryTransactions(location, repositoryUuId, messages) {
        try {
            const response = await this.sendMessage(location + '/write', {
                messages,
                repositoryUuId
            });
            if (response.error) {
                console.error(response.error);
                return 0;
            }
            return response.syncTimestamp;
        }
        catch (e) {
            console.error(e);
            return 0;
        }
    }
    async sendMessage(location, request) {
        let packagedMessage = JSON.stringify(request);
        // if (this.encryptionKey) {
        //     packagedMessage = await encryptString(
        //         packagedMessage, this.encryptionKey)
        // }
        const response = await fetch(this.serverLocationProtocol + location, {
            method: 'PUT',
            mode: 'cors',
            // cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            // credentials: 'same-origin',
            headers: {
                'Content-Type': 'application/json'
            },
            // redirect: 'follow', // manual, *follow, error
            // referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
            body: packagedMessage // body data type must match "Content-Type" header
        });
        // let unpackagedMessage = response.text()
        // if (this.encryptionKey) {
        //     unpackagedMessage = await decryptString(unpackagedMessage, this.encryptionKey)
        // }
        // return JSON.parse(unpackagedMessage)
        return response.json();
    }
};
NonhubClient = __decorate$y([
    Injected()
], NonhubClient);

// import {
//     decryptString,
//     encryptString,
// } from "string-cipher";
const nonhubClient = lib$1('nonhub-client');
const NONHUB_CLIENT = nonhubClient.token({
    class: NonhubClient,
    interface: 'INonhubClient',
    token: 'INonhubClient'
});

const groundTransport = lib$1('ground-transport');
const STAGE1_SYNCED_IN_DATA_PROCESSOR = groundTransport.token({
    class: Stage1SyncedInDataProcessor,
    interface: 'IStage1SyncedInDataProcessor',
    token: 'STAGE1_SYNCED_IN_DATA_PROCESSOR'
});
const STAGE2_SYNCED_IN_DATA_PROCESSOR = groundTransport.token({
    class: Stage2SyncedInDataProcessor,
    interface: 'IStage2SyncedInDataProcessor',
    token: 'STAGE2_SYNCED_IN_DATA_PROCESSOR'
});
const SYNC_IN_ACTOR_CHECKER = groundTransport.token({
    class: SyncInActorChecker,
    interface: 'ISyncInActorChecker',
    token: 'SYNC_IN_ACTOR_CHECKER'
});
const SYNC_IN_CHECKER = groundTransport.token({
    class: SyncInChecker,
    interface: 'ISyncInChecker',
    token: 'SYNC_IN_CHECKER'
});
const SYNC_IN_DATA_CHECKER = groundTransport.token({
    class: SyncInDataChecker,
    interface: 'ISyncInDataChecker',
    token: 'SYNC_IN_DATA_CHECKER'
});
const SYNC_IN_TERMINAL_CHECKER = groundTransport.token({
    class: SyncInTerminalChecker,
    interface: 'ISyncInTerminalChecker',
    token: 'SYNC_IN_TERMINAL_CHECKER'
});
const SYNC_IN_REPOSITORY_CHECKER = groundTransport.token({
    class: SyncInRepositoryChecker,
    interface: 'ISyncInRepositoryChecker',
    token: 'SYNC_IN_REPOSITORY_CHECKER'
});
const SYNC_IN_APPLICATION_CHECKER = groundTransport.token({
    class: SyncInApplicationChecker,
    interface: 'ISyncInApplicationChecker',
    token: 'SYNC_IN_APPLICATION_CHECKER'
});
const SYNC_IN_APPLICATION_VERSION_CHECKER = groundTransport.token({
    class: SyncInApplicationVersionChecker,
    interface: 'ISyncInApplicationVersionChecker',
    token: 'SYNC_IN_APPLICATION_VERSION_CHECKER'
});
const SYNC_IN_USER_CHECKER = groundTransport.token({
    class: SyncInUserChecker,
    interface: 'ISyncInUserChecker',
    token: 'SYNC_IN_USER_CHECKER'
});
const SYNC_IN_UTILS = groundTransport.token({
    class: SyncInUtils,
    interface: 'ISyncInUtils',
    token: 'SYNC_IN_UTILS'
});
const SYNCHRONIZATION_IN_MANAGER = groundTransport.token({
    class: SynchronizationInManager,
    interface: 'ISynchronizationInManager',
    token: 'SYNCHRONIZATION_IN_MANAGER'
});
const SYNCHRONIZATION_OUT_MANAGER = groundTransport.token({
    class: SynchronizationOutManager,
    interface: 'ISynchronizationOutManager',
    token: 'SYNCHRONIZATION_OUT_MANAGER'
});
const SYNC_OUT_DATA_SERIALIZER = groundTransport.token({
    class: SyncOutDataSerializer,
    interface: 'ISyncOutDataSerializer',
    token: 'SYNC_OUT_DATA_SERIALIZER'
});
const TWO_STAGE_SYNCED_IN_DATA_PROCESSOR = groundTransport.token({
    class: TwoStageSyncedInDataProcessor,
    interface: 'ITwoStageSyncedInDataProcessor',
    token: 'TWO_STAGE_SYNCED_IN_DATA_PROCESSOR'
});
const DEBUG_SYNCHRONIZATION_ADAPTER = groundTransport.token({
    class: DebugSynchronizationAdapter,
    interface: 'ISynchronizationAdapter',
    token: 'DEBUG_SYNCHRONIZATION_ADAPTER'
});
const SYNCHRONIZATION_ADAPTER_LOADER = groundTransport.token({
    class: SynchronizationAdapterLoader,
    interface: 'ISynchronizationAdapterLoader',
    token: 'SYNCHRONIZATION_ADAPTER_LOADER'
});
DEBUG_SYNCHRONIZATION_ADAPTER.setDependencies({
    nonhubClient: NONHUB_CLIENT
});
STAGE1_SYNCED_IN_DATA_PROCESSOR.setDependencies({
    actorDao: ACTOR_DAO,
    airportDatabase: AIRPORT_DATABASE,
    repositoryTransactionHistoryDao: REPOSITORY_TRANSACTION_HISTORY_DAO,
    repositoryTransactionHistoryDuo: REPOSITORY_TRANSACTION_HISTORY_DUO,
    sequenceGenerator: SEQUENCE_GENERATOR,
    syncInUtils: SYNC_IN_UTILS
});
STAGE2_SYNCED_IN_DATA_PROCESSOR.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    databaseFacade: DATABASE_FACADE,
    recordUpdateStageDao: RECORD_UPDATE_STAGE_DAO,
    utils: UTILS
});
SYNC_IN_ACTOR_CHECKER.setDependencies({
    actorDao: ACTOR_DAO,
});
SYNC_IN_APPLICATION_CHECKER.setDependencies({
    applicationDao: APPLICATION_DAO,
    domainDao: DOMAIN_DAO
});
SYNC_IN_APPLICATION_VERSION_CHECKER.setDependencies({
    applicationVersionDao: APPLICATION_VERSION_DAO
});
SYNC_IN_CHECKER.setDependencies({
    syncInActorChecker: SYNC_IN_ACTOR_CHECKER,
    syncInApplicationChecker: SYNC_IN_APPLICATION_CHECKER,
    syncInApplicationVersionChecker: SYNC_IN_APPLICATION_VERSION_CHECKER,
    syncInDataChecker: SYNC_IN_DATA_CHECKER,
    syncInRepositoryChecker: SYNC_IN_REPOSITORY_CHECKER,
    syncInTerminalChecker: SYNC_IN_TERMINAL_CHECKER,
    syncInUserChecker: SYNC_IN_USER_CHECKER
});
SYNC_IN_DATA_CHECKER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    sequenceGenerator: SEQUENCE_GENERATOR,
    terminalStore: TERMINAL_STORE
});
SYNC_IN_REPOSITORY_CHECKER.setDependencies({
    repositoryDao: REPOSITORY_DAO,
});
SYNC_IN_TERMINAL_CHECKER.setDependencies({
    terminalDao: TERMINAL_DAO
});
SYNC_IN_USER_CHECKER.setDependencies({
    userDao: USER_DAO
});
SYNC_OUT_DATA_SERIALIZER.setDependencies({
    repositoryDao: REPOSITORY_DAO,
});
SYNCHRONIZATION_ADAPTER_LOADER.setDependencies({
    debugSynchronizationAdapter: DEBUG_SYNCHRONIZATION_ADAPTER
});
SYNCHRONIZATION_IN_MANAGER.setDependencies({
    repositoryTransactionHistoryDao: REPOSITORY_TRANSACTION_HISTORY_DAO,
    syncInChecker: SYNC_IN_CHECKER,
    transactionManager: TRANSACTION_MANAGER,
    twoStageSyncedInDataProcessor: TWO_STAGE_SYNCED_IN_DATA_PROCESSOR
});
SYNCHRONIZATION_OUT_MANAGER.setDependencies({
    repositoryDao: REPOSITORY_DAO,
    repositoryTransactionHistoryDao: REPOSITORY_TRANSACTION_HISTORY_DAO,
    synchronizationAdapterLoader: SYNCHRONIZATION_ADAPTER_LOADER,
    syncOutDataSerializer: SYNC_OUT_DATA_SERIALIZER
});
TWO_STAGE_SYNCED_IN_DATA_PROCESSOR.setDependencies({
    repositoryTransactionHistoryDuo: REPOSITORY_TRANSACTION_HISTORY_DUO,
    stage1SyncedInDataProcessor: STAGE1_SYNCED_IN_DATA_PROCESSOR,
    stage2SyncedInDataProcessor: STAGE2_SYNCED_IN_DATA_PROCESSOR,
    synchronizationConflictDao: SYNCHRONIZATION_CONFLICT_DAO,
    synchronizationConflictValuesDao: SYNCHRONIZATION_CONFLICT_VALUES_DAO
});

const terminal = lib$1('terminal');
REPOSITORY_LOADER.setClass(RepositoryLoader);
TRANSACTIONAL_CONNECTOR.setClass(InternalTransactionalConnector);
TRANSACTIONAL_CONNECTOR.setDependencies({
    terminalStore: TERMINAL_STORE,
    transactionalServer: TRANSACTIONAL_SERVER
});
TRANSACTIONAL_SERVER.setClass(TransactionalServer);
TRANSACTION_MANAGER.setClass(TransactionManager);
OPERATION_CONTEXT_LOADER.setClass(OperationContextLoader);
QUERY_PARAMETER_DESERIALIZER.setClass(QueryParameterDeserializer);
QUERY_RESULTS_SERIALIZER.setClass(QueryResultsSerializer);
const ABSTRACT_MUTATION_MANAGER = terminal.token({
    class: AbstractMutationManager,
    interface: 'class AbstractMutationManager',
    token: 'ABSTRACT_MUTATION_MANAGER'
});
const ABSTRACT_TRANSACTIONAL_RECIEVER = terminal.token({
    class: TransactionalReceiver,
    interface: 'class TransactionalReceiver',
    token: 'ABSTRACT_TRANSACTIONAL_RECIEVER'
});
const CASCADE_GRAPH_VERIFIER = terminal.token({
    class: CascadeGraphVerifier,
    interface: 'ICascadeGraphVerifier',
    token: 'CASCADE_GRAPH_VERIFIER'
});
const DATABASE_MANAGER = terminal.token({
    class: DatabaseManager,
    interface: 'IDatabaseManager',
    token: 'DATABASE_MANAGER'
});
const DELETE_MANAGER = terminal.token({
    class: DeleteManager,
    interface: 'IDeleteManager',
    token: 'DELETE_MANAGER'
});
const DEPENDENCY_GRAPH_RESOLVER = terminal.token({
    class: DependencyGraphResolver,
    interface: 'IDependencyGraphResolver',
    token: 'DEPENDENCY_GRAPH_RESOLVER'
});
const ENTITY_GRAPH_RECONSTRUCTOR = terminal.token({
    class: EntityGraphReconstructor,
    interface: 'IEntityGraphReconstructor',
    token: 'ENTITY_GRAPH_RECONSTRUCTOR'
});
const HISTORY_MANAGER = terminal.token({
    class: HistoryManager,
    interface: 'IHistoryManager',
    token: 'HISTORY_MANAGER'
});
const INSERT_MANAGER = terminal.token({
    class: InsertManager,
    interface: 'IInsertManager',
    token: 'INSERT_MANAGER'
});
const INTERNAL_RECORD_MANAGER = terminal.token({
    class: InternalRecordManager,
    interface: 'IInternalRecordManager',
    token: 'INTERNAL_RECORD_MANAGER'
});
const ONLINE_MANAGER = terminal.token({
    class: OnlineManager,
    interface: 'IOnlineManager',
    token: 'ONLINE_MANAGER'
});
const OPERATION_MANAGER = terminal.token({
    class: OperationManager,
    interface: 'IOperationManager',
    token: 'OPERATION_MANAGER'
});
const QUERY_MANAGER = terminal.token({
    class: QueryManager,
    interface: 'IQueryManager',
    token: 'QUERY_MANAGER'
});
const REPOSITORY_MANAGER = terminal.token({
    class: RepositoryManager,
    interface: 'IRepositoryManager',
    token: 'REPOSITORY_MANAGER'
});
const STRUCTURAL_ENTITY_VALIDATOR = terminal.token({
    class: StructuralEntityValidator,
    interface: 'IStructuralEntityValidator',
    token: 'STRUCTURAL_ENTITY_VALIDATOR'
});
const UPDATE_MANAGER = terminal.token({
    class: UpdateManager,
    interface: 'IUpdateManager',
    token: 'UPDATE_MANAGER'
});
ABSTRACT_MUTATION_MANAGER.setDependencies({
    applicationUtils: APPLICATION_UTILS,
    fieldUtils: FIELD_UTILS,
    queryUtils: QUERY_UTILS,
    relationManager: RELATION_MANAGER
});
ABSTRACT_TRANSACTIONAL_RECIEVER.setDependencies({
    terminalStore: TERMINAL_STORE,
    transactionalServer: TRANSACTIONAL_SERVER
});
DATABASE_MANAGER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    applicationDao: APPLICATION_DAO,
    applicationInitializer: APPLICATION_INITIALIZER,
    dbApplicationUtils: DB_APPLICATION_UTILS,
    internalRecordManager: INTERNAL_RECORD_MANAGER,
    storeDriver: STORE_DRIVER,
    transactionalServer: TRANSACTIONAL_SERVER,
    transactionManager: TRANSACTION_MANAGER
});
DELETE_MANAGER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: APPLICATION_UTILS,
    historyManager: HISTORY_MANAGER,
    operationHistoryDuo: OPERATION_HISTORY_DUO,
    recordHistoryDuo: RECORD_HISTORY_DUO,
    repositoryTransactionHistoryDuo: REPOSITORY_TRANSACTION_HISTORY_DUO,
    sequenceGenerator: SEQUENCE_GENERATOR,
    utils: UTILS
});
DEPENDENCY_GRAPH_RESOLVER.setDependencies({
    entityStateManager: ENTITY_STATE_MANAGER
});
ENTITY_GRAPH_RECONSTRUCTOR.setDependencies({
    entityStateManager: ENTITY_STATE_MANAGER
});
HISTORY_MANAGER.setDependencies({
    transactionHistoryDuo: TRANSACTION_HISTORY_DUO,
});
INSERT_MANAGER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    historyManager: HISTORY_MANAGER,
    operationHistoryDuo: OPERATION_HISTORY_DUO,
    recordHistoryDuo: RECORD_HISTORY_DUO,
    repositoryTransactionHistoryDuo: REPOSITORY_TRANSACTION_HISTORY_DUO,
    sequenceGenerator: SEQUENCE_GENERATOR
});
INTERNAL_RECORD_MANAGER.setDependencies({
    actorDao: ACTOR_DAO,
    applicationDao: APPLICATION_DAO,
    domainDao: DOMAIN_DAO,
    entityStateManager: ENTITY_STATE_MANAGER,
    terminalStore: TERMINAL_STORE,
    transactionManager: TRANSACTION_MANAGER
});
ONLINE_MANAGER.setDependencies({
    repositoryDao: REPOSITORY_DAO,
    repositoryManager: REPOSITORY_MANAGER,
    repositoryTransactionHistoryDao: REPOSITORY_TRANSACTION_HISTORY_DAO,
    transactionManager: TRANSACTION_MANAGER
});
OPERATION_MANAGER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: APPLICATION_UTILS,
    cascadeGraphVerifier: CASCADE_GRAPH_VERIFIER,
    deleteManager: DELETE_MANAGER,
    dependencyGraphResolver: DEPENDENCY_GRAPH_RESOLVER,
    entityGraphReconstructor: ENTITY_GRAPH_RECONSTRUCTOR,
    entityStateManager: ENTITY_STATE_MANAGER,
    insertManager: INSERT_MANAGER,
    qMetadataUtils: Q_METADATA_UTILS,
    queryFacade: QUERY_FACADE,
    structuralEntityValidator: STRUCTURAL_ENTITY_VALIDATOR,
    updateManager: UPDATE_MANAGER,
    utils: UTILS
});
QUERY_MANAGER.setDependencies({
    repositoryLoader: REPOSITORY_LOADER,
    storeDriver: STORE_DRIVER
});
REPOSITORY_LOADER.setDependencies({
    repositoryDao: REPOSITORY_DAO,
    synchronizationAdapterLoader: SYNCHRONIZATION_ADAPTER_LOADER,
    synchronizationInManager: SYNCHRONIZATION_IN_MANAGER
});
REPOSITORY_MANAGER.setDependencies({
    repositoryDao: REPOSITORY_DAO,
});
STRUCTURAL_ENTITY_VALIDATOR.setDependencies({
    applicationUtils: APPLICATION_UTILS,
    entityStateManager: ENTITY_STATE_MANAGER,
    repositoryManager: REPOSITORY_MANAGER,
});
TRANSACTION_MANAGER.setDependencies({
    activeQueries: ACTIVE_QUERIES,
    idGenerator: ID_GENERATOR,
    synchronizationOutManager: SYNCHRONIZATION_OUT_MANAGER,
    transactionHistoryDuo: TRANSACTION_HISTORY_DUO,
});
TRANSACTIONAL_RECEIVER.setDependencies({
    databaseManager: DATABASE_MANAGER,
    internalRecordManager: INTERNAL_RECORD_MANAGER
});
TRANSACTIONAL_SERVER.setDependencies({
    deleteManager: DELETE_MANAGER,
    insertManager: INSERT_MANAGER,
    operationContextLoader: OPERATION_CONTEXT_LOADER,
    operationManager: OPERATION_MANAGER,
    queryManager: QUERY_MANAGER,
    repositoryManager: REPOSITORY_MANAGER,
    updateManager: UPDATE_MANAGER
});
UPDATE_MANAGER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: APPLICATION_UTILS,
    fieldUtils: FIELD_UTILS,
    historyManager: HISTORY_MANAGER,
    operationHistoryDuo: OPERATION_HISTORY_DUO,
    queryFacade: QUERY_FACADE,
    queryUtils: QUERY_UTILS,
    recordHistoryDuo: RECORD_HISTORY_DUO,
    relationManager: RELATION_MANAGER,
    repositoryTransactionHistoryDuo: REPOSITORY_TRANSACTION_HISTORY_DUO,
    sequenceGenerator: SEQUENCE_GENERATOR,
});

DEPENDENCY_INJECTION.isFramework = true;

var __decorate$x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApiRegistry = class ApiRegistry {
    initialize(
    // installedApi: InstalledApi
    applicationApi) {
        // this.installedApi = installedApi
        this.applicationApi = applicationApi;
    }
    async findApiObjectAndOperation(domainName, applicationName, apiObjectName, methodName) {
        const apiObjectDefinition = this.applicationApi.apiObjectMap[apiObjectName];
        if (!apiObjectDefinition) {
            throw new Error(`Could not find API object for
        Domain:
            ${domainName}
        Application:
            ${applicationName}
        Token:
            ${apiObjectName}`);
        }
        const apiOperation = apiObjectDefinition.operationMap[methodName];
        if (!apiOperation) {
            throw new Error(`Could not find API object method for 
        Domain:
            ${domainName}
        Application:
            ${applicationName}
        Token:
            ${apiObjectName}
        Method name:
            ${methodName}`);
        }
        const apiObject = await this.containerAccessor.getContainer(this)
            .getByNames(domainName, applicationName, apiObjectName);
        return {
            apiObject,
            apiOperation
        };
    }
};
__decorate$x([
    Inject()
], ApiRegistry.prototype, "containerAccessor", void 0);
ApiRegistry = __decorate$x([
    Injected()
], ApiRegistry);

var __decorate$w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApiValidator = class ApiValidator {
    validate(operation, parameters) {
        // FIXME: implement (eventually)
    }
};
ApiValidator = __decorate$w([
    Injected()
], ApiValidator);

var __decorate$v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let LocalAPIServer = class LocalAPIServer {
    async handleRequest(request) {
        let payload;
        let errorMessage;
        try {
            const { apiObject, apiOperation } = await this.apiRegistry.findApiObjectAndOperation(request.domain, request.application, request.objectName, request.methodName);
            const result = apiObject[request.methodName].apply(apiObject, request.args);
            if (apiOperation.isAsync) {
                payload = await result;
            }
            else {
                payload = result;
            }
        }
        catch (e) {
            errorMessage = e.message;
            console.error(e);
        }
        const response = {
            application: request.application,
            category: 'ToClient',
            domain: request.domain,
            errorMessage,
            id: request.id,
            methodName: request.methodName,
            objectName: request.objectName,
            protocol: request.protocol,
            payload,
        };
        return response;
    }
};
__decorate$v([
    Inject()
], LocalAPIServer.prototype, "apiRegistry", void 0);
LocalAPIServer = __decorate$v([
    Injected()
], LocalAPIServer);

var __decorate$u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// TODO: figure out if this is needed - originally written for deserializing
// Client-side operation entities.  Since then moved to Isolates and generic
// API calls.  Probably should be used in go-tower to deserialize all of the
// method argiments passed it (and won't be tied to a query of any kind, API
// interface is generic, unless already known to contain entity objects.)
let OperationDeserializer = class OperationDeserializer {
    deserialize(entity, dbEntity, entityStateManager, applicationUtils) {
        const operation = {
            lookupTable: [],
        };
        let deserializedEntity;
        if (entity instanceof Array) {
            deserializedEntity = entity.map(anEntity => this.doDeserialize(anEntity, dbEntity, operation, entityStateManager, applicationUtils));
        }
        else {
            deserializedEntity = this.doDeserialize(entity, dbEntity, operation, entityStateManager, applicationUtils);
        }
        return deserializedEntity;
    }
    doDeserialize(entity, dbEntity, operation, entityStateManager, applicationUtils) {
        let state = entityStateManager.getEntityState(entity);
        let operationUniqueId = entityStateManager.getOperationUniqueId(entity);
        if (!operationUniqueId || typeof operationUniqueId !== 'number'
            || operationUniqueId < 1 || operationUniqueId % 1 === 0) {
            throw new Error(`Invalid or missing ${entityStateManager.getUniqueIdFieldName()} field.`);
        }
        let alreadyDeserializedEntity = operation.lookupTable[operationUniqueId];
        switch (state) {
            case EntityState$1.STUB: {
                let alreadyDeserializedEntity = operation.lookupTable[operationUniqueId];
                if (!alreadyDeserializedEntity) {
                    throw new Error(`Could not find an already present entity for
					${entityStateManager.getUniqueIdFieldName()} of ${operationUniqueId}`);
                }
                return alreadyDeserializedEntity;
            }
            default:
                if (alreadyDeserializedEntity) {
                    throw new Error(`Entity appears more than once for
					${entityStateManager.getUniqueIdFieldName()} of ${operationUniqueId}`);
                }
        }
        let deserializedEntity = {};
        operation.lookupTable[operationUniqueId] = deserializedEntity;
        deserializedEntity[entityStateManager.getStateFieldName()] = state;
        for (const dbProperty of dbEntity.properties) {
            let value = entity[dbProperty.name];
            if (applicationUtils.isEmpty(value)) {
                continue;
            }
            let propertyCopy;
            if (dbProperty.relation) {
                const dbRelation = dbProperty.relation[0];
                switch (dbRelation.relationType) {
                    case EntityRelationType.ONE_TO_MANY:
                        if (!(value instanceof Array)) {
                            throw new Error(`Expecting @OneToMany for an array entity relation`);
                        }
                        propertyCopy = value.map(aProperty => this.doDeserialize(aProperty, dbRelation.entity, operation, entityStateManager, applicationUtils));
                        break;
                    case EntityRelationType.MANY_TO_ONE:
                        if (!(value instanceof Object) || value instanceof Array) {
                            throw new Error(`Expecting @ManyToOne for a non-array entity relation`);
                        }
                        propertyCopy = this.doDeserialize(value, dbRelation.entity, operation, entityStateManager, applicationUtils);
                        break;
                    default:
                        throw new Error(`Unknown relation type: ${dbRelation.relationType}`);
                }
            }
            else {
                const dbColumn = dbProperty.propertyColumns[0].column;
                switch (dbColumn.type) {
                    case SQLDataType.JSON:
                        // propertyCopy = this.cleanJsonObject(value, dbProperty, entityStateManager)
                        throw new Error('Json properties cannot be deserialized');
                    case SQLDataType.DATE:
                        if (!(value instanceof Object)
                            || value[entityStateManager.getStateFieldName()] !== EntityState$1.DATE
                            || !value.value) {
                            throw new Error(`Invalid Serialized Date format for ${dbEntity.name}.${dbProperty.name}`);
                        }
                        try {
                            propertyCopy = new Date(value);
                        }
                        catch (e) {
                            throw new Error(`Invalid Serialized Date format for ${dbEntity.name}.${dbProperty.name}`);
                        }
                        break;
                    case SQLDataType.ANY:
                    case SQLDataType.BOOLEAN:
                    case SQLDataType.NUMBER:
                    case SQLDataType.STRING:
                        propertyCopy = value;
                        break;
                    default:
                        throw new Error(`Unexpected data type for ${dbEntity.name}.${dbProperty.name}`);
                }
            }
            deserializedEntity[dbProperty.name] = propertyCopy;
        }
        return deserializedEntity;
    }
    cleanJsonObject(value, dbProperty, entityStateManager) {
        let valueCopy;
        if (value instanceof Object) {
            if (value instanceof Array) {
                valueCopy = value.map(aValue => this.cleanJsonObject(aValue, dbProperty, entityStateManager));
            }
            else {
                valueCopy = {};
                if (value[entityStateManager.getStateFieldName()] === EntityState$1.STUB) {
                    throw new Error(`Interlinked object graphs are not supported in @Json() columns 
                    ${dbProperty.entity.name}.${dbProperty.name}`);
                }
                delete value[entityStateManager.getStateFieldName()];
                delete value[entityStateManager.getUniqueIdFieldName()];
                for (const propertyName in value) {
                    const property = value[propertyName];
                    valueCopy[propertyName] = this.
                        cleanJsonObject(property, dbProperty, entityStateManager);
                }
            }
        }
        else {
            valueCopy = value;
        }
        return valueCopy;
    }
};
OperationDeserializer = __decorate$u([
    Injected()
], OperationDeserializer);

var __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let EntityCopier = class EntityCopier {
    copyEntityForProcessing(entity, dbEntity, entityStateManager, context) {
        const operation = {
            processedEntityMap: new Map(),
            sequence: context.lastOUID ? context.lastOUID : 0,
        };
        const copy = this.doCopyEntityForProcessing(entity, dbEntity, entityStateManager, operation);
        context.lastOUID = operation.sequence;
        return copy;
    }
    doCopyEntityForProcessing(entity, dbEntity, entityStateManager, operation) {
        if (entity instanceof Array) {
            return entity.map(anEntity => this.doCopyEntityForProcessing(anEntity, dbEntity, entityStateManager, operation));
        }
        else {
            let entityCopy = {};
            if (operation.processedEntityMap.has(entity)) {
                return operation.processedEntityMap.get(entity);
            }
            operation.processedEntityMap.set(entity, entityCopy);
            const operationUniqueId = ++operation.sequence;
            entityCopy[entityStateManager.getUniqueIdFieldName()] = operationUniqueId;
            entity[entityStateManager.getUniqueIdFieldName()] = operationUniqueId;
            entityStateManager.setOriginalValues(entityStateManager.getOriginalValues(entity), entityCopy);
            for (let dbProperty of dbEntity.properties) {
                const property = entity[dbProperty.name];
                if (dbProperty.relation && dbProperty.relation.length && property) {
                    entityCopy[dbProperty.name] = this.doCopyEntityForProcessing(property, dbProperty.relation[0].relationEntity, entityStateManager, operation);
                }
                else {
                    // No need to clone dates or JSON objects - they
                    // won't be modified by the save process
                    entityCopy[dbProperty.name] = property;
                }
            }
            entityCopy[entityStateManager.getStateFieldName()]
                = entity[entityStateManager.getStateFieldName()];
            return entityCopy;
        }
    }
};
EntityCopier = __decorate$t([
    Injected()
], EntityCopier);

var __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let UpdateCacheManager = class UpdateCacheManager {
    saveOriginalValues(entity, dbEntity) {
        if (entity instanceof Array) {
            for (let i = 0; i < entity.length; i++) {
                this.saveOriginalValues(entity[i], dbEntity);
            }
            return;
        }
        if (!entity) {
            return;
        }
        const originalValuesObject = {};
        this.entityStateManager.setOriginalValues(originalValuesObject, entity);
        for (let dbProperty of dbEntity.properties) {
            const property = entity[dbProperty.name];
            if (dbProperty.relation && dbProperty.relation.length) {
                if (!property) {
                    continue;
                }
                if (dbProperty.relation[0].relationType === EntityRelationType.MANY_TO_ONE) {
                    // Save the nested child object Ids in the original values of this object
                    // in case the object behind this relation is changed
                    this.applicationUtils.forEachColumnTypeOfRelation(dbProperty.relation[0], (_dbColumn, propertyNameChains) => {
                        for (let propertyNameChain of propertyNameChains) {
                            let nestedProperty = entity;
                            let currentPropertyOriginalValue = originalValuesObject;
                            for (let i = 0; i < propertyNameChain.length; i++) {
                                const propertyName = propertyNameChain[i];
                                if (nestedProperty instanceof Object) {
                                    nestedProperty = nestedProperty[propertyName];
                                    let originalValue;
                                    // Nested object continues
                                    if (i === propertyNameChain.length - 1) {
                                        originalValue = nestedProperty;
                                    }
                                    else {
                                        originalValue = {};
                                    }
                                    currentPropertyOriginalValue[propertyName] = originalValue;
                                    currentPropertyOriginalValue = currentPropertyOriginalValue[propertyName];
                                }
                                else {
                                    // This is the actual value
                                    currentPropertyOriginalValue[propertyName] = nestedProperty;
                                }
                            }
                        }
                    });
                }
                this.saveOriginalValues(property, dbProperty.relation[0].relationEntity);
            }
            else {
                originalValuesObject[dbProperty.name] = entity[dbProperty.name];
            }
        }
    }
    setOperationState(entityCopy, dbEntity, processedEntities) {
        if (entityCopy instanceof Array) {
            for (var i = 0; i < entityCopy.length; i++) {
                this.setOperationState(entityCopy[i], dbEntity, processedEntities);
            }
            return;
        }
        if (processedEntities.has(entityCopy)) {
            return;
        }
        processedEntities.add(entityCopy);
        const originalValuesObject = this.entityStateManager
            .getOriginalValues(entityCopy);
        let entityState = entityCopy[this.entityStateManager.getStateFieldName()];
        let hasId = true;
        let hasGeneratedIds = false;
        for (const dbProperty of dbEntity.properties) {
            if (!dbProperty.isId) {
                continue;
            }
            for (const propertyColumn of dbProperty.propertyColumns) {
                if (propertyColumn.column.isGenerated) {
                    hasGeneratedIds = true;
                }
            }
            if (dbProperty.relation && dbProperty.relation.length) {
                this.applicationUtils.forEachColumnTypeOfRelation(dbProperty.relation[0], (_dbColumn, propertyNameChains) => {
                    for (let propertyNameChain of propertyNameChains) {
                        let nestedProperty = entityCopy;
                        for (let i = 0; i < propertyNameChain.length; i++) {
                            const propertyName = propertyNameChain[i];
                            if (nestedProperty) {
                                nestedProperty = nestedProperty[propertyName];
                            }
                        }
                        if (!nestedProperty) {
                            if (entityState === EntityState$1.DELETE) {
                                throw new Error(`Entity is marked for deletion but does not have an @Id() property:
            ${propertyNameChain.join('.')}
                                    `);
                            }
                            else {
                                entityState = EntityState$1.CREATE;
                                hasId = false;
                                return true;
                            }
                        }
                    }
                });
            }
            else if (!entityCopy[dbProperty.name] && entityCopy[dbProperty.name] !== 0) {
                hasId = false;
            }
        }
        if (originalValuesObject) {
            for (const dbProperty of dbEntity.properties) {
                const property = entityCopy[dbProperty.name];
                if (dbProperty.relation && dbProperty.relation.length) {
                    if (!property) {
                        continue;
                    }
                    const dbRelation = dbProperty.relation[0];
                    this.entityStateManager
                        .getOriginalValues(property);
                    this.applicationUtils.forEachColumnTypeOfRelation(dbRelation, (_dbColumn, propertyNameChains) => {
                        const propertyOriginalValuesObject = this.entityStateManager
                            .getOriginalValues(property);
                        // const firstPropertyNameChain = propertyNameChains[0];
                        for (const propertyNameChain of propertyNameChains) {
                            let value = entityCopy;
                            let originalValue = propertyOriginalValuesObject;
                            for (let i = 0; i < propertyNameChain.length; i++) {
                                const propertyName = propertyNameChain[i];
                                value = value[propertyName];
                                // Skip the property itself since the original values object
                                // belongs to the property and not the checked object
                                // (in the case of relations only)
                                if (i !== 0) {
                                    originalValue = originalValue[propertyName];
                                }
                                let noValue = value === null || value === undefined;
                                let noOriginalValue = originalValue === null
                                    || originalValue === undefined;
                                if (noValue) {
                                    if (originalValue) {
                                        entityState = EntityState$1.UPDATE;
                                        return true;
                                    }
                                    break;
                                }
                                if (noOriginalValue) {
                                    if (value) {
                                        entityState = EntityState$1.UPDATE;
                                        return true;
                                    }
                                    break;
                                }
                                // If it's a nested object
                                if (typeof value === 'object') {
                                    // If original isn't a nested object
                                    if (typeof originalValue !== 'object') {
                                        entityState = EntityState$1.UPDATE;
                                        return true;
                                    }
                                    // Values should not be dates or json objects, only
                                    // nested object references to eventual Ids
                                }
                                else if (typeof originalValue === 'object') {
                                    // value is not a nested object but originalValue is
                                    entityState = EntityState$1.UPDATE;
                                    return true;
                                }
                                else {
                                    // Both values are primitives (nested ids)
                                    if (value !== originalValue) {
                                        entityState = EntityState$1.UPDATE;
                                        return true;
                                    }
                                }
                            }
                        }
                    });
                }
                else {
                    if (entityState) {
                        continue;
                    }
                    let originalValue = originalValuesObject[dbProperty.name];
                    let propertyValue;
                    switch (dbProperty.propertyColumns[0].column.type) {
                        case SQLDataType.DATE:
                            if (originalValue) {
                                originalValue = originalValue.getTime();
                            }
                            if (property) {
                                propertyValue = property.getTime();
                            }
                            break;
                        case SQLDataType.JSON:
                            if (originalValue) {
                                originalValue = JSON.stringify(originalValue);
                            }
                            if (property) {
                                propertyValue = JSON.stringify(property);
                            }
                            break;
                        default:
                            propertyValue = property;
                            break;
                    }
                    if (propertyValue !== originalValue) {
                        entityState = EntityState$1.UPDATE;
                    }
                }
            }
        }
        for (const dbProperty of dbEntity.properties) {
            const property = entityCopy[dbProperty.name];
            if (property && dbProperty.relation && dbProperty.relation.length) {
                this.setOperationState(property, dbProperty.relation[0].relationEntity, processedEntities);
            }
        }
        if (!entityState) {
            if ((hasId && hasGeneratedIds) || originalValuesObject) {
                entityState = EntityState$1.PASS_THROUGH;
            }
            else {
                entityState = EntityState$1.CREATE;
            }
        }
        entityCopy[this.entityStateManager.getStateFieldName()] = entityState;
    }
    afterSaveModifications(entity, dbEntity, saveResult, processedEntities) {
        this.updateOriginalValuesAfterSave(entity, dbEntity, saveResult, new Set());
        this.removeDeletedEntities(entity, dbEntity, saveResult, processedEntities);
    }
    updateOriginalValuesAfterSave(entity, dbEntity, saveResult, processedEntities) {
        if (entity instanceof Array) {
            for (let i = 0; i < entity.length; i++) {
                this.updateOriginalValuesAfterSave(entity[i], dbEntity, saveResult, processedEntities);
            }
        }
        else {
            if (processedEntities.has(entity)) {
                return;
            }
            processedEntities.add(entity);
            let operationUniqueId = this.entityStateManager.getOperationUniqueId(entity, false, dbEntity);
            let originalValuesObject = {};
            if (operationUniqueId) {
                originalValuesObject = this.doUpdateOriginalValuesAfterSave(entity, dbEntity, saveResult, processedEntities, operationUniqueId);
            }
            this.entityStateManager.setOriginalValues(originalValuesObject, entity);
        }
    }
    doUpdateOriginalValuesAfterSave(entity, dbEntity, saveResult, processedEntities, operationUniqueId) {
        let createdRecord = saveResult.created[operationUniqueId];
        if (createdRecord) {
            if (createdRecord !== true) {
                for (const generatedPropertyName in createdRecord) {
                    entity[generatedPropertyName] = createdRecord[generatedPropertyName];
                }
                if (dbEntity.isRepositoryEntity) {
                    let repositoryEntity = entity;
                    if (!repositoryEntity.repository || !repositoryEntity.repository.id) {
                        repositoryEntity.repository = saveResult.newRepository;
                    }
                    repositoryEntity.actor = saveResult.actor;
                }
            }
        }
        else if (saveResult.deleted[operationUniqueId]) {
            this.entityStateManager.setIsDeleted(true, entity);
            this.entityStateManager.setOriginalValues(null, entity);
            return;
        }
        let originalValuesObject = {};
        for (const dbProperty of dbEntity.properties) {
            const property = entity[dbProperty.name];
            if (property && dbProperty.relation && dbProperty.relation.length) {
                if (dbProperty.relation[0].relationType === EntityRelationType.MANY_TO_ONE) {
                    // Save the nested child object Ids in the original values of this object
                    // in case the object behind this relation is changed
                    this.applicationUtils.forEachColumnTypeOfRelation(dbProperty.relation[0], (_dbColumn, propertyNameChains) => {
                        for (let propertyNameChain of propertyNameChains) {
                            let nestedProperty = entity;
                            let currentPropertyOriginalValue = originalValuesObject;
                            for (let i = 0; i < propertyNameChain.length; i++) {
                                const propertyName = propertyNameChain[i];
                                if (nestedProperty instanceof Object) {
                                    nestedProperty = nestedProperty[propertyName];
                                    let originalValue;
                                    // Nested object continues
                                    if (i === propertyNameChain.length - 1) {
                                        originalValue = nestedProperty;
                                    }
                                    else {
                                        originalValue = {};
                                    }
                                    currentPropertyOriginalValue[propertyName] = originalValue;
                                    currentPropertyOriginalValue = currentPropertyOriginalValue[propertyName];
                                }
                                else {
                                    // This is the actual value
                                    currentPropertyOriginalValue[propertyName] = nestedProperty;
                                }
                            }
                        }
                    });
                }
                this.updateOriginalValuesAfterSave(property, dbProperty.relation[0].relationEntity, saveResult, processedEntities);
            }
            else {
                originalValuesObject[dbProperty.name] = property;
            }
        }
        return originalValuesObject;
    }
    removeDeletedEntities(entity, dbEntity, saveResult, processedEntities) {
        if (entity instanceof Array) {
            for (let i = entity.length - 1; i >= 0; i--) {
                if (this.removeDeletedEntities(entity[i], dbEntity, saveResult, processedEntities)) {
                    entity.splice(i, 1);
                }
            }
            return !entity.length;
        }
        else {
            if (processedEntities.has(entity)) {
                return this.entityStateManager.isDeleted(entity);
            }
            processedEntities.add(entity);
            for (const dbRelation of dbEntity.relations) {
                const dbRelationProperty = dbRelation.property;
                const property = entity[dbRelationProperty.name];
                if (!property) {
                    continue;
                }
                switch (dbRelation.relationType) {
                    case EntityRelationType.MANY_TO_ONE:
                        if (this.removeDeletedEntities(property, dbRelation.relationEntity, saveResult, processedEntities)) {
                            entity[dbRelationProperty.name] = null;
                        }
                        break;
                    case EntityRelationType.ONE_TO_MANY:
                        this.removeDeletedEntities(property, dbRelation.relationEntity, saveResult, processedEntities);
                        break;
                }
            }
            return this.entityStateManager.isDeleted(entity);
        }
    }
};
__decorate$s([
    Inject()
], UpdateCacheManager.prototype, "entityStateManager", void 0);
__decorate$s([
    Inject()
], UpdateCacheManager.prototype, "applicationUtils", void 0);
UpdateCacheManager = __decorate$s([
    Injected()
], UpdateCacheManager);

var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EntityStateManager_1;
let EntityStateManager = EntityStateManager_1 = class EntityStateManager {
    isStub(entity) {
        return this.getEntityState(entity) === EntityState$1.STUB;
    }
    isParentId(entity) {
        return this.getEntityState(entity) === EntityState$1.PARENT_ID;
    }
    markForDeletion(entity) {
        entity[EntityStateManager_1.STATE_FIELD] = EntityState$1.DELETE;
    }
    markToCreate(entity) {
        entity[EntityStateManager_1.STATE_FIELD] = EntityState$1.CREATE;
    }
    markToUpdate(entity) {
        entity[EntityStateManager_1.STATE_FIELD] = EntityState$1.UPDATE;
    }
    getEntityState(entity) {
        return entity[EntityStateManager_1.STATE_FIELD];
    }
    getOriginalValues(entity) {
        return entity[EntityStateManager_1.ORIGINAL_VALUES_PROPERTY];
    }
    setOriginalValues(originalValues, entity) {
        entity[EntityStateManager_1.ORIGINAL_VALUES_PROPERTY] = originalValues;
    }
    copyEntityState(fromEntity, toEntity) {
        toEntity[EntityStateManager_1.STATE_FIELD]
            = fromEntity[EntityStateManager_1.STATE_FIELD];
        toEntity[EntityStateManager_1.ORIGINAL_VALUES_PROPERTY]
            = fromEntity[EntityStateManager_1.ORIGINAL_VALUES_PROPERTY];
    }
    getStateFieldName() {
        return EntityStateManager_1.STATE_FIELD;
    }
    getEntityStateTypeAsFlags(entity, dbEntity) {
        let isCreate, isDelete, isParentId, isPassThrough, isResultDate, isStub, isUpdate;
        const entityState = this.getEntityState(entity);
        switch (entityState) {
            case EntityState$1.CREATE:
                isCreate = true;
                break;
            case EntityState$1.DELETE:
                isDelete = true;
                break;
            case EntityState$1.PARENT_ID:
                isParentId = true;
                break;
            case EntityState$1.PASS_THROUGH:
                isPassThrough = true;
                break;
            // case EntityState.RESULT:
            // 	isResult = true
            // 	break
            case EntityState$1.DATE:
                isResultDate = true;
                break;
            // case EntityState.RESULT_JSON:
            // 	isResultJson = true
            // 	break
            case EntityState$1.STUB:
                isStub = true;
                break;
            case EntityState$1.UPDATE:
                isUpdate = true;
                break;
            default:
                throw new Error(`Unexpected entity state
"${this.getStateFieldName()}" for ${dbEntity.name}: ${entityState}`);
        }
        return {
            isCreate,
            isDelete,
            isParentId,
            isPassThrough,
            // isResult,
            isResultDate,
            isStub,
            isUpdate,
        };
    }
    setIsDeleted(isDeleted, entity) {
        entity[EntityStateManager_1.STATE_FIELD] = EntityState$1.DELETE;
    }
    isDeleted(entity) {
        return entity[EntityStateManager_1.STATE_FIELD] === EntityState$1.DELETE;
    }
    getOperationUniqueId(entity, throwIfNotFound = true, dbEntity = null) {
        const operationUniqueId = entity[EntityStateManager_1.OPERATION_UNIQUE_ID_FIELD];
        if (!operationUniqueId || typeof operationUniqueId !== 'number' || operationUniqueId < 1) {
            if (throwIfNotFound) {
                let entityDescription;
                if (dbEntity) {
                    entityDescription = dbEntity.applicationVersion.application.name + '.' + dbEntity.name;
                }
                else {
                    entityDescription = JSON.stringify(entity);
                }
                throw new Error(`Could not find "${EntityStateManager_1.OPERATION_UNIQUE_ID_FIELD}" property on DTO:
        
        ${entityDescription}`);
            }
        }
        return operationUniqueId;
    }
    copyOperationUniqueId(entity, entityCopy) {
        const operationUniqueId = entity[EntityStateManager_1.OPERATION_UNIQUE_ID_FIELD];
        entityCopy[EntityStateManager_1.OPERATION_UNIQUE_ID_FIELD] = operationUniqueId;
    }
    markAsStub(entity) {
        entity[EntityStateManager_1.STATE_FIELD] = EntityState$1.STUB;
    }
    getUniqueIdFieldName() {
        return EntityStateManager_1.OPERATION_UNIQUE_ID_FIELD;
    }
};
EntityStateManager.DELETED_PROPERTY = '__deleted__';
EntityStateManager.ORIGINAL_VALUES_PROPERTY = '__originalValues__';
EntityStateManager.STATE_FIELD = '__state__';
EntityStateManager.OPERATION_UNIQUE_ID_FIELD = '__OUID__';
EntityStateManager = EntityStateManager_1 = __decorate$r([
    Injected()
], EntityStateManager);
function injectEntityStateManager() {
    console.log('inject EntityStateManager');
}

var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 5/23/2016.
 */
let DatabaseFacade = class DatabaseFacade {
    async addRepository(
    // url: string = null,
    // platform: PlatformType = PlatformType.GOOGLE_DOCS,
    // platformConfig: string = null,
    // distributionStrategy: DistributionStrategy = DistributionStrategy.S3_DISTIBUTED_PUSH,
    context) {
        // TODO: figure out how addRepository will work
        return await this.transactionalConnector.addRepository(
        // url, platform, platformConfig, distributionStrategy, 
        context);
    }
    async insertColumnValues(rawInsertColumnValues, context) {
        if (!rawInsertColumnValues) {
            return 0;
        }
        if (rawInsertColumnValues instanceof Function) {
            rawInsertColumnValues = rawInsertColumnValues();
        }
        const insertColumnValues = new InsertColumnValues(rawInsertColumnValues);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(insertColumnValues, null, queryContext);
        return await this.transactionalConnector.insertValues(portableQuery, context);
    }
    async insertValues(rawInsertValues, context) {
        if (!rawInsertValues) {
            return 0;
        }
        if (rawInsertValues instanceof Function) {
            rawInsertValues = rawInsertValues();
        }
        const insertValues = new InsertValues(rawInsertValues);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(insertValues, null, queryContext);
        return await this.transactionalConnector.insertValues(portableQuery, context);
    }
    async insertColumnValuesGenerateIds(rawInsertColumnValues, context) {
        if (!rawInsertColumnValues) {
            return [];
        }
        if (rawInsertColumnValues instanceof Function) {
            rawInsertColumnValues = rawInsertColumnValues();
        }
        const insertValues = new InsertColumnValues(rawInsertColumnValues);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(insertValues, null, queryContext);
        return await this.transactionalConnector.insertValuesGetIds(portableQuery, context);
    }
    async insertValuesGenerateIds(rawInsertValues, context) {
        if (!rawInsertValues) {
            return [];
        }
        if (rawInsertValues instanceof Function) {
            rawInsertValues = rawInsertValues();
        }
        const insertValues = new InsertValues(rawInsertValues);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(insertValues, null, queryContext);
        return await this.transactionalConnector.insertValuesGetIds(portableQuery, context);
    }
    async deleteWhere(rawDelete, context) {
        if (!rawDelete) {
            return 0;
        }
        if (rawDelete instanceof Function) {
            rawDelete = rawDelete();
        }
        let deleteWhere = new Delete(rawDelete);
        const queryContext = await this.ensureQueryContext(context);
        let portableQuery = this.queryFacade.getPortableQuery(deleteWhere, null, queryContext);
        return await this.transactionalConnector.deleteWhere(portableQuery, context);
    }
    async save(entity, context) {
        if (!entity) {
            return null;
        }
        const entityCopy = await this.preSaveOperations(entity, context);
        const saveResult = await this.transactionalConnector.save(entityCopy, context);
        this.updateCacheManager.afterSaveModifications(entity, context.dbEntity, saveResult, new Set());
        return saveResult;
    }
    async saveToDestination(repositoryDestination, entity, context) {
        if (!entity) {
            return null;
        }
        const entityCopy = await this.preSaveOperations(entity, context);
        const saveResult = await this.transactionalConnector
            .saveToDestination(repositoryDestination, entityCopy, context);
        this.updateCacheManager.afterSaveModifications(entity, context.dbEntity, saveResult, new Set());
        return saveResult;
    }
    async preSaveOperations(entity, context) {
        if (!entity) {
            return null;
        }
        const dbEntity = context.dbEntity;
        const entityCopy = this.entityCopier
            .copyEntityForProcessing(entity, dbEntity, this.entityStateManager, context);
        this.updateCacheManager.setOperationState(entityCopy, dbEntity, new Set());
        return entityCopy;
    }
    /**
     * Updates an entity with a where clause, using a column based set clause
     * - internal API.  Use the API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records updated
     */
    async updateColumnsWhere(rawUpdate, context) {
        if (!rawUpdate) {
            return 0;
        }
        if (rawUpdate instanceof Function) {
            rawUpdate = rawUpdate();
        }
        let updateColumns = new UpdateColumns(rawUpdate);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(updateColumns, null, queryContext);
        return await this.transactionalConnector.updateValues(portableQuery, context);
    }
    async updateWhere(rawUpdate, context) {
        if (!rawUpdate) {
            return 0;
        }
        if (rawUpdate instanceof Function) {
            rawUpdate = rawUpdate();
        }
        let update = new UpdateProperties(rawUpdate);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(update, null, queryContext);
        return await this.transactionalConnector.updateValues(portableQuery, context);
    }
    prepare(queryFunction) {
        return new FunctionWrapper(queryFunction);
    }
    async ensureQueryContext(context) {
        const queryContext = context;
        return queryContext;
    }
};
__decorate$q([
    Inject()
], DatabaseFacade.prototype, "entityCopier", void 0);
__decorate$q([
    Inject()
], DatabaseFacade.prototype, "entityStateManager", void 0);
__decorate$q([
    Inject()
], DatabaseFacade.prototype, "queryFacade", void 0);
__decorate$q([
    Inject()
], DatabaseFacade.prototype, "transactionalConnector", void 0);
__decorate$q([
    Inject()
], DatabaseFacade.prototype, "updateCacheManager", void 0);
DatabaseFacade = __decorate$q([
    Injected()
], DatabaseFacade);
class FunctionWrapper {
    constructor(queryFunction) {
        throw new Error('Not Implemented');
    }
    find(...params) {
    }
}

var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let QueryFacade = class QueryFacade {
    async find(query, queryResultType, context) {
        await this.ensureContext(context);
        const result = await this.transactionalConnector.find(this.getPortableQuery(query, queryResultType, context), context);
        return result;
    }
    async findOne(query, queryResultType, context) {
        await this.ensureContext(context);
        const result = await this.transactionalConnector.findOne(this.getPortableQuery(query, queryResultType, context), context);
        return result;
    }
    getPortableQuery(query, queryResultType, context) {
        return {
            jsonQuery: query.toJSON(this.queryUtils, this.fieldUtils, this.relationManager),
            parameterMap: query.getParameters(),
            queryResultType,
            applicationIndex: context.dbEntity.applicationVersion.application.index,
            tableIndex: context.dbEntity.index,
            // values: query.values
        };
    }
    // FIXME: merge update caches on the client
    async search(query, queryResultType, context) {
        await this.ensureContext(context);
        let observable = await this.transactionalConnector.search(this.getPortableQuery(query, queryResultType, context), context);
        return observable;
    }
    async searchOne(query, queryResultType, context) {
        await this.ensureContext(context);
        let observable = await this.transactionalConnector.searchOne(this.getPortableQuery(query, queryResultType, context), context);
        return observable;
    }
    async ensureContext(context) {
    }
};
__decorate$p([
    Inject()
], QueryFacade.prototype, "fieldUtils", void 0);
__decorate$p([
    Inject()
], QueryFacade.prototype, "queryUtils", void 0);
__decorate$p([
    Inject()
], QueryFacade.prototype, "relationManager", void 0);
__decorate$p([
    Inject()
], QueryFacade.prototype, "transactionalConnector", void 0);
QueryFacade = __decorate$p([
    Injected()
], QueryFacade);

var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class EntityAccumulator {
    constructor(applicationDomain, applicationName, entityMap) {
        this.applicationDomain = applicationDomain;
        this.applicationName = applicationName;
        this.entityMap = entityMap;
    }
    add(clazz, index) {
        this.entityMap.set(clazz, {
            entity: {
                index,
                name: clazz.name,
            },
            application: {
                domain: this.applicationDomain,
                name: this.applicationName,
            },
        });
    }
}
let AirportDatabase = class AirportDatabase {
    get entityMap() {
        return this.databaseStore.entityMap;
    }
    ;
    get F() {
        return this.databaseStore.functions;
    }
    get functions() {
        return this.databaseStore.functions;
    }
    get A() {
        return this.databaseStore.applications;
    }
    get applications() {
        return this.databaseStore.applications;
    }
    get qApplications() {
        return this.databaseStore.qApplications;
    }
    get Q() {
        return this.databaseStore.qApplications;
    }
    get QM() {
        return this.databaseStore.QM;
    }
    async load() {
        // Just calling this method, loads the AirpotDatabase object
    }
    setQApplication(qApplication) {
        const fullApplicationName = this.dbApplicationUtils
            .getFullApplicationName(qApplication);
        const existingQApplication = this.QM[fullApplicationName];
        if (existingQApplication) {
            const dbApplication = existingQApplication.__dbApplication__;
            qApplication.__dbApplication__ = dbApplication;
            setQApplicationEntities(dbApplication, qApplication, this.qApplications, this.appliationUtils, this.relationManager);
            this.Q[dbApplication.index] = qApplication;
        }
        this.QM[fullApplicationName] = qApplication;
    }
    getAccumulator(applicationDomain, applicationName) {
        return new EntityAccumulator(applicationDomain, applicationName, this.entityMap);
    }
    async addRepository(
    // url: string,
    // platform: PlatformType,
    // platformConfig: string,
    // distributionStrategy: DistributionStrategy,
    context) {
        return await this.databaseFacade.addRepository(
        // url, platform, platformConfig, distributionStrategy, 
        context);
    }
    async insertColumnValues(rawInsertValues, context) {
        return await this.databaseFacade.insertColumnValues(rawInsertValues, context);
    }
    async insertValues(rawInsertValues, context) {
        return await this.databaseFacade.insertValues(rawInsertValues, context);
    }
    async insertColumnValuesGenerateIds(rawInsertValues, context) {
        return await this.databaseFacade.insertColumnValuesGenerateIds(rawInsertValues, context);
    }
    async insertValuesGenerateIds(rawInsertValues, context) {
        return await this.databaseFacade.insertValuesGenerateIds(rawInsertValues, context);
    }
    /**
     * Creates an entity with a where clause - internal API.  Use the
     *  API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records deleted
     */
    async deleteWhere(rawDelete, context) {
        return await this.databaseFacade.deleteWhere(rawDelete, context);
    }
    /**
     * Ether creates or updates an entity - internal API.  Use the
     *  API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records saved (1 or 0)
     */
    async save(entity, context, operationName) {
        return await this.databaseFacade.save(entity, context);
    }
    /**
     * Updates an entity with a where clause, using a column based set clause
     * - internal API.  Use the API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records updated
     */
    async updateColumnsWhere(rawUpdateColumns, context) {
        return await this.databaseFacade.updateColumnsWhere(rawUpdateColumns, context);
    }
    /**
     * Updates an entity with a where clause, using a property based set clause
     * - internal API.  Use the API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records updated
     */
    async updateWhere(rawUpdate, context) {
        return await this.databaseFacade.updateWhere(rawUpdate, context);
    }
};
__decorate$o([
    Inject()
], AirportDatabase.prototype, "appliationUtils", void 0);
__decorate$o([
    Inject()
], AirportDatabase.prototype, "databaseFacade", void 0);
__decorate$o([
    Inject()
], AirportDatabase.prototype, "databaseStore", void 0);
__decorate$o([
    Inject()
], AirportDatabase.prototype, "dbApplicationUtils", void 0);
__decorate$o([
    Inject()
], AirportDatabase.prototype, "find", void 0);
__decorate$o([
    Inject()
], AirportDatabase.prototype, "findOne", void 0);
__decorate$o([
    Inject()
], AirportDatabase.prototype, "relationManager", void 0);
__decorate$o([
    Inject()
], AirportDatabase.prototype, "search", void 0);
__decorate$o([
    Inject()
], AirportDatabase.prototype, "searchOne", void 0);
AirportDatabase = __decorate$o([
    Injected()
], AirportDatabase);
function injectAirportDatabase() {
    console.log('Injecting AirportDatabase');
}

const tower = lib$1('tower');
const ENTITY_COPIER = tower.token({
    class: EntityCopier,
    interface: 'IEntityCopier',
    token: 'ENTITY_COPIER'
});
AIRPORT_DATABASE.setClass(AirportDatabase);
ENTITY_STATE_MANAGER.setClass(EntityStateManager);
API_REGISTRY.setClass(ApiRegistry);
API_VALIDATOR.setClass(ApiValidator);
LOCAL_API_SERVER.setClass(LocalAPIServer);
OPERATION_DESERIALIZER.setClass(OperationDeserializer);
UPDATE_CACHE_MANAGER.setClass(UpdateCacheManager);
DATABASE_FACADE.setClass(DatabaseFacade);
DATABASE_FACADE.setDependencies({
    entityCopier: ENTITY_COPIER,
    queryFacade: QUERY_FACADE
});
QUERY_FACADE.setClass(QueryFacade);

var util = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNode = exports.PROMISE_RESOLVED_VOID = exports.PROMISE_RESOLVED_TRUE = exports.PROMISE_RESOLVED_FALSE = void 0;
exports.isPromise = isPromise;
exports.microSeconds = microSeconds;
exports.randomInt = randomInt;
exports.randomToken = randomToken;
exports.sleep = sleep;

/**
 * returns true if the given object is a promise
 */
function isPromise(obj) {
  if (obj && typeof obj.then === 'function') {
    return true;
  } else {
    return false;
  }
}

var PROMISE_RESOLVED_FALSE = Promise.resolve(false);
exports.PROMISE_RESOLVED_FALSE = PROMISE_RESOLVED_FALSE;
var PROMISE_RESOLVED_TRUE = Promise.resolve(true);
exports.PROMISE_RESOLVED_TRUE = PROMISE_RESOLVED_TRUE;
var PROMISE_RESOLVED_VOID = Promise.resolve();
exports.PROMISE_RESOLVED_VOID = PROMISE_RESOLVED_VOID;

function sleep(time, resolveWith) {
  if (!time) time = 0;
  return new Promise(function (res) {
    return setTimeout(function () {
      return res(resolveWith);
    }, time);
  });
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * https://stackoverflow.com/a/8084248
 */


function randomToken() {
  return Math.random().toString(36).substring(2);
}

var lastMs = 0;
var additional = 0;
/**
 * returns the current time in micro-seconds,
 * WARNING: This is a pseudo-function
 * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.
 * This is enough in browsers, and this function will not be used in nodejs.
 * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.
 */

function microSeconds() {
  var ms = new Date().getTime();

  if (ms === lastMs) {
    additional++;
    return ms * 1000 + additional;
  } else {
    lastMs = ms;
    additional = 0;
    return ms * 1000;
  }
}
/**
 * copied from the 'detect-node' npm module
 * We cannot use the module directly because it causes problems with rollup
 * @link https://github.com/iliakan/detect-node/blob/master/index.js
 */


var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';
exports.isNode = isNode;
});

var interopRequireDefault = createCommonjsModule(function (module) {
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

createCommonjsModule(function (module) {
function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}

module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

var _util = util;

var native = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.averageResponseTime = averageResponseTime;
exports.canBeUsed = canBeUsed;
exports.close = close;
exports.create = create;
exports.microSeconds = exports["default"] = void 0;
exports.onMessage = onMessage;
exports.postMessage = postMessage;
exports.type = void 0;



var microSeconds = _util.microSeconds;
exports.microSeconds = microSeconds;
var type = 'native';
exports.type = type;

function create(channelName) {
  var state = {
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: [] // subscriberFunctions

  };

  state.bc.onmessage = function (msg) {
    if (state.messagesCallback) {
      state.messagesCallback(msg.data);
    }
  };

  return state;
}

function close(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}

function postMessage(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return _util.PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}

function onMessage(channelState, fn) {
  channelState.messagesCallback = fn;
}

function canBeUsed() {
  /**
   * in the electron-renderer, isNode will be true even if we are in browser-context
   * so we also check if window is undefined
   */
  if (_util.isNode && typeof window === 'undefined') return false;

  if (typeof BroadcastChannel === 'function') {
    if (BroadcastChannel._pubkey) {
      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');
    }

    return true;
  } else return false;
}

function averageResponseTime() {
  return 150;
}

var _default = {
  create: create,
  close: close,
  onMessage: onMessage,
  postMessage: postMessage,
  canBeUsed: canBeUsed,
  type: type,
  averageResponseTime: averageResponseTime,
  microSeconds: microSeconds
};
exports["default"] = _default;
});

/**
 * this is a set which automatically forgets
 * a given entry when a new entry is set and the ttl
 * of the old one is over
 */
var ObliviousSet = /** @class */ (function () {
    function ObliviousSet(ttl) {
        this.ttl = ttl;
        this.set = new Set();
        this.timeMap = new Map();
    }
    ObliviousSet.prototype.has = function (value) {
        return this.set.has(value);
    };
    ObliviousSet.prototype.add = function (value) {
        var _this = this;
        this.timeMap.set(value, now());
        this.set.add(value);
        /**
         * When a new value is added,
         * start the cleanup at the next tick
         * to not block the cpu for more important stuff
         * that might happen.
         */
        setTimeout(function () {
            removeTooOldValues(_this);
        }, 0);
    };
    ObliviousSet.prototype.clear = function () {
        this.set.clear();
        this.timeMap.clear();
    };
    return ObliviousSet;
}());
/**
 * Removes all entries from the set
 * where the TTL has expired
 */
function removeTooOldValues(obliviousSet) {
    var olderThen = now() - obliviousSet.ttl;
    var iterator = obliviousSet.set[Symbol.iterator]();
    /**
     * Because we can assume the new values are added at the bottom,
     * we start from the top and stop as soon as we reach a non-too-old value.
     */
    while (true) {
        var value = iterator.next().value;
        if (!value) {
            return; // no more elements
        }
        var time = obliviousSet.timeMap.get(value);
        if (time < olderThen) {
            obliviousSet.timeMap.delete(value);
            obliviousSet.set.delete(value);
        }
        else {
            // We reached a value that is not old enough
            return;
        }
    }
}
function now() {
    return new Date().getTime();
}

var es$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ObliviousSet: ObliviousSet,
    removeTooOldValues: removeTooOldValues,
    now: now
});

var fillOptionsWithDefaults_1 = fillOptionsWithDefaults$1;

function fillOptionsWithDefaults$1() {
  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = JSON.parse(JSON.stringify(originalOptions)); // main

  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db

  if (!options.idb) options.idb = {}; //  after this time the messages get deleted

  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;
  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; //  handles abrupt db onclose events.

  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose; // localstorage

  if (!options.localstorage) options.localstorage = {};
  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // custom methods

  if (originalOptions.methods) options.methods = originalOptions.methods; // node

  if (!options.node) options.node = {};
  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;

  /**
   * On linux use 'ulimit -Hn' to get the limit of open files.
   * On ubuntu this was 4096 for me, so we use half of that as maxParallelWrites default.
   */

  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;
  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;
  return options;
}

var options = /*#__PURE__*/Object.defineProperty({
	fillOptionsWithDefaults: fillOptionsWithDefaults_1
}, '__esModule', {value: true});

var _obliviousSet = /*@__PURE__*/getAugmentedNamespace(es$1);

var _options = options;

var indexedDb = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.averageResponseTime = averageResponseTime;
exports.canBeUsed = canBeUsed;
exports.cleanOldMessages = cleanOldMessages;
exports.close = close;
exports.create = create;
exports.createDatabase = createDatabase;
exports["default"] = void 0;
exports.getAllMessages = getAllMessages;
exports.getIdb = getIdb;
exports.getMessagesHigherThan = getMessagesHigherThan;
exports.getOldMessages = getOldMessages;
exports.microSeconds = void 0;
exports.onMessage = onMessage;
exports.postMessage = postMessage;
exports.removeMessageById = removeMessageById;
exports.type = void 0;
exports.writeMessage = writeMessage;







/**
 * this method uses indexeddb to store the messages
 * There is currently no observerAPI for idb
 * @link https://github.com/w3c/IndexedDB/issues/51
 */
var microSeconds = _util.microSeconds;
exports.microSeconds = microSeconds;
var DB_PREFIX = 'pubkey.broadcast-channel-0-';
var OBJECT_STORE_ID = 'messages';
var type = 'idb';
exports.type = type;

function getIdb() {
  if (typeof indexedDB !== 'undefined') return indexedDB;

  if (typeof window !== 'undefined') {
    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;
  }

  return false;
}

function createDatabase(channelName) {
  var IndexedDB = getIdb(); // create table

  var dbName = DB_PREFIX + channelName;
  var openRequest = IndexedDB.open(dbName, 1);

  openRequest.onupgradeneeded = function (ev) {
    var db = ev.target.result;
    db.createObjectStore(OBJECT_STORE_ID, {
      keyPath: 'id',
      autoIncrement: true
    });
  };

  var dbPromise = new Promise(function (res, rej) {
    openRequest.onerror = function (ev) {
      return rej(ev);
    };

    openRequest.onsuccess = function () {
      res(openRequest.result);
    };
  });
  return dbPromise;
}
/**
 * writes the new message to the database
 * so other readers can find it
 */


function writeMessage(db, readerUuid, messageJson) {
  var time = new Date().getTime();
  var writeObject = {
    uuid: readerUuid,
    time: time,
    data: messageJson
  };
  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');
  return new Promise(function (res, rej) {
    transaction.oncomplete = function () {
      return res();
    };

    transaction.onerror = function (ev) {
      return rej(ev);
    };

    var objectStore = transaction.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
  });
}

function getAllMessages(db) {
  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function (res) {
    objectStore.openCursor().onsuccess = function (ev) {
      var cursor = ev.target.result;

      if (cursor) {
        ret.push(cursor.value); //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);

        cursor["continue"]();
      } else {
        res(ret);
      }
    };
  });
}

function getMessagesHigherThan(db, lastCursorId) {
  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);
  var ret = [];

  function openCursor() {
    // Occasionally Safari will fail on IDBKeyRange.bound, this
    // catches that error, having it open the cursor to the first
    // item. When it gets data it will advance to the desired key.
    try {
      var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e) {
      return objectStore.openCursor();
    }
  }

  return new Promise(function (res) {
    openCursor().onsuccess = function (ev) {
      var cursor = ev.target.result;

      if (cursor) {
        if (cursor.value.id < lastCursorId + 1) {
          cursor["continue"](lastCursorId + 1);
        } else {
          ret.push(cursor.value);
          cursor["continue"]();
        }
      } else {
        res(ret);
      }
    };
  });
}

function removeMessageById(db, id) {
  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)["delete"](id);
  return new Promise(function (res) {
    request.onsuccess = function () {
      return res();
    };
  });
}

function getOldMessages(db, ttl) {
  var olderThen = new Date().getTime() - ttl;
  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function (res) {
    objectStore.openCursor().onsuccess = function (ev) {
      var cursor = ev.target.result;

      if (cursor) {
        var msgObk = cursor.value;

        if (msgObk.time < olderThen) {
          ret.push(msgObk); //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);

          cursor["continue"]();
        } else {
          // no more old messages,
          res(ret);
          return;
        }
      } else {
        res(ret);
      }
    };
  });
}

function cleanOldMessages(db, ttl) {
  return getOldMessages(db, ttl).then(function (tooOld) {
    return Promise.all(tooOld.map(function (msgObj) {
      return removeMessageById(db, msgObj.id);
    }));
  });
}

function create(channelName, options) {
  options = (0, _options.fillOptionsWithDefaults)(options);
  return createDatabase(channelName).then(function (db) {
    var state = {
      closed: false,
      lastCursorId: 0,
      channelName: channelName,
      options: options,
      uuid: (0, _util.randomToken)(),

      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new _obliviousSet.ObliviousSet(options.idb.ttl * 2),
      // ensures we do not read messages in parrallel
      writeBlockPromise: _util.PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db: db
    };
    /**
     * Handle abrupt closes that do not originate from db.close().
     * This could happen, for example, if the underlying storage is
     * removed or if the user clears the database in the browser's
     * history preferences.
     */

    db.onclose = function () {
      state.closed = true;
      if (options.idb.onclose) options.idb.onclose();
    };
    /**
     * if service-workers are used,
     * we have no 'storage'-event if they post a message,
     * therefore we also have to set an interval
     */


    _readLoop(state);

    return state;
  });
}

function _readLoop(state) {
  if (state.closed) return;
  readNewMessages(state).then(function () {
    return (0, _util.sleep)(state.options.idb.fallbackInterval);
  }).then(function () {
    return _readLoop(state);
  });
}

function _filterMessage(msgObj, state) {
  if (msgObj.uuid === state.uuid) return false; // send by own

  if (state.eMIs.has(msgObj.id)) return false; // already emitted

  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback

  return true;
}
/**
 * reads all new messages from the database and emits them
 */


function readNewMessages(state) {
  // channel already closed
  if (state.closed) return _util.PROMISE_RESOLVED_VOID; // if no one is listening, we do not need to scan for new messages

  if (!state.messagesCallback) return _util.PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {
    var useMessages = newerMessages
    /**
     * there is a bug in iOS where the msgObj can be undefined some times
     * so we filter them out
     * @link https://github.com/pubkey/broadcast-channel/issues/19
     */
    .filter(function (msgObj) {
      return !!msgObj;
    }).map(function (msgObj) {
      if (msgObj.id > state.lastCursorId) {
        state.lastCursorId = msgObj.id;
      }

      return msgObj;
    }).filter(function (msgObj) {
      return _filterMessage(msgObj, state);
    }).sort(function (msgObjA, msgObjB) {
      return msgObjA.time - msgObjB.time;
    }); // sort by time

    useMessages.forEach(function (msgObj) {
      if (state.messagesCallback) {
        state.eMIs.add(msgObj.id);
        state.messagesCallback(msgObj.data);
      }
    });
    return _util.PROMISE_RESOLVED_VOID;
  });
}

function close(channelState) {
  channelState.closed = true;
  channelState.db.close();
}

function postMessage(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {
    return writeMessage(channelState.db, channelState.uuid, messageJson);
  }).then(function () {
    if ((0, _util.randomInt)(0, 10) === 0) {
      /* await (do not await) */
      cleanOldMessages(channelState.db, channelState.options.idb.ttl);
    }
  });
  return channelState.writeBlockPromise;
}

function onMessage(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
  readNewMessages(channelState);
}

function canBeUsed() {
  if (_util.isNode) return false;
  var idb = getIdb();
  if (!idb) return false;
  return true;
}

function averageResponseTime(options) {
  return options.idb.fallbackInterval * 2;
}

var _default = {
  create: create,
  close: close,
  onMessage: onMessage,
  postMessage: postMessage,
  canBeUsed: canBeUsed,
  type: type,
  averageResponseTime: averageResponseTime,
  microSeconds: microSeconds
};
exports["default"] = _default;
});

var localstorage = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addStorageEventListener = addStorageEventListener;
exports.averageResponseTime = averageResponseTime;
exports.canBeUsed = canBeUsed;
exports.close = close;
exports.create = create;
exports["default"] = void 0;
exports.getLocalStorage = getLocalStorage;
exports.microSeconds = void 0;
exports.onMessage = onMessage;
exports.postMessage = postMessage;
exports.removeStorageEventListener = removeStorageEventListener;
exports.storageKey = storageKey;
exports.type = void 0;







/**
 * A localStorage-only method which uses localstorage and its 'storage'-event
 * This does not work inside of webworkers because they have no access to locastorage
 * This is basically implemented to support IE9 or your grandmothers toaster.
 * @link https://caniuse.com/#feat=namevalue-storage
 * @link https://caniuse.com/#feat=indexeddb
 */
var microSeconds = _util.microSeconds;
exports.microSeconds = microSeconds;
var KEY_PREFIX = 'pubkey.broadcastChannel-';
var type = 'localstorage';
/**
 * copied from crosstab
 * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32
 */

exports.type = type;

function getLocalStorage() {
  var localStorage;
  if (typeof window === 'undefined') return null;

  try {
    localStorage = window.localStorage;
    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;
  } catch (e) {// New versions of Firefox throw a Security exception
    // if cookies are disabled. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153
  }

  return localStorage;
}

function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}
/**
* writes the new message to the storage
* and fires the storage-event so other readers can find it
*/


function postMessage(channelState, messageJson) {
  return new Promise(function (res) {
    (0, _util.sleep)().then(function () {
      var key = storageKey(channelState.channelName);
      var writeObj = {
        token: (0, _util.randomToken)(),
        time: new Date().getTime(),
        data: messageJson,
        uuid: channelState.uuid
      };
      var value = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value);
      /**
       * StorageEvent does not fire the 'storage' event
       * in the window that changes the state of the local storage.
       * So we fire it manually
       */

      var ev = document.createEvent('Event');
      ev.initEvent('storage', true, true);
      ev.key = key;
      ev.newValue = value;
      window.dispatchEvent(ev);
      res();
    });
  });
}

function addStorageEventListener(channelName, fn) {
  var key = storageKey(channelName);

  var listener = function listener(ev) {
    if (ev.key === key) {
      fn(JSON.parse(ev.newValue));
    }
  };

  window.addEventListener('storage', listener);
  return listener;
}

function removeStorageEventListener(listener) {
  window.removeEventListener('storage', listener);
}

function create(channelName, options) {
  options = (0, _options.fillOptionsWithDefaults)(options);

  if (!canBeUsed()) {
    throw new Error('BroadcastChannel: localstorage cannot be used');
  }

  var uuid = (0, _util.randomToken)();
  /**
   * eMIs
   * contains all messages that have been emitted before
   * @type {ObliviousSet}
   */

  var eMIs = new _obliviousSet.ObliviousSet(options.localstorage.removeTimeout);
  var state = {
    channelName: channelName,
    uuid: uuid,
    eMIs: eMIs // emittedMessagesIds

  };
  state.listener = addStorageEventListener(channelName, function (msgObj) {
    if (!state.messagesCallback) return; // no listener

    if (msgObj.uuid === uuid) return; // own message

    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted

    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old

    eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  return state;
}

function close(channelState) {
  removeStorageEventListener(channelState.listener);
}

function onMessage(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
}

function canBeUsed() {
  if (_util.isNode) return false;
  var ls = getLocalStorage();
  if (!ls) return false;

  try {
    var key = '__broadcastchannel_check';
    ls.setItem(key, 'works');
    ls.removeItem(key);
  } catch (e) {
    // Safari 10 in private mode will not allow write access to local
    // storage and fail with a QuotaExceededError. See
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes
    return false;
  }

  return true;
}

function averageResponseTime() {
  var defaultTime = 120;
  var userAgent = navigator.userAgent.toLowerCase();

  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
    // safari is much slower so this time is higher
    return defaultTime * 2;
  }

  return defaultTime;
}

var _default = {
  create: create,
  close: close,
  onMessage: onMessage,
  postMessage: postMessage,
  canBeUsed: canBeUsed,
  type: type,
  averageResponseTime: averageResponseTime,
  microSeconds: microSeconds
};
exports["default"] = _default;
});

var simulate = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.averageResponseTime = averageResponseTime;
exports.canBeUsed = canBeUsed;
exports.close = close;
exports.create = create;
exports.microSeconds = exports["default"] = void 0;
exports.onMessage = onMessage;
exports.postMessage = postMessage;
exports.type = void 0;



var microSeconds = _util.microSeconds;
exports.microSeconds = microSeconds;
var type = 'simulate';
exports.type = type;
var SIMULATE_CHANNELS = new Set();

function create(channelName) {
  var state = {
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state);
  return state;
}

function close(channelState) {
  SIMULATE_CHANNELS["delete"](channelState);
}

function postMessage(channelState, messageJson) {
  return new Promise(function (res) {
    return setTimeout(function () {
      var channelArray = Array.from(SIMULATE_CHANNELS);
      channelArray.filter(function (channel) {
        return channel.name === channelState.name;
      }).filter(function (channel) {
        return channel !== channelState;
      }).filter(function (channel) {
        return !!channel.messagesCallback;
      }).forEach(function (channel) {
        return channel.messagesCallback(messageJson);
      });
      res();
    }, 5);
  });
}

function onMessage(channelState, fn) {
  channelState.messagesCallback = fn;
}

function canBeUsed() {
  return true;
}

function averageResponseTime() {
  return 5;
}

var _default = {
  create: create,
  close: close,
  onMessage: onMessage,
  postMessage: postMessage,
  canBeUsed: canBeUsed,
  type: type,
  averageResponseTime: averageResponseTime,
  microSeconds: microSeconds
};
exports["default"] = _default;
});

var require$$0 = native;

var require$$1 = indexedDb;

var require$$2 = localstorage;

var require$$3 = simulate;

var chooseMethod_1 = chooseMethod;

var _native = interopRequireDefault(require$$0);

var _indexedDb = interopRequireDefault(require$$1);

var _localstorage = interopRequireDefault(require$$2);

var _simulate = interopRequireDefault(require$$3);

// the line below will be removed from es5/browser builds
// order is important
var METHODS = [_native["default"], // fastest
_indexedDb["default"], _localstorage["default"]];

function chooseMethod(options) {
  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean); // the line below will be removed from es5/browser builds



  if (options.type) {
    if (options.type === 'simulate') {
      // only use simulate-method if directly chosen
      return _simulate["default"];
    }

    var ret = chooseMethods.find(function (m) {
      return m.type === options.type;
    });
    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;
  }
  /**
   * if no webworker support is needed,
   * remove idb from the list so that localstorage is been chosen
   */


  if (!options.webWorkerSupport && !_util.isNode) {
    chooseMethods = chooseMethods.filter(function (m) {
      return m.type !== 'idb';
    });
  }

  var useMethod = chooseMethods.find(function (method) {
    return method.canBeUsed();
  });
  if (!useMethod) throw new Error("No useable method found in " + JSON.stringify(METHODS.map(function (m) {
    return m.type;
  })));else return useMethod;
}

var methodChooser = /*#__PURE__*/Object.defineProperty({
	chooseMethod: chooseMethod_1
}, '__esModule', {value: true});

var _methodChooser = methodChooser;

var broadcastChannel = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OPEN_BROADCAST_CHANNELS = exports.BroadcastChannel = void 0;
exports.clearNodeFolder = clearNodeFolder;
exports.enforceOptions = enforceOptions;







/**
 * Contains all open channels,
 * used in tests to ensure everything is closed.
 */
var OPEN_BROADCAST_CHANNELS = new Set();
exports.OPEN_BROADCAST_CHANNELS = OPEN_BROADCAST_CHANNELS;
var lastId = 0;

var BroadcastChannel = function BroadcastChannel(name, options) {
  // identifier of the channel to debug stuff
  this.id = lastId++;
  OPEN_BROADCAST_CHANNELS.add(this);
  this.name = name;

  if (ENFORCED_OPTIONS) {
    options = ENFORCED_OPTIONS;
  }

  this.options = (0, _options.fillOptionsWithDefaults)(options);
  this.method = (0, _methodChooser.chooseMethod)(this.options); // isListening

  this._iL = false;
  /**
   * _onMessageListener
   * setting onmessage twice,
   * will overwrite the first listener
   */

  this._onML = null;
  /**
   * _addEventListeners
   */

  this._addEL = {
    message: [],
    internal: []
  };
  /**
   * Unsend message promises
   * where the sending is still in progress
   * @type {Set<Promise>}
   */

  this._uMP = new Set();
  /**
   * _beforeClose
   * array of promises that will be awaited
   * before the channel is closed
   */

  this._befC = [];
  /**
   * _preparePromise
   */

  this._prepP = null;

  _prepareChannel(this);
}; // STATICS

/**
 * used to identify if someone overwrites
 * window.BroadcastChannel with this
 * See methods/native.js
 */


exports.BroadcastChannel = BroadcastChannel;
BroadcastChannel._pubkey = true;
/**
 * clears the tmp-folder if is node
 * @return {Promise<boolean>} true if has run, false if not node
 */

function clearNodeFolder(options) {
  options = (0, _options.fillOptionsWithDefaults)(options);
  var method = (0, _methodChooser.chooseMethod)(options);

  if (method.type === 'node') {
    return method.clearNodeFolder().then(function () {
      return true;
    });
  } else {
    return _util.PROMISE_RESOLVED_FALSE;
  }
}
/**
 * if set, this method is enforced,
 * no mather what the options are
 */


var ENFORCED_OPTIONS;

function enforceOptions(options) {
  ENFORCED_OPTIONS = options;
} // PROTOTYPE


BroadcastChannel.prototype = {
  postMessage: function postMessage(msg) {
    if (this.closed) {
      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +
      /**
       * In the past when this error appeared, it was realy hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(msg));
    }

    return _post(this, 'message', msg);
  },
  postInternal: function postInternal(msg) {
    return _post(this, 'internal', msg);
  },

  set onmessage(fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time: time,
      fn: fn
    };

    _removeListenerObject(this, 'message', this._onML);

    if (fn && typeof fn === 'function') {
      this._onML = listenObj;

      _addListenerObject(this, 'message', listenObj);
    } else {
      this._onML = null;
    }
  },

  addEventListener: function addEventListener(type, fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time: time,
      fn: fn
    };

    _addListenerObject(this, type, listenObj);
  },
  removeEventListener: function removeEventListener(type, fn) {
    var obj = this._addEL[type].find(function (obj) {
      return obj.fn === fn;
    });

    _removeListenerObject(this, type, obj);
  },
  close: function close() {
    var _this = this;

    if (this.closed) {
      return;
    }

    OPEN_BROADCAST_CHANNELS["delete"](this);
    this.closed = true;
    var awaitPrepare = this._prepP ? this._prepP : _util.PROMISE_RESOLVED_VOID;
    this._onML = null;
    this._addEL.message = [];
    return awaitPrepare // wait until all current sending are processed
    .then(function () {
      return Promise.all(Array.from(_this._uMP));
    }) // run before-close hooks
    .then(function () {
      return Promise.all(_this._befC.map(function (fn) {
        return fn();
      }));
    }) // close the channel
    .then(function () {
      return _this.method.close(_this._state);
    });
  },

  get type() {
    return this.method.type;
  },

  get isClosed() {
    return this.closed;
  }

};
/**
 * Post a message over the channel
 * @returns {Promise} that resolved when the message sending is done
 */

function _post(broadcastChannel, type, msg) {
  var time = broadcastChannel.method.microSeconds();
  var msgObj = {
    time: time,
    type: type,
    data: msg
  };
  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util.PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(function () {
    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list

    broadcastChannel._uMP.add(sendPromise);

    sendPromise["catch"]().then(function () {
      return broadcastChannel._uMP["delete"](sendPromise);
    });
    return sendPromise;
  });
}

function _prepareChannel(channel) {
  var maybePromise = channel.method.create(channel.name, channel.options);

  if ((0, _util.isPromise)(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then(function (s) {
      // used in tests to simulate slow runtime

      /*if (channel.options.prepareDelay) {
           await new Promise(res => setTimeout(res, this.options.prepareDelay));
      }*/
      channel._state = s;
    });
  } else {
    channel._state = maybePromise;
  }
}

function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0) return true;
  if (channel._addEL.internal.length > 0) return true;
  return false;
}

function _addListenerObject(channel, type, obj) {
  channel._addEL[type].push(obj);

  _startListening(channel);
}

function _removeListenerObject(channel, type, obj) {
  channel._addEL[type] = channel._addEL[type].filter(function (o) {
    return o !== obj;
  });

  _stopListening(channel);
}

function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    // someone is listening, start subscribing
    var listenerFn = function listenerFn(msgObj) {
      channel._addEL[msgObj.type].forEach(function (listenerObject) {
        /**
         * Getting the current time in JavaScript has no good precision.
         * So instead of only listening to events that happend 'after' the listener
         * was added, we also listen to events that happended 100ms before it.
         * This ensures that when another process, like a WebWorker, sends events
         * we do not miss them out because their timestamp is a bit off compared to the main process.
         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.
         * @link https://johnresig.com/blog/accuracy-of-javascript-time/
         */
        var hundredMsInMicro = 100 * 1000;
        var minMessageTime = listenerObject.time - hundredMsInMicro;

        if (msgObj.time >= minMessageTime) {
          listenerObject.fn(msgObj.data);
        }
      });
    };

    var time = channel.method.microSeconds();

    if (channel._prepP) {
      channel._prepP.then(function () {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time);
    }
  }
}

function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    // noone is listening, stop subscribing
    channel._iL = false;
    var time = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time);
  }
}
});

/* global WorkerGlobalScope */
function add$1(fn) {
  if (typeof WorkerGlobalScope === 'function' && self instanceof WorkerGlobalScope) ; else {
    /**
     * if we are on react-native, there is no window.addEventListener
     * @link https://github.com/pubkey/unload/issues/6
     */
    if (typeof window.addEventListener !== 'function') return;
    /**
     * for normal browser-windows, we use the beforeunload-event
     */

    window.addEventListener('beforeunload', function () {
      fn();
    }, true);
    /**
     * for iframes, we have to use the unload-event
     * @link https://stackoverflow.com/q/47533670/3443137
     */

    window.addEventListener('unload', function () {
      fn();
    }, true);
  }
  /**
   * TODO add fallback for safari-mobile
   * @link https://stackoverflow.com/a/26193516/3443137
   */

}

var BrowserMethod = {
  add: add$1
};

var USE_METHOD = BrowserMethod;
var LISTENERS = new Set();
var startedListening = false;

function startListening() {
  if (startedListening) return;
  startedListening = true;
  USE_METHOD.add(runAll);
}

function add(fn) {
  startListening();
  if (typeof fn !== 'function') throw new Error('Listener is no function');
  LISTENERS.add(fn);
  var addReturn = {
    remove: function remove() {
      return LISTENERS["delete"](fn);
    },
    run: function run() {
      LISTENERS["delete"](fn);
      return fn();
    }
  };
  return addReturn;
}
function runAll() {
  var promises = [];
  LISTENERS.forEach(function (fn) {
    promises.push(fn());
    LISTENERS["delete"](fn);
  });
  return Promise.all(promises);
}
function removeAll() {
  LISTENERS.clear();
}
function getSize() {
  return LISTENERS.size;
}

var es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add,
    runAll: runAll,
    removeAll: removeAll,
    getSize: getSize
});

var _unload = /*@__PURE__*/getAugmentedNamespace(es);

var beLeader_1 = beLeader;
var createLeaderElection_1 = createLeaderElection;





var LeaderElection = function LeaderElection(broadcastChannel, options) {
  var _this = this;

  this.broadcastChannel = broadcastChannel;
  this._options = options;
  this.isLeader = false;
  this.hasLeader = false;
  this.isDead = false;
  this.token = (0, _util.randomToken)();
  /**
   * Apply Queue,
   * used to ensure we do not run applyOnce()
   * in parallel.
   */

  this._aplQ = _util.PROMISE_RESOLVED_VOID; // amount of unfinished applyOnce() calls

  this._aplQC = 0; // things to clean up

  this._unl = []; // _unloads

  this._lstns = []; // _listeners

  this._dpL = function () {}; // onduplicate listener


  this._dpLC = false; // true when onduplicate called

  /**
   * Even when the own instance is not applying,
   * we still listen to messages to ensure the hasLeader flag
   * is set correctly.
   */

  var hasLeaderListener = function hasLeaderListener(msg) {
    if (msg.context === 'leader') {
      if (msg.action === 'death') {
        _this.hasLeader = false;
      }

      if (msg.action === 'tell') {
        _this.hasLeader = true;
      }
    }
  };

  this.broadcastChannel.addEventListener('internal', hasLeaderListener);

  this._lstns.push(hasLeaderListener);
};

LeaderElection.prototype = {
  /**
   * Returns true if the instance is leader,
   * false if not.
   * @async
   */
  applyOnce: function applyOnce( // true if the applyOnce() call came from the fallbackInterval cycle
  isFromFallbackInterval) {
    var _this2 = this;

    if (this.isLeader) {
      return (0, _util.sleep)(0, true);
    }

    if (this.isDead) {
      return (0, _util.sleep)(0, false);
    }
    /**
     * Already applying more then once,
     * -> wait for the apply queue to be finished.
     */


    if (this._aplQC > 1) {
      return this._aplQ;
    }
    /**
     * Add a new apply-run
     */


    var applyRun = function applyRun() {
      /**
       * Optimization shortcuts.
       * Directly return if a previous run
       * has already elected a leader.
       */
      if (_this2.isLeader) {
        return _util.PROMISE_RESOLVED_TRUE;
      }

      var stopCriteria = false;
      var stopCriteriaPromiseResolve;
      /**
       * Resolves when a stop criteria is reached.
       * Uses as a performance shortcut so we do not
       * have to await the responseTime when it is already clear
       * that the election failed.
       */

      var stopCriteriaPromise = new Promise(function (res) {
        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {
          stopCriteria = true;
          res();
        };
      });

      var handleMessage = function handleMessage(msg) {
        if (msg.context === 'leader' && msg.token != _this2.token) {

          if (msg.action === 'apply') {
            // other is applying
            if (msg.token > _this2.token) {
              /**
               * other has higher token
               * -> stop applying and let other become leader.
               */
              stopCriteriaPromiseResolve();
            }
          }

          if (msg.action === 'tell') {
            // other is already leader
            stopCriteriaPromiseResolve();
            _this2.hasLeader = true;
          }
        }
      };

      _this2.broadcastChannel.addEventListener('internal', handleMessage);
      /**
       * If the applyOnce() call came from the fallbackInterval,
       * we can assume that the election runs in the background and
       * not critical process is waiting for it.
       * When this is true, we give the other intances
       * more time to answer to messages in the election cycle.
       * This makes it less likely to elect duplicate leaders.
       * But also it takes longer which is not a problem because we anyway
       * run in the background.
       */


      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;

      var applyPromise = _sendMessage(_this2, 'apply') // send out that this one is applying
      .then(function () {
        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {
          return Promise.reject(new Error());
        })]);
      }) // send again in case another instance was just created
      .then(function () {
        return _sendMessage(_this2, 'apply');
      }) // let others time to respond
      .then(function () {
        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {
          return Promise.reject(new Error());
        })]);
      })["catch"](function () {}).then(function () {
        _this2.broadcastChannel.removeEventListener('internal', handleMessage);

        if (!stopCriteria) {
          // no stop criteria -> own is leader
          return beLeader(_this2).then(function () {
            return true;
          });
        } else {
          // other is leader
          return false;
        }
      });

      return applyPromise;
    };

    this._aplQC = this._aplQC + 1;
    this._aplQ = this._aplQ.then(function () {
      return applyRun();
    }).then(function () {
      _this2._aplQC = _this2._aplQC - 1;
    });
    return this._aplQ.then(function () {
      return _this2.isLeader;
    });
  },
  awaitLeadership: function awaitLeadership() {
    if (
    /* _awaitLeadershipPromise */
    !this._aLP) {
      this._aLP = _awaitLeadershipOnce(this);
    }

    return this._aLP;
  },

  set onduplicate(fn) {
    this._dpL = fn;
  },

  die: function die() {
    var _this3 = this;

    this._lstns.forEach(function (listener) {
      return _this3.broadcastChannel.removeEventListener('internal', listener);
    });

    this._lstns = [];

    this._unl.forEach(function (uFn) {
      return uFn.remove();
    });

    this._unl = [];

    if (this.isLeader) {
      this.hasLeader = false;
      this.isLeader = false;
    }

    this.isDead = true;
    return _sendMessage(this, 'death');
  }
};
/**
 * @param leaderElector {LeaderElector}
 */

function _awaitLeadershipOnce(leaderElector) {
  if (leaderElector.isLeader) {
    return _util.PROMISE_RESOLVED_VOID;
  }

  return new Promise(function (res) {
    var resolved = false;

    function finish() {
      if (resolved) {
        return;
      }

      resolved = true;
      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);
      res(true);
    } // try once now


    leaderElector.applyOnce().then(function () {
      if (leaderElector.isLeader) {
        finish();
      }
    });
    /**
     * Try on fallbackInterval
     * @recursive
     */

    var tryOnFallBack = function tryOnFallBack() {
      return (0, _util.sleep)(leaderElector._options.fallbackInterval).then(function () {
        if (leaderElector.isDead || resolved) {
          return;
        }

        if (leaderElector.isLeader) {
          finish();
        } else {
          return leaderElector.applyOnce(true).then(function () {
            if (leaderElector.isLeader) {
              finish();
            } else {
              tryOnFallBack();
            }
          });
        }
      });
    };

    tryOnFallBack(); // try when other leader dies

    var whenDeathListener = function whenDeathListener(msg) {
      if (msg.context === 'leader' && msg.action === 'death') {
        leaderElector.hasLeader = false;
        leaderElector.applyOnce().then(function () {
          if (leaderElector.isLeader) {
            finish();
          }
        });
      }
    };

    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);

    leaderElector._lstns.push(whenDeathListener);
  });
}
/**
 * sends and internal message over the broadcast-channel
 */


function _sendMessage(leaderElector, action) {
  var msgJson = {
    context: 'leader',
    action: action,
    token: leaderElector.token
  };
  return leaderElector.broadcastChannel.postInternal(msgJson);
}

function beLeader(leaderElector) {
  leaderElector.isLeader = true;
  leaderElector.hasLeader = true;
  var unloadFn = (0, _unload.add)(function () {
    return leaderElector.die();
  });

  leaderElector._unl.push(unloadFn);

  var isLeaderListener = function isLeaderListener(msg) {
    if (msg.context === 'leader' && msg.action === 'apply') {
      _sendMessage(leaderElector, 'tell');
    }

    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {
      /**
       * another instance is also leader!
       * This can happen on rare events
       * like when the CPU is at 100% for long time
       * or the tabs are open very long and the browser throttles them.
       * @link https://github.com/pubkey/broadcast-channel/issues/414
       * @link https://github.com/pubkey/broadcast-channel/issues/385
       */
      leaderElector._dpLC = true;

      leaderElector._dpL(); // message the lib user so the app can handle the problem


      _sendMessage(leaderElector, 'tell'); // ensure other leader also knows the problem

    }
  };

  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);

  leaderElector._lstns.push(isLeaderListener);

  return _sendMessage(leaderElector, 'tell');
}

function fillOptionsWithDefaults(options, channel) {
  if (!options) options = {};
  options = JSON.parse(JSON.stringify(options));

  if (!options.fallbackInterval) {
    options.fallbackInterval = 3000;
  }

  if (!options.responseTime) {
    options.responseTime = channel.method.averageResponseTime(channel.options);
  }

  return options;
}

function createLeaderElection(channel, options) {
  if (channel._leaderElector) {
    throw new Error('BroadcastChannel already has a leader-elector');
  }

  options = fillOptionsWithDefaults(options, channel);
  var elector = new LeaderElection(channel, options);

  channel._befC.push(function () {
    return elector.die();
  });

  channel._leaderElector = elector;
  return elector;
}

var leaderElection = /*#__PURE__*/Object.defineProperty({
	beLeader: beLeader_1,
	createLeaderElection: createLeaderElection_1
}, '__esModule', {value: true});

var _broadcastChannel = broadcastChannel;

var _leaderElection = leaderElection;

var lib = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "BroadcastChannel", {
  enumerable: true,
  get: function get() {
    return _broadcastChannel.BroadcastChannel;
  }
});
Object.defineProperty(exports, "OPEN_BROADCAST_CHANNELS", {
  enumerable: true,
  get: function get() {
    return _broadcastChannel.OPEN_BROADCAST_CHANNELS;
  }
});
Object.defineProperty(exports, "beLeader", {
  enumerable: true,
  get: function get() {
    return _leaderElection.beLeader;
  }
});
Object.defineProperty(exports, "clearNodeFolder", {
  enumerable: true,
  get: function get() {
    return _broadcastChannel.clearNodeFolder;
  }
});
Object.defineProperty(exports, "createLeaderElection", {
  enumerable: true,
  get: function get() {
    return _leaderElection.createLeaderElection;
  }
});
Object.defineProperty(exports, "enforceOptions", {
  enumerable: true,
  get: function get() {
    return _broadcastChannel.enforceOptions;
  }
});
});

var _index = lib;

/**
 * because babel can only export on default-attribute,
 * we use this for the non-module-build
 * this ensures that users do not have to use
 * var BroadcastChannel = require('broadcast-channel').default;
 * but
 * var BroadcastChannel = require('broadcast-channel');
 */
var index_es5 = {
  BroadcastChannel: _index.BroadcastChannel,
  createLeaderElection: _index.createLeaderElection,
  clearNodeFolder: _index.clearNodeFolder,
  enforceOptions: _index.enforceOptions,
  beLeader: _index.beLeader
};

var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let WebMesageReceiver = class WebMesageReceiver {
    init() {
        this.isNativeBroadcastChannel = typeof BroadcastChannel === 'function';
        const createChannel = () => {
            this.communicationChannel = new index_es5.BroadcastChannel('clientCommunication', {
                idb: {
                    onclose: () => {
                        // the onclose event is just the IndexedDB closing.
                        // you should also close the channel before creating
                        // a new one.
                        this.communicationChannel.close();
                        createChannel();
                    },
                },
            });
            this.communicationChannel.onmessage = (message) => {
                this.transactionalReceiver.handleClientRequest(message);
            };
        };
        createChannel();
        window.addEventListener("message", event => {
            const message = event.data;
            this.transactionalReceiver.handleAppRequest(message, event.origin, event.source);
        }, false);
    }
    needMessageSerialization() {
        return !this.isNativeBroadcastChannel;
    }
    sendMessageToClient(message) {
        this.communicationChannel.postMessage(message);
    }
    sendMessageToApp() {
    }
};
__decorate$n([
    Inject()
], WebMesageReceiver.prototype, "transactionalReceiver", void 0);
WebMesageReceiver = __decorate$n([
    Injected()
], WebMesageReceiver);
function injectWebReceiver() {
    const terminalStore = IOC.getSync(TERMINAL_STORE);
    const webReciever = terminalStore.getWebReceiver();
    webReciever.localDomain = 'localhost:31717';
}

var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DomainRetriever = class DomainRetriever {
    async retrieveDomain(domainName, domainNameMapByName, allDomains, newDomains) {
        return domainNameMapByName.get(domainName);
    }
};
DomainRetriever = __decorate$m([
    Injected()
], DomainRetriever);

var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SqlSchemaBuilder = class SqlSchemaBuilder {
    async build(jsonApplication, existingApplicationMap, newJsonApplicationMap, context) {
        await this.createApplication(jsonApplication, context);
        for (const jsonEntity of jsonApplication.versions[jsonApplication.versions.length - 1].entities) {
            await this.buildTable(jsonApplication, jsonEntity, existingApplicationMap, context);
        }
        const relatedJsonApplicationMap = new Map();
        for (const jsonEntity of jsonApplication.versions[jsonApplication.versions.length - 1].entities) {
            await this.buildForeignKeys(jsonApplication, jsonEntity, existingApplicationMap, newJsonApplicationMap, relatedJsonApplicationMap, context);
        }
    }
    async buildTable(jsonApplication, jsonEntity, existingApplicationMap, context) {
        const primaryKeyColumnNames = [];
        const tableColumnsDdl = jsonEntity.columns.map((jsonColumn) => {
            let columnDdl = `${jsonColumn.name} ${this.getColumnSuffix(jsonApplication, jsonEntity, jsonColumn)}`;
            if (this.isPrimaryKeyColumn(jsonEntity, jsonColumn)) {
                primaryKeyColumnNames.push(jsonColumn.name);
            }
            return columnDdl;
        });
        const createTableSuffix = this.getCreateTableSuffix(jsonApplication, jsonEntity);
        const tableName = this.storeDriver.getTableName(jsonApplication, jsonEntity, context);
        let primaryKeySubStatement = ``;
        if (primaryKeyColumnNames.length) {
            primaryKeySubStatement = this.getPrimaryKeyStatement(primaryKeyColumnNames);
        }
        const createTableDdl = `CREATE TABLE ${tableName} (
		${tableColumnsDdl.join(',\n')}${primaryKeySubStatement}
		)${createTableSuffix}`;
        await this.storeDriver.query(QueryType.DDL, createTableDdl, [], context, false);
        let indexNumber = 0;
        if (jsonEntity.tableConfig.columnIndexes) {
            for (const indexConfig of jsonEntity.tableConfig.columnIndexes) {
                const createIndexDdl = this.getIndexSql('idx_' + tableName + '_' + (++indexNumber), tableName, indexConfig.columnList, indexConfig.unique);
                await this.storeDriver.query(QueryType.DDL, createIndexDdl, [], context, false);
            }
        }
        if (jsonEntity.tableConfig.propertyIndexes) {
            for (const indexConfig of jsonEntity.tableConfig.propertyIndexes) {
                const columnNameList = [];
                for (const jsonColumn of jsonEntity.columns) {
                    for (const propertyRef of jsonColumn.propertyRefs) {
                        if (propertyRef.index === indexConfig.propertyIndex) {
                            columnNameList.push(jsonColumn.name);
                            break;
                        }
                    }
                }
                const createIndexDdl = this.getIndexSql('idx_' + tableName + '_' + (++indexNumber), tableName, columnNameList, indexConfig.unique);
                await this.storeDriver.query(QueryType.DDL, createIndexDdl, [], context, false);
            }
        }
        //
    }
    async buildForeignKeys(jsonApplication, jsonEntity, existingApplicationMap, newJsonApplicationMap, relatedJsonApplicationMap, context) {
        if (!jsonEntity.relations || !jsonEntity.relations.length) {
            return;
        }
        const applicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const tableName = this.storeDriver.getTableName(jsonApplication, jsonEntity, context);
        for (const jsonRelation of jsonEntity.relations) {
            if (jsonRelation.relationType !== EntityRelationType.MANY_TO_ONE) {
                continue;
            }
            let relatedJsonApplication;
            let relatedJsonEntity;
            if (jsonRelation.relationTableApplicationIndex
                || jsonRelation.relationTableApplicationIndex === 0) {
                const referencedApplication = applicationVersion
                    .referencedApplications[jsonRelation.relationTableApplicationIndex];
                let relatedFullApplicationName = this.dbApplicationUtils
                    .getFullApplicationNameFromDomainAndName(referencedApplication.domain, referencedApplication.name);
                relatedJsonApplication = relatedJsonApplicationMap.get(relatedFullApplicationName);
                if (!relatedJsonApplication) {
                    const relatedApplication = existingApplicationMap.get(relatedFullApplicationName);
                    if (relatedApplication) {
                        // FIXME: this should be looked up though currentVersion - make sure it's populated
                        // relatedJsonApplication = relatedApplication.currentVersion[0].applicationVersion.jsonApplication
                        relatedJsonApplication = relatedApplication.versions[0].jsonApplication;
                    }
                    else {
                        relatedJsonApplication = newJsonApplicationMap.get(relatedFullApplicationName);
                    }
                    if (!relatedJsonApplication) {
                        throw new Error(`Could not find related application ${relatedFullApplicationName}
            in either existing applications or newly installing applications.`);
                    }
                    relatedJsonApplicationMap.set(relatedFullApplicationName, relatedJsonApplication);
                }
                const relatedApplicationVersion = relatedJsonApplication
                    .versions[relatedJsonApplication.versions.length - 1];
                relatedJsonEntity = relatedApplicationVersion.entities[jsonRelation.relationTableIndex];
            }
            else {
                relatedJsonApplication = jsonApplication;
                relatedJsonEntity = applicationVersion.entities[jsonRelation.relationTableIndex];
            }
            let foreignKeyColumnNames = [];
            for (const jsonColumn of jsonEntity.columns) {
                for (const propertyRef of jsonColumn.propertyRefs) {
                    if (propertyRef.index === jsonRelation.propertyRef.index) {
                        foreignKeyColumnNames.push(jsonColumn.name);
                        break;
                    }
                }
            }
            const referencedTableName = this.storeDriver
                .getTableName(relatedJsonApplication, relatedJsonEntity, context);
            let referencedColumnNames = [];
            for (const relatedIdColumnRef of relatedJsonEntity.idColumnRefs) {
                referencedColumnNames.push(relatedJsonEntity.columns[relatedIdColumnRef.index].name);
            }
            const foreignKeySql = this.getForeignKeySql(tableName, 'fk_' + tableName + '_foreignKeyNumber', foreignKeyColumnNames, referencedTableName, referencedColumnNames);
            if (foreignKeySql) {
                await this.storeDriver.query(QueryType.DDL, foreignKeySql, [], context, false);
            }
        }
    }
    async buildForeignKeysForTable() {
    }
    isPrimaryKeyColumn(jsonEntity, jsonColumn) {
        return jsonColumn.propertyRefs.some((propertyRef) => {
            const jsonProperty = jsonEntity.properties[propertyRef.index];
            if (jsonProperty.isId) {
                return true;
            }
        });
    }
    /*
    protected abstract isForeignKey(
      jsonEntity: JsonApplicationEntity,
      jsonColumn: JsonApplicationColumn
    ): boolean
    */
    getPrimaryKeyStatement(columnNames) {
        return `,
			PRIMARY KEY (
			${columnNames.join(',\n')}
			)`;
    }
};
__decorate$l([
    Inject()
], SqlSchemaBuilder.prototype, "airportDatabase", void 0);
__decorate$l([
    Inject()
], SqlSchemaBuilder.prototype, "dbApplicationUtils", void 0);
__decorate$l([
    Inject()
], SqlSchemaBuilder.prototype, "sequenceDao", void 0);
__decorate$l([
    Inject()
], SqlSchemaBuilder.prototype, "storeDriver", void 0);
SqlSchemaBuilder = __decorate$l([
    Injected()
], SqlSchemaBuilder);

var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationChecker = class ApplicationChecker {
    async check(jsonApplication) {
        if (!jsonApplication) {
            throw new Error(`Json Application not provided`);
        }
        if (!(jsonApplication.versions instanceof Array)) {
            throw new Error('application.versions is not an array');
        }
        if (jsonApplication.versions.length !== 1) {
            // FIXME: add support for application versioning
            throw new Error('Currently only 1 version of application is supported');
        }
        await this.checkDomain(jsonApplication);
    }
    async checkDomain(jsonApplication) {
        // TODO: implement domain checking
    }
    async checkDependencies(jsonApplications) {
        const allReferencedApplicationMap = new Map();
        const referencedApplicationMapByApplication = new Map();
        for (const jsonApplication of jsonApplications) {
            const lastJsonApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
            const referencedApplicationMapForApplication = ensureChildJsMap(ensureChildJsMap(referencedApplicationMapByApplication, jsonApplication.domain), jsonApplication.name);
            for (const jsonReferencedApplication of lastJsonApplicationVersion.referencedApplications) {
                ensureChildJsMap(allReferencedApplicationMap, jsonReferencedApplication.domain).set(jsonReferencedApplication.name, jsonReferencedApplication);
                ensureChildJsMap(referencedApplicationMapForApplication, jsonReferencedApplication.domain).set(jsonReferencedApplication.name, jsonReferencedApplication);
            }
        }
        this.pruneInGroupReferences(jsonApplications, allReferencedApplicationMap, referencedApplicationMapByApplication);
        await this.pruneReferencesToExistingApplications(jsonApplications, allReferencedApplicationMap, referencedApplicationMapByApplication);
        const applicationsWithValidDependencies = [];
        const applicationsInNeedOfAdditionalDependencies = [];
        const neededDependencies = [];
        for (const dependenciesForDomain of allReferencedApplicationMap.values()) {
            for (const dependency of dependenciesForDomain.values()) {
                neededDependencies.push(dependency);
            }
        }
        for (const jsonApplication of jsonApplications) {
            const referencedApplicationMapForApplication = referencedApplicationMapByApplication.get(jsonApplication.domain).get(jsonApplication.name);
            if (this.hasReferences(referencedApplicationMapForApplication)) {
                applicationsInNeedOfAdditionalDependencies.push(jsonApplication);
            }
            else {
                applicationsWithValidDependencies.push(jsonApplication);
            }
        }
        return {
            applicationsWithValidDependencies,
            applicationsInNeedOfAdditionalDependencies,
            neededDependencies
        };
    }
    pruneInGroupReferences(jsonApplications, allReferencedApplicationMap, referencedApplicationMapByApplication) {
        for (const jsonApplication of jsonApplications) {
            // Remove every in-group reference for this application
            for (const [_domainName, referenceMapForApplicationsOfDomain] of referencedApplicationMapByApplication) {
                for (const [_applicationName, applicationsReferencedByAGivenApplication] of referenceMapForApplicationsOfDomain) {
                    const applicationReferencesForDomain = applicationsReferencedByAGivenApplication.get(jsonApplication.domain);
                    if (applicationReferencesForDomain) {
                        applicationReferencesForDomain.delete(jsonApplication.name);
                    }
                }
            }
            const allApplicationReferencesForDomain = allReferencedApplicationMap.get(jsonApplication.domain);
            if (allApplicationReferencesForDomain) {
                allApplicationReferencesForDomain.delete(jsonApplication.name);
            }
        }
    }
    async pruneReferencesToExistingApplications(jsonApplications, allReferencedApplicationMap, referencedApplicationMapByApplication) {
        const existingApplicationInfo = await this.findExistingApplications(allReferencedApplicationMap);
        for (const applicationName of existingApplicationInfo.existingApplicationMapByName.keys()) {
            const coreDomainAndApplicationNames = existingApplicationInfo.coreDomainAndApplicationNamesByApplicationName.get(applicationName);
            // Remove every reference for this existing application
            for (const referenceMapForApplicationsOfDomain of referencedApplicationMapByApplication.values()) {
                for (const applicationsReferencedByAGivenApplication of referenceMapForApplicationsOfDomain.values()) {
                    const applicationReferencesForDomain = applicationsReferencedByAGivenApplication.get(coreDomainAndApplicationNames.domain);
                    if (applicationReferencesForDomain) {
                        applicationReferencesForDomain.delete(coreDomainAndApplicationNames.application);
                    }
                }
            }
            const allApplicationReferencesForDomain = allReferencedApplicationMap.get(coreDomainAndApplicationNames.domain);
            if (allApplicationReferencesForDomain) {
                allApplicationReferencesForDomain.delete(coreDomainAndApplicationNames.application);
            }
        }
    }
    async findExistingApplications(allReferencedApplicationMap) {
        const fullApplicationNames = [];
        const coreDomainAndApplicationNamesByApplicationName = new Map();
        for (const [domainName, allReferencedApplicationsForDomain] of allReferencedApplicationMap) {
            for (const [coreApplicationName, referencedApplication] of allReferencedApplicationsForDomain) {
                const fullApplicationName = this.dbApplicationUtils.
                    getFullApplicationName(referencedApplication);
                fullApplicationNames.push(fullApplicationName);
                coreDomainAndApplicationNamesByApplicationName.set(fullApplicationName, {
                    domain: domainName,
                    application: coreApplicationName
                });
            }
        }
        let existingApplicationMapByName;
        if (!fullApplicationNames.length) {
            existingApplicationMapByName = new Map();
        }
        else {
            existingApplicationMapByName = await this.applicationDao.findMapByFullNames(fullApplicationNames);
        }
        return {
            coreDomainAndApplicationNamesByApplicationName,
            existingApplicationMapByName
        };
    }
    hasReferences(referencedApplicationMap) {
        for (const referencesForDomain of referencedApplicationMap.values()) {
            for (const _ of referencesForDomain) {
                return true;
            }
        }
        return false;
    }
};
__decorate$k([
    Inject()
], ApplicationChecker.prototype, "applicationDao", void 0);
__decorate$k([
    Inject()
], ApplicationChecker.prototype, "dbApplicationUtils", void 0);
ApplicationChecker = __decorate$k([
    Injected()
], ApplicationChecker);

var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationLocator = class ApplicationLocator {
    // private terminalStore: ITerminalStore
    locateExistingApplicationVersionRecord(jsonApplication, terminalStore) {
        const applicationVersionsForDomainName = terminalStore
            .getLatestApplicationVersionMapByNames().get(jsonApplication.domain);
        if (!applicationVersionsForDomainName) {
            return null;
        }
        const fullApplicationName = this.dbApplicationUtils.
            getFullApplicationNameFromDomainAndName(jsonApplication.domain, jsonApplication.name);
        const latestApplicationVersionForApplication = applicationVersionsForDomainName.get(fullApplicationName);
        const jsonApplicationVersion = jsonApplication.versions[0];
        if (latestApplicationVersionForApplication
            && latestApplicationVersionForApplication.integerVersion !== jsonApplicationVersion.integerVersion) {
            throw new Error(`Multiple versions of applications are not yet supported`);
        }
        return latestApplicationVersionForApplication;
    }
    async locateLatestApplicationVersionByApplicationName(fullApplicationName, terminalStore) {
        return terminalStore.getLatestApplicationVersionMapByFullApplicationName()
            .get(fullApplicationName);
    }
};
__decorate$j([
    Inject()
], ApplicationLocator.prototype, "dbApplicationUtils", void 0);
ApplicationLocator = __decorate$j([
    Injected()
], ApplicationLocator);

var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationComposer = class ApplicationComposer {
    async compose(jsonApplications, context) {
        // NOTE: application name contains domain name as a prefix
        const jsonApplicationMapByFullName = new Map();
        const terminalStore = context.terminalStore;
        const allDomains = terminalStore.getDomains().slice();
        const domainMapByName = new Map();
        for (const domain of allDomains) {
            domainMapByName.set(domain.name, domain);
        }
        const allApplications = terminalStore.getApplications().slice();
        // NOTE: application fullName contains domain name as a prefix
        const applicationMapByFullName = new Map();
        for (const application of allApplications) {
            applicationMapByFullName.set(application.fullName, application);
        }
        const newLatestApplicationVersions = [];
        const newApplicationVersionMapByApplicationName = new Map();
        const newEntitiesMapByApplicationName = new Map();
        const newPropertiesMap = new Map();
        const newRelationsMap = new Map();
        const newColumnsMap = new Map();
        const added = {
            columns: [],
            domains: [],
            entities: [],
            latestApplicationVersions: [],
            properties: [],
            propertyColumns: [],
            relationColumns: [],
            relations: [],
            applicationReferences: [],
            applications: [],
            applicationVersions: []
        };
        const allApplicationVersionsByIds = [...terminalStore.getAllApplicationVersionsByIds()];
        const all = {
            columns: [],
            domains: [],
            entities: [],
            latestApplicationVersions: [],
            properties: [],
            propertyColumns: [],
            relationColumns: [],
            relations: [],
            applicationReferences: [],
            applications: [],
            applicationVersions: [] //
        };
        const allDdlObjects = {
            all,
            allApplicationVersionsByIds,
            added
        };
        for (const jsonApplication of jsonApplications) {
            jsonApplicationMapByFullName.set(this.dbApplicationUtils.
                getFullApplicationName(jsonApplication), jsonApplication);
            const domain = await this.composeDomain(jsonApplication.domain, allDomains, added.domains, domainMapByName);
            const application = this.composeApplication(domain, jsonApplication, allApplications, added.applications, applicationMapByFullName);
            this.composeApplicationVersion(jsonApplication, application, newLatestApplicationVersions, added.applicationVersions, newApplicationVersionMapByApplicationName);
        }
        const { newApplicationReferenceMap, newApplicationReferences } = await this.composeApplicationReferences(jsonApplicationMapByFullName, newApplicationVersionMapByApplicationName, terminalStore, allDdlObjects, context.deepTraverseReferences);
        added.applicationReferences = newApplicationReferences;
        for (const applicationVersion of allApplicationVersionsByIds) {
            if (applicationVersion) {
                this.addApplicationVersionObjects(applicationVersion, all);
            }
        }
        for (const jsonApplication of jsonApplications) {
            const fullApplicationName = this.dbApplicationUtils.
                getFullApplicationName(jsonApplication);
            jsonApplicationMapByFullName.set(fullApplicationName, jsonApplication);
            const domain = domainMapByName.get(jsonApplication.domain);
            const application = applicationMapByFullName.get(this.dbApplicationUtils.
                getFullApplicationName(jsonApplication));
            if (!application.index) {
                jsonApplication.lastIds = {
                    ...this.terminalStore.getLastIds()
                };
                application.index = ++this.terminalStore.getLastIds().applications;
            }
            if (!domain.id) {
                domain.id = ++this.terminalStore.getLastIds().domains;
            }
            const applicationVersion = newApplicationVersionMapByApplicationName.get(application.fullName);
            if (!applicationVersion.id) {
                applicationVersion.id = ++this.terminalStore.getLastIds().applicationVersions;
                applicationVersion.jsonApplication = jsonApplication;
            }
            this.composeApplicationEntities(jsonApplication, applicationVersion, newEntitiesMapByApplicationName, added.entities);
            this.composeApplicationProperties(jsonApplication, added.properties, newPropertiesMap, newEntitiesMapByApplicationName);
            await this.composeApplicationRelations(jsonApplication, added.relations, newRelationsMap, newEntitiesMapByApplicationName, newPropertiesMap, newApplicationReferenceMap, terminalStore, allDdlObjects);
            this.composeApplicationColumns(jsonApplication, added.columns, newColumnsMap, added.propertyColumns, newEntitiesMapByApplicationName, newPropertiesMap);
            await this.composeApplicationRelationColumns(jsonApplication, added.relationColumns, newApplicationVersionMapByApplicationName, newApplicationReferenceMap, newRelationsMap, newColumnsMap, terminalStore, allDdlObjects);
        }
        this.addObjects(allDdlObjects.added, allDdlObjects.all);
        for (const applicationVersion of allDdlObjects.all.applicationVersions) {
            allDdlObjects.allApplicationVersionsByIds[applicationVersion.id] = applicationVersion;
        }
        return allDdlObjects;
    }
    async getExistingLatestApplicationVersion(referencedApplicationName, allDdlObjects) {
        for (const latestApplicationVersion of allDdlObjects.all.latestApplicationVersions) {
            if (latestApplicationVersion.application.fullName == referencedApplicationName) {
                return latestApplicationVersion;
            }
        }
        throw new Error(`Cannot find application "${referencedApplicationName}".`);
    }
    addApplicationVersionObjects(applicationVersion, ddlObjects) {
        let foundDomain = false;
        for (const domain of ddlObjects.domains) {
            if (domain.name === applicationVersion.application.domain.name) {
                foundDomain = true;
                break;
            }
        }
        if (!foundDomain) {
            ddlObjects.domains.push(applicationVersion.application.domain);
        }
        let foundApplication = false;
        for (const application of ddlObjects.applications) {
            if (application.domain === applicationVersion.application.domain
                && application.name === applicationVersion.application.name) {
                foundApplication = true;
                break;
            }
        }
        if (!foundApplication) {
            ddlObjects.applications.push(applicationVersion.application);
        }
        ddlObjects.applicationVersions.push(applicationVersion);
        ddlObjects.latestApplicationVersions.push(applicationVersion);
        ddlObjects.applicationReferences = ddlObjects.applicationReferences
            .concat(applicationVersion.references);
        ddlObjects.entities = ddlObjects.entities.concat(applicationVersion.entities);
        for (const entity of applicationVersion.entities) {
            ddlObjects.columns = ddlObjects.columns.concat(entity.columns);
            ddlObjects.properties = ddlObjects.properties.concat(entity.properties);
            let entityPropertyColumns = [];
            for (const property of entity.properties) {
                entityPropertyColumns = entityPropertyColumns
                    .concat(property.propertyColumns);
            }
            ddlObjects.propertyColumns = ddlObjects.propertyColumns
                .concat(entityPropertyColumns);
            ddlObjects.relations = ddlObjects.relations.concat(entity.relations);
            let entityRelationColumns = [];
            for (const relation of entity.relations) {
                entityRelationColumns = entityRelationColumns
                    .concat(relation.manyRelationColumns);
            }
            ddlObjects.relationColumns = ddlObjects.relationColumns
                .concat(entityRelationColumns);
        }
    }
    addObjects(fromObjects, toObjects) {
        toObjects.columns = toObjects.columns.concat(fromObjects.columns);
        for (const fromDomain of fromObjects.domains) {
            let foundDomain = false;
            for (const toDomain of toObjects.domains) {
                if (toDomain.name === fromDomain.name) {
                    foundDomain = true;
                    break;
                }
            }
            if (!foundDomain) {
                toObjects.domains.push(fromDomain);
            }
        }
        toObjects.entities = toObjects.entities.concat(fromObjects.entities);
        toObjects.latestApplicationVersions = toObjects.latestApplicationVersions
            .concat(fromObjects.latestApplicationVersions);
        toObjects.properties = toObjects.properties.concat(fromObjects.properties);
        toObjects.propertyColumns = toObjects.propertyColumns
            .concat(fromObjects.propertyColumns);
        toObjects.relationColumns = toObjects.relationColumns
            .concat(fromObjects.relationColumns);
        toObjects.relations = toObjects.relations.concat(fromObjects.relations);
        for (const fromApplication of fromObjects.applications) {
            let foundApplication = false;
            for (const toApplication of toObjects.applications) {
                if (toApplication.domain === fromApplication.domain
                    && toApplication.name === fromApplication.name) {
                    foundApplication = true;
                    break;
                }
            }
            if (!foundApplication) {
                toObjects.applications.push(fromApplication);
            }
        }
        toObjects.applicationReferences = toObjects.applicationReferences
            .concat(fromObjects.applicationReferences);
        toObjects.applicationVersions = toObjects.applicationVersions
            .concat(fromObjects.applicationVersions);
    }
    async composeDomain(domainName, allDomains, newDomains, domainMapByName) {
        let domain = await this.domainRetriever.retrieveDomain(domainName, domainMapByName, allDomains, newDomains);
        if (!domain) {
            domain = {
                id: null,
                name: domainName,
                applications: []
            };
            allDomains.push(domain);
            newDomains.push(domain);
            domainMapByName.set(domainName, domain);
        }
        return domain;
    }
    composeApplication(domain, jsonApplication, allApplications, newApplications, applicationMapByFullName) {
        const fullApplicationName = this.dbApplicationUtils.
            getFullApplicationName(jsonApplication);
        let application = applicationMapByFullName.get(fullApplicationName);
        if (!application) {
            application = {
                domain,
                index: null,
                fullName: fullApplicationName,
                name: jsonApplication.name,
                scope: 'public',
                signature: 'localhost',
                status: ApplicationStatus.CURRENT,
            };
            allApplications.push(application);
            newApplications.push(application);
            applicationMapByFullName.set(fullApplicationName, application);
        }
        return application;
    }
    composeApplicationVersion(jsonApplication, application, newLatestApplicationVersions, newApplicationVersions, newApplicationVersionMapByApplicationName) {
        // Application versions are guaranteed to be new
        let newApplicationVersion;
        for (const applicationVersion of jsonApplication.versions) {
            const versionParts = applicationVersion.versionString.split('.');
            newApplicationVersion = {
                id: null,
                integerVersion: applicationVersion.integerVersion,
                versionString: applicationVersion.versionString,
                majorVersion: parseInt(versionParts[0]),
                minorVersion: parseInt(versionParts[1]),
                patchVersion: parseInt(versionParts[2]),
                application,
                jsonApplication,
                entities: [],
                references: [],
                referencedBy: [],
                entityMapByName: {},
                referencesMapByName: {},
                referencedByMapByName: {},
            };
            if (application.versions) {
                application.versions.push(newApplicationVersion);
            }
            else {
                application.versions = [newApplicationVersion];
            }
            newApplicationVersions.push(newApplicationVersion);
        }
        let newApplicationCurrentVersion = {
            application,
            applicationVersion: newApplicationVersion
        };
        // needed for normalOperation only
        application.currentVersion = [newApplicationCurrentVersion];
        newLatestApplicationVersions.push(newApplicationVersion);
        newApplicationVersionMapByApplicationName.set(application.fullName, newApplicationVersion);
        return newApplicationVersion;
    }
    async composeApplicationReferences(jsonApplicationMapByName, newApplicationVersionMapByApplicationName, terminalStore, allDdlObjects, deepTraverseReferences) {
        const newApplicationReferenceMap = new Map();
        const newApplicationReferenceLookup = new Map();
        const newApplicationReferences = [];
        for (const [applicationName, ownApplicationVersion] of newApplicationVersionMapByApplicationName) {
            const application = ownApplicationVersion.application;
            const jsonApplication = jsonApplicationMapByName.get(application.fullName);
            const lastJsonApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
            const applicationReferences = ensureChildArray(newApplicationReferenceMap, applicationName);
            const applicationReferenceLookup = ensureChildJsSet(newApplicationReferenceLookup, applicationName);
            for (const jsonReferencedApplication of lastJsonApplicationVersion.referencedApplications) {
                const referencedFullApplicationName = this.dbApplicationUtils.
                    getFullApplicationName(jsonReferencedApplication);
                let referencedApplicationVersion = newApplicationVersionMapByApplicationName.get(referencedFullApplicationName);
                if (!referencedApplicationVersion) {
                    referencedApplicationVersion = await this.applicationLocator.locateLatestApplicationVersionByApplicationName(referencedFullApplicationName, terminalStore);
                    if (!referencedApplicationVersion) {
                        throw new Error(`Could not locate application:
						${referencedFullApplicationName}
						in either existing applications or applications being currently processed`);
                    }
                    this.addApplicationVersionObjects(referencedApplicationVersion, allDdlObjects.all);
                    if (deepTraverseReferences) {
                        // This should cause another iteration over the outer loop to process newly added ApplicationVersion
                        jsonApplicationMapByName.set(referencedFullApplicationName, referencedApplicationVersion.jsonApplication);
                        newApplicationVersionMapByApplicationName.set(referencedFullApplicationName, referencedApplicationVersion);
                    }
                }
                const applicationReference = {
                    index: jsonReferencedApplication.index,
                    ownApplicationVersion,
                    referencedApplicationVersion
                };
                if (!applicationReferenceLookup.has(jsonReferencedApplication.index)) {
                    applicationReferenceLookup.add(jsonReferencedApplication.index);
                    newApplicationReferences.push(applicationReference);
                    applicationReferences.push(applicationReference);
                }
            }
        }
        return {
            newApplicationReferenceMap,
            newApplicationReferences
        };
    }
    composeApplicationEntities(jsonApplication, applicationVersion, newEntitiesMapByApplicationName, newEntities) {
        const applicationName = this.dbApplicationUtils.
            getFullApplicationName(jsonApplication);
        let index = 0;
        // TODO: verify that jsonApplication.versions is always ordered ascending
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const newApplicationEntities = [];
        for (const jsonEntity of jsonEntities) {
            const entity = {
                id: ++this.terminalStore.getLastIds().entities,
                index: index++,
                applicationVersion,
                isLocal: jsonEntity.isLocal,
                isRepositoryEntity: jsonEntity.isRepositoryEntity,
                name: jsonEntity.name,
                tableConfig: jsonEntity.tableConfig,
                // columns: [],
                // columnMap: {},
                // idColumns: [],
                // idColumnMap: {},
                // relations: [],
                // properties: [],
                // propertyMap: {}
            };
            // applicationVersion.entities.push(entity)
            newApplicationEntities.push(entity);
            newEntities.push(entity);
        }
        newEntitiesMapByApplicationName.set(applicationName, newApplicationEntities);
        applicationVersion.entities = newApplicationEntities;
    }
    composeApplicationProperties(jsonApplication, newProperties, newPropertiesMap, newEntitiesMapByApplicationName) {
        const applicationName = this.dbApplicationUtils.
            getFullApplicationName(jsonApplication);
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const entities = newEntitiesMapByApplicationName.get(applicationName);
        const propertiesByEntityIndex = ensureChildArray(newPropertiesMap, applicationName);
        jsonEntities.forEach((jsonEntity, tableIndex) => {
            const entity = entities[tableIndex];
            const propertiesForEntity = [];
            propertiesByEntityIndex[tableIndex]
                = propertiesForEntity;
            let index = 0;
            for (const jsonProperty of jsonEntity.properties) {
                const property = {
                    id: ++this.terminalStore.getLastIds().properties,
                    index,
                    entity,
                    name: jsonProperty.name,
                    isId: jsonProperty.isId,
                };
                propertiesForEntity[index] = property;
                index++;
                newProperties.push(property);
            }
        });
    }
    async composeApplicationRelations(jsonApplication, newRelations, newRelationsMap, newEntitiesMapByApplicationName, newPropertiesMap, newApplicationReferenceMap, terminalStore, allDdlObjects) {
        const applicationName = this.dbApplicationUtils.
            getFullApplicationName(jsonApplication);
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const entitiesForApplication = newEntitiesMapByApplicationName.get(applicationName);
        const propertiesByEntityIndex = newPropertiesMap.get(applicationName);
        const relationsByEntityIndex = ensureChildArray(newRelationsMap, applicationName);
        const referencesForApplication = newApplicationReferenceMap.get(applicationName);
        for (let tableIndex = 0; tableIndex < jsonEntities.length; tableIndex++) {
            const jsonEntity = jsonEntities[tableIndex];
            const propertiesForEntity = propertiesByEntityIndex[tableIndex];
            const relationsForEntity = [];
            relationsByEntityIndex[tableIndex]
                = relationsForEntity;
            const entity = entitiesForApplication[tableIndex];
            let index = 0;
            for (const jsonRelation of jsonEntity.relations) {
                const property = propertiesForEntity[jsonRelation.propertyRef.index];
                let referencedApplicationName = applicationName;
                if (jsonRelation.relationTableApplicationIndex
                    || jsonRelation.relationTableApplicationIndex === 0) {
                    const applicationReference = referencesForApplication[jsonRelation.relationTableApplicationIndex];
                    referencedApplicationName = applicationReference.referencedApplicationVersion.application.fullName;
                }
                let entitiesArray = newEntitiesMapByApplicationName.get(referencedApplicationName);
                if (!entitiesArray) {
                    const applicationVersion = await this.getExistingLatestApplicationVersion(referencedApplicationName, allDdlObjects);
                    entitiesArray = applicationVersion.entities;
                }
                const relationEntity = entitiesArray[jsonRelation.relationTableIndex];
                const relation = {
                    entity,
                    id: ++terminalStore.getLastIds().relations,
                    index,
                    foreignKey: jsonRelation.foreignKey,
                    isId: property.isId,
                    manyToOneElems: jsonRelation.manyToOneElems,
                    property,
                    oneToManyElems: jsonRelation.oneToManyElems,
                    relationEntity,
                    relationType: jsonRelation.relationType,
                    // oneRelationColumns: [],
                    // manyRelationColumns: []
                };
                // property.relation               = [relation]
                // relationEntity.relations.push(relation)
                relationsForEntity[index] = relation;
                index++;
                newRelations.push(relation);
            }
        }
    }
    composeApplicationColumns(jsonApplication, newColumns, newColumnsMap, newPropertyColumns, newEntitiesMapByApplicationName, newPropertiesMap) {
        const applicationName = this.dbApplicationUtils.
            getFullApplicationName(jsonApplication);
        const columnsByTable = [];
        newColumnsMap.set(applicationName, columnsByTable);
        const entitiesForApplication = newEntitiesMapByApplicationName.get(applicationName);
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const propertiesForApplication = newPropertiesMap.get(applicationName);
        jsonEntities.forEach((jsonEntity, tableIndex) => {
            const entity = entitiesForApplication[tableIndex];
            const columnsForTable = [];
            columnsByTable[tableIndex] = columnsForTable;
            const idColumnIndexes = [];
            jsonEntity.idColumnRefs.forEach((idColumnRef, idColumnIndex) => {
                idColumnIndexes[idColumnRef.index] = idColumnIndex;
            });
            const propertiesForEntity = propertiesForApplication[tableIndex];
            jsonEntity.columns.forEach((jsonColumn, index) => {
                const idColumndIndex = idColumnIndexes[index];
                const column = {
                    allocationSize: jsonColumn.allocationSize,
                    entity,
                    id: ++this.terminalStore.getLastIds().columns,
                    idIndex: idColumndIndex,
                    index,
                    isGenerated: jsonColumn.isGenerated,
                    manyRelationColumns: [],
                    name: jsonColumn.name,
                    notNull: jsonColumn.notNull,
                    oneRelationColumns: [],
                    precision: jsonColumn.precision,
                    propertyColumns: [],
                    scale: jsonColumn.scale,
                    type: jsonColumn.type,
                };
                columnsForTable[index] = column;
                newColumns.push(column);
                jsonColumn.propertyRefs.forEach((propertyReference) => {
                    const property = propertiesForEntity[propertyReference.index];
                    const propertyColumn = {
                        column,
                        property
                    };
                    newPropertyColumns.push(propertyColumn);
                });
            });
        });
    }
    async composeApplicationRelationColumns(jsonApplication, newRelationColumns, newApplicationVersionMapByApplicationName, newApplicationReferenceMap, newRelationsMap, newColumnsMap, terminalStore, allDdlObjects) {
        const applicationName = this.dbApplicationUtils.
            getFullApplicationName(jsonApplication);
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const columnsForApplication = newColumnsMap.get(applicationName);
        const relationsForApplication = newRelationsMap.get(applicationName);
        const applicationReferencesForApplication = newApplicationReferenceMap.get(applicationName);
        for (let tableIndex = 0; tableIndex < jsonEntities.length; tableIndex++) {
            const jsonEntity = jsonEntities[tableIndex];
            const columnsForEntity = columnsForApplication[tableIndex];
            const relationsForEntity = relationsForApplication[tableIndex];
            for (let index = 0; index < jsonEntity.columns.length; index++) {
                const jsonColumn = jsonEntity.columns[index];
                const manyColumn = columnsForEntity[index];
                for (const jsonRelationColumn of jsonColumn.manyRelationColumnRefs) {
                    const manyRelation = relationsForEntity[jsonRelationColumn.manyRelationIndex];
                    // if (!manyRelation.manyRelationColumns) {
                    // 	manyRelation.manyRelationColumns = []
                    // }
                    let oneRelationApplicationVersion;
                    if (jsonRelationColumn.oneApplicationIndex
                        || jsonRelationColumn.oneApplicationIndex === 0) {
                        const applicationReference = applicationReferencesForApplication[jsonRelationColumn.oneApplicationIndex];
                        oneRelationApplicationVersion = applicationReference.referencedApplicationVersion;
                    }
                    else {
                        oneRelationApplicationVersion = newApplicationVersionMapByApplicationName.get(applicationName);
                    }
                    const referencedApplicationName = oneRelationApplicationVersion.application.fullName;
                    const oneTableColumnsMapForApplication = newColumnsMap.get(referencedApplicationName);
                    let oneTableColumns;
                    let oneTableRelations;
                    if (oneTableColumnsMapForApplication) {
                        oneTableColumns = oneTableColumnsMapForApplication[jsonRelationColumn.oneTableIndex];
                        oneTableRelations = newRelationsMap.get(oneRelationApplicationVersion.application.fullName)[jsonRelationColumn.oneTableIndex];
                    }
                    else {
                        const applicationVersion = await this.getExistingLatestApplicationVersion(referencedApplicationName, allDdlObjects);
                        const entitiesArray = applicationVersion.entities;
                        const entity = entitiesArray[jsonRelationColumn.oneTableIndex];
                        oneTableColumns = entity.columns;
                        oneTableRelations = entity.relations;
                    }
                    const oneColumn = oneTableColumns[jsonRelationColumn.oneColumnIndex];
                    // if (!jsonRelationColumn.oneApplicationIndex
                    // 	&& !oneColumn.oneRelationColumns) {
                    // 	oneColumn.oneRelationColumns = []
                    // }
                    const oneRelation = oneTableRelations[jsonRelationColumn.oneRelationIndex];
                    // if (!jsonRelationColumn.oneApplicationIndex
                    // 	&& !oneRelation.oneRelationColumns) {
                    // 	oneRelation.oneRelationColumns = []
                    // }
                    const relationColumn = {
                        id: ++terminalStore.getLastIds().relationColumns,
                        manyColumn,
                        manyRelation,
                        oneColumn,
                        oneRelation,
                        // FIXME: figure out how to many OneToMany-only relations
                        parentRelation: manyRelation
                    };
                    newRelationColumns.push(relationColumn);
                }
                manyColumn.manyRelationColumns = []; // relationColumns
            }
        }
    }
};
__decorate$i([
    Inject()
], ApplicationComposer.prototype, "applicationLocator", void 0);
__decorate$i([
    Inject()
], ApplicationComposer.prototype, "dbApplicationUtils", void 0);
__decorate$i([
    Inject()
], ApplicationComposer.prototype, "domainRetriever", void 0);
__decorate$i([
    Inject()
], ApplicationComposer.prototype, "terminalStore", void 0);
ApplicationComposer = __decorate$i([
    Injected()
], ApplicationComposer);

var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationRecorder = class ApplicationRecorder {
    async record(ddlObjects, 
    // normalOperation: boolean,
    context) {
        await this.transactionManager.transactInternal(async () => {
            // FIXME: add support for real application versioning
            this.setDefaultVersioning(ddlObjects);
            const domainDao = await this.getdomainDaoAsync();
            await domainDao.checkAndInsertIfNeeded(ddlObjects.domains, context);
            await this.applicationDao.insert(ddlObjects.applications, context);
            await this.applicationVersionDao.insert(ddlObjects.applicationVersions, context);
            await this.applicationReferenceDao.insert(ddlObjects.applicationReferences, context);
            await this.applicationEntityDao.insert(ddlObjects.entities, context);
            await this.applicationPropertyDao.insert(ddlObjects.properties, context);
            await this.applicationRelationDao.insert(ddlObjects.relations, context);
            await this.applicationColumnDao.insert(ddlObjects.columns, context);
            await this.applicationPropertyColumnDao.insert(ddlObjects.propertyColumns, context);
            await this.applicationRelationColumnDao.insert(ddlObjects.relationColumns, context);
        }, context);
    }
    setDefaultVersioning(ddlObjects) {
        for (const applicationReference of ddlObjects.applicationReferences) {
            applicationReference.deprecatedSinceVersion = null;
            applicationReference.removedInVersion = null;
            applicationReference.sinceVersion = applicationReference.ownApplicationVersion;
        }
        for (const entity of ddlObjects.entities) {
            entity.deprecatedSinceVersion = null;
            entity.removedInVersion = null;
            entity.sinceVersion = entity.applicationVersion;
        }
        for (const property of ddlObjects.properties) {
            property.deprecatedSinceVersion = null;
            property.removedInVersion = null;
            property.sinceVersion = property.entity.applicationVersion;
        }
        for (const relation of ddlObjects.relations) {
            relation.deprecatedSinceVersion = null;
            relation.removedInVersion = null;
            relation.sinceVersion = relation.entity.applicationVersion;
        }
        for (const column of ddlObjects.columns) {
            column.deprecatedSinceVersion = null;
            column.removedInVersion = null;
            column.sinceVersion = column.entity.applicationVersion;
        }
        for (const propertyColumn of ddlObjects.propertyColumns) {
            propertyColumn.deprecatedSinceVersion = null;
            propertyColumn.removedInVersion = null;
            propertyColumn.sinceVersion = propertyColumn.property.entity.applicationVersion;
        }
        for (const relationColumn of ddlObjects.relationColumns) {
            relationColumn.deprecatedSinceVersion = null;
            relationColumn.removedInVersion = null;
            relationColumn.sinceVersion = relationColumn.parentRelation.entity.applicationVersion;
        }
    }
    async bulkCreate(dao, entities, context) {
        await dao.save(entities, context);
    }
};
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "applicationColumnDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "applicationDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "applicationEntityDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "applicationPropertyColumnDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "applicationPropertyDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "applicationReferenceDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "applicationRelationColumnDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "applicationRelationDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "applicationVersionDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "domainDao", void 0);
__decorate$h([
    Inject()
], ApplicationRecorder.prototype, "transactionManager", void 0);
ApplicationRecorder = __decorate$h([
    Injected()
], ApplicationRecorder);

var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let Sequence = class Sequence {
};
__decorate$g([
    Id(),
    Column(),
    DbNumber()
], Sequence.prototype, "applicationIndex", void 0);
__decorate$g([
    Id(),
    Column(),
    DbNumber()
], Sequence.prototype, "tableIndex", void 0);
__decorate$g([
    Id(),
    Column(),
    DbNumber()
], Sequence.prototype, "columnIndex", void 0);
__decorate$g([
    Column()
], Sequence.prototype, "incrementBy", void 0);
__decorate$g([
    Column()
], Sequence.prototype, "currentValue", void 0);
Sequence = __decorate$g([
    Entity(),
    Table()
], Sequence);

var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * No actual records are inserted into this table, only used for the sequence
 */
let SystemWideOperationId = class SystemWideOperationId {
};
__decorate$f([
    Id(),
    Column(),
    DbNumber(),
    GeneratedValue()
], SystemWideOperationId.prototype, "id", void 0);
SystemWideOperationId = __decorate$f([
    Entity(),
    Table()
], SystemWideOperationId);

var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A record of the Terminal running (being up at a given point in time)
 */
let TerminalRun = class TerminalRun {
};
__decorate$e([
    Id(),
    GeneratedValue()
], TerminalRun.prototype, "id", void 0);
__decorate$e([
    Column()
], TerminalRun.prototype, "createTimestamp", void 0);
__decorate$e([
    Column()
], TerminalRun.prototype, "randomNumber", void 0);
TerminalRun = __decorate$e([
    Entity(),
    Table()
], TerminalRun);

const __constructors__ = {
    Sequence: Sequence,
    SystemWideOperationId: SystemWideOperationId,
    TerminalRun: TerminalRun
};
const Q_APPLICATION = {
    __constructors__,
    domain: 'air',
    name: '@airport/airport-code'
};
const Q = Q_APPLICATION;
function duoDiSet(dbEntityId) {
    return duoDiSet$5(Q.__dbApplication__, dbEntityId);
}
DEPENDENCY_INJECTION.db().eventuallyGet(AIRPORT_DATABASE).then((airportDatabase) => {
    airportDatabase.setQApplication(Q_APPLICATION);
});

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q);
    }
}
class BaseSequenceDao extends SQDIDao {
    constructor() {
        super(0);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet(0);
    }
}
BaseSequenceDao.Find = new DaoQueryDecorators();
BaseSequenceDao.FindOne = new DaoQueryDecorators();
BaseSequenceDao.Search = new DaoQueryDecorators();
BaseSequenceDao.SearchOne = new DaoQueryDecorators();
class BaseSystemWideOperationIdDao extends SQDIDao {
    constructor() {
        super(1);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet(1);
    }
}
BaseSystemWideOperationIdDao.Find = new DaoQueryDecorators();
BaseSystemWideOperationIdDao.FindOne = new DaoQueryDecorators();
BaseSystemWideOperationIdDao.Search = new DaoQueryDecorators();
BaseSystemWideOperationIdDao.SearchOne = new DaoQueryDecorators();
class BaseTerminalRunDao extends SQDIDao {
    constructor() {
        super(2);
    }
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return duoDiSet(2);
    }
}
BaseTerminalRunDao.Find = new DaoQueryDecorators();
BaseTerminalRunDao.FindOne = new DaoQueryDecorators();
BaseTerminalRunDao.Search = new DaoQueryDecorators();
BaseTerminalRunDao.SearchOne = new DaoQueryDecorators();

var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TerminalRunDao = class TerminalRunDao extends BaseTerminalRunDao {
};
TerminalRunDao = __decorate$d([
    Injected()
], TerminalRunDao);

var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SequenceDao = class SequenceDao extends BaseSequenceDao {
    static diSet() {
        return Q.__dbApplication__ && Q.__dbApplication__.currentVersion[0]
            .applicationVersion.entities[0];
    }
    async incrementCurrentValues(context) {
        const s = Q.Sequence;
        await this.db.updateWhere({
            update: s,
            set: {
                currentValue: plus(s.currentValue, s.incrementBy)
            }
        }, context);
    }
    async incrementSequence(context) {
        const s = Q.Sequence;
        await this.db.updateWhere({
            update: s,
            set: {
                currentValue: plus(s.currentValue, s.incrementBy)
            }
        }, context);
    }
};
SequenceDao = __decorate$c([
    Injected()
], SequenceDao);

const airportCode = lib$1('airport-code');
const SEQUENCE_DAO = airportCode.token({
    class: SequenceDao,
    interface: 'ISequenceDao',
    token: 'SEQUENCE_DAO'
});
airportCode.token({
    class: TerminalRunDao,
    interface: 'ITerminalRunDao',
    token: 'TERMINAL_RUN_DAO'
});

var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// TODO: probably not needed, included application source populates itself
// May be needed to populate applications from the database
let AirportDatabasePopulator = class AirportDatabasePopulator {
    populate() {
        // FIXME: implement
        // this.airDb.applications
        // this.airDb.qApplications
    }
};
AirportDatabasePopulator = __decorate$b([
    Injected()
], AirportDatabasePopulator);

var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DdlObjectLinker = class DdlObjectLinker {
    link(allDdlObjects) {
        const { all, allApplicationVersionsByIds, added } = allDdlObjects;
        const { latestApplicationVersions, properties, relations, applicationReferences, applications } = added;
        this.linkDomainsAndApplicationsAndVersions(allApplicationVersionsByIds, all.domains, applications, latestApplicationVersions, applicationReferences);
        const entityArrayById = this.linkEntities(allApplicationVersionsByIds, all.entities, added.entities);
        const { propertyMapById, relationMapById } = this.linkPropertiesAndRelations(properties, relations, entityArrayById);
        this.linkColumns(propertyMapById, relationMapById, allDdlObjects, entityArrayById);
    }
    linkDomainsAndApplicationsAndVersions(allApplicationVersionsByIds, domains, applications, latestApplicationVersions, applicationReferences) {
        const domainMapById = new Map();
        domains.forEach((domain) => {
            domainMapById.set(domain.id, domain);
        });
        const applicationMapByIndex = new Map();
        applications.forEach((application) => {
            applicationMapByIndex.set(application.index, application);
            const domain = domainMapById.get(application.domain.id);
            application.domain = domain;
            domain.applications.push(application);
        });
        latestApplicationVersions.forEach((applicationVersion) => {
            const application = applicationMapByIndex.get(applicationVersion.application.index);
            let applicationCurrentVersion = {
                application,
                applicationVersion
            };
            application.currentVersion = [applicationCurrentVersion];
            application.versions = [applicationVersion];
            applicationVersion.application = application;
            applicationVersion.entities = [];
            applicationVersion.references = [];
            applicationVersion.referencedBy = [];
            applicationVersion.entityMapByName = {};
            applicationVersion.referencesMapByName = {};
            applicationVersion.referencedByMapByName = {};
        });
        applicationReferences.forEach((applicationReference) => {
            const ownApplicationVersion = allApplicationVersionsByIds[applicationReference.ownApplicationVersion.id];
            const referencedApplicationVersion = allApplicationVersionsByIds[applicationReference.referencedApplicationVersion.id];
            ownApplicationVersion.references[applicationReference.index] = applicationReference;
            ownApplicationVersion.referencesMapByName[referencedApplicationVersion.application.fullName] = applicationReference;
            referencedApplicationVersion.referencedBy.push(applicationReference);
            referencedApplicationVersion.referencedByMapByName[ownApplicationVersion.application.fullName] = applicationReference;
            applicationReference.ownApplicationVersion = ownApplicationVersion;
            applicationReference.referencedApplicationVersion = referencedApplicationVersion;
        });
    }
    linkEntities(allApplicationVersionsByIds, allEntities, // All of the entities of newly created applications
    addedEntities // All of the entities of newly created applications
    // from the latest available versions
    ) {
        const entityArrayById = [];
        allEntities.forEach((entity) => {
            entityArrayById[entity.id] = entity;
        });
        addedEntities.forEach((entity) => {
            const applicationVersion = allApplicationVersionsByIds[entity.applicationVersion.id];
            entity.applicationVersion = applicationVersion;
            applicationVersion.entities[entity.index] = entity;
            applicationVersion.entityMapByName[entity.name] = entity;
            entityArrayById[entity.id] = entity;
            entity.columns = [];
            entity.properties = [];
            entity.relations = [];
            entity.relationReferences = [];
            entity.columnMap = {};
            entity.idColumns = [];
            entity.idColumnMap = {};
            entity.propertyMap = {};
        });
        return entityArrayById;
    }
    linkPropertiesAndRelations(properties, relations, entityArrayById) {
        const propertyMapById = new Map();
        properties.forEach((property) => {
            // Entity is already property wired in
            const entity = entityArrayById[property.entity.id];
            entity.properties[property.index] = property;
            entity.propertyMap[property.name] = property;
            property.entity = entity;
            property.propertyColumns = [];
            propertyMapById.set(property.id, property);
        });
        const relationMapById = new Map();
        relations.forEach((relation) => {
            const entity = entityArrayById[relation.entity.id];
            entity.relations[relation.index] = relation;
            let relationEntity = entityArrayById[relation.relationEntity.id];
            if (!relationEntity) {
                relationEntity = this.terminalStore.getAllEntities()[relation.relationEntity.id];
            }
            relationEntity.relationReferences.push(relation);
            const property = propertyMapById.get(relation.property.id);
            relation.property = property;
            property.relation = [relation];
            relation.entity = entity;
            relation.relationEntity = relationEntity;
            relation.manyRelationColumns = [];
            relation.oneRelationColumns = [];
            relationMapById.set(relation.id, relation);
        });
        return {
            propertyMapById, relationMapById
        };
    }
    linkColumns(propertyMapById, relationMapById, allDdlObjects, entityArrayById) {
        const columnMapById = new Map();
        allDdlObjects.all.columns.forEach((column) => {
            columnMapById.set(column.id, column);
        });
        allDdlObjects.added.columns.forEach((column) => {
            columnMapById.set(column.id, column);
            const entity = entityArrayById[column.entity.id];
            entity.columns[column.index] = column;
            entity.columnMap[column.name] = column;
            if (column.idIndex || column.idIndex === 0) {
                entity.idColumns[column.idIndex] = column;
                entity.idColumnMap[column.name] = column;
            }
            column.entity = entity;
        });
        allDdlObjects.added.propertyColumns.forEach((propertyColumn) => {
            const column = columnMapById.get(propertyColumn.column.id);
            column.propertyColumns.push(propertyColumn);
            const property = propertyMapById.get(propertyColumn.property.id);
            property.propertyColumns.push(propertyColumn);
            propertyColumn.column = column;
            propertyColumn.property = property;
        });
        allDdlObjects.added.relationColumns.forEach((relationColumn) => {
            let manyColumn = columnMapById.get(relationColumn.manyColumn.id);
            if (!manyColumn) {
                manyColumn = this.terminalStore.getAllColumns()[relationColumn.manyColumn.id];
            }
            manyColumn.manyRelationColumns.push(relationColumn);
            let oneColumn = columnMapById.get(relationColumn.oneColumn.id);
            if (!oneColumn) {
                oneColumn = this.terminalStore.getAllColumns()[relationColumn.oneColumn.id];
            }
            oneColumn.oneRelationColumns.push(relationColumn);
            let manyRelation;
            if (relationColumn.manyRelation && relationColumn.manyRelation.id) {
                manyRelation = relationMapById.get(relationColumn.manyRelation.id);
                if (!manyRelation) {
                    manyRelation = this.terminalStore.getAllRelations()[relationColumn.manyRelation.id];
                }
                manyRelation.manyRelationColumns.push(relationColumn);
            }
            let oneRelation;
            if (relationColumn.oneRelation && relationColumn.oneRelation.id) {
                oneRelation = relationMapById.get(relationColumn.oneRelation.id);
                if (!oneRelation) {
                    oneRelation = this.terminalStore.getAllRelations()[relationColumn.oneRelation.id];
                }
                oneRelation.oneRelationColumns.push(relationColumn);
            }
            relationColumn.manyColumn = manyColumn;
            relationColumn.manyRelation = manyRelation;
            relationColumn.oneColumn = oneColumn;
            relationColumn.oneRelation = oneRelation;
        });
    }
};
__decorate$a([
    Inject()
], DdlObjectLinker.prototype, "terminalStore", void 0);
DdlObjectLinker = __decorate$a([
    Injected()
], DdlObjectLinker);

var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DdlObjectRetriever = class DdlObjectRetriever {
    async retrieveDdlObjects() {
        const applications = await this.applicationDao.findAllActive();
        const applicationIndexes = [];
        const domainIdSet = new Set();
        applications.forEach(application => {
            applicationIndexes.push(application.index);
            domainIdSet.add(application.domain.id);
        });
        applications.sort((application1, application2) => {
            return application1.index - application2.index;
        });
        const domains = await this.domainDao.findByIdIn(Array.from(domainIdSet));
        const allApplicationVersions = await this.applicationVersionDao
            .findAllActiveOrderByApplicationIndexAndId();
        let lastApplicationIndex;
        // const allApplicationVersionsByIds: IApplicationVersion[] = []
        const latestApplicationVersions = [];
        const applicationVersions = [];
        for (const applicationVersion of allApplicationVersions) {
            if (applicationVersion.application.index !== lastApplicationIndex) {
                latestApplicationVersions.push(applicationVersion);
            }
            // allApplicationVersionsByIds[applicationVersion.id] = applicationVersion
            lastApplicationIndex = applicationVersion.application.index;
            applicationVersions.push(applicationVersion);
        }
        const latestApplicationVersionIds = latestApplicationVersions.map(applicationVersion => applicationVersion.id);
        const applicationReferences = await this.applicationReferenceDao
            .findAllForApplicationVersions(latestApplicationVersionIds);
        const entities = await this.applicationEntityDao
            .findAllForApplicationVersions(latestApplicationVersionIds);
        const entityIds = entities.map(entity => entity.id);
        /*
        const entityIds = entities.map(
    entity => {
        if (entity.tableConfig) {
            entity.tableConfig = JSON.parse(entity.tableConfig as any)
        }
        return entity.id
    })
         */
        const properties = await this.applicationPropertyDao
            .findAllForEntities(entityIds);
        const propertyIds = properties.map(property => property.id);
        const relations = await this.applicationRelationDao
            .findAllForProperties(propertyIds);
        const columns = await this.applicationColumnDao
            .findAllForEntities(entityIds);
        const columnIds = columns.map(column => column.id);
        const propertyColumns = await this.applicationPropertyColumnDao
            .findAllForColumns(columnIds);
        const relationColumns = await this.applicationRelationColumnDao
            .findAllForColumns(columnIds);
        const lastTerminalState = this.terminalStore.getTerminalState();
        const lastIds = {
            columns: columns.length,
            domains: domains.length,
            entities: entities.length,
            properties: properties.length,
            propertyColumns: propertyColumns.length,
            relationColumns: relationColumns.length,
            relations: relations.length,
            applications: applications.length,
            applicationVersions: applicationVersions.length,
        };
        this.terminalStore.state.next({
            ...lastTerminalState,
            lastIds
        });
        return {
            // allDomains: domains,
            // allApplications: applications,
            // allApplicationVersionsByIds,
            columns,
            domains,
            entities,
            latestApplicationVersions,
            properties,
            propertyColumns,
            relationColumns,
            relations,
            applicationReferences,
            applications,
            applicationVersions
        };
    }
};
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "applicationColumnDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "applicationDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "applicationEntityDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "applicationPropertyColumnDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "applicationPropertyDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "applicationReferenceDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "applicationRelationColumnDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "applicationRelationDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "applicationVersionDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "domainDao", void 0);
__decorate$9([
    Inject()
], DdlObjectRetriever.prototype, "terminalStore", void 0);
DdlObjectRetriever = __decorate$9([
    Injected()
], DdlObjectRetriever);

var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let QueryEntityClassCreator = class QueryEntityClassCreator {
    createAll(applications) {
        const applicationsToCreate = orderApplicationsInOrderOfPrecedence(applications);
        applicationsToCreate.map(dbApplication => this.create(dbApplication));
    }
    create(dbApplication) {
        let qApplication = this.airportDatabase.QM[dbApplication.fullName];
        // If the Application API source has already been loaded
        if (qApplication) {
            qApplication.__dbApplication__ = dbApplication;
        }
        else {
            qApplication = {
                __constructors__: {},
                __qConstructors__: {},
                __dbApplication__: dbApplication,
                name: dbApplication.name,
                domain: dbApplication.domain.name
            };
            this.airportDatabase.QM[dbApplication.fullName] = qApplication;
        }
        this.airportDatabase.Q[dbApplication.index] = qApplication;
        setQApplicationEntities(dbApplication, qApplication, this.airportDatabase.qApplications, this.applicationUtils, this.relationManager);
        return qApplication;
    }
};
__decorate$8([
    Inject()
], QueryEntityClassCreator.prototype, "airportDatabase", void 0);
__decorate$8([
    Inject()
], QueryEntityClassCreator.prototype, "applicationUtils", void 0);
__decorate$8([
    Inject()
], QueryEntityClassCreator.prototype, "relationManager", void 0);
QueryEntityClassCreator = __decorate$8([
    Injected()
], QueryEntityClassCreator);

var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let QueryObjectInitializer = class QueryObjectInitializer {
    generateQObjectsAndPopulateStore(allDdlObjects) {
        this.ddlObjectLinker.link(allDdlObjects);
        this.queryEntityClassCreator.createAll(allDdlObjects.all.applications);
        const lastTerminalState = this.terminalStore.getTerminalState();
        const existingDomainMap = {};
        for (const domain of lastTerminalState.domains) {
            existingDomainMap[domain.name] = domain;
        }
        for (const domain of allDdlObjects.added.domains) {
            delete existingDomainMap[domain.name];
        }
        const unmodifiedDomains = [];
        for (const domainName in existingDomainMap) {
            unmodifiedDomains.push(existingDomainMap[domainName]);
        }
        const existingApplicationMap = {};
        for (const application of lastTerminalState.applications) {
            existingApplicationMap[application.fullName] = application;
        }
        for (const application of allDdlObjects.added.applications) {
            delete existingApplicationMap[application.fullName];
        }
        const unmodifiedApplications = [];
        for (const applicationName in existingApplicationMap) {
            unmodifiedApplications.push(existingApplicationMap[applicationName]);
        }
        this.terminalStore.state.next({
            ...lastTerminalState,
            domains: [
                ...unmodifiedDomains,
                ...allDdlObjects.added.domains
            ],
            applications: [
                ...unmodifiedApplications,
                ...allDdlObjects.added.applications
            ]
        });
    }
    async initialize() {
        const ddlObjects = await this.ddlObjectRetriever.retrieveDdlObjects();
        const allApplicationVersionsByIds = [];
        for (const applicationVersion of ddlObjects.applicationVersions) {
            allApplicationVersionsByIds[applicationVersion.id] = applicationVersion;
        }
        let allDdlObjects = {
            all: ddlObjects,
            allApplicationVersionsByIds,
            added: ddlObjects
        };
        this.generateQObjectsAndPopulateStore(allDdlObjects);
        return allDdlObjects;
    }
};
__decorate$7([
    Inject()
], QueryObjectInitializer.prototype, "ddlObjectLinker", void 0);
__decorate$7([
    Inject()
], QueryObjectInitializer.prototype, "ddlObjectRetriever", void 0);
__decorate$7([
    Inject()
], QueryObjectInitializer.prototype, "queryEntityClassCreator", void 0);
__decorate$7([
    Inject()
], QueryObjectInitializer.prototype, "terminalStore", void 0);
QueryObjectInitializer = __decorate$7([
    Injected()
], QueryObjectInitializer);

const takeoff = lib$1('takeoff');
takeoff.token({
    class: AirportDatabasePopulator,
    interface: 'IAirportDatabasePopulator',
    token: 'AIRPORT_DATABASE_POPULATOR'
});
const DDL_OBJECT_LINKER = takeoff.token({
    class: DdlObjectLinker,
    interface: 'IDdlObjectLinker',
    token: 'DDL_OBJECT_LINKER'
});
const DDL_OBJECT_RETRIEVER = takeoff.token({
    class: DdlObjectRetriever,
    interface: 'IDdlObjectRetriever',
    token: 'DDL_OBJECT_RETRIEVER'
});
const QUERY_ENTITY_CLASS_CREATOR = takeoff.token({
    class: QueryEntityClassCreator,
    interface: 'IQueryEntityClassCreator',
    token: 'QUERY_ENTITY_CLASS_CREATOR'
});
const QUERY_OBJECT_INITIALIZER = takeoff.token({
    class: QueryObjectInitializer,
    interface: 'IQueryObjectInitializer',
    token: 'QUERY_OBJECT_INITIALIZER'
});
DDL_OBJECT_LINKER.setDependencies({
    terminalStore: TERMINAL_STORE
});
DDL_OBJECT_RETRIEVER.setDependencies({
    applicationColumnDao: APPLICATION_COLUMN_DAO,
    applicationDao: APPLICATION_DAO,
    applicationEntityDao: APPLICATION_ENTITY_DAO,
    applicationPropertyColumnDao: APPLICATION_PROPERTY_COLUMN_DAO,
    applicationPropertyDao: APPLICATION_PROPERTY_DAO,
    applicationReferenceDao: APPLICATION_REFERENCE_DAO,
    applicationRelationColumnDao: APPLICATION_RELATION_COLUMN_DAO,
    applicationRelationDao: APPLICATION_RELATION_DAO,
    applicationVersionDao: APPLICATION_VERSION_DAO,
    domainDao: DOMAIN_DAO
});
QUERY_ENTITY_CLASS_CREATOR.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: APPLICATION_UTILS,
    relationManager: RELATION_MANAGER,
});
QUERY_OBJECT_INITIALIZER.setDependencies({
    ddlObjectLinker: DDL_OBJECT_LINKER,
    ddlObjectRetriever: DDL_OBJECT_RETRIEVER,
    queryEntityClassCreator: QUERY_ENTITY_CLASS_CREATOR,
    terminalStore: TERMINAL_STORE
});

var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ApplicationInitializer = class ApplicationInitializer {
    addNewApplicationVersionsToAll(ddlObjects) {
        for (const applicationVersion of ddlObjects.added.applicationVersions) {
            ddlObjects.allApplicationVersionsByIds[applicationVersion.id] = applicationVersion;
        }
    }
    async hydrate(jsonApplications, context) {
        await this.stage(jsonApplications, context);
        // Hydrate all DDL objects and Sequences
        const ddlObjects = await this.queryObjectInitializer.initialize();
        this.addNewApplicationVersionsToAll(ddlObjects);
        this.setAirDbApplications(ddlObjects);
        await this.sequenceGenerator.initialize(context);
    }
    /*
     * Initialization scenarios:
     *
     * Brand new install - initialize BLUEPRINT applications
     * Install new App - initialize New application (and any new dependency applications)
     * Reload existing install - hydrate all applications
     * Reload exiting App - nothing to do
     */
    async initialize(jsonApplications, context, checkDependencies, loadExistingApplications) {
        const applicationsWithValidDependencies = await this.
            getApplicationsWithValidDependencies(jsonApplications, checkDependencies);
        const existingApplicationMap = new Map();
        if (loadExistingApplications) {
            const applications = await this.applicationDao.findAllWithJson();
            for (const application of applications) {
                existingApplicationMap.set(application.fullName, application);
            }
        }
        const newJsonApplicationMap = new Map();
        for (const jsonApplication of jsonApplications) {
            const existingApplication = existingApplicationMap.get(this.dbApplicationUtils.
                getFullApplicationName(jsonApplication));
            if (existingApplication) {
                jsonApplication.lastIds = existingApplication.versions[0].jsonApplication.lastIds;
            }
            else {
                newJsonApplicationMap.set(this.dbApplicationUtils.
                    getFullApplicationName(jsonApplication), jsonApplication);
            }
        }
        let checkedApplicationsWithValidDependencies = [];
        for (const jsonApplication of applicationsWithValidDependencies) {
            const existingApplication = existingApplicationMap.get(this.dbApplicationUtils.
                getFullApplicationName(jsonApplication));
            if (!existingApplication) {
                checkedApplicationsWithValidDependencies.push(jsonApplication);
                await this.applicationBuilder.build(jsonApplication, existingApplicationMap, newJsonApplicationMap, context);
            }
        }
        const allDdlObjects = await this.applicationComposer.compose(checkedApplicationsWithValidDependencies, {
            terminalStore: this.terminalStore
        });
        this.addNewApplicationVersionsToAll(allDdlObjects);
        this.queryObjectInitializer.generateQObjectsAndPopulateStore(allDdlObjects);
        this.setAirDbApplications(allDdlObjects);
        this.transactionManager.transactInternal(async (_transaction, context) => {
            const newSequences = await this.applicationBuilder.buildAllSequences(applicationsWithValidDependencies, context);
            await this.sequenceGenerator.initialize(context, newSequences);
            await this.applicationRecorder.record(allDdlObjects.added, context);
        }, context);
    }
    async initializeForAIRportApp(jsonApplication) {
        const applicationsWithValidDependencies = await this.
            getApplicationsWithValidDependencies([jsonApplication], false);
        const ddlObjects = await this.applicationComposer.compose(applicationsWithValidDependencies, {
            deepTraverseReferences: true,
            terminalStore: this.terminalStore
        });
        this.addNewApplicationVersionsToAll(ddlObjects);
        this.queryObjectInitializer.generateQObjectsAndPopulateStore(ddlObjects);
        this.setAirDbApplications(ddlObjects);
    }
    async stage(jsonApplications, context) {
        // Temporarily Initialize application DDL objects and Sequences to allow for normal hydration
        const tempDdlObjects = await this.applicationComposer.compose(jsonApplications, {
            terminalStore: this.terminalStore
        });
        this.addNewApplicationVersionsToAll(tempDdlObjects);
        this.queryObjectInitializer.generateQObjectsAndPopulateStore(tempDdlObjects);
        this.setAirDbApplications(tempDdlObjects);
        const newSequences = await this.applicationBuilder.stageSequences(jsonApplications, context);
        await this.sequenceGenerator.tempInitialize(context, newSequences);
    }
    async wait(milliseconds) {
        return new Promise((resolve, _reject) => {
            setTimeout(() => {
                resolve();
            }, milliseconds);
        });
    }
    async getApplicationsWithValidDependencies(jsonApplications, checkDependencies) {
        const jsonApplicationsToInstall = [];
        for (const jsonApplication of jsonApplications) {
            await this.applicationChecker.check(jsonApplication);
            const existingApplication = this.applicationLocator.locateExistingApplicationVersionRecord(jsonApplication, this.terminalStore);
            if (existingApplication) {
                // Nothing needs to be done, we already have this application version
                continue;
            }
            jsonApplicationsToInstall.push(jsonApplication);
        }
        let applicationsWithValidDependencies;
        if (checkDependencies) {
            const applicationReferenceCheckResults = await this.applicationChecker
                .checkDependencies(jsonApplicationsToInstall);
            if (applicationReferenceCheckResults.applicationsInNeedOfAdditionalDependencies.length) {
                // const
                for (let i = 0; i < applicationReferenceCheckResults.neededDependencies.length; i++) {
                    const neededDependency = applicationReferenceCheckResults.neededDependencies[i];
                    const fullApplicationName = this.dbApplicationUtils.
                        getFullApplicationName(neededDependency);
                    await this.nativeInitializeApplication(neededDependency.domain, neededDependency.name, fullApplicationName);
                }
            }
            applicationsWithValidDependencies = [
                ...applicationReferenceCheckResults.applicationsWithValidDependencies,
                ...applicationReferenceCheckResults.applicationsInNeedOfAdditionalDependencies
            ];
        }
        else {
            applicationsWithValidDependencies = jsonApplicationsToInstall;
        }
        return applicationsWithValidDependencies;
    }
    setAirDbApplications(ddlObjects) {
        for (let application of ddlObjects.all.applications) {
            this.airportDatabase.applications[application.index] = application;
        }
    }
};
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "airportDatabase", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "applicationBuilder", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "applicationChecker", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "applicationComposer", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "applicationDao", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "applicationLocator", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "applicationRecorder", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "dbApplicationUtils", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "queryObjectInitializer", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "sequenceGenerator", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "terminalStore", void 0);
__decorate$6([
    Inject()
], ApplicationInitializer.prototype, "transactionManager", void 0);
ApplicationInitializer = __decorate$6([
    Injected()
], ApplicationInitializer);

const landing = lib$1('landing');
const ABSTRACT_APPLICATION_INITIALIZER = landing.token({
    class: ApplicationInitializer,
    interface: 'class ApplicationInitializer',
    token: 'ABSTRACT_APPLICATION_INITIALIZER'
});
const APPLICATION_BUILDER = landing.token({
    class: null,
    interface: 'ISchemaBuilder',
    token: 'APPLICATION_BUILDER'
});
const APPLICATION_CHECKER = landing.token({
    class: ApplicationChecker,
    interface: 'IApplicationChecker',
    token: 'APPLICATION_CHECKER'
});
const APPLICATION_COMPOSER = landing.token({
    class: ApplicationComposer,
    interface: 'IApplicationComposer',
    token: 'APPLICATION_COMPOSER'
});
const APPLICATION_LOCATOR = landing.token({
    class: ApplicationLocator,
    interface: 'IApplicationLocator',
    token: 'APPLICATION_LOCATOR'
});
const APPLICATION_RECORDER = landing.token({
    class: ApplicationRecorder,
    interface: 'IApplicationRecorder',
    token: 'APPLICATION_RECORDER'
});
const SQL_SCHEMA_BUILDER = landing.token({
    class: SqlSchemaBuilder,
    interface: 'class SqlSchemaBuilder',
    token: 'SQL_SCHEMA_BUILDER'
});
ABSTRACT_APPLICATION_INITIALIZER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    applicationBuilder: APPLICATION_BUILDER,
    applicationChecker: APPLICATION_CHECKER,
    applicationComposer: APPLICATION_COMPOSER,
    applicationDao: APPLICATION_DAO,
    applicationLocator: APPLICATION_LOCATOR,
    applicationRecorder: APPLICATION_RECORDER,
    dbApplicationUtils: DB_APPLICATION_UTILS,
    queryObjectInitializer: QUERY_OBJECT_INITIALIZER,
    sequenceGenerator: SEQUENCE_GENERATOR,
    terminalStore: TERMINAL_STORE,
    transactionManager: TRANSACTION_MANAGER
});
APPLICATION_BUILDER.setDependencies({
    airportDatabase: AIRPORT_DATABASE
});
APPLICATION_CHECKER.setDependencies({
    applicationDao: APPLICATION_DAO,
    dbApplicationUtils: DB_APPLICATION_UTILS
});
APPLICATION_COMPOSER.setDependencies({
    applicationLocator: APPLICATION_LOCATOR,
    dbApplicationUtils: DB_APPLICATION_UTILS,
    domainRetriever: DOMAIN_RETRIEVER,
    terminalStore: TERMINAL_STORE
});
APPLICATION_LOCATOR.setDependencies({
    dbApplicationUtils: DB_APPLICATION_UTILS,
});
APPLICATION_RECORDER.setDependencies({
    applicationColumnDao: APPLICATION_COLUMN_DAO,
    applicationDao: APPLICATION_DAO,
    applicationEntityDao: APPLICATION_ENTITY_DAO,
    applicationPropertyColumnDao: APPLICATION_PROPERTY_COLUMN_DAO,
    applicationPropertyDao: APPLICATION_PROPERTY_DAO,
    applicationRecorder: APPLICATION_RECORDER,
    applicationReferenceDao: APPLICATION_REFERENCE_DAO,
    applicationRelationColumnDao: APPLICATION_RELATION_COLUMN_DAO,
    applicationRelationDao: APPLICATION_RELATION_DAO,
    applicationVersionDao: APPLICATION_VERSION_DAO,
    domainDao: DOMAIN_DAO,
    transactionManager: TRANSACTION_MANAGER
});
SQL_SCHEMA_BUILDER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    dbApplicationUtils: DB_APPLICATION_UTILS,
    sequenceDao: SEQUENCE_DAO,
    storeDriver: STORE_DRIVER
});

var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let WebApplicationInitializer = class WebApplicationInitializer extends ApplicationInitializer {
    constructor() {
        super(...arguments);
        this.applicationWindowMap = new Map();
        this.initializingApplicationMap = new Map();
    }
    async nativeInitializeApplication(domain, application, fullApplicationName) {
        if (this.terminalStore.getReceiver().initializedApps
            .has(fullApplicationName)) {
            return;
        }
        let appIframes = document.getElementsByName(fullApplicationName);
        let appIframe;
        if (!appIframes.length) {
            appIframe = document.createElement('iframe');
            appIframe.src = 'http://' + domain + '/AIRport/apps/'
                + application + '/index.html';
            appIframe.name = fullApplicationName;
            appIframe.style.display = 'none';
            document.body.appendChild(appIframe);
        }
        while (!this.terminalStore.getReceiver().initializedApps
            .has(fullApplicationName)) {
            await this.wait(100);
        }
        this.applicationWindowMap.set(fullApplicationName, appIframe.contentWindow);
        this.initializingApplicationMap.set(fullApplicationName, false);
    }
};
WebApplicationInitializer = __decorate$5([
    Injected()
], WebApplicationInitializer);

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let WebTransactionalReceiver = class WebTransactionalReceiver extends TransactionalReceiver {
    init() {
        const ownDomain = window.location.hostname;
        const mainDomainFragments = ownDomain.split('.');
        if (mainDomainFragments[0] === 'www'
            || mainDomainFragments[0].startsWith('random_')) {
            mainDomainFragments.splice(0, 1);
        }
        const domainPrefix = '.' + mainDomainFragments.join('.');
        // set domain to a random value so that an iframe cannot directly invoke logic in this domain
        if (document.domain !== 'localhost') {
            document.domain = 'random_' + Math.random() + '_' + Math.random() + domainPrefix;
        }
        const webReciever = this.terminalStore.getWebReceiver();
        webReciever.domainPrefix = domainPrefix;
        webReciever.mainDomainFragments = mainDomainFragments;
    }
    handleClientRequest(message) {
        if (message.__received__) {
            return;
        }
        message.__received__ = true;
        // All requests need to have a application signature
        // to know what application is being communicated to/from
        if (!this.hasValidApplicationInfo(message)) {
            return;
        }
        if (this.webMessageReciever.needMessageSerialization()) ;
        const webReciever = this.terminalStore.getWebReceiver();
        if (webReciever.onClientMessageCallback) {
            const receivedDate = new Date();
            message.__receivedTime__ = receivedDate.getTime();
            webReciever.onClientMessageCallback(message);
        }
        switch (message.category) {
            case 'FromClient':
                const fromClientRedirectedMessage = {
                    ...message,
                    __received__: false,
                    __receivedTime__: null,
                    category: 'FromClientRedirected'
                };
                this.handleFromClientRequest(fromClientRedirectedMessage).then();
                break;
            case 'IsConnectionReady':
                this.ensureConnectionIsReady(message).then();
                break;
        }
    }
    handleAppRequest(message, messageOrigin, source) {
        if (message.__received__) {
            return;
        }
        message.__received__ = true;
        // All requests need to have a application signature
        // to know what application is being communicated to/from
        if (!this.hasValidApplicationInfo(message)) {
            return;
        }
        const webReciever = this.terminalStore.getWebReceiver();
        if (webReciever.onClientMessageCallback) {
            const receivedDate = new Date();
            message.__receivedTime__ = receivedDate.getTime();
            webReciever.onClientMessageCallback(message);
        }
        switch (message.category) {
            case 'ToDb':
                this.handleIsolateMessage(message, messageOrigin, source).then();
                break;
            case 'ToClient':
                const interAppApiCallRequest = webReciever.pendingInterAppApiCallMessageMap.get(message.id);
                const context = {};
                this.endApiCall({
                    application: message.application,
                    domain: message.domain,
                    methodName: message.methodName,
                    objectName: message.objectName,
                }, message.errorMessage, context).then((success) => {
                    if (interAppApiCallRequest) {
                        if (!success) {
                            interAppApiCallRequest.reject(message.errorMessage);
                        }
                        else if (message.errorMessage) {
                            interAppApiCallRequest.reject(message.errorMessage);
                        }
                        else {
                            interAppApiCallRequest.resolve(message.payload);
                        }
                    }
                    else {
                        const toClientRedirectedMessage = {
                            ...message,
                            __received__: false,
                            __receivedTime__: null,
                            application: message.application,
                            category: 'ToClientRedirected',
                            domain: message.domain,
                            errorMessage: null,
                            methodName: message.methodName,
                            objectName: message.objectName,
                            payload: null,
                            protocol: null,
                        };
                        if (!success) {
                            toClientRedirectedMessage.errorMessage = context.errorMessage;
                            toClientRedirectedMessage.payload = null;
                        }
                        this.handleToClientRequest(toClientRedirectedMessage, messageOrigin)
                            .then();
                    }
                });
                break;
        }
    }
    onMessage(callback) {
        const webReciever = this.terminalStore.getWebReceiver();
        webReciever.onClientMessageCallback = callback;
    }
    async nativeStartApiCall(message, context) {
        return await this.startApiCall(message, context, async () => {
            const fullApplicationName = this.dbApplicationUtils.
                getFullApplicationNameFromDomainAndName(message.domain, message.application);
            const frameWindow = this.getFrameWindow(fullApplicationName);
            if (frameWindow) {
                // Forward the request to the correct application iframe
                frameWindow.postMessage(message, '*');
            }
            else {
                throw new Error(`No Application IFrame found for: ${fullApplicationName}`);
            }
        });
    }
    async nativeHandleApiCall(message, context) {
        if (!await this.nativeStartApiCall(message, context)) {
            throw new Error(context.errorMessage);
        }
        const webReciever = this.terminalStore.getWebReceiver();
        return new Promise((resolve, reject) => {
            webReciever.pendingInterAppApiCallMessageMap.set(message.id, {
                message,
                reject,
                resolve
            });
        });
    }
    async ensureConnectionIsReady(message) {
        const fullApplicationName = this.dbApplicationUtils.
            getFullApplicationNameFromDomainAndName(message.domain, message.application);
        const applicationInitializing = this.applicationInitializer.initializingApplicationMap.get(fullApplicationName);
        if (applicationInitializing) {
            return;
        }
        const applicationWindow = this.applicationInitializer.applicationWindowMap.get(fullApplicationName);
        if (!applicationWindow) {
            this.applicationInitializer.initializingApplicationMap.set(fullApplicationName, true);
            await this.applicationInitializer.nativeInitializeApplication(message.domain, message.application, fullApplicationName);
        }
        const connectionIsReadyMessage = {
            application: message.application,
            category: 'ConnectionIsReady',
            domain: message.domain,
            errorMessage: null,
            id: message.id,
            methodName: message.methodName,
            objectName: message.objectName,
            protocol: window.location.protocol,
            payload: null,
        };
        if (this.webMessageReciever.needMessageSerialization()) ;
        this.webMessageReciever.sendMessageToClient(connectionIsReadyMessage);
    }
    hasValidApplicationInfo(message) {
        return typeof message.domain === 'string' && message.domain.length >= 3
            && typeof message.application === 'string' && message.application.length >= 3;
    }
    async handleFromClientRequest(message) {
        const webReciever = this.terminalStore.getWebReceiver();
        let numPendingMessagesFromHost = webReciever.pendingHostCounts.get(message.domain);
        if (!numPendingMessagesFromHost) {
            numPendingMessagesFromHost = 0;
        }
        if (numPendingMessagesFromHost > 4) {
            // Prevent hosts from making local 'Denial of Service' attacks
            return;
        }
        const fullApplicationName = this.dbApplicationUtils.
            getFullApplicationNameFromDomainAndName(message.domain, message.application);
        let numPendingMessagesForApplication = webReciever.pendingApplicationCounts.get(fullApplicationName);
        if (!numPendingMessagesForApplication) {
            numPendingMessagesForApplication = 0;
        }
        if (numPendingMessagesForApplication === -1) {
            // Already could not install the application, may be a DOS attack, return right away
            return;
        }
        webReciever.pendingHostCounts.set(message.domain, numPendingMessagesFromHost + 1);
        webReciever.pendingApplicationCounts.set(fullApplicationName, numPendingMessagesForApplication + 1);
        if (!await this.ensureApplicationIsInstalled(fullApplicationName)) {
            this.relyToClientWithError(message, `Application is not installed`);
            return;
        }
        const context = {};
        if (!await this.nativeStartApiCall(message, context)) {
            this.relyToClientWithError(message, context.errorMessage);
        }
    }
    relyToClientWithError(message, errorMessage) {
        const toClientRedirectedMessage = {
            __received__: false,
            __receivedTime__: null,
            application: message.application,
            category: 'ToClientRedirected',
            domain: message.domain,
            errorMessage,
            id: message.id,
            methodName: message.methodName,
            objectName: message.objectName,
            payload: null,
            protocol: message.protocol,
        };
        this.replyToClientRequest(toClientRedirectedMessage);
    }
    getFrameWindow(fullApplicationName) {
        const iframe = document
            .getElementsByName(fullApplicationName);
        if (!iframe || !iframe[0]) {
            return null;
        }
        return iframe[0].contentWindow;
    }
    async handleToClientRequest(message, messageOrigin) {
        if (!await this.messageIsFromValidApp(message, messageOrigin)) {
            return;
        }
        this.replyToClientRequest(message);
    }
    replyToClientRequest(message) {
        const fullApplicationName = this.dbApplicationUtils.
            getFullApplicationNameFromDomainAndName(message.domain, message.application);
        const webReciever = this.terminalStore.getWebReceiver();
        let numMessagesFromHost = webReciever.pendingHostCounts.get(message.domain);
        if (numMessagesFromHost > 0) {
            webReciever.pendingHostCounts.set(message.domain, numMessagesFromHost - 1);
        }
        let numMessagesForApplication = webReciever.pendingApplicationCounts.get(fullApplicationName);
        if (numMessagesForApplication > 0) {
            webReciever.pendingApplicationCounts.set(message.domain, numMessagesForApplication - 1);
        }
        // Forward the request to the source client
        if (this.webMessageReciever.needMessageSerialization()) ;
        this.webMessageReciever.sendMessageToClient(message);
    }
    async ensureApplicationIsInstalled(fullApplicationName) {
        if (!fullApplicationName) {
            return false;
        }
        return !!this.applicationInitializer.applicationWindowMap.get(fullApplicationName);
    }
    async messageIsFromValidApp(message, messageOrigin) {
        const applicationDomain = messageOrigin.split('//')[1];
        const applicationDomainFragments = applicationDomain.split('.');
        // Allow local debugging
        if (applicationDomain.split(':')[0] === 'localhost') {
            return true;
        }
        const webReciever = this.terminalStore.getWebReceiver();
        const fullApplicationName = this.dbApplicationUtils.
            getFullApplicationNameFromDomainAndName(message.domain, message.application);
        // Only accept requests from https protocol
        if (!messageOrigin.startsWith("https")
            // and from application domains that match the fullApplicationName
            || applicationDomain !== fullApplicationName + webReciever.domainPrefix) {
            return false;
        }
        // Only accept requests from '${applicationName}.${mainDomainName}'
        if (applicationDomainFragments.length !== webReciever.mainDomainFragments.length + 1) {
            return false;
        }
        // Only accept requests from non-'www' domain (don't accept requests from self)
        if (applicationDomainFragments[0] === 'www') {
            return false;
        }
        const applicationDomainFirstFragment = applicationDomainFragments[0];
        // check application domain-embedded signature and fullApplicationName in message
        // and make sure they result in a match
        if (applicationDomainFirstFragment !== fullApplicationName) {
            return false;
        }
        // Make sure the application is installed
        return !!this.applicationInitializer.applicationWindowMap.get(fullApplicationName);
    }
    async handleIsolateMessage(message, messageOrigin, source) {
        if (!await this.messageIsFromValidApp(message, messageOrigin)) {
            return;
        }
        const webReciever = this.terminalStore.getWebReceiver();
        const fullApplicationName = this.dbApplicationUtils.
            getFullApplicationNameFromDomainAndName(message.domain, message.application);
        switch (message.type) {
            case IsolateMessageType.SEARCH_UNSUBSCRIBE:
                let isolateSubscriptionMap = webReciever.subsriptionMap.get(fullApplicationName);
                if (!isolateSubscriptionMap) {
                    return;
                }
                let subscription = isolateSubscriptionMap.get(message.id);
                if (!subscription) {
                    return;
                }
                subscription.unsubscribe();
                isolateSubscriptionMap.delete(message.id);
                return;
        }
        this.processMessage(message).then(response => {
            if (!response) {
                return;
            }
            const webReciever = this.terminalStore.getWebReceiver();
            let shemaDomainName = fullApplicationName + '.' + webReciever.localDomain;
            switch (message.type) {
                case IsolateMessageType.SEARCH:
                case IsolateMessageType.SEARCH_ONE:
                    const observableDataResult = response;
                    observableDataResult.result.pipe(map(value => {
                        window.postMessage(value, shemaDomainName);
                    }));
                    const subscription = observableDataResult.result.subscribe();
                    let isolateSubscriptionMap = webReciever.subsriptionMap.get(fullApplicationName);
                    if (!isolateSubscriptionMap) {
                        isolateSubscriptionMap = new Map();
                        webReciever.subsriptionMap.set(fullApplicationName, isolateSubscriptionMap);
                    }
                    isolateSubscriptionMap.set(message.id, subscription);
                    return;
            }
            source.postMessage(response, '*');
        });
    }
};
__decorate$4([
    Inject()
], WebTransactionalReceiver.prototype, "applicationInitializer", void 0);
__decorate$4([
    Inject()
], WebTransactionalReceiver.prototype, "dbApplicationUtils", void 0);
__decorate$4([
    Inject()
], WebTransactionalReceiver.prototype, "terminalStore", void 0);
__decorate$4([
    Inject()
], WebTransactionalReceiver.prototype, "webMessageReciever", void 0);
WebTransactionalReceiver = __decorate$4([
    Injected()
], WebTransactionalReceiver);

const webTerminal = lib$1('web-terminal');
DOMAIN_RETRIEVER.setClass(DomainRetriever);
APPLICATION_INITIALIZER.setClass(WebApplicationInitializer);
const WEB_MESSAGE_RECEIVER = webTerminal.token({
    class: WebMesageReceiver,
    interface: 'IWebMessageReceiver',
    token: 'WEB_MESSAGE_RECEIVER'
});
WEB_MESSAGE_RECEIVER.setDependencies({
    transactionalReceiver: TRANSACTIONAL_RECEIVER
});
TRANSACTIONAL_RECEIVER.setClass(WebTransactionalReceiver);
TRANSACTIONAL_RECEIVER.setDependencies({
    databaseManager: DATABASE_MANAGER,
    dbApplicationUtils: DB_APPLICATION_UTILS,
    internalRecordManager: INTERNAL_RECORD_MANAGER,
    terminalStore: TERMINAL_STORE,
    webMessageReciever: WEB_MESSAGE_RECEIVER
});

function injectTransactionalReceiver() {
    console.log('Injecting TransactionalReceiver');
    // injectMovingWalkway()
    injectTransactionalConnector();
    injectAirportDatabase();
    injectTransactionalServer();
    injectEntityStateManager();
    injectWebReceiver();
}

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Assumptions: 7/4/2019
 *
 * 1. Only a single process will be inserting records at any given point in time
 * a)  This means that the service worker running the the background will only
 * receive and temporarily store data (in IndexedDb, but won't be inserting
 * proper relational records)
 * b)  This also means that web-workers won't be doing parallel inserts
 *
 * In general, this is consistent with SqLites policy of only one modifying
 * operation at a time (while possibly multiple read ops)
 *
 *
 * With these assumptions in place, it is safe to synchronize sequence retrieval
 * in-memory.   Hence, SequenceBlocks are retired in favor of a simpler
 * Sequence-only solution
 *
 */
let SequenceGenerator = class SequenceGenerator {
    get sequences() {
        return this.terminalStore.getSequenceGenerator().sequences;
    }
    get sequenceBlocks() {
        return this.terminalStore.getSequenceGenerator().sequenceBlocks;
    }
    get generatingSequenceNumbers() {
        return this.terminalStore.getSequenceGenerator().generatingSequenceNumbers;
    }
    set generatingSequenceNumbers(generatingSequenceNumbers) {
        this.terminalStore.getSequenceGenerator().generatingSequenceNumbers
            = generatingSequenceNumbers;
    }
    exists(dbEntity) {
        const generatedColumns = dbEntity.columns.filter(dbColumn => dbColumn.isGenerated);
        if (!generatedColumns.length) {
            return true;
        }
        const applicationSequences = this.sequences[dbEntity.applicationVersion.application.index];
        if (!applicationSequences) {
            return false;
        }
        const tableSequences = applicationSequences[dbEntity.index];
        if (!tableSequences) {
            return false;
        }
        return generatedColumns.every(dbColumn => !!tableSequences[dbColumn.index]);
    }
    async initialize(context, sequences) {
        if (!sequences) {
            sequences = await this.sequenceDao.findAll();
        }
        this.addSequences(sequences);
        await this.sequenceDao.incrementCurrentValues(context);
    }
    async tempInitialize(context, sequences) {
        this.addSequences(sequences);
    }
    async generateSequenceNumbers(dbColumns, numSequencesNeeded) {
        if (!dbColumns.length) {
            return [];
        }
        await this.waitForPreviousGeneration();
        this.generatingSequenceNumbers = true;
        try {
            return await this.doGenerateSequenceNumbers(dbColumns, numSequencesNeeded);
        }
        finally {
            this.generatingSequenceNumbers = false;
        }
    }
    /**
     * Keeping return value as number[][] in case we ever revert back
     * to SequenceBlock-like solution
     * @param dbColumns
     * @param numSequencesNeeded
     */
    async doGenerateSequenceNumbers(dbColumns, numSequencesNeeded) {
        const sequentialNumbers = [];
        for (let i = 0; i < dbColumns.length; i++) {
            const dbColumn = dbColumns[i];
            let numColumnSequencesNeeded = numSequencesNeeded[i];
            const columnNumbers = ensureChildArray(sequentialNumbers, i);
            const dbEntity = dbColumn.propertyColumns[0].property.entity;
            const application = dbEntity.applicationVersion.application;
            let sequenceBlock = this.sequenceBlocks[application.index][dbEntity.index][dbColumn.index];
            const sequence = this.sequences[application.index][dbEntity.index][dbColumn.index];
            while (numColumnSequencesNeeded && sequenceBlock) {
                columnNumbers.push(sequence.currentValue - sequenceBlock + 1);
                numColumnSequencesNeeded--;
                sequenceBlock--;
            }
            this.sequenceBlocks[application.index][dbEntity.index][dbColumn.index] = sequenceBlock;
            if (numColumnSequencesNeeded) {
                const numNewSequencesNeeded = sequence.incrementBy + numColumnSequencesNeeded;
                const newSequence = { ...sequence };
                newSequence.currentValue += numNewSequencesNeeded;
                await this.sequenceDao.save(newSequence);
                this.sequences[application.index][dbEntity.index][dbColumn.index] = newSequence;
                sequenceBlock = numNewSequencesNeeded;
                while (numColumnSequencesNeeded) {
                    columnNumbers.push(sequence.currentValue - sequenceBlock + 1);
                    numColumnSequencesNeeded--;
                    sequenceBlock--;
                }
                this.sequenceBlocks[application.index][dbEntity.index][dbColumn.index] = sequenceBlock;
            }
        }
        return sequentialNumbers;
    }
    waitForPreviousGeneration() {
        return new Promise(resolve => {
            this.isDoneGeneratingSeqNums(resolve);
        });
    }
    isDoneGeneratingSeqNums(resolve) {
        if (this.generatingSequenceNumbers) {
            setTimeout(() => {
                this.isDoneGeneratingSeqNums(resolve);
            }, 20);
        }
        else {
            resolve();
        }
    }
    addSequences(sequences) {
        for (const sequence of sequences) {
            ensureChildArray(ensureChildArray(this.sequences, sequence.applicationIndex), sequence.tableIndex)[sequence.columnIndex] = sequence;
            sequence.currentValue += sequence.incrementBy;
            ensureChildArray(ensureChildArray(this.sequenceBlocks, sequence.applicationIndex), sequence.tableIndex)[sequence.columnIndex] = sequence.incrementBy;
        }
    }
};
__decorate$3([
    Inject()
], SequenceGenerator.prototype, "sequenceDao", void 0);
__decorate$3([
    Inject()
], SequenceGenerator.prototype, "terminalStore", void 0);
SequenceGenerator = __decorate$3([
    Injected()
], SequenceGenerator);
function injectSequenceGenerator() {
    console.log('injecting SequenceGenerator');
}

SEQUENCE_GENERATOR.setClass(SequenceGenerator);
SEQUENCE_GENERATOR.setDependencies({
    sequenceDao: SEQUENCE_DAO,
    terminalStore: TERMINAL_STORE
});

/**
 * Created by Papa on 11/27/2016.
 */
class SqLiteDriver extends SqlDriver {
    constructor() {
        super();
        this.maxValues = 999;
    }
    composeTableName(applicationName, tableName) {
        return `${applicationName}__${tableName}`;
    }
    async doesTableExist(applicationName, tableName, context) {
        const matchingTableNames = await this.findNative(
        // ` SELECT tbl_name, sql from sqlite_master WHERE type = '${tableName}'`,
        `SELECT
	tbl_name
from
	sqlite_master
WHERE
	type = 'table'
	AND tbl_name = '${applicationName}__${tableName}'`, [], context);
        return this.getNumberOfRows(matchingTableNames) === 1;
    }
    getNumberOfRows(result) {
        return this.getRows(result).length;
    }
    async dropTable(applicationName, tableName, context) {
        const matchingTableNames = await this.findNative(`DROP TABLE '${applicationName}__${tableName}'`, [], context);
        return matchingTableNames.length === 1;
    }
    async findNative(sqlQuery, parameters, context) {
        let nativeParameters = parameters.map((value) => this.convertValueIn(value));
        return await this.query(QueryType.SELECT, sqlQuery, nativeParameters, context);
    }
    async executeNative(sql, parameters, context) {
        return await this.query(QueryType.MUTATE, sql, parameters, context);
    }
    convertValueIn(value) {
        switch (typeof value) {
            case 'boolean':
                return value ? 1 : 0;
            case 'number':
            case 'string':
                return value;
            case 'undefined':
                return null;
            case 'object':
                if (!value) {
                    return null;
                }
                else if (value instanceof Date) {
                    return value.getTime();
                }
                else {
                    throw new Error(`Unexpected non-date object ${value}`);
                }
            default:
                throw new Error(`Unexpected typeof value: ${typeof value}`);
        }
    }
    isValueValid(value, sqlDataType, context) {
        throw new Error('Method not implemented.');
        // switch (sqlDataType) {
        // 	case SQLDataType.DATE:
        // 	case SQLDataType.NUMBER:
        // }
        // return false
    }
    async initTables(createQueries) {
        for (let i = 0; i < createQueries.length; i++) {
            let currentQuery = createQueries[i];
            await currentQuery;
        }
    }
    getDialect() {
        return SQLDialect.SQLITE;
    }
    isServer() {
        return false;
    }
}

/**
 * Created by Papa on 8/27/2016.
 */
class SqLiteQueryAdaptor {
    constructor() {
        this.functionAdaptor = new SqlLiteFunctionAdaptor();
    }
    getParameterReference(parameterReferences, newReference) {
        return '?';
    }
    dateToDbQuery(date) {
        let milliseconds = date.getTime();
        return '' + milliseconds;
    }
    getResultArray(rawResponse) {
        return rawResponse.res.rows;
    }
    getResultCellValue(resultRow, columnName, index, dataType, defaultValue) {
        let value = this.getResultCellRawValue(resultRow, columnName, index, dataType, defaultValue);
        switch (dataType) {
            case SQLDataType.BOOLEAN:
                if (value !== null) {
                    return !!value;
                }
                break;
            case SQLDataType.DATE:
                if (value !== null) {
                    return new Date(value);
                }
                break;
            case SQLDataType.JSON:
                if (value !== null) {
                    return JSON.parse(value);
                }
                break;
            case SQLDataType.ANY:
            case SQLDataType.NUMBER:
            case SQLDataType.STRING:
                return value;
            default:
                throw new Error(`Unexpected data type for column ${columnName}`);
        }
    }
    getFunctionAdaptor() {
        return this.functionAdaptor;
    }
    getOffsetFragment(offset) {
        return `
OFFSET
	${offset}`;
    }
    getLimitFragment(limit) {
        return `
LIMIT
	${limit}`;
    }
    getParameterValue(parameter) {
        return this.getValue(parameter.value);
    }
    getValue(value, allowArrays = true) {
        switch (typeof value) {
            case 'boolean':
                return value ? '1' : '0';
            case 'number':
            case 'string':
                return value;
            case 'object':
                if (value instanceof Date) {
                    return value.getTime();
                }
                else if (value instanceof Array) {
                    return value.map(aValue => this.getValue(aValue, false));
                }
                throw new Error(`Unexpected object as a parameter.`);
            default:
                throw new Error(`Unexpected type of parameter '${typeof value}.'`);
        }
    }
}
class SqlLiteFunctionAdaptor extends AbstractFunctionAdaptor {
    getFunctionCall(jsonFunctionCall, value, qEntityMapByAlias, sqlValueProvider, context) {
        let param2;
        switch (jsonFunctionCall.ft) {
            case SqlFunction.ABS:
                return `ABS(${value})`;
            case SqlFunction.AVG:
                return `AVG(${value})`;
            case SqlFunction.COUNT:
                return `COUNT(${value})`;
            case SqlFunction.MAX:
                return `MAX(${value})`;
            case SqlFunction.MIN:
                return `MIN(${value})`;
            case SqlFunction.SUM:
                return `SUM(${value})`;
            case SqlFunction.UCASE:
                return `UPPER(${value})`;
            case SqlFunction.LCASE:
                return `LOWER(${value})`;
            case SqlFunction.MID:
                let start = sqlValueProvider.getFunctionCallValue(jsonFunctionCall.p[0], context);
                let length = sqlValueProvider.getFunctionCallValue(jsonFunctionCall.p[1], context);
                return `SUBSTR(${value}, ${start}, ${length})`;
            case SqlFunction.LEN:
                return `LENGTH(${value})`;
            case SqlFunction.ROUND:
                let digits = sqlValueProvider.getFunctionCallValue(jsonFunctionCall.p[0], context);
                return `ROUND(${value}, ${digits})`;
            case SqlFunction.NOW:
                return `DATE('now')`;
            case SqlFunction.FORMAT:
                let formatCall = `FORMAT('${value}', `;
                for (let i = 0; i < jsonFunctionCall.p.length; i++) {
                    let formatParam = jsonFunctionCall.p[i];
                    formatParam = sqlValueProvider.getFunctionCallValue(formatParam, context);
                    formatCall = `${formatCall}, ${formatParam}`;
                }
                formatCall += ')';
                return formatCall;
            case SqlFunction.REPLACE:
                let param1 = sqlValueProvider.getFunctionCallValue(jsonFunctionCall.p[0], context);
                param2 = sqlValueProvider.getFunctionCallValue(jsonFunctionCall.p[1], context);
                return `REPLACE('${value}', ${param1}, ${param2})`;
            case SqlFunction.TRIM:
                return `TRIM(${value})`;
            case SqlFunction.DISTINCT:
                throw new Error(`Invalid placement of a distinct function`);
            case SqlFunction.EXISTS:
                throw new Error(`Invalid placement of an exists function`);
            case SqlFunction.DIVIDE:
                param2 = sqlValueProvider.getFunctionCallValue(jsonFunctionCall.p[0], context);
                return `${value} / ${param2}`;
            case SqlFunction.MINUS:
                param2 = sqlValueProvider.getFunctionCallValue(jsonFunctionCall.p[0], context);
                return `${value} - ${param2}`;
            case SqlFunction.MULTIPLY:
                param2 = sqlValueProvider.getFunctionCallValue(jsonFunctionCall.p[0], context);
                return `${value} * ${param2}`;
            case SqlFunction.PLUS:
                param2 = sqlValueProvider.getFunctionCallValue(jsonFunctionCall.p[0], context);
                return `${value} + ${param2}`;
            case SqlFunction.CONCATENATE:
                return jsonFunctionCall.p.reduce((acc, val) => {
                    this.toString(sqlValueProvider.getFunctionCallValue(val, context));
                    return acc + val;
                }, this.toString(value));
            case SqlFunction.COALESCE:
                throw new Error('Not Implemented');
            default:
                throw new Error(`Unknown function type: ${jsonFunctionCall.ft}`);
        }
    }
    toString(val) {
        switch (typeof val) {
            case 'string':
                return val;
            case 'boolean':
            case 'number':
                return val.toString();
            case 'undefined':
                return 'null';
            case 'object':
                if (val === null) {
                    return 'null';
                }
                if (val instanceof Date) {
                    return val.toJSON();
                }
                throw new Error(`Unsupported value for conversion to string.`);
            default:
                throw new Error(`Unsupported value for conversion to string.`);
        }
    }
}

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SqLiteApplicationBuilder = class SqLiteApplicationBuilder extends SqlSchemaBuilder {
    async createApplication(jsonApplication, context) {
        // Nothing to do
    }
    getColumnSuffix(jsonApplication, jsonEntity, jsonColumn) {
        let primaryKeySuffix = '';
        if (jsonColumn.notNull
            || this.isPrimaryKeyColumn(jsonEntity, jsonColumn)) {
            primaryKeySuffix = ' NOT NULL';
        }
        const suffix = primaryKeySuffix; // + autoincrementSuffix
        switch (jsonColumn.type) {
            case SQLDataType.ANY:
                return suffix;
            case SQLDataType.BOOLEAN:
                return `INTEGER ${suffix}`;
            case SQLDataType.DATE:
                return `REAL ${suffix}`;
            case SQLDataType.JSON:
                return `TEXT ${suffix}`;
            case SQLDataType.NUMBER:
                if (suffix) {
                    return `INTEGER ${suffix}`;
                }
                return 'REAL';
            case SQLDataType.STRING:
                return `TEXT ${suffix}`;
            default:
                throw new Error(`Unexpected data type for ${jsonApplication.name}.${jsonEntity.name}.${jsonColumn.name}`);
        }
    }
    getCreateTableSuffix(jsonApplication, jsonEntity) {
        return ` WITHOUT ROWID`;
    }
    async buildAllSequences(jsonApplications, context) {
        console.log('buildAllSequences');
        let allSequences = [];
        for (const jsonApplication of jsonApplications) {
            const qApplication = this.airportDatabase.QM[this.dbApplicationUtils.
                getFullApplicationName(jsonApplication)];
            for (const jsonEntity of jsonApplication.versions[jsonApplication.versions.length - 1].entities) {
                allSequences = allSequences.concat(this.buildSequences(qApplication.__dbApplication__, jsonEntity));
            }
        }
        await this.sequenceDao.save(allSequences, context);
        return allSequences;
    }
    stageSequences(jsonApplications, context) {
        console.log('stageSequences');
        let stagedSequences = [];
        for (const jsonApplication of jsonApplications) {
            const qApplication = this.airportDatabase.QM[this.dbApplicationUtils.
                getFullApplicationName(jsonApplication)];
            for (const jsonEntity of jsonApplication.versions[jsonApplication.versions.length - 1].entities) {
                stagedSequences = stagedSequences.concat(this.buildSequences(qApplication.__dbApplication__, jsonEntity));
            }
        }
        return stagedSequences;
    }
    buildSequences(dbApplication, jsonEntity) {
        const sequences = [];
        for (const jsonColumn of jsonEntity.columns) {
            if (!jsonColumn.isGenerated) {
                continue;
            }
            let incrementBy = jsonColumn.allocationSize;
            if (!incrementBy) {
                incrementBy = 100;
            }
            sequences.push({
                applicationIndex: dbApplication.index,
                tableIndex: jsonEntity.index,
                columnIndex: jsonColumn.index,
                incrementBy,
                currentValue: 0,
            });
        }
        return sequences;
    }
    getIndexSql(indexName, tableName, columnNameList, unique) {
        let uniquePrefix;
        if (unique) {
            uniquePrefix = ' UNIQUE';
        }
        else {
            uniquePrefix = '';
        }
        return `CREATE${uniquePrefix} INDEX ${indexName}
    ON ${tableName} (
    ${columnNameList.join(', ')}
    )`;
    }
    getForeignKeySql(tableName, foreignKeyName, foreignKeyColumnNames, referencedTableName, referencedColumnNames) {
        // TODO: investigate adding foreign key support for SqLite.
        // Right now there is no alter table command and it has to be baked
        // into the CREATE TALBE command, though techniques for getting
        // around this do exist:
        // https://stackoverflow.com/questions/1884818/how-do-i-add-a-foreign-key-to-an-existing-sqlite-table
        return null;
    }
};
__decorate$2([
    Inject()
], SqLiteApplicationBuilder.prototype, "airportDatabase", void 0);
SqLiteApplicationBuilder = __decorate$2([
    Injected()
], SqLiteApplicationBuilder);

APPLICATION_BUILDER.setClass(SqLiteApplicationBuilder);

class SqlJsTransaction extends SqlTransaction {
    isServer(context) {
        return false;
    }
}

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 11/27/2016.
 */
let SqlJsDriver = class SqlJsDriver extends SqLiteDriver {
    constructor() {
        super();
        this.type = StoreType.SQLJS;
    }
    async initialize() {
        const SQL = await initSqlJs({
            // Required to load the wasm binary asynchronously. Of course, you can host it wherever you want
            // You can omit locateFile completely when running in node
            locateFile: file => `./${file}`
        });
        this._db = new SQL.Database();
    }
    async setupTransaction(context, parentTransaction) {
        const transaction = new SqlJsTransaction(this, parentTransaction);
        await this.internalSetupTransaction(transaction, context);
        return transaction;
    }
    async internalStartTransaction(transaction, context) {
        while (!this._db) {
            await this.wait(50);
        }
        const command = `SAVEPOINT '${transaction.id}'`;
        console.log(command);
        this._db.exec(command);
    }
    async internalCommit(transaction, context) {
        while (!this._db) {
            await this.wait(50);
        }
        const command = `RELEASE SAVEPOINT '${transaction.id}'`;
        console.log(command);
        this._db.exec(command);
    }
    async internalRollback(transaction, context) {
        while (!this._db) {
            await this.wait(50);
        }
        const command = `ROLLBACK TO SAVEPOINT '${transaction.id}'`;
        console.log(command);
        this._db.exec(command);
    }
    async query(queryType, query, params = [], context, saveTransaction = false) {
        while (!this._db) {
            await this.wait(50);
        }
        return new Promise((resolve, reject) => {
            let stmt;
            try {
                if (!['TQ_BOOLEAN_FIELD_CHANGE', 'TQ_DATE_FIELD_CHANGE', 'TQ_NUMBER_FIELD_CHANGE', 'TQ_STRING_FIELD_CHANGE',
                    'TQ_ENTITY_CHANGE', 'TQ_ENTITY_WHERE_CHANGE', 'TQ_TRANSACTION'].some((deltaTableName) => {
                    return query.indexOf(deltaTableName) > -1;
                })) {
                    console.log(query);
                    console.log(params);
                }
                stmt = this._db.prepare(query);
                stmt.bind(params);
                let results = [];
                while (stmt.step()) {
                    results.push(stmt.get());
                }
                console.log(results);
                resolve(results);
            }
            catch (error) {
                reject(error);
            }
            finally {
                if (stmt) {
                    stmt.free();
                }
            }
        });
    }
    handleError(error) {
        throw error;
    }
    getRows(result) {
        return result;
    }
    wait(milliseconds) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, milliseconds);
        });
    }
    getReturnValue(queryType, response) {
        switch (queryType) {
            case QueryType.MUTATE:
                return response.rowsAffected;
            case QueryType.SELECT:
                return response.rows;
            default:
                return null;
        }
    }
    getDialect() {
        return SQLDialect.SQLITE;
    }
};
SqlJsDriver = __decorate$1([
    Injected()
], SqlJsDriver);

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Created by Papa on 2/8/2017.
 */
let SqlJsQueryAdaptor = class SqlJsQueryAdaptor extends SqLiteQueryAdaptor {
    getResultCellRawValue(resultRow, columnName, index, dataType, defaultValue) {
        return resultRow[index];
    }
};
SqlJsQueryAdaptor = __decorate([
    Injected()
], SqlJsQueryAdaptor);

STORE_DRIVER.setClass(SqlJsDriver);
SQL_QUERY_ADAPTOR.setClass(SqlJsQueryAdaptor);

injectSequenceGenerator();
async function startDb(domainName) {
    const dbManager = await IOC.get(DATABASE_MANAGER);
    await dbManager.initWithDb(domainName, {});
}

injectTransactionalReceiver();
async function initFramework() {
    await startDb('AIRportA-demo-demo-demo-functionalty');
    await IOC.get(WEB_MESSAGE_RECEIVER);
}

const app = new App({
    target: document.body,
    props: {}
});
initFramework().then();

export { app as default };
//# sourceMappingURL=main.js.map
