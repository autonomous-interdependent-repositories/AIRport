import * as fs from 'fs';
import fs__default from 'fs';
import path from 'path';
import * as tsc from 'typescript';
import tsc__default from 'typescript';

/**
 * Created by Papa on 4/24/2016.
 */
var ArgumentType;
(function (ArgumentType) {
    ArgumentType["CONFIG"] = "ArgumentType";
})(ArgumentType || (ArgumentType = {}));
class Flags {
}
var ARGUMENT_FLAGS = {
    '--config': ArgumentType.CONFIG,
    '-c': ArgumentType.CONFIG
};

/**
 * Created by Papa on 4/24/2016.
 */
function parseFlags(programArguments) {
    let flags = new Flags();
    let argumentGroups = getArgumentGroups(programArguments);
    let foundFlags = {};
    argumentGroups.forEach((argumentGroup) => {
        let flag = argumentGroup[0];
        let argType = ARGUMENT_FLAGS[flag];
        switch (argType) {
            case ArgumentType.CONFIG:
                if (foundFlags[argType]) {
                    throw new Error(`Flag already specified '${flag}'`);
                }
                verifyArgumentGroupLength(argumentGroup, 2);
                foundFlags[argType] = true;
                flags.optionsFilePath = argumentGroup[1];
            default:
                throw new Error(`Unexpected flag '${flag}'`);
        }
    });
    if (!flags.optionsFilePath) {
        flags.optionsFilePath = 'package.json';
    }
    return flags;
}
function verifyArgumentGroupLength(argumentGroup, expectedLength) {
    if (argumentGroup.length !== expectedLength) {
        throw new Error(`Expecting '${expectedLength - 1}' values for '${argumentGroup[0]}' flag`);
    }
}
function getArgumentGroups(programArguments) {
    let optionGroups = [];
    let currentOptionGroup;
    for (let i = 2; i < programArguments.length; i++) {
        let currentArgument = programArguments[i];
        // we have a new option
        if (currentArgument.indexOf('-') === 0) {
            if (currentOptionGroup) {
                optionGroups.push(currentOptionGroup);
            }
            currentOptionGroup = [];
        }
        currentOptionGroup.push(currentArgument);
    }
    if (currentOptionGroup) {
        optionGroups.push(currentOptionGroup);
    }
    return optionGroups;
}

function readConfiguration(projectPath, programArguments) {
    let flags = parseFlags(programArguments);
    let configFilePath = projectPath + '/' + flags.optionsFilePath;
    let configFile = fs.readFileSync(configFilePath);
    let configString = configFile.toString();
    let config = JSON.parse(configString);
    verifyConfiguration(config);
    return config;
}
function verifyConfiguration(options) {
    if (!options.name) {
        throw new Error(`"name" must be specified in package.json.`);
    }
    if (!options.airport) {
        throw new Error(`"airport" configuration object must be specified in package.json.`);
    }
    if (typeof options.airport.domain !== 'string') {
        throw new Error(`"airport.domain" configuration object must be specified 
		(as HTTL Domain URL or 'private') in package.json.  
		It is: ${options.airport.domain}`);
    }
    if (!options.airport.ddlDir) {
        options.airport.ddlDir = 'src/ddl';
        // 	throw new Error(
        // 	`"airport.ddlDir" configuration property must be specified in package.json.`);
    }
    options.airport.ddlDir = path.normalize(options.airport.ddlDir);
    if (!options.airport.generatedDir) {
        options.airport.generatedDir = 'src/generated';
        // 	throw new Error(
        // 	`"airport.generatedDir" configuration property must be specified in package.json.`);
    }
    options.airport.generatedDir = path.normalize(options.airport.generatedDir);
    if (!options.airport.daoDir) {
        options.airport.daoDir = 'src/dao';
    }
    options.airport.daoDir = path.normalize(options.airport.daoDir);
    if (!options.airport.apiDir) {
        options.airport.apiDir = 'src/api';
    }
    options.airport.apiDir = path.normalize(options.airport.apiDir);
    if (!options.airport.cacheGeneratedPaths && options.airport.cacheGeneratedPaths !== false) {
        options.airport.cacheGeneratedPaths = false;
    }
    let node_modulesLinks = options.airport.node_modulesLinks;
    if (!node_modulesLinks) {
        node_modulesLinks = {};
        options.airport.node_modulesLinks = node_modulesLinks;
    }
    // if (!node_modulesLinks.pathToProject) {
    // 	node_modulesLinks.pathToProject = options.airport.ddlDir;
    // } else {
    // 	node_modulesLinks.pathToProject = node_modulesLinks.pathToProject + '/' + options.airport.ddlDir;
    // }
}

if (!globalThis.CLASSES) {
    globalThis.CLASSES = {};
}
// For Non-Injected (core) classes
function addClasses(classes) {
    const container = globalThis.CLASSES;
    for (const clazz of classes) {
        let className = clazz.prototype.constructor.name;
        // if (!container[className]) {
        //     container[className] = []
        // } else {
        //     console.warn(`More than one '${className}' loaded!`)
        // }
        // container[className].push(clazz)
        if (container[className]) {
            throw new Error(`Class ${className} is defined more than once!`);
        }
    }
}

var ContextType;
(function (ContextType) {
    ContextType["DB"] = "DB";
    ContextType["UI"] = "UI";
})(ContextType || (ContextType = {}));
globalThis.ContextType = ContextType;
class Context {
    constructor(id, type) {
        this.id = id;
        this.type = type;
    }
}
addClasses([Context]);

class Container {
}
addClasses([Container]);

class InjectionDomain {
    constructor(name) {
        this.name = name;
        this.applicationMap = {};
    }
    app(applicationName) {
        if (this.applicationMap[applicationName]) {
            throw new Error(`
			Application already defined.
			Domain:      ${this.name}
			Application: ${applicationName}
			`);
        }
        const application = new InjectionApplication(applicationName, this);
        application.getDomain = domain;
        this.applicationMap[applicationName] = application;
        return application;
    }
    getApp(applicationName) {
        return this.applicationMap[applicationName];
    }
}
addClasses([InjectionDomain]);
let injectionDomain;
if (globalThis.AIRPORT_DOMAIN) {
    injectionDomain = globalThis.AIRPORT_DOMAIN;
}
else {
    injectionDomain = domain('airport');
    globalThis.AIRPORT_DOMAIN = injectionDomain;
}
const AIRPORT_DOMAIN = injectionDomain;
function domain(domainName) {
    if (!globalThis.AIRPORT_DOMAIN_MAP) {
        globalThis.AIRPORT_DOMAIN_MAP = {};
    }
    const DOMAIN_MAP = globalThis.AIRPORT_DOMAIN_MAP;
    if (DOMAIN_MAP[domainName]) {
        return DOMAIN_MAP[domainName];
    }
    const domain = new InjectionDomain(domainName);
    DOMAIN_MAP[domainName] = domain;
    return domain;
}
globalThis.domain = domain;
function app(applicationDescriptor) {
    const airDomain = globalThis.domain(applicationDescriptor.domain.name);
    return airDomain.app(applicationDescriptor.name);
}

class DependencyInjectionToken {
    static getPath(tokenOrFullDescriptor) {
        return tokenOrFullDescriptor.application.domain.name + ':' + tokenOrFullDescriptor.application.name + ':'
            + tokenOrFullDescriptor.descriptor.interface;
    }
    get dependencyConfiguration() {
        return this.getInheritedDependencyConfiguration(this.descriptor.class);
    }
    constructor(application, descriptor) {
        this.application = application;
        this.descriptor = descriptor;
    }
    getPath() {
        return DependencyInjectionToken.getPath(this);
    }
    setDependencies(dependencyConfiguration) {
        let tokenBasedDependencyConfiguration = {};
        for (let propertyName in dependencyConfiguration) {
            let dependency = dependencyConfiguration[propertyName];
            let prototype = dependency.prototype;
            if (prototype && prototype.constructor) {
                let apiClass = dependency;
                if (!apiClass.token) {
                    const applicationDescriptor = apiClass.application;
                    if (!applicationDescriptor || !applicationDescriptor.name || !applicationDescriptor.domain
                        || !applicationDescriptor.domain.name) {
                        throw new Error(`Did not find application descriptor on @Injected() ${apiClass.name}`);
                    }
                    this.application.getDomain(applicationDescriptor.domain.name).app(applicationDescriptor.name)
                        .register(apiClass);
                }
                dependency = apiClass.token;
            }
            tokenBasedDependencyConfiguration[propertyName] = dependency;
            if (!(dependency instanceof DependencyInjectionToken)) {
                throw new Error(`Property dependency is not a DependencyInjectionToken or a @Injected() class
	Token:    ${this.getPath}
	Property: ${propertyName}`);
            }
        }
        if (this._dependencyConfiguration) {
            this._dependencyConfiguration = {
                ...this._dependencyConfiguration,
                ...tokenBasedDependencyConfiguration
            };
        }
        else {
            this._dependencyConfiguration = tokenBasedDependencyConfiguration;
        }
        if (!this.descriptor.class) {
            return;
        }
        if (this.descriptor.class.dependencyConfiguration) {
            this.descriptor.class.dependencyConfiguration = {
                ...this.descriptor.class.dependencyConfiguration,
                ...dependencyConfiguration
            };
        }
        else {
            this.descriptor.class.dependencyConfiguration = dependencyConfiguration;
        }
    }
    setClass(aClass) {
        let prototype = aClass.prototype;
        if (!prototype || !prototype.constructor) {
            return;
        }
        let classWithDescriptor = aClass;
        classWithDescriptor.application = {
            domain: {
                name: this.application.domain.name
            },
            name: this.application.name
        };
        classWithDescriptor.token = this;
        this.descriptor.class = aClass;
        classWithDescriptor.dependencyConfiguration = this._dependencyConfiguration;
    }
    getInheritedDependencyConfiguration(aClass) {
        let returnedDependencyConfiguration = {};
        if (!aClass) {
            return returnedDependencyConfiguration;
        }
        const parentClass = Object.getPrototypeOf(aClass);
        if (parentClass) {
            returnedDependencyConfiguration = this.getInheritedDependencyConfiguration(parentClass);
        }
        const dependencyConfiguration = aClass.dependencyConfiguration;
        if (dependencyConfiguration) {
            returnedDependencyConfiguration = {
                ...returnedDependencyConfiguration,
                ...dependencyConfiguration
            };
        }
        return returnedDependencyConfiguration;
    }
    getClass() {
        return this.descriptor.class;
    }
}
addClasses([DependencyInjectionToken]);

class InjectionApplication {
    static getTokenDescriptor(input) {
        let descriptor = input;
        if (typeof input === 'string') {
            descriptor = {
                interface: input
            };
        }
        else {
            let prototype = input.prototype;
            if (prototype && prototype.constructor) {
                descriptor = {
                    class: input,
                    interface: prototype.constructor.name
                };
            }
        }
        if (!descriptor.class) {
            descriptor.class = null;
        }
        return descriptor;
    }
    constructor(name, domain) {
        this.name = name;
        this.domain = domain;
        this.tokenMap = new Map();
    }
    register(...injectedClassesOrInterfaceNames) {
        let tokensObject = {};
        for (let injectedClassOrInterfaceName of injectedClassesOrInterfaceNames) {
            const token = this.token(injectedClassOrInterfaceName);
            tokensObject[token.descriptor.interface] = token;
        }
        return tokensObject;
    }
    setDependencies(injectedClass, denendencyDescriptor) {
        injectedClass.token.setDependencies(denendencyDescriptor);
    }
    getFullName() {
        return `${this.domain.name}/${this.name}`;
    }
    token(input, failOnExistingToken = true) {
        const descriptor = InjectionApplication.getTokenDescriptor(input);
        const existingToken = this.tokenMap.get(descriptor.interface);
        if (existingToken) {
            if (failOnExistingToken) {
                throw new Error(`Token with interface '${descriptor.interface}' has already been created`);
            }
            else {
                return existingToken;
            }
        }
        const token = new DependencyInjectionToken(this, descriptor);
        token.setClass(input);
        this.tokenMap.set(descriptor.interface, token);
        if (descriptor.class) {
            token.setClass(descriptor.class);
        }
        return token;
    }
    getDomain(domainName) {
        return null;
    }
}
addClasses([InjectionApplication]);
function lib(libraryName) {
    return AIRPORT_DOMAIN.app(libraryName);
}

/**
 * A container (at this point) is primarily about maintaining transaction and user
 * session information through a request into an app (and across multiple apps).
 */
class ChildContainer extends Container {
    constructor(rootContainer, context) {
        super();
        this.rootContainer = rootContainer;
        this.context = context;
        // TODO: implement continuous upgrading
        // classes: any[]  = []
        // numPendingInits = 0
        // theObjects: any[]  = []
        this.objectMap = new Map();
    }
    getToken(token) {
        return globalThis.domain(token.application.domain.name)
            .getApp(token.application.name)
            .tokenMap.get(token.descriptor.interface);
    }
    setToken(token) {
        return globalThis.domain(token.application.domain.name)
            .getApp(token.application.name)
            .tokenMap.set(token.descriptor.interface, token);
    }
    getObject(token) {
        let mapForDomain = this.objectMap.get(token.application.domain.name);
        if (!mapForDomain) {
            return null;
        }
        let mapForApp = mapForDomain.get(token.application.name);
        if (!mapForApp) {
            return null;
        }
        return mapForApp.get(token.descriptor.interface);
    }
    setObject(token, object) {
        let mapForDomain = this.objectMap.get(token.application.domain.name);
        if (!mapForDomain) {
            mapForDomain = new Map();
            this.objectMap.set(token.application.domain.name, mapForDomain);
        }
        let mapForApp = mapForDomain.get(token.application.name);
        if (!mapForApp) {
            mapForApp = new Map();
            mapForDomain.set(token.application.name, mapForApp);
        }
        mapForApp.set(token.descriptor.interface, object);
    }
    doEventuallyGet(tokens, successCallback, errorCallback) {
        const normalizedTokens = this.normalizeTokens(tokens);
        let { firstDiNotSetClass, firstMissingClassToken, objects } = this.doGetCore(normalizedTokens);
        if (firstMissingClassToken || firstDiNotSetClass) {
            setTimeout(() => {
                this.doEventuallyGet(tokens, successCallback, errorCallback);
            }, 100);
        }
        else {
            if (objects.length > 1) {
                successCallback(objects);
            }
            else {
                successCallback(objects[0]);
            }
        }
    }
    doGet(tokens, successCallback, errorCallback) {
        const normalizedTokens = this.normalizeTokens(tokens);
        const { firstDiNotSetClass, firstMissingClassToken, objects } = this.doGetCore(normalizedTokens);
        if (firstDiNotSetClass) {
            console.log(`Dependency Injection is not ready for token ${firstMissingClassToken.getPath()}
			, class: ${firstDiNotSetClass.name}. Delaying injection by 100ms`);
            setTimeout(() => {
                this.doGet(tokens, successCallback, errorCallback);
            }, 100);
            return;
        }
        else if (objects.filter(object => object && !object.__initialized__).length) {
            const notInitializedObjectIndexes = objects.map((object, index) => object.__initialized__ ? -1 : index)
                .filter(index => index !== -1);
            const objectPaths = [];
            for (const index of notInitializedObjectIndexes) {
                const tokenPath = DependencyInjectionToken.getPath(normalizedTokens[index]);
                objectPaths.push(tokenPath);
            }
            console.log(`Dependency Injection is not ready for tokens:
				 ${objectPaths.join('\n')}
			, these classes are not yet initialized, delaying injection by 100ms`);
            setTimeout(() => {
                this.doGet(tokens, successCallback, errorCallback);
            }, 100);
            return;
        }
        if (firstMissingClassToken) {
            const message = 'Dependency Injection could not find class for token: '
                + firstMissingClassToken.getPath();
            console.log(message);
            errorCallback(message);
        }
        else {
            if (objects.length > 1) {
                successCallback(objects);
            }
            else {
                successCallback(objects[0]);
            }
        }
    }
    normalizeTokens(tokens) {
        const normalizedTokens = [];
        for (let token of tokens) {
            let prototype = token.prototype;
            if (prototype && prototype.constructor) {
                token = {
                    application: token.application,
                    descriptor: {
                        class: token,
                        interface: prototype.constructor.name
                    }
                };
            }
            let normalizedToken = token;
            if (!token.dependencyConfiguration) {
                normalizedToken = this.getToken(token);
                if (!normalizedToken) {
                    const fullTokenDescriptor = token;
                    const app = globalThis.domain(fullTokenDescriptor.application.domain.name)
                        .getApp(fullTokenDescriptor.application.name);
                    normalizedToken = app.token(fullTokenDescriptor.descriptor);
                    this.setToken(normalizedToken);
                }
            }
            normalizedTokens.push(normalizedToken);
        }
        return normalizedTokens;
    }
    doGetCore(tokens) {
        let firstMissingClassToken;
        let firstDiNotSetClass;
        const objects = tokens.map(token => {
            if (firstMissingClassToken || firstDiNotSetClass) {
                return;
            }
            let object = this.getObject(token);
            if (!object) {
                if (!(token instanceof DependencyInjectionToken)) {
                    throw new Error(`Non-API token lookups must be done
                            with an instance of a DependencyInjectionToken.`);
                }
                // NOTE: object pooling is not supported, see RootContainer for why
                // const rootObjectPool = this.rootContainer.objectPoolMap.get(token.descriptor.interface);
                // if (rootObjectPool && rootObjectPool.length) {
                //     object = rootObjectPool.pop()
                // } else {
                const aClass = token.descriptor.class;
                if (!aClass) {
                    firstMissingClassToken = token;
                    return;
                }
                if (aClass.diSet && !aClass.diSet()) {
                    firstMissingClassToken = token;
                    firstDiNotSetClass = aClass;
                    return;
                }
                object = new aClass();
                this.setDependencyGetters(object, token);
                // }
                object.__container__ = this;
                this.setObject(token, object);
                if (object.init) {
                    const result = object.init();
                    if (result instanceof Promise) {
                        result.then(_ => {
                            object.__initialized__ = true;
                            console.log(`${token.getPath()} initialized.`);
                        });
                    }
                    else {
                        object.__initialized__ = true;
                        console.log(`${token.getPath()} initialized.`);
                    }
                }
                else {
                    object.__initialized__ = true;
                }
            }
            return object;
        });
        return {
            firstDiNotSetClass,
            firstMissingClassToken,
            objects
        };
    }
    manualInject(object, propertyName, application, apiObject) {
        const descriptor = InjectionApplication.getTokenDescriptor(apiObject);
        object.__container__ = this;
        this.setDependencyGetter(object, propertyName, {
            application,
            descriptor
        });
    }
    setDependencyGetters(object, token) {
        if (!token.dependencyConfiguration) {
            return;
        }
        const dependencyConfiguration = token.dependencyConfiguration;
        for (let propertyName in dependencyConfiguration) {
            const dependencyToken = dependencyConfiguration[propertyName];
            this.setDependencyGetter(object, propertyName, dependencyToken);
        }
    }
    setDependencyGetter(object, propertyName, dependencyToken) {
        delete object[propertyName];
        Object.defineProperty(object, propertyName, {
            get() {
                return this.__container__.getSync(dependencyToken);
            }
        });
        object['get' + propertyName + 'Async'] = async function () {
            return await this.__container__.get(dependencyToken);
        };
    }
    async getByNames(domainName, applicationName, tokenInterface) {
        const injectionDomain = globalThis.domain(domainName);
        if (!injectionDomain) {
            throw new Error(`Could nof find
	Domain:
		${domainName}
		`);
        }
        const application = globalThis.domain(domainName).getApp(applicationName);
        if (!application) {
            throw new Error(`Could not find
	Domain:
		${domainName}
	Application:
		${applicationName}
		`);
        }
        const token = application.tokenMap.get(tokenInterface);
        if (!token) {
            throw new Error(`Could not find token: ${tokenInterface}
	in Domain:
		${domainName}
 	Application:
			${applicationName}
		`);
        }
        return await this.get(token);
    }
    get(...tokens) {
        return new Promise((resolve, reject) => {
            this.doGet(tokens, resolve, reject);
        });
    }
    eventuallyGet(...tokens) {
        return new Promise((resolve, reject) => {
            this.doEventuallyGet(tokens, resolve, reject);
        });
    }
    getSync(...tokens) {
        const normalizedTokens = this.normalizeTokens(tokens);
        const { firstDiNotSetClass, firstMissingClassToken, objects } = this.doGetCore(normalizedTokens);
        if (firstMissingClassToken) {
            throw new Error('Dependency Injection could not find class for token: '
                + firstMissingClassToken.getPath());
        }
        else if (firstDiNotSetClass) {
            throw new Error('Dependency Injection is not ready for class: '
                + firstDiNotSetClass.name);
        }
        if (objects.length > 1) {
            return objects;
        }
        else {
            return objects[0];
        }
    }
}
addClasses([ChildContainer]);

class RootContainer extends Container {
    constructor() {
        super(...arguments);
        this.dbContainerMap = new Map();
        this.uiContainers = new Set();
    }
    // NOTE: Object pooling is not supported because of possible callbacks
    // that are out of synchronous flow of a transaction.  Thus objects are
    // retained in the container even after the container is removed
    // in order to allow for transactionId reference
    // objectPoolMap: Map<string, any[]> = new Map();
    db(id = null) {
        let dbContainer = this.dbContainerMap.get(id);
        if (!dbContainer) {
            dbContainer = new ChildContainer(this, new Context(id, ContextType.DB));
            this.dbContainerMap.set(id, dbContainer);
        }
        return dbContainer;
    }
    remove(container) {
        if (!container) {
            return;
        }
        const dbContainer = this.dbContainerMap.get(container.context.id);
        if (dbContainer) {
            this.dbContainerMap.delete(container.context.id);
            // NOTE: objectPooling is not supported, see above
            // const objectTokens = dbContainer.objectMap.keys()
            // for (const objectToken of objectTokens) {
            // const object = dbContainer.objectMap.get(objectToken)
            // let objectPool = this.objectPoolMap.get(objectToken)
            // if (!objectPool) {
            //     objectPool = []
            //     this.objectPoolMap.set(objectToken, objectPool)
            // }
            // objectPool.push(object)
            // }
        }
        else {
            this.uiContainers.delete(container);
        }
    }
    ui(componentName) {
        const context = new Context(componentName, ContextType.UI);
        const childContainer = new ChildContainer(this, context);
        this.uiContainers.add(childContainer);
        return childContainer;
    }
}
addClasses([RootContainer]);
let rootContainer;
if (globalThis.DEPENDENCY_INJECTION) {
    rootContainer = globalThis.DEPENDENCY_INJECTION;
}
else {
    rootContainer = new RootContainer();
}
const DEPENDENCY_INJECTION = rootContainer;

class ContainerAccessor {
    getContainer(injectedObject) {
        const iocContainer = injectedObject.__container__;
        if (!iocContainer) {
            throw new Error('"container" is not set on injectable object.');
        }
        if (!(iocContainer instanceof Container)) {
            throw new Error('"container" property of injectable is not an' +
                'instance of @airport/direction-indicator Container');
        }
        return iocContainer;
    }
}

const directionIndicator = lib('direction-indicator');
directionIndicator.register(ContainerAccessor);
const AIR_ENTITY_UTILS = lib('aviation-communication').token('AirEntityUtils');
globalThis.AIR_ENTITY_UTILS = AIR_ENTITY_UTILS;
const pressurization = lib('pressurization');
globalThis.OPERATION_SERIALIZER = pressurization.token('OperationSerializer');
const QUERY_RESULTS_DESERIALIZER = pressurization.token('QueryResultsDeserializer');
globalThis.QUERY_RESULTS_DESERIALIZER = QUERY_RESULTS_DESERIALIZER;
globalThis.SERIALIZATION_STATE_MANAGER = pressurization.token('SerializationStateManager');
const autopilot = lib('autopilot');
const AUTOPILOT_API_LOADER = autopilot.token('AutopilotApiLoader');
globalThis.AUTOPILOT_API_LOADER = AUTOPILOT_API_LOADER;
const API_CLIENT = autopilot.token('InterAppAPIClient');
globalThis.API_CLIENT = API_CLIENT;

class InversionOfControl {
    async get(...tokens) {
        return await DEPENDENCY_INJECTION.db().get(...tokens);
    }
    async eventuallyGet(...tokens) {
        return await DEPENDENCY_INJECTION.db().eventuallyGet(...tokens);
    }
    getSync(...tokens) {
        return DEPENDENCY_INJECTION.db().getSync(...tokens);
    }
    getAutopilotApiLoader() {
        return this.getSync(AUTOPILOT_API_LOADER);
    }
}
addClasses([InversionOfControl]);

const Injected = function () {
    return function (constructor) {
        // No runtime logic required.
    };
};
const Inject = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};

/**
 * From:
 * http://js-bits.blogspot.com/2010/08/javascript-inheritance-done-right.html
 * Via:
 * https://stackoverflow.com/questions/6617780/how-to-call-parent-constructor
 */
function extend(base, sub, methods) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    sub.base = base.prototype;
    // Copy the methods passed in to the prototype
    for (const name in methods) {
        sub.prototype[name] = methods[name];
    }
    // so we can define the constructor inline
    return sub;
}
globalThis.extend = extend;

let inversionOfControl;
if (globalThis.IOC) {
    inversionOfControl = globalThis.IOC;
}
else {
    inversionOfControl = new InversionOfControl();
    globalThis.IOC = inversionOfControl;
}
const IOC = inversionOfControl;

class Dictionary {
    constructor() {
        this.airbridge = {
            DOMAIN_NAME: 'airbridge'
        };
        this.airport = {
            DOMAIN_NAME: 'airport',
            apps: {
                AIRPORT_CODE: {
                    name: '@airport/airport-code',
                    entities: {
                        SystemWideOperationId: {
                            name: 'SystemWideOperationId',
                            columns: {
                                SYSTEM_WIDE_OPERATION_LID: 'SYSTEM_WIDE_OPERATION_LID'
                            },
                            properties: {
                                systemWideOperationId: 'systemWideOperationId'
                            }
                        }
                    }
                },
                AIRSPACE: {
                    name: '@airport/airspace',
                    entities: {
                        ApplicationRelation: {
                            name: 'ApplicationRelation'
                        }
                    }
                },
                FINAL_APPROACH: {
                    name: '@airport/final-approach',
                    entities: {
                        AirEntity: {
                            name: 'AirEntity',
                            columns: {
                                ACTOR_LID: 'ACTOR_LID',
                                ACTOR_RECORD_ID: 'ACTOR_RECORD_ID',
                                REPOSITORY_LID: 'REPOSITORY_LID',
                                SYSTEM_WIDE_OPERATION_LID: 'SYSTEM_WIDE_OPERATION_LID'
                            },
                            properties: {
                                _actorRecordId: '_actorRecordId',
                                _localId: '_localId',
                                actor: 'actor',
                                repository: 'repository',
                                systemWideOperationId: 'systemWideOperationId'
                            }
                        }
                    }
                },
                /*
                FLIGHT_RECORDER: {
                    name: '@airport/flight-recorder',
                    entities: {
                        CopiedRecordLedger: {
                            name: 'CopiedRecordLedger',
                            columns: {
                                COPY_ACTOR_LID: 'COPY_ACTOR_LID',
                                COPY_REPOSITORY_LID: 'COPY_REPOSITORY_LID',
                            }
                        },
                        CrossRepositoryRelationLedger: {
                            name: 'CrossRepositoryRelationLedger',
                            columns: {
                                RELATION_LID: 'MANY_SIDE_APPLICATION_RELATION_LID',
                                RELATED_REPOSITORY_LID: 'MANY_SIDE_REPOSITORY_LID',
                            }
                        }
                    }
                },
                */
                HOLDING_PATTERN: {
                    name: '@airport/holding-pattern',
                    entities: {
                        Actor: {
                            name: 'Actor',
                            columns: {
                                ACTOR_LID: 'ACTOR_LID',
                                USER_ACCOUNT_LID: 'USER_ACCOUNT_LID'
                            },
                            properties: {
                                userAccount: 'userAccount'
                            }
                        },
                        InternalAirEntity: {
                            name: 'InternalAirEntity'
                        },
                        Repository: {
                            name: 'Repository',
                            columns: {
                                REPOSITORY_LID: 'REPOSITORY_LID',
                                GUID: 'GUID'
                            },
                            properties: {
                                _localId: '_localId',
                                GUID: 'GUID'
                            }
                        },
                        RepositoryMember: {
                            name: 'RepositoryMember'
                        },
                        RepositoryMemberAcceptance: {
                            name: 'RepositoryMemberAcceptance'
                        },
                        RepositoryMemberInvitation: {
                            name: 'RepositoryMemberInvitation'
                        },
                        RepositoryMemberUpdate: {
                            name: 'RepositoryMemberUpdate'
                        }
                    }
                },
                TRAVEL_DOCUMENT_CHECKPOINT: {
                    name: '@airport/travel-document-checkpoint',
                    entities: {
                        Terminal: {
                            name: 'Terminal',
                            columns: {
                                TERMINAL_LID: 'TERMINAL_LID'
                            }
                        },
                        UserAccount: {
                            name: 'UserAccount',
                            columns: {
                                USER_ACCOUNT_LID: 'USER_ACCOUNT_LID'
                            },
                            properties: {
                                userAccount: 'userAccount'
                            }
                        }
                    }
                }
            }
        };
        this.airway = {
            DOMAIN_NAME: 'airway'
        };
        this.INTERNAL_APP = '@airport/terminal';
        this.INTERNAL_DOMAIN = 'internal://domain';
        this.Actor = this.airport.apps.HOLDING_PATTERN.entities.Actor;
        this.AirEntity = this.airport.apps.FINAL_APPROACH.entities.AirEntity;
        this.ApplicationRelation = this.airport.apps.AIRSPACE.entities.ApplicationRelation;
        this.InternalAirEntity = this.airport.apps.HOLDING_PATTERN.entities.InternalAirEntity;
        // CopiedRecordLedger = this.airport.apps.FLIGHT_RECORDER.entities.CopiedRecordLedger
        // CrossRepositoryRelationLedger = this.airport.apps.FLIGHT_RECORDER.entities.CrossRepositoryRelationLedger
        this.Repository = this.airport.apps.HOLDING_PATTERN.entities.Repository;
        this.SystemWideOperationId = this.airport.apps.AIRPORT_CODE.entities.SystemWideOperationId;
        this.Terminal = this.airport.apps.TRAVEL_DOCUMENT_CHECKPOINT.entities.Terminal;
        this.UserAccount = this.airport.apps.TRAVEL_DOCUMENT_CHECKPOINT.entities.UserAccount;
        this.column = {
            /**
             * Name property of the column.
             * @type {string}
             */
            NAME: 'name',
            /**
             * Column data types.
             */
            type: {
                ANY: 'any',
                BOOLEAN: 'boolean',
                DATE: 'Date',
                NUMBER: 'number',
                STRING: 'string',
            },
            _localId: '_localId'
        };
        /**
         * Entity configuration keys.
         */
        this.entity = {
            DATABASES: 'databases'
        };
        /**
         * File level keys.
         */
        this.file = {
            ENTITY: 'Entity',
            TABLE: 'Table'
        };
        /**
         * Foreign Key configuration keys.
         */
        this.foreignkey = {
            DEFINITION: 'foreignKeyDefinition',
            NAME: 'name',
            VALUE: 'value'
        };
        /**
         * Index configuration keys.
         */
        this.index = {
            COLUMN_LIST: 'columnList',
            NAME: 'name',
            UNIQUE: 'unique'
        };
        /**
         * JoinColumn configuration keys.
         */
        this.joincolumn = {
            FOREIGN_KEY: 'foreignKey',
            REFERENCED_COLUMN_NAME: 'referencedColumnName',
            VALUE: 'value'
        };
        /**
         * OneToMany configuration keys.
         */
        this.onetomany = {
            MAPPED_BY: 'mappedBy'
        };
        /**
         * Property annotation keys.
         */
        this.property = {
            COLUMN: 'Column',
            ENUM_TYPE: 'Enum',
            ID: 'Id',
            JOIN_COLUMN: 'JoinColumn',
            JOIN_COLUMNS: 'JoinColumns',
            JSON_TYPE: 'Json',
            MANY_TO_ONE: 'ManyToOne',
            ONE_TO_MANY: 'OneToMany',
            // R_JOIN_COLUMN(s) are not needed since Repository relations are now
            // standardized - simple (@ManyToOne) and (@OneToMany) suffice.
            // R_JOIN_COLUMN   : 'RJoinColumn';
            // R_JOIN_COLUMNS  : 'RJoinColumns';
            SUB_QUERY: 'SubQuery',
            // WHERE_JOIN_TABLE: 'WhereJoinTable';
        };
        /**
         * Table configuration keys.
         */
        this.table = {
            INDEXES: 'indexes',
            NAME: 'name',
            PRIMARY_KEY: 'primaryKey',
            APPLICATION: 'application'
        };
        this.userAccount = {
            USER_ACCOUNT_LID: 'USER_ACCOUNT_LID'
        };
        this.terminal = {
            TERMINAL_LID: 'TERMINAL_LID'
        };
    }
    isActor(dbEntity) {
        return this.isEntityType(dbEntity, this.airport.apps.HOLDING_PATTERN, this.Actor);
    }
    isApplicationRelation(dbEntity) {
        return this.isEntityType(dbEntity, this.airport.apps.AIRSPACE, this.ApplicationRelation);
    }
    isRepository(dbEntity) {
        return this.isEntityType(dbEntity, this.airport.apps.HOLDING_PATTERN, this.Repository);
    }
    isRepositoryGUIDProperty(dbProperty) {
        if (!this.isRepository(dbProperty.entity)) {
            return false;
        }
        return dbProperty.name === this.Repository.properties.GUID;
    }
    isRepositoryLIDColumn(dbProperty, dbColumn) {
        if (!dbProperty.entity.isAirEntity) {
            if (!this.isRepository(dbProperty.entity)) {
                return false;
            }
            return dbColumn.name === this.Repository.columns.REPOSITORY_LID;
        }
        return this.isRepositoryRelationColumn(dbColumn);
    }
    isTerminal(dbEntity) {
        return this.isEntityType(dbEntity, this.airport.apps.TRAVEL_DOCUMENT_CHECKPOINT, this.Terminal);
    }
    isUserAccount(dbEntity) {
        return this.isEntityType(dbEntity, this.airport.apps.TRAVEL_DOCUMENT_CHECKPOINT, this.UserAccount);
    }
    isActorRelationColumn(dbColumn) {
        return /.*_AID_[\d]+$/.test(dbColumn.name)
            && !!dbColumn.manyRelationColumns.length;
    }
    isRepositoryRelationColumn(dbColumn) {
        return /.*_RID_[\d]+$/.test(dbColumn.name)
            && !!dbColumn.manyRelationColumns.length;
    }
    isActorProperty(dbProperty) {
        return dbProperty.entity.isAirEntity
            && this.AirEntity.properties.actor === dbProperty.name;
    }
    isRepositoryProperty(dbProperty) {
        return dbProperty.entity.isAirEntity
            && this.AirEntity.properties.repository === dbProperty.name;
    }
    isEntityType(dbEntity, application, entity) {
        const dbApplication = dbEntity.applicationVersion.application;
        return dbApplication.domain.name === this.airport.DOMAIN_NAME
            && dbApplication.name === application.name
            && dbEntity.name === entity.name;
    }
}

/**
 * SQL Join contentType.
 */
var JoinType;
(function (JoinType) {
    JoinType["FULL_JOIN"] = "FULL_JOIN";
    JoinType["INNER_JOIN"] = "INNER_JOIN";
    JoinType["LEFT_JOIN"] = "LEFT_JOIN";
    JoinType["RIGHT_JOIN"] = "RIGHT_JOIN";
})(JoinType || (JoinType = {}));
/**
 * Type of Entity Relation
 */
var EntityRelationType;
(function (EntityRelationType) {
    EntityRelationType["ONE_TO_MANY"] = "ONE_TO_MANY";
    EntityRelationType["MANY_TO_ONE"] = "MANY_TO_ONE";
})(EntityRelationType || (EntityRelationType = {}));
/**
 * Serialized relation contentType.
 */
var JSONRelationType;
(function (JSONRelationType) {
    // Join of an entity with the ON clause
    JSONRelationType["ENTITY_JOIN_ON"] = "ENTITY_JOIN_ON";
    // Join of an entity via a application relation
    JSONRelationType["ENTITY_APPLICATION_RELATION"] = "ENTITY_APPLICATION_RELATION";
    // The root entity in a join
    JSONRelationType["ENTITY_ROOT"] = "ENTITY_ROOT";
    // Join of a sub-query (with the ON clause)
    JSONRelationType["SUB_QUERY_JOIN_ON"] = "SUB_QUERY_JOIN_ON";
    // The root sub-query in a join
    JSONRelationType["SUB_QUERY_ROOT"] = "SUB_QUERY_ROOT";
})(JSONRelationType || (JSONRelationType = {}));

/**
 * Order of a sorted field, as specified in the ORDER BY clause.
 */
var SortOrder;
(function (SortOrder) {
    SortOrder["ASCENDING"] = "ASCENDING";
    SortOrder["DESCENDING"] = "DESCENDING";
})(SortOrder || (SortOrder = {}));

/**
 * Extracted from http://www.w3schools.com/sql/sql_functions.asp
 */
var SqlFunction;
(function (SqlFunction) {
    // SQL Aggregate Functions
    // SQL aggregate functions return a single value, calculated from values in a column.
    // Useful Aggregate functions:
    SqlFunction["ABS"] = "ABS";
    SqlFunction["AVG"] = "AVG";
    SqlFunction["COUNT"] = "COUNT";
    //FIRST, // not in SqLite: Returns the first value
    //LAST, // not in SqLite: Returns the last value
    SqlFunction["MAX"] = "MAX";
    SqlFunction["MIN"] = "MIN";
    SqlFunction["SUM"] = "SUM";
    //SQL Scalar functions
    //SQL scalar functions return a single value, based on the input value.
    // Useful scalar functions:
    SqlFunction["UCASE"] = "UCASE";
    SqlFunction["LCASE"] = "LCASE";
    SqlFunction["MID"] = "MID";
    SqlFunction["LEN"] = "LEN";
    SqlFunction["ROUND"] = "ROUND";
    SqlFunction["NOW"] = "NOW";
    SqlFunction["FORMAT"] = "FORMAT";
    // Added
    SqlFunction["REPLACE"] = "REPLACE";
    SqlFunction["TRIM"] = "TRIM";
    // Other
    SqlFunction["DISTINCT"] = "DISTINCT";
    SqlFunction["EXISTS"] = "EXISTS";
    // Algebra Operators
    SqlFunction["DIVIDE"] = "DIVIDE";
    SqlFunction["MINUS"] = "MINUS";
    SqlFunction["MODULUS"] = "MODULUS";
    SqlFunction["MULTIPLY"] = "MULTIPLY";
    SqlFunction["PLUS"] = "PLUS";
    // Concatenate '||' functions
    SqlFunction["CONCATENATE"] = "CONCATENATE";
    // Other functions
    SqlFunction["COALESCE"] = "COALESCE";
})(SqlFunction || (SqlFunction = {}));

/**
 * All possible types of serialized JSON clauses.
 */
var JSONClauseObjectType;
(function (JSONClauseObjectType) {
    JSONClauseObjectType["FIELD"] = "FIELD";
    JSONClauseObjectType["FIELD_FUNCTION"] = "FIELD_FUNCTION";
    JSONClauseObjectType["FIELD_QUERY"] = "FIELD_QUERY";
    JSONClauseObjectType["DISTINCT_FUNCTION"] = "DISTINCT_FUNCTION";
    JSONClauseObjectType["EXISTS_FUNCTION"] = "EXISTS_FUNCTION";
    JSONClauseObjectType["MANY_TO_ONE_RELATION"] = "MANY_TO_ONE_RELATION"; // A many-to-one relation (used in a query)
})(JSONClauseObjectType || (JSONClauseObjectType = {}));
/**
 * Types of data
 */
var SQLDataType;
(function (SQLDataType) {
    // Allowing ANY allows developers to de-type their data
    SQLDataType["ANY"] = "ANY";
    SQLDataType["BOOLEAN"] = "BOOLEAN";
    SQLDataType["DATE"] = "DATE";
    // Allowing JSON allows developers to de-normalize their data
    SQLDataType["JSON"] = "JSON";
    SQLDataType["NUMBER"] = "NUMBER";
    SQLDataType["STRING"] = "STRING";
})(SQLDataType || (SQLDataType = {}));
function getSqlDataType(sColumn) {
    switch (sColumn.type) {
        case 'any':
            return SQLDataType.ANY;
        case 'boolean':
            return SQLDataType.BOOLEAN;
        case 'Date':
            return SQLDataType.DATE;
        case 'Json':
            return SQLDataType.JSON;
        case 'number':
            return SQLDataType.NUMBER;
        case 'string':
            return SQLDataType.STRING;
        default:
            throw new Error(`Uknown type: ${sColumn.type} for column '${sColumn.name}'`);
    }
}

var EntityState;
(function (EntityState) {
    EntityState["CREATE"] = "CREATE";
    EntityState["DATE"] = "DATE";
    EntityState["DELETE"] = "DELETE";
    // Originally it was PARENT_SCHEMA_ID and was meant for @ManyToOne() references
    // when nothing is returned except for the id fields of the relation, however
    // this schenario was sufficiently covered by STUB - id's only stub.  Now it's
    // PARENT_SCHEMA_ID and currently used only for save operations
    // when the entity referenced via the relation belongs to another application.
    // This is because save does not allow to peristance of records across application
    // boundaries (that should be done via an @Api() which will run validation and
    // other logic).
    // In that case we want to keep the ID of the record from another application
    // so that it can be saved in the record of the current application that is
    // referencing it.
    EntityState["PARENT_SCHEMA_ID"] = "PARENT_SCHEMA_LID";
    // A "Pass through object" is an existing that is present in the object graph
    // but no operations are performed on it
    EntityState["PASS_THROUGH"] = "PASS_THROUGH";
    // An "Id's only" stub
    EntityState["STUB"] = "STUB";
    EntityState["UPDATE"] = "UPDATE";
    // Json fields promote application de-normalization and a currently not implemented
    // except for internal APIs
    // RESULT_JSON = 'RESULT_JSON',
    // RESULT_JSON_ARRAY = 'RESULT_JSON_ARRAY'
})(EntityState || (EntityState = {}));

/**
 * Category of a SQL contentType
 */
var OperationCategory;
(function (OperationCategory) {
    OperationCategory["BOOLEAN"] = "BOOLEAN";
    OperationCategory["DATE"] = "DATE";
    OperationCategory["FUNCTION"] = "FUNCTION";
    OperationCategory["LOGICAL"] = "LOGICAL";
    OperationCategory["NUMBER"] = "NUMBER";
    OperationCategory["STRING"] = "STRING";
    OperationCategory["UNTYPED"] = "UNTYPED"; // Operation on an untyped field
})(OperationCategory || (OperationCategory = {}));
var SqlOperator;
(function (SqlOperator) {
    SqlOperator["AND"] = "AND";
    SqlOperator["EQUALS"] = "EQUALS";
    SqlOperator["EXISTS"] = "EXISTS";
    SqlOperator["GREATER_THAN"] = "GREATER_THAN";
    SqlOperator["GREATER_THAN_OR_EQUALS"] = "GREATER_THAN_OR_EQUALS";
    SqlOperator["IN"] = "IN";
    SqlOperator["IS_NOT_NULL"] = "IS_NOT_NULL";
    SqlOperator["IS_NULL"] = "IS_NULL";
    SqlOperator["LESS_THAN"] = "LESS_THAN";
    SqlOperator["LESS_THAN_OR_EQUALS"] = "LESS_THAN_OR_EQUALS";
    SqlOperator["LIKE"] = "LIKE";
    SqlOperator["OR"] = "OR";
    SqlOperator["NOT"] = "NOT";
    SqlOperator["NOT_EQUALS"] = "NOT_EQUALS";
    SqlOperator["NOT_IN"] = "NOT_IN";
})(SqlOperator || (SqlOperator = {}));
var CRUDOperation;
(function (CRUDOperation) {
    CRUDOperation["CREATE"] = "CREATE";
    CRUDOperation["READ"] = "READ";
    CRUDOperation["UPDATE"] = "UPDATE";
    CRUDOperation["DELETE"] = "DELETE";
})(CRUDOperation || (CRUDOperation = {}));

var RepositoryMember_Status;
(function (RepositoryMember_Status) {
    RepositoryMember_Status[RepositoryMember_Status["INVITED"] = 0] = "INVITED";
    RepositoryMember_Status[RepositoryMember_Status["JOINED"] = 1] = "JOINED";
})(RepositoryMember_Status || (RepositoryMember_Status = {}));

var SynchronizationConflict_Type;
(function (SynchronizationConflict_Type) {
    SynchronizationConflict_Type["LOCAL_UPDATE_REMOTELY_DELETED"] = "LOCAL_UPDATE_REMOTELY_DELETED";
    SynchronizationConflict_Type["REMOTE_CREATE_REMOTELY_DELETED"] = "REMOTE_CREATE_REMOTELY_DELETED";
    SynchronizationConflict_Type["REMOTE_UPDATE_LOCALLY_DELETED"] = "REMOTE_UPDATE_LOCALLY_DELETED";
    SynchronizationConflict_Type["REMOTE_UPDATE_LOCALLY_UPDATED"] = "REMOTE_UPDATE_LOCALLY_UPDATED";
})(SynchronizationConflict_Type || (SynchronizationConflict_Type = {}));

var UpdateState;
(function (UpdateState) {
    UpdateState["GO_ONLINE"] = "GO_ONLINE";
    UpdateState["REMOTE"] = "REMOTE";
    UpdateState["LOCAL"] = "LOCAL";
})(UpdateState || (UpdateState = {}));

var TransactionType;
(function (TransactionType) {
    TransactionType["LOCAL"] = "LOCAL";
    TransactionType["REMOTE_SYNC"] = "REMOTE_SYNC";
})(TransactionType || (TransactionType = {}));
var RepositoryTransactionType;
(function (RepositoryTransactionType) {
    RepositoryTransactionType["LOCAL"] = "LOCAL";
    RepositoryTransactionType["REMOTE"] = "REMOTE";
    RepositoryTransactionType["REMOTE_REFERENCE"] = "REMOTE_REFERENCE";
})(RepositoryTransactionType || (RepositoryTransactionType = {}));

var ChangeType;
(function (ChangeType) {
    ChangeType["DELETE_ROWS"] = "DELETE_ROWS";
    ChangeType["INSERT_VALUES"] = "INSERT_VALUES";
    ChangeType["UPDATE_ROWS"] = "UPDATE_ROWS";
})(ChangeType || (ChangeType = {}));

/**
 * Possible distribution strategies for Change List Federations.
 *
 * A common (and only currently supported) basic setup:
 *
 * There is always a Single Shared Store (S3).
 * There are always at least one or more 'Personal' Stores.
 *
 * The stores communicate via servers that propagate data from
 * personal stores to the shared store.
 *
 * What differs is how this propagation is accomplished.
 *
 * In the future, we'll add a truly distributed setup, without any S3s.
 */
var DistributionStrategy;
(function (DistributionStrategy) {
    /**
     *  The server is aware of all Personal Stores and it
     *  subscribes to any possible changes in any of these stores.
     *  It is the server's responsibility to update the S3.
     */
    DistributionStrategy["S3_SECURE_POLL"] = "S3_SECURE_POLL";
    /**
     * There is no need for a server, all clients are aware of S3
     * and are responsible for pushing their changes to it.
     */
    DistributionStrategy["S3_DISTIBUTED_PUSH"] = "S3_DISTIBUTED_PUSH";
})(DistributionStrategy || (DistributionStrategy = {}));

var QueryType;
(function (QueryType) {
    QueryType["DDL"] = "DDL";
    QueryType["SELECT"] = "SELECT";
    QueryType["MUTATE"] = "MUTATE";
})(QueryType || (QueryType = {}));

var PlatformType;
(function (PlatformType) {
    PlatformType["GOOGLE_DOCS"] = "GOOGLE_DOCS";
    PlatformType["IN_MEMORY"] = "IN_MEMORY";
    PlatformType["OFFLINE"] = "OFFLINE";
    PlatformType["STUB"] = "STUB";
})(PlatformType || (PlatformType = {}));

var StoreType;
(function (StoreType) {
    StoreType["COCKROACHDB"] = "COCKROACHDB";
    StoreType["MYSQL"] = "MYSQL";
    StoreType["POSTGRESQL"] = "POSTGRESQL";
    StoreType["REMOTE"] = "REMOTE";
    StoreType["SQLITE"] = "SQLITE";
    StoreType["SQLJS"] = "SQLJS";
    StoreType["WEB_SQL"] = "WEB_SQL";
})(StoreType || (StoreType = {}));
var IdGeneration;
(function (IdGeneration) {
    IdGeneration["ENTITY_CHANGE_ID"] = "ENTITY_CHANGE_LID";
})(IdGeneration || (IdGeneration = {}));

var JsonStatementType;
(function (JsonStatementType) {
    JsonStatementType["ENTITY_QUERY"] = "ENTITY_QUERY";
    JsonStatementType["NON_ENTITY_QUERY"] = "NON_ENTITY_QUERY";
})(JsonStatementType || (JsonStatementType = {}));

var QueryResultType;
(function (QueryResultType) {
    // Ordered query result with bridging for all MtOs and OtM
    QueryResultType["ENTITY_GRAPH"] = "ENTITY_GRAPH";
    // Ordered query result, with objects grouped hierarchically by entity
    QueryResultType["ENTITY_TREE"] = "ENTITY_TREE";
    // Ordered query result, with objects grouped hierarchically by mapping
    QueryResultType["TREE"] = "TREE";
    // Flat array query result, with no forced ordering or grouping
    QueryResultType["SHEET"] = "SHEET";
    // A single field query result, with no forced ordering or grouping
    QueryResultType["FIELD"] = "FIELD";
    // Raw result, returned by a SQL string query
    QueryResultType["RAW"] = "RAW";
})(QueryResultType || (QueryResultType = {}));

var OperationType;
(function (OperationType) {
    OperationType["DELETE"] = "DELETE";
    OperationType["FIND_ONE_GRAPH"] = "FIND_ONE_GRAPH";
    OperationType["FIND_ONE_TREE"] = "FIND_ONE_TREE";
    OperationType["FIND_GRAPH"] = "FIND_GRAPH";
    OperationType["FIND_TREE"] = "FIND_TREE";
    OperationType["SAVE"] = "SAVE";
    OperationType["SEARCH_ONE_GRAPH"] = "SEARCH_ONE_GRAPH";
    OperationType["SEARCH_ONE_TREE"] = "SEARCH_ONE_TREE";
    OperationType["SEARCH_GRAPH"] = "SEARCH_GRAPH";
    OperationType["SEARCH_TREE"] = "SEARCH_TREE";
})(OperationType || (OperationType = {}));
var QueryInputKind;
(function (QueryInputKind) {
    QueryInputKind["PARAMETER"] = "PARAMETER";
    QueryInputKind["Q"] = "Q";
    QueryInputKind["QENTITY"] = "QENTITY";
})(QueryInputKind || (QueryInputKind = {}));
var QueryParameterType;
(function (QueryParameterType) {
    QueryParameterType["BOOLEAN"] = "BOOLEAN";
    QueryParameterType["DATE"] = "DATE";
    QueryParameterType["NUMBER"] = "NUMBER";
    QueryParameterType["STRING"] = "STRING";
})(QueryParameterType || (QueryParameterType = {}));

var ApplicationStatus;
(function (ApplicationStatus) {
    ApplicationStatus["CURRENT"] = "CURRENT";
    ApplicationStatus["MISSING"] = "MISSING";
    ApplicationStatus["NEEDS_UPGRADES"] = "NEEDS_UPGRADES";
    ApplicationStatus["STUB"] = "STUB";
})(ApplicationStatus || (ApplicationStatus = {}));

class ColumnMap {
    constructor(tableIndex, allColumns = false) {
        this.tableIndex = tableIndex;
        this.columnMap = {};
        if (allColumns) {
            this.columnMap[globalThis.ALL_TABLE_COLUMNS] = true;
        }
    }
    ensure(columnIndex) {
        this.columnMap[columnIndex] = true;
    }
}
globalThis.ColumnMap = ColumnMap;

class DbApplicationUtils {
    getApplication_FullName({ domain, name, }) {
        if (domain.name) {
            domain = domain.name;
        }
        return this.getApplication_FullNameFromDomainAndName(domain, name);
    }
    getApplication_FullNameFromDomainAndName(domainName, applicationName) {
        if (domainName.indexOf('___') > -1) {
            throw new Error('Domain Name cannot contain "___" (3 consecutive underscores) in it.');
        }
        if (domainName.endsWith('.')
            || domainName.endsWith('-')
            || domainName.endsWith(':')
            || domainName.endsWith('__')) {
            throw new Error('Domain Name cannot end with ".", "-", ":" or "__"');
        }
        const domainPrefix = domainName
            .replace(/\./g, '_dot_')
            .replace(/-/g, '_dash_')
            .replace(/:/g, '_colon_');
        if (domainPrefix.indexOf('___') > -1) {
            throw new Error('Domain Name cannot have with ".", "-", ":", or "_" right next to each other.');
        }
        if (applicationName.indexOf('_') > -1) {
            throw new Error('Application Name cannot contain "_" in it.');
        }
        if (applicationName.indexOf('@') !== applicationName.lastIndexOf('@')) {
            throw new Error('Application Name cannot have more than one "@" in it.');
        }
        if (applicationName.indexOf('@') > 0) {
            throw new Error('Application Name cannot contain "@" after the first character in it.');
        }
        if (applicationName.indexOf('/') !== applicationName.lastIndexOf('/')) {
            throw new Error('Application Name cannot have more than one "/" in it.');
        }
        const applicationPrefix = applicationName
            .replace(/@/g, '_at_')
            .replace(/\//g, '_slash_')
            .replace(/-/g, '_dash_');
        if (applicationPrefix.endsWith('_')) {
            throw new Error('Application Name cannot end with "@", "/" or "."');
        }
        if (applicationPrefix.indexOf('___') > -1) {
            throw new Error('Application Name cannot have with "@", "/", "." or "_" right next to each other.');
        }
        let fullApplication_Name = `${domainPrefix}___${applicationPrefix}`;
        if (fullApplication_Name.endsWith('_dash_runtime')) {
            fullApplication_Name = fullApplication_Name.substring(0, fullApplication_Name.length - 13);
        }
        return fullApplication_Name;
    }
    getSequenceName(prefixedTableName, columnName) {
        return `${prefixedTableName}_${columnName}__SEQUENCE`;
    }
}

/**
 * Created by Papa on 9/10/2016.
 */
globalThis.ALL_TABLE_COLUMNS = '__ALL_TABLE_COLUMNS__';
class TableMap {
    constructor(applicationVersionId, tableMap = {}) {
        this.applicationVersionId = applicationVersionId;
        this.tableMap = tableMap;
    }
    ensure(tableIndex, allColumns = false, ColumnMapConstructor = globalThis.ColumnMap) {
        let tableColumnMap = this.tableMap[tableIndex];
        if (!tableColumnMap) {
            tableColumnMap = new ColumnMapConstructor(tableIndex, allColumns);
            this.tableMap[tableIndex] = tableColumnMap;
        }
        return tableColumnMap;
    }
    existsByStructure(tableIndex, columnIndex) {
        let tableColumnMap = this.tableMap[tableIndex];
        if (!tableColumnMap) {
            return false;
        }
        return !!tableColumnMap.columnMap[columnIndex];
    }
}
globalThis.TableMap = TableMap;

class ApplicationMap {
    constructor(applicationMap = {}) {
        this.applicationMap = applicationMap;
    }
    ensureEntity(entity, allColumns = false, TableMapConstructor = TableMap) {
        return this.ensure(entity.applicationVersion._localId, entity.index, allColumns, TableMapConstructor);
    }
    ensure(applicationVersionLocalId, tableIndex, allColumns = false, TableMapConstructor = globalThis.TableMap) {
        let tableMap = this.applicationMap[applicationVersionLocalId];
        if (!tableMap) {
            tableMap = new TableMapConstructor(applicationVersionLocalId);
            this.applicationMap[applicationVersionLocalId] = tableMap;
        }
        return tableMap.ensure(tableIndex, allColumns);
    }
    existsByStructure(applicationVersionLocalId, tableIndex, columnIndex) {
        let tableMap = this.applicationMap[applicationVersionLocalId];
        if (!tableMap) {
            return false;
        }
        return tableMap.existsByStructure(tableIndex, columnIndex);
    }
}
globalThis.ApplicationMap = ApplicationMap;

class SyncColumnMap extends ColumnMap {
    constructor(tableIndex, allColumns = false) {
        super(tableIndex, allColumns);
    }
}
globalThis.SyncColumnMap = SyncColumnMap;

class SyncApplicationMap extends ApplicationMap {
    constructor(applicationMap) {
        super(applicationMap);
    }
    ensureEntity(entity, allColumns = false) {
        return super.ensureEntity(entity, allColumns, globalThis.SyncTableMap);
    }
    intersects(fieldMap) {
        for (const applicationIndex in this.applicationMap) {
            if (fieldMap.applicationMap[applicationIndex]) {
                const syncTableMap = new globalThis.SyncTableMap(parseInt(applicationIndex), this.applicationMap[applicationIndex].tableMap);
                if (syncTableMap.intersects(fieldMap.applicationMap[applicationIndex])) {
                    return true;
                }
            }
        }
        return false;
    }
    merge(fieldMap) {
        for (const applicationIndex in fieldMap.applicationMap) {
            const tableMap = this.applicationMap[applicationIndex];
            const tableMapIn = fieldMap.applicationMap[applicationIndex];
            if (!tableMap) {
                this.applicationMap[applicationIndex] = tableMapIn;
                continue;
            }
            for (const tableIndex in tableMapIn.tableMap) {
                const columnMap = tableMap.tableMap[tableIndex];
                const columnMapIn = tableMapIn.tableMap[tableIndex];
                if (!columnMap) {
                    tableMap.tableMap[tableIndex] = columnMapIn;
                }
                for (const columnIndex in columnMapIn.columnMap) {
                    columnMap.columnMap[columnIndex] = true;
                }
            }
        }
    }
}
globalThis.SyncApplicationMap = SyncApplicationMap;

var BlockSyncStatus;
(function (BlockSyncStatus) {
    // Sync request has been sent but no reply has come yet
    BlockSyncStatus["SYNCHRONIZING"] = "SYNCHRONIZING";
    // Sync has been acknowledged by the AGT
    BlockSyncStatus["SYNCHRONIZED"] = "SYNCHRONIZED";
    // Sync has not been acked by AGT so, requesting sync status from AGT
    BlockSyncStatus["REQUESTING_SYNC_STATUS"] = "REQUESTING_SYNC_STATUS";
    /*
       Do not re-sync until AGT starts responds with a request for more data.
       NOTE: no need of a separate status, state is maintained on SharingNode level.
     */
    // RESYNC_SUSPENDED = 'RESYNC_SUSPENDED',
    // AGT requested re-sync for this block, send it again
    BlockSyncStatus["RESYNC_REQUESTED"] = "RESYNC_REQUESTED";
})(BlockSyncStatus || (BlockSyncStatus = {}));
var RepositorySyncStatus;
(function (RepositorySyncStatus) {
    // Actively syncing this repository
    RepositorySyncStatus["ACTIVE"] = "ACTIVE";
    // AGT is not responding, temporarily pending AGT responses
    RepositorySyncStatus["PENDING"] = "PENDING";
    // AGT (or TM) delayed sync of this repository (for a period of time)
    RepositorySyncStatus["DELAYED"] = "DELAYED";
    // AGT (or TM) suspended sync of this repository
    RepositorySyncStatus["SUSPENDED"] = "SUSPENDED";
    // AGT (or TM) temporarily rerouted syncing of this repository to a different AGT
    RepositorySyncStatus["TEMPORARILY_REROUTED"] = "TEMPORARILY_REROUTED";
    // AGT (or TM) permanently rerouted syncing of this repository to a different AGT
    RepositorySyncStatus["PERMANENTLY_REROUTED"] = "PERMANENTLY_REROUTED";
})(RepositorySyncStatus || (RepositorySyncStatus = {}));
var TerminalSyncStatus;
(function (TerminalSyncStatus) {
    // Terminal is actively syncing
    TerminalSyncStatus["ACTIVE"] = "ACTIVE";
    // Terminal syncing has been suspended
    TerminalSyncStatus["SUSPENDED"] = "SUSPENDED";
})(TerminalSyncStatus || (TerminalSyncStatus = {}));

/**
 * Created by Papa on 10/7/2016.
 */
class SyncTableMap extends TableMap {
    constructor(applicationIndex, tableMap) {
        super(applicationIndex, tableMap);
    }
    ensureEntity(tableIndex, allColumns = false) {
        return super.ensure(tableIndex, allColumns, globalThis.SyncColumnMap);
    }
    intersects(columnMap) {
        for (let tableIndex in this.tableMap) {
            if (columnMap.tableMap[tableIndex]) {
                let tableColumnMap = this.tableMap[tableIndex];
                let otherTableColumnMap = columnMap.tableMap[tableIndex];
                if (tableColumnMap[globalThis.ALL_TABLE_COLUMNS]
                    || tableColumnMap[globalThis.ALL_TABLE_COLUMNS]) {
                    return true;
                }
                for (let columnIndex in tableColumnMap.columnMap) {
                    if (otherTableColumnMap.columnMap[columnIndex]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
globalThis.SyncTableMap = SyncTableMap;

class AppTrackerUtils {
    get EXTERNAL_ACCESS_ENTITIES() {
        if (this._EXTERNAL_ACCESS_ENTITIES) {
            return this._EXTERNAL_ACCESS_ENTITIES;
        }
        const apps = this.dictionary.airport.apps;
        const Actor = this.dictionary.Actor;
        const Repository = this.dictionary.Repository;
        const UserAccount = this.dictionary.UserAccount;
        // Serialization check rules must be added for every new entity in this list
        this._EXTERNAL_ACCESS_ENTITIES = [{
                domainName: this.dictionary.airport.DOMAIN_NAME,
                applicationPermissions: [{
                        applicationName: apps.TRAVEL_DOCUMENT_CHECKPOINT.name,
                        versionPermissions: [{
                                entities: [{
                                        name: UserAccount.name,
                                        columnNames: [
                                            UserAccount.columns.USER_ACCOUNT_LID
                                        ]
                                    }]
                            }]
                    },
                    {
                        applicationName: apps.HOLDING_PATTERN.name,
                        versionPermissions: [{
                                entities: [{
                                        name: Actor.name,
                                        columnNames: [
                                            Actor.columns.ACTOR_LID
                                        ]
                                    },
                                    {
                                        name: Repository.name,
                                        columnNames: [
                                            Repository.columns.REPOSITORY_LID
                                        ]
                                    }]
                            }]
                    }]
            }];
        return this._EXTERNAL_ACCESS_ENTITIES;
    }
    getInternalApp() {
        return this.dictionary.INTERNAL_APP;
    }
    getInternalDomain() {
        return this.dictionary.INTERNAL_DOMAIN;
    }
    async isInternalDomain(domainName) {
        return [
            this.dictionary.airbridge.DOMAIN_NAME,
            this.dictionary.airport.DOMAIN_NAME,
            this.dictionary.airway.DOMAIN_NAME,
            this.dictionary.INTERNAL_DOMAIN
        ].indexOf(domainName) > -1;
    }
    entityHasExternalAccessPermissions(checkedDomainName, checkedApplicationName, checkedApplicationIntegerVersion, checkedEntityName, checkedColumnName) {
        for (const domainPermissions of this.EXTERNAL_ACCESS_ENTITIES) {
            if (domainPermissions.domainName !== checkedDomainName) {
                continue;
            }
            for (const applicationPermissions of domainPermissions.applicationPermissions) {
                if (applicationPermissions.applicationName !== checkedApplicationName) {
                    continue;
                }
                for (const versionPermissions of applicationPermissions.versionPermissions) {
                    if (versionPermissions.integerVersion === checkedApplicationIntegerVersion
                        || (versionPermissions.sinceIntegerVersion
                            && versionPermissions.sinceIntegerVersion <= checkedApplicationIntegerVersion)
                        || (versionPermissions.beforeIntegerVersion
                            && versionPermissions.beforeIntegerVersion > checkedApplicationIntegerVersion)) {
                        for (const entity of versionPermissions.entities) {
                            if (entity.name !== checkedEntityName) {
                                continue;
                            }
                            if (!checkedColumnName) {
                                return true;
                            }
                            return entity.columnNames.includes(checkedColumnName);
                        }
                    }
                }
            }
        }
        return false;
    }
}

class ApplicationReferenceUtils {
    getCurrentJsonApplicationVersion(jsonApplication) {
        return jsonApplication.versions[jsonApplication.versions.length - 1];
    }
    checkFrameworkReferences(jsonApplication, getRelationInfo) {
        if (this.appTrackerUtils.isInternalDomain(jsonApplication.domain)) {
            return;
        }
        const applicationVersion = this.getCurrentJsonApplicationVersion(jsonApplication);
        for (const jsonEntity of applicationVersion.entities) {
            for (const jsonColumn of jsonEntity.columns) {
                // If it's not a many relation, include it in the generated columns
                if (!jsonColumn.manyRelationColumnRefs
                    || !jsonColumn.manyRelationColumnRefs.length) {
                    continue;
                }
                const relations = this.getRelationsFromColumn(jsonEntity, jsonColumn);
                for (let jsonRelation of relations) {
                    const { relatedJsonApplication, relatedJsonEntity } = getRelationInfo(jsonApplication, applicationVersion, jsonRelation);
                    this.isRelationToAFrameworkEntity(relatedJsonApplication, relatedJsonEntity, jsonApplication, jsonEntity, jsonEntity.properties[jsonRelation.propertyRef.index], jsonColumn);
                }
            }
        }
    }
    getRelationsFromColumn(jsonEntity, jsonColumn) {
        let relationSet = new Set();
        for (let propertyRef of jsonColumn.propertyRefs) {
            let property = jsonEntity.properties[propertyRef.index];
            if (property.relationRef) {
                let relation = jsonEntity.relations[property.relationRef.index];
                if (!relationSet.has(relation)) {
                    relationSet.add(relation);
                }
            }
        }
        return Array.from(relationSet.values());
    }
    isRelationToAFrameworkEntity(relatedJsonApplication, relatedJsonEntity, jsonApplication, jsonEntity, jsonProperty, jsonColumn) {
        const domain = relatedJsonApplication.domain;
        const domainName = typeof domain === 'string' ? domain : domain.name;
        // All non @Id AIR entity references 
        const manyRelationColumnRef = jsonColumn.manyRelationColumnRefs[0];
        const relatedColumn = relatedJsonEntity.columns[manyRelationColumnRef.oneColumnIndex];
        if (!this.appTrackerUtils.entityHasExternalAccessPermissions(domainName, relatedJsonApplication.name, relatedJsonApplication.versions[0].integerVersion, relatedJsonEntity.name, relatedColumn.name)) {
            throw new Error(`Found an invalid reference to an internal schema:
Referencing:
  Domain:   ${typeof relatedJsonApplication.domain === 'string' ? relatedJsonApplication.domain : relatedJsonApplication.domain.name}
  App:      ${relatedJsonApplication.name}
  Entity:   ${relatedJsonEntity.name}

From:
  Domain:   ${jsonApplication.domain}
  App:      ${jsonApplication.name}
  Entity:   ${jsonEntity.name}
  Property: ${jsonProperty.name}
          
          `);
        }
        return true;
    }
}

class DatastructureUtils {
    ensureChildArray(parentContainer, index) {
        let childArray;
        if (parentContainer instanceof Map) {
            childArray = parentContainer.get(index);
        }
        else {
            childArray = parentContainer[index];
        }
        if (!childArray) {
            childArray = [];
            if (parentContainer instanceof Map) {
                parentContainer.set(index, childArray);
            }
            else {
                parentContainer[index] = childArray;
            }
        }
        return childArray;
    }
    ensureChildMap(parentContainer, index) {
        let childObject;
        if (parentContainer instanceof Map) {
            childObject = parentContainer.get(index);
            if (!childObject) {
                childObject = {};
                parentContainer.set(index, childObject);
            }
        }
        else {
            childObject = parentContainer[index];
            if (!childObject) {
                childObject = {};
                parentContainer[index] = childObject;
            }
        }
        return childObject;
    }
    ensureChildJsMap(parentContainer, index) {
        let childMap = parentContainer.get(index);
        if (!childMap) {
            childMap = new Map();
            parentContainer.set(index, childMap);
        }
        return childMap;
    }
    ensureChildJsSet(parentContainer, index) {
        let childSet = parentContainer.get(index);
        if (!childSet) {
            childSet = new Set();
            parentContainer.set(index, childSet);
        }
        return childSet;
    }
    undefinedToNull(value) {
        return value === undefined ? null : value;
    }
}

class KeyUtils {
    constructor() {
        this.textDecoder = new TextDecoder("utf-8");
        this.textEncoder = new TextEncoder();
    }
    digest(str, bitLength) {
        return crypto.subtle.digest("SHA-" + bitLength, new TextEncoder( /*"utf-8"*/).encode(str)).then(buf => {
            return Array.prototype.map
                .call(new Uint8Array(buf), x => (('00' + x.toString(16)).slice(-2))).join('');
        });
    }
    async getEncryptionKey(length = 256) {
        const encryptionKey = await window.crypto.subtle.generateKey({
            name: "AES-GCM",
            length
        }, true, ["encrypt", "decrypt"]);
        const serializedEncryptionKey = await this.serializeKey(encryptionKey);
        return serializedEncryptionKey;
    }
    async getSigningKey(curveBitLength = 384) {
        let keyPair = await window.crypto.subtle.generateKey({
            name: "ECDSA",
            namedCurve: "P-" + curveBitLength
        }, true, ["sign", "verify"]);
        const privateSigningKey = await this.serializeKey(keyPair.privateKey);
        const publicSigningKey = await this.serializeKey(keyPair.publicKey);
        return {
            private: privateSigningKey,
            public: publicSigningKey
        };
    }
    sha512(str) {
        return this.digest(str, 512);
    }
    async sign(text, privateKey, privateKeyBitLength = 384) {
        const encoded = this.textEncoder.encode(text);
        const signKey = await this.deserializeSignKey(privateKey, privateKeyBitLength);
        const signature = await window.crypto.subtle.sign({
            name: "ECDSA",
            hash: { name: "SHA-" + privateKeyBitLength },
        }, signKey, encoded);
        return this.textDecoder.decode(signature);
    }
    async verify(text, signature, publicKey, publicKeyBitLength = 384) {
        const encodedText = this.textEncoder.encode(text);
        const encodedSignature = this.textEncoder.encode(signature);
        const verifyKey = await this.deserializeVerifyKey(publicKey, publicKeyBitLength);
        let isValidSignature = await window.crypto.subtle.verify({
            name: "ECDSA",
            hash: {
                name: "SHA-" + publicKeyBitLength
            },
        }, verifyKey, encodedSignature, encodedText);
        return isValidSignature;
    }
    async serializeKey(rawKey) {
        const exportedPrivateSigningKey = await window.crypto.subtle.exportKey("jwk", rawKey);
        return JSON.stringify(exportedPrivateSigningKey, null, " ");
    }
    async deserializeSignKey(serializedKey, privateKeyBitLength = 384) {
        const jwk = JSON.parse(serializedKey);
        return window.crypto.subtle.importKey("jwk", jwk, {
            name: "ECDSA",
            namedCurve: "P-" + privateKeyBitLength
        }, true, ["sign"]);
    }
    async deserializeVerifyKey(serializedKey, privateKeyBitLength = 384) {
        const jwk = JSON.parse(serializedKey);
        return window.crypto.subtle.importKey("jwk", jwk, {
            name: "ECDSA",
            namedCurve: "P-" + privateKeyBitLength
        }, true, ["verify"]);
    }
    async deserializeEncryptionKey(serializedKey) {
        const jwk = JSON.parse(serializedKey);
        return window.crypto.subtle.importKey("jwk", jwk, "AES-GCM", true, ["encrypt", "decrypt"]);
    }
}

const groundControl = lib('ground-control');
groundControl.register(ApplicationReferenceUtils, AppTrackerUtils, DatastructureUtils, DbApplicationUtils, Dictionary, KeyUtils);
const ENTITY_STATE_MANAGER = groundControl.token('EntityStateManager');
const OPERATION_DESERIALIZER = groundControl.token('OperationDeserializer');
const QUERY_PARAMETER_DESERIALIZER = groundControl.token('QueryParameterDeserializer');
const QUERY_RESULTS_SERIALIZER = groundControl.token('QueryResultsSerializer');
const SEQUENCE_GENERATOR = groundControl.token('SequenceGenerator');
const TRANSACTIONAL_CONNECTOR = groundControl.token('TransactionalConnector');
const UPDATE_CACHE_MANAGER = groundControl.token('UpdateCacheManager');
groundControl.setDependencies(ApplicationReferenceUtils, {
    appTrackerUtils: AppTrackerUtils
});
groundControl.setDependencies(AppTrackerUtils, {
    dictionary: Dictionary
});
TRANSACTIONAL_CONNECTOR.setDependencies({
    dbApplicationUtils: DbApplicationUtils,
});

function forEach$1(collection, callback) {
    if (collection instanceof Map) {
        for (let [key, value] of collection.entries()) {
            callback(key, value);
        }
    }
    else {
        for (let memberName in collection) {
            callback(memberName, collection[memberName]);
        }
    }
}
function getExpectedPropertyIndexesFormatMessage() {
    return `
	General expected @Table({ indexes: ...}) formats for property based indexes:

	@Entity()
	@Table({
		name: 'TABLE_NAME',
		indexes: (enityAlias:  EntityType) => [{
			property: entityAlias.propetyName
		}]
	})
	export class EntityType {

		@ManyToOne()
		propertyName: AnotherEntityType 

		...
	}`;
}

const entityOperationMap = {};
const entityOperationPaths = {};
// let currentFileImports
const daoFileMap = {};
const daoMap = {};
// const fileImportsMapByFilePath: { [path: string]: FileImports } = {}
function visitDaoFile(node, path) {
    let file = daoFileMap[path];
    if (!file) {
        file = {
            path,
            hasDao: false
        };
        daoFileMap[path] = file;
    }
    // let fileImports = fileImportsMapByFilePath[path]
    // if (!fileImports) {
    // 	fileImports                    = ImportManager.resolveImports(node.parent, file.path)
    // 	fileImportsMapByFilePath[path] = fileImports
    // }
    // currentFileImports = fileImports
    if (node.kind !== tsc__default.SyntaxKind.ClassDeclaration) {
        return;
    }
    const classNode = node;
    // This is a top level class, get its symbol
    let symbol = globalThis.checker
        .getSymbolAtLocation(classNode.name);
    let daoName = classNode.name.escapedText;
    let entityName;
    let extendedBaseClass;
    for (const heritageClause of classNode.heritageClauses) {
        switch (heritageClause.token) {
            case tsc__default.SyntaxKind.ExtendsKeyword: {
                extendedBaseClass = heritageClause.types[0].expression.escapedText;
                if (!extendedBaseClass.startsWith('Base') || !extendedBaseClass.endsWith('Dao')) {
                    throw new Error(`Dao ${daoName} must extends the Base{ApplicationEntity_Name}Dao class.`);
                }
                entityName = extendedBaseClass.substring(4, extendedBaseClass.length - 3);
                break;
            }
            // case tsc.SyntaxKind.ImplementsKeyword: {
            // 	const interfaceName = (heritageClause.types[0].expression as any).escapedText;
            // 	break;
            // }
        }
    }
    if (!entityName) {
        throw new Error(`The '${daoName}' Dao must extend the Base{ApplicationEntity_Name}Dao class.`);
    }
    if (file.hasDao) {
        throw new Error(`Cannot declare more than one DAO per file
	(or have multiple class definitions per file).`);
    }
    file.hasDao = true;
    if (daoMap[daoName]) {
        throw new Error(`Cannot declare multiple DAOs for the same entity ${entityName}.`);
    }
    daoMap[daoName] = true;
    entityOperationMap[entityName] = serializeClass$2(symbol);
    entityOperationPaths[entityName] = path;
}
/** Serialize a class symbol information */
function serializeClass$2(symbol, daoName, entityName) {
    let daoOperations = {};
    // if(true) {
    // 	// No more directly explosed Dao methods, instead
    // 	// parameters of @API() methods will in the future be
    // 	// checked structurally
    // 	return;
    // }
    forEach$1(symbol.members, (memberName, member) => {
        if (!member.valueDeclaration) {
            return;
        }
        switch (member.valueDeclaration.kind) {
            // case tsc.SyntaxKind.MethodDeclaration:
            // 	serializeMethod(symbol, daoName, entityName, memberName, member, daoOperations);
            // 	break;
            case tsc__default.SyntaxKind.PropertyDeclaration:
                // NOTE: all queries are done in code, query serialization is no longer needed
                // serializeProperty(symbol, daoName, entityName, memberName, member, daoOperations);
                break;
        }
    });
    return daoOperations;
}

/**
 * Created by Papa on 3/27/2016.
 */
class Interface {
    constructor(path, name) {
        this.name = name;
        this.implementedBySet = new Set();
    }
}
class EntityCandidate {
    static create(type, path, parentClass, parentImport, isSuperClass) {
        return new EntityCandidate(type, path, parentClass, parentImport, undefined, isSuperClass);
    }
    constructor(type, path, parentClassName, location, verified, isSuperclass) {
        this.type = type;
        this.path = path;
        this.parentClassName = parentClassName;
        this.location = location;
        this.verified = verified;
        this.isSuperclass = isSuperclass;
        this.ids = [];
        if (!type) {
            return;
        }
        console.log(`\tcreating entity: ${type}, parent: ${parentClassName}, isSuperclass: ${isSuperclass}`);
    }
    getIdProperties() {
        return this.getPropertiesOfType(true);
    }
    getNonIdProperties() {
        return this.getPropertiesOfType(false);
    }
    getPropertiesOfType(isId) {
        return this.docEntry.properties.filter((property, index) => {
            if (property.isTransient) {
                return false;
            }
            property.index = index;
            const idDecorators = property.decorators.filter(decorator => {
                return decorator.name === 'Id';
            });
            if (isId) {
                return !!idDecorators.length;
            }
            else {
                return !idDecorators.length;
            }
        });
    }
    getTransientProperties() {
        return this.docEntry.properties.filter((property, index) => {
            return property.isTransient;
        });
    }
    matches(type, location) {
        return this.type === type;
    }
}

/**
 * Created by Papa on 4/27/2016.
 */
function resolveRelativeEntityPath(from, //
to) {
    return resolveRelativePath(from.path, to.path);
}
/**
 * Gets the full path to the import in a given file.
 *
 * @param {string} relativePath  ../../e/f/importedFileName
 * @param {string} relativeToPath  /a/b/c/sourceFileName
 * @returns {string}
 */
function getFullPathFromRelativePath(relativePath, //
relativeToPath) {
    if (relativePath.indexOf('.') !== 0) {
        return relativePath;
    }
    relativePath = normalizePath(relativePath);
    relativeToPath = normalizePath(relativeToPath);
    const relativeFragments = relativePath.split('/');
    const relativeToFragments = relativeToPath.split('/');
    const numDirectoriesBack = relativeFragments.filter(relativeFragment => relativeFragment === '..').length;
    const numCommonFragments = relativeToFragments.length - numDirectoriesBack - 1;
    const commonFragments = [];
    for (let i = 0; i < numCommonFragments; i++) {
        commonFragments.push(relativeToFragments[i]);
    }
    let commonRelativeFragmentIndex = numDirectoriesBack;
    if (!commonRelativeFragmentIndex) {
        commonRelativeFragmentIndex++;
    }
    for (let j = commonRelativeFragmentIndex; j < relativeFragments.length; j++) {
        commonFragments.push(relativeFragments[j]);
    }
    return commonFragments.join('/');
}
function resolveRelativePath(fromPath, //
toPath) {
    fromPath = normalizePath(fromPath);
    toPath = normalizePath(toPath);
    let fromFragments = fromPath.split('/');
    let toFragments = toPath.split('/');
    let numCommonFragments = 0;
    for (let i = 0; i < fromFragments.length; i++) {
        let fromFragment;
        if (fromFragments[i]) {
            fromFragment = fromFragments[i];
        }
        let toFragment;
        if (toFragments[i]) {
            toFragment = toFragments[i];
        }
        if (fromFragment !== toFragment) {
            break;
        }
        numCommonFragments = i + 1;
    }
    let numFromPathDiffDirectories = fromFragments.length - numCommonFragments - 1;
    let toPathDiffNodes = toFragments.slice(numCommonFragments);
    let relativePath = '';
    if (numFromPathDiffDirectories == 0) {
        relativePath = './';
    }
    else {
        for (let i = 0; i < numFromPathDiffDirectories; i++) {
            relativePath += '../';
        }
    }
    for (let i = 0; i < toPathDiffNodes.length; i++) {
        relativePath += toPathDiffNodes[i];
        if (i < toPathDiffNodes.length - 1) {
            relativePath += '/';
        }
    }
    return relativePath;
}
function addImportForType(entity, type, fileBuilder) {
    const moduleImport = entity.docEntry.fileImports.importMapByObjectAsName[type];
    if (!moduleImport) {
        throw new Error(`Could not find import for ${type} in file for '${entity.type}'`);
    }
    let relativePathToImport = moduleImport.path;
    if (moduleImport.path.indexOf('.') === 0) {
        const fullPathToImport = getFullPathFromRelativePath(moduleImport.path, entity.path);
        relativePathToImport = resolveRelativePath(fileBuilder.fullGenerationPath, fullPathToImport);
    }
    fileBuilder.addImport([moduleImport.objectMapByAsName[type]], relativePathToImport);
}
/*
 *   ../../e/f/g
 *   /a/b/c/d
 *
 */
const workingDirPath = normalizePath(process.cwd());
function getRelativePath(filePath) {
    const normalizedFilePath = normalizePath(filePath);
    return normalizedFilePath.substring(workingDirPath.length);
}
function normalizePath(path) {
    let forwardSlashedPath = path.replace(/\\/g, '/');
    return forwardSlashedPath;
}
function canBeInterface(type) {
    return type.startsWith('I');
}
function getImplNameFromInterfaceName(interfaceName) {
    return interfaceName.substr(1);
}

class DbApplicationBuilder {
    constructor() {
        this.datastructureUtils = new DatastructureUtils();
    }
    buildDbApplicationWithoutReferences(jsonApplication, allApplications, dictionary) {
        const entities = [];
        const entityMapByName = {};
        const references = [];
        const referencedBy = [];
        const referencedByMapByName = {};
        const referencesMapByName = {};
        // FIXME: when versioning is added process all application versions
        const currentJsonApplicationVersion = jsonApplication.versions[0];
        const versionString = currentJsonApplicationVersion.versionString;
        const versionParts = versionString.split('.');
        const dbApplicationVersion = {
            _localId: null,
            entities,
            entityMapByName,
            integerVersion: currentJsonApplicationVersion.integerVersion,
            majorVersion: parseInt(versionParts[0]),
            minorVersion: parseInt(versionParts[1]),
            patchVersion: parseInt(versionParts[2]),
            referencedBy,
            referencedByMapByName,
            references,
            referencesMapByName,
            application: undefined,
            versionString,
        };
        const dbApplicationCurrentVersion = {
            application: null,
            applicationVersion: dbApplicationVersion
        };
        const dbDomain = {
            applications: [],
            _localId: undefined,
            name: jsonApplication.domain,
        };
        const dbApplication = {
            currentVersion: [dbApplicationCurrentVersion],
            domain: dbDomain,
            fullName: IOC.getSync(DbApplicationUtils).
                getApplication_FullNameFromDomainAndName(dbDomain.name, jsonApplication.name),
            index: allApplications.length,
            name: jsonApplication.name,
            scope: null,
            signature: null,
            sinceVersion: dbApplicationVersion,
            status: ApplicationStatus.CURRENT,
            versions: [dbApplicationVersion]
        };
        dbApplicationCurrentVersion.application = dbApplication;
        dbApplicationVersion.application = dbApplication;
        allApplications.push(dbApplication);
        for (const jsonEntity of currentJsonApplicationVersion.entities) {
            const dbEntity = this.buildDbEntity(jsonApplication, jsonEntity, dictionary, currentJsonApplicationVersion.referencedApplications, dbApplicationVersion);
            entities[dbEntity.index] = dbEntity;
            entityMapByName[dbEntity.name] = dbEntity;
        }
        return dbApplication;
    }
    /**
     *
     * @param {{[p: string]: DbApplication}} applicationMap
     * @param {{[p: string]: JsonApplication}} jsonApplicationMap
     * @param {ILinkingDictionary} dictionary
     */
    linkDbApplicationsByReferences(applicationMap, jsonApplicationMap, dictionary, failOnMissingMappings = true) {
        // Map referenced applications
        for (const domain in jsonApplicationMap) {
            const domainMap = jsonApplicationMap[domain];
            const dbDomainMap = applicationMap[domain];
            if (!dbDomainMap) {
                if (failOnMissingMappings) {
                    throw new Error(`Domain '${domain}' is not yet available for relation linking.`);
                }
                continue;
            }
            for (const applicationName in domainMap) {
                const ownApplication = dbDomainMap[applicationName];
                if (!ownApplication) {
                    if (failOnMissingMappings) {
                        throw new Error(`Application '${applicationName}' is not yet available for relation linking.`);
                    }
                    continue;
                }
                const jsonApplication = domainMap[applicationName];
                // FIXME: find a way to get the right application version once versioning is added
                const jsonApplicationVersion = jsonApplication.versions[0];
                for (const index in jsonApplicationVersion.referencedApplications) {
                    const applicationReference = jsonApplicationVersion.referencedApplications[index];
                    const referencedApplication_Name = applicationReference.name;
                    const referencedDbDomain = applicationMap[applicationReference.domain];
                    if (!referencedDbDomain) {
                        if (failOnMissingMappings) {
                            throw new Error(`Domain '${applicationReference.domain}' is not yet available for relation linking.`);
                        }
                        continue;
                    }
                    const referencedApplication = referencedDbDomain[referencedApplication_Name];
                    if (!referencedApplication) {
                        if (failOnMissingMappings) {
                            throw new Error(`Application '${referencedApplication_Name}' is not yet available for relation linking.`);
                        }
                        continue;
                    }
                    // FIXME: find a way to get the right application version once versioning is added
                    const ownApplicationVersion = ownApplication.currentVersion[0]
                        .applicationVersion;
                    const referencedApplicationVersion = referencedApplication.currentVersion[0]
                        .applicationVersion;
                    const dbApplicationReference = {
                        index: parseInt(index),
                        ownApplicationVersion,
                        referencedApplicationVersion,
                        sinceVersion: null
                    };
                    ownApplicationVersion.references[index] = dbApplicationReference;
                    referencedApplicationVersion.referencedBy.push(dbApplicationReference);
                    ownApplicationVersion.referencesMapByName[referencedApplication.fullName] = dbApplicationReference;
                    referencedApplicationVersion.referencedByMapByName[ownApplication.fullName] = dbApplicationReference;
                }
            }
        }
        // Map Column Relations
        for (const domain in dictionary.dbColumnRelationMapByManySide) {
            const domainMap = dictionary.dbColumnRelationMapByManySide[domain];
            for (const applicationName in domainMap) {
                const mapForApplication = domainMap[applicationName];
                const manyApplication = applicationMap[applicationName];
                if (!manyApplication) {
                    if (failOnMissingMappings) {
                        throw new Error(`Application '${applicationName}' is not yet available for relation linking.`);
                    }
                    continue;
                }
                for (const entityIndex in mapForApplication) {
                    const mapForEntity = mapForApplication[entityIndex];
                    const manyEntity = manyApplication.entities[entityIndex];
                    if (!applicationMap) {
                        throw new Error(`Table '${applicationName}.${entityIndex}' is not defined.`);
                    }
                    for (const relationIndex in mapForEntity) {
                        const mapForRelation = mapForEntity[relationIndex];
                        const manyRelation = manyEntity.relations[relationIndex];
                        if (!manyRelation) {
                            throw new Error(`Relation '${applicationName}.${manyEntity.name} - ${relationIndex}' is not defined.`);
                        }
                        for (const columnIndex in mapForRelation) {
                            const relationColumnReference = mapForRelation[columnIndex];
                            const oneApplication = applicationMap[relationColumnReference.applicationName];
                            if (!oneApplication) {
                                if (failOnMissingMappings) {
                                    throw new Error(`Application '${relationColumnReference.applicationName}' is not yet available for relation linking.`);
                                }
                                break;
                            }
                            const oneEntity = manyApplication.entities[relationColumnReference.entityIndex];
                            if (!oneEntity) {
                                throw new Error(`Table '${relationColumnReference.applicationName}.${relationColumnReference.entityIndex}' is not defined.`);
                            }
                            const oneRelation = manyEntity.relations[relationColumnReference.relationIndex];
                            if (!oneRelation) {
                                throw new Error(`Relation '${relationColumnReference.applicationName}.${oneEntity.name} - ${relationColumnReference.relationIndex}' is not defined.`);
                            }
                            const oneColumn = oneEntity.columns[relationColumnReference.columnIndex];
                            if (!oneColumn) {
                                throw new Error(`Column '${relationColumnReference.applicationName}.${oneEntity.name} - ${relationColumnReference.columnIndex}' is not defined.`);
                            }
                            const manyColumn = oneEntity.columns[columnIndex];
                            if (!manyColumn) {
                                throw new Error(`Column '${applicationName}.${oneEntity.name} - ${columnIndex}' is not defined.`);
                            }
                            const relationColumn = {
                                manyColumn,
                                oneColumn,
                                manyRelation,
                                oneRelation
                            };
                            manyColumn.manyRelationColumns.push(relationColumn);
                            manyRelation.manyRelationColumns.push(relationColumn);
                            oneColumn.oneRelationColumns.push(relationColumn);
                            oneRelation.oneRelationColumns.push(relationColumn);
                        }
                    }
                }
            }
        }
    }
    buildDbEntity(jsonApplication, jsonEntity, dictionary, referencedApplications, applicationVersion) {
        const columnMap = {};
        const columns = [];
        const idColumns = [];
        const idColumnMap = {};
        const propertyMap = {};
        const properties = [];
        const relations = [];
        const dbEntity = {
            columnMap,
            columns,
            idColumns,
            idColumnMap,
            _localId: null,
            index: jsonEntity.index,
            isLocal: jsonEntity.isLocal,
            isAirEntity: jsonEntity.isAirEntity,
            name: jsonEntity.name,
            propertyMap,
            properties,
            relationReferences: [],
            relations,
            applicationVersion,
            sinceVersion: applicationVersion,
            tableConfig: jsonEntity.tableConfig
        };
        jsonEntity.properties.forEach((jsonProperty, index) => {
            const property = {
                propertyColumns: [],
                entity: dbEntity,
                _localId: null,
                index: jsonProperty.index,
                isId: jsonProperty.isId,
                name: jsonProperty.name,
                relation: null,
                sinceVersion: applicationVersion
            };
            propertyMap[jsonProperty.name] = property;
            properties[index] = property;
        });
        jsonEntity.properties.sort((a, b) => a.index < b.index ? -1 : 1);
        properties.sort((a, b) => a.index < b.index ? -1 : 1);
        jsonEntity.relations.forEach((jsonRelation, index) => {
            const dbProperty = properties[jsonRelation.propertyRef.index];
            const dbRelation = this.buildDbRelation(jsonRelation, dbProperty, applicationVersion);
            relations[index] = dbRelation;
        });
        relations.sort((a, b) => a.index < b.index ? -1 : 1);
        jsonEntity.columns.forEach((jsonColumn, index) => {
            const dbColumn = this.buildDbColumn(jsonApplication, jsonEntity, jsonColumn, properties, dictionary, referencedApplications, applicationVersion, dbEntity);
            columnMap[jsonColumn.name] = dbColumn;
            columns[index] = dbColumn;
        });
        jsonEntity.idColumnRefs.forEach((idColumnRef, index) => {
            idColumns[index] = columns[idColumnRef.index];
        });
        columns.sort((a, b) => a.index < b.index ? -1 : 1);
        return dbEntity;
    }
    buildDbRelation(jsonRelation, dbProperty, applicationVersion) {
        const dbRelation = {
            entity: undefined,
            foreignKey: jsonRelation.foreignKey,
            isId: dbProperty.isId,
            // isRepositoryJoin: jsonRelation.isRepositoryJoin,
            manyToOneElems: jsonRelation.manyToOneElems,
            oneToManyElems: jsonRelation.oneToManyElems,
            relationType: jsonRelation.relationType,
            _localId: null,
            index: jsonRelation.index,
            property: dbProperty,
            manyRelationColumns: [],
            oneRelationColumns: [],
            relationEntity: null,
            sinceVersion: applicationVersion
            // addToJoinFunction: jsonRelation.addToJoinFunction,
            // joinFunctionWithOperator: jsonRelation.joinFunctionWithOperator,
        };
        // if (dbRelation.addToJoinFunction) {
        // 	dbRelation.whereJoinTable = {
        // 		addToJoinFunction: new Function('return ' + dbRelation.addToJoinFunction)(),
        // 		joinFunctionWithOperator:
        // 			dbRelation.joinFunctionWithOperator === SqlOperator.AND ? and : or,
        // 	}
        // }
        dbProperty.relation = [dbRelation];
        return dbRelation;
    }
    /**
     * Application loading process at runtime:
     *
     * First the build-in application's run:
     *
     * 1) Traffic Pattern
     * 2) Holding Pattern
     *
     * Then the application for the application being loaded is run, in order of the dependency
     * graph:
     *
     * 3) App application grand-dependency
     * 4) App application dependency
     * 5) Application application
     *
     * Load provided applications
     */
    buildDbColumn(jsonApplication, jsonEntity, jsonColumn, properties, dictionary, referencedApplications, applicationVersion, entity) {
        const dbColumn = {
            entity,
            _localId: null,
            index: jsonColumn.index,
            isGenerated: !!jsonColumn.isGenerated,
            manyRelationColumns: [],
            name: jsonColumn.name,
            notNull: jsonColumn.notNull,
            oneRelationColumns: [],
            precision: jsonColumn.precision,
            propertyColumnMap: {},
            propertyColumns: null,
            scale: jsonColumn.scale,
            sinceVersion: applicationVersion,
            type: jsonColumn.type
        };
        const propertyColumns = jsonColumn.propertyRefs.map(propertyColumnRef => {
            const propertyIndex = propertyColumnRef.index;
            const property = properties[propertyIndex];
            return {
                column: dbColumn,
                property,
                sinceVersion: applicationVersion,
            };
        });
        dbColumn.propertyColumns = propertyColumns;
        jsonColumn.manyRelationColumnRefs.map(relationColumnRef => {
            const manyApplicationReference_Index = jsonApplication.index;
            let manyApplication;
            if (manyApplicationReference_Index === null) {
                manyApplication = jsonApplication;
            }
            else {
                manyApplication = referencedApplications[manyApplicationReference_Index];
            }
            const manyTableIndex = jsonEntity.index;
            const manyRelationIndex = relationColumnRef.manyRelationIndex;
            const manyColumnIndex = dbColumn.index;
            const oneApplicationReference_Index = relationColumnRef.oneApplication_Index;
            let oneApplication;
            if (oneApplicationReference_Index === null) {
                oneApplication = jsonApplication;
            }
            else {
                oneApplication = referencedApplications[oneApplicationReference_Index];
            }
            if (!oneApplication) {
                // FIXME: figure out if not having references to nested applications is OK
                return;
            }
            const oneTableIndex = relationColumnRef.oneTableIndex;
            const oneRelationIndex = relationColumnRef.oneRelationIndex;
            const oneColumnIndex = relationColumnRef.oneColumnIndex;
            const manyRelationColumnMap = this.datastructureUtils.ensureChildMap(this.datastructureUtils.ensureChildMap(this.datastructureUtils.ensureChildMap(this.datastructureUtils.ensureChildMap(dictionary.dbColumnRelationMapByManySide, manyApplication.domain), manyApplication.name), manyTableIndex), manyRelationIndex);
            manyRelationColumnMap[manyColumnIndex] = {
                domain: oneApplication.domain,
                applicationName: oneApplication.name,
                entityIndex: oneTableIndex,
                relationIndex: oneRelationIndex,
                columnIndex: oneColumnIndex,
            };
        });
        for (const dbPropertyColumn of propertyColumns) {
            const property = dbPropertyColumn.property;
            // if (property.relation) {
            // 	dbColumn.relation = property.relation[0];
            // }
            if (property.isId) {
                let idIndex;
                jsonEntity.idColumnRefs.some((idColumnRef, index) => {
                    if (idColumnRef.index == jsonColumn.index) {
                        idIndex = index;
                        return true;
                    }
                });
                if (!idIndex && idIndex !== 0) {
                    throw new Error(`Could not find column "${jsonColumn.name}" 
					in @Id column references of entity "${jsonEntity.name}".`);
                }
                dbColumn.idIndex = idIndex;
            }
            property.propertyColumns.push(dbPropertyColumn);
        }
        return dbColumn;
    }
}

class ApplicationLoader {
    constructor() {
        this.applicationMap = {};
        this.allApplications = [];
        this.dbApplicationBuilder = new DbApplicationBuilder();
        this.dictionary = {
            dbColumnRelationMapByManySide: {},
            dbColumnRelationMapByOneSide: {}
        };
    }
    setApplicationMap(applicationMap) {
        this.applicationMap = applicationMap;
    }
    findAllReferencedJsonApplications() {
        const jsonApplications = [];
        const fileNames = fs__default.readdirSync(process.cwd() + '/node_modules/');
        for (let fileName of fileNames) {
            if (fileName.startsWith('@')) {
                const subDirFileNames = fs__default.readdirSync(process.cwd() + '/node_modules/' + fileName + '/');
                for (let subDirFileName of subDirFileNames) {
                    const jsonApplication = this.getJsonApplication(fileName + '/' + subDirFileNames);
                    if (!jsonApplication) {
                        continue;
                    }
                    jsonApplications.push(jsonApplication);
                }
            }
            else {
                const jsonApplication = this.getJsonApplication(fileName);
                if (!jsonApplication) {
                    continue;
                }
                jsonApplications.push(jsonApplication);
            }
        }
        return jsonApplications;
    }
    getReferencedApplication(projectName, property) {
        const knownApplication = this.applicationMap[projectName];
        if (knownApplication) {
            return knownApplication;
        }
        const relatedApplication = this.getJsonApplication(projectName, property);
        if (!relatedApplication) {
            return null;
        }
        const dbApplication = this.dbApplicationBuilder.buildDbApplicationWithoutReferences(relatedApplication, this.allApplications, this.dictionary);
        this.applicationMap[projectName] = dbApplication;
        return dbApplication;
    }
    getJsonApplication(projectName, property) {
        // const pathsToReferencedApplications =
        // this.configuration.airport.node_modulesLinks.pathsToReferencedApplications let
        // relatedApplicationProject if (pathsToReferencedApplications &&
        // pathsToReferencedApplications[projectName]) { let referencedApplicationRelativePath =
        // '../../' + pathsToReferencedApplications[projectName] for (let i = 0; i < 10; i++) {
        // referencedApplicationRelativePath = '../' + referencedApplicationRelativePath let
        // pathToApplication             =
        // getFullPathFromRelativePath(referencedApplicationRelativePath, __filename) if
        // (fs.existsSync(pathToApplication) && fs.lstatSync(pathToApplication).isDirectory()) {
        // relatedApplicationProject = require(pathToApplication) break } } } else {
        // relatedApplicationProject = require(process.cwd() + '/node_modules/' + projectName) }
        let relatedApplicationJson;
        try {
            relatedApplicationJson = fs__default.readFileSync(process.cwd() + '/node_modules/'
                + projectName + '/src/generated/application-spec.json');
        }
        catch (e) {
            console.error(`Unable to load Application Spec FROM:
${process.cwd()}/node_modules/${projectName}/src/generated/application-spec.json

Entity: ${property?.ownerEntity?.docEntry.name}
Property: ${property?.name}

If you are using an external type that represents a primite please add one of
the following decorators to the property definition:

@Json()
@DbAny()
@DbBoolean()
@DbDate()
@DbNumer()
@DbString()
`);
            return null;
        }
        // if (!relatedApplicationProject) {
        // 	throw new Error(`Could not find related application project '${projectName}'`)
        // }
        // if (!relatedApplicationProject.APPLICATION) {
        // 	throw new Error(`Could not find related application in project '${projectName}'`)
        // }
        if (!relatedApplicationJson) {
            return null;
        }
        return JSON.parse(relatedApplicationJson);
    }
}
const DB_APPLICATION_LOADER = new ApplicationLoader();

function isDecoratedAsEntity(decorators) {
    if (!decorators || !decorators.length) {
        return null;
    }
    let isDecoratedAsEntity;
    decorators.some((decorator) => {
        let expression = decorator.expression;
        if (!expression) {
            return false;
        }
        if (expression.kind === tsc__default.SyntaxKind.CallExpression) {
            expression = expression.expression;
        }
        if (expression.kind !== tsc__default.SyntaxKind.Identifier) {
            return false;
        }
        let decoratorName = expression.text;
        if (decoratorName === 'Entity') {
            isDecoratedAsEntity = {
                isSuperclass: false
            };
            return true;
        }
        else if (decoratorName === 'MappedSuperclass') {
            isDecoratedAsEntity = {
                isSuperclass: true
            };
            return true;
        }
    });
    return isDecoratedAsEntity;
}
function getClassPath(sourceFile) {
    if (!sourceFile) {
        return null;
    }
    if (!sourceFile || sourceFile.kind !== tsc__default.SyntaxKind.SourceFile) {
        return null;
    }
    return fs.realpathSync.native(sourceFile.path);
}
function getImplementedInterfaces(classSymbol) {
    let valueDeclaration = classSymbol.valueDeclaration;
    if (!valueDeclaration.heritageClauses) {
        return [];
    }
    let interfaces = [];
    valueDeclaration.heritageClauses.forEach((heritageClause) => {
        if (heritageClause.token != tsc__default.SyntaxKind.ImplementsKeyword) {
            return;
        }
        heritageClause.types.forEach(type => {
            interfaces.push(type.expression.text);
        });
    });
    return interfaces;
}
function getParentClassImport(classSymbol, parentClassName) {
    let parentClassImport = null;
    let parent = classSymbol.parent;
    if (!parent) {
        return parentClassImport;
    }
    let valueDeclaration = parent.valueDeclaration;
    if (!valueDeclaration || valueDeclaration.kind !== tsc__default.SyntaxKind.SourceFile) {
        return parentClassImport;
    }
    const imports = valueDeclaration['imports'];
    if (!imports || !imports.length) {
        return parentClassImport;
    }
    imports.some((anImport) => {
        if (anImport.kind !== tsc__default.SyntaxKind.StringLiteral) {
            return false;
        }
        let parent = anImport.parent;
        if (!parent || parent.kind !== tsc__default.SyntaxKind.ImportDeclaration) {
            return false;
        }
        let nameMatches = endsWith(anImport.text, parentClassName);
        if (nameMatches && anImport.text.length > parentClassName.length) {
            nameMatches = endsWith(anImport.text, `/${parentClassName}`);
        }
        if (nameMatches) {
            parentClassImport = anImport.text;
            return true;
        }
    });
    return parentClassImport;
}
function getParentClassName(classSymbol) {
    let parentEntityName = null;
    if (!classSymbol.declarations || !classSymbol.declarations.length) {
        return parentEntityName;
    }
    classSymbol.declarations.some((declaration) => {
        if (declaration.kind !== tsc__default.SyntaxKind.ClassDeclaration) {
            return false;
        }
        let heritageClauses = declaration.heritageClauses;
        if (!heritageClauses || !heritageClauses.length) {
            return false;
        }
        return heritageClauses.some((heritageClause) => {
            if (heritageClause.kind !== tsc__default.SyntaxKind.HeritageClause) {
                return false;
            }
            if (heritageClause.token !== tsc__default.SyntaxKind.ExtendsKeyword) {
                return false;
            }
            let types = heritageClause.types;
            if (!types || !types.length) {
                return false;
            }
            return types.some((type) => {
                let expression = type.expression;
                if (!expression || expression.kind !== tsc__default.SyntaxKind.Identifier) {
                    return false;
                }
                parentEntityName = expression.text;
                return true;
            });
        });
    });
    return parentEntityName;
}
function isPrimitive(type) {
    switch (type) {
        case 'boolean':
        case 'number':
        case 'string':
        case 'Date':
        case 'any':
            return true;
    }
    return false;
}
function endsWith(target, suffix) {
    return target.indexOf(suffix, target.length - suffix.length) !== -1;
}
function startsWith(target, suffix) {
    return target.indexOf(suffix) === 0;
}

/**
 * Created by Papa on 3/27/2016.
 */
class EntityCandidateRegistry {
    constructor() {
        this.entityCandidateMap = new Map();
        this.allInterfacesMap = new Map();
        this.mappedSuperClassMap = {};
        this.enumMap = new Map();
    }
    addCandidate(candidate) {
        let matchesExisting = this.matchToExistingEntity(candidate);
        if (!matchesExisting) {
            this.entityCandidateMap.set(candidate.type, candidate);
        }
        else {
            candidate = this.entityCandidateMap.get(candidate.type);
        }
    }
    async matchVerifiedEntities() {
        let entityMapByName = {};
        for (let targetCandidate of this.entityCandidateMap.values()) {
            entityMapByName[targetCandidate.type] = targetCandidate;
            if (!targetCandidate.parentClassName || targetCandidate.parentEntity) {
                continue;
            }
            targetCandidate.parentEntity = this.entityCandidateMap.get(targetCandidate.parentClassName);
            if (targetCandidate.parentEntity) {
                continue;
            }
            let parentType = GLOBAL_CANDIDATES.inheritanceMap[targetCandidate.type];
            while (parentType) {
                targetCandidate.parentEntity = this.entityCandidateMap.get(parentType);
                if (targetCandidate.parentEntity) {
                    break;
                }
                parentType = GLOBAL_CANDIDATES.inheritanceMap[parentType];
            }
            if (targetCandidate.parentEntity) {
                continue;
            }
            targetCandidate.parentEntity = await this.getMappedSuperclassFromProject(targetCandidate.docEntry.fileImports, targetCandidate.parentClassName);
        }
        let entityInterfaceMap = {};
        for (let className in entityMapByName) {
            let entityCandidate = entityMapByName[className];
            entityCandidate.implementedInterfaceNames.forEach((interfaceName) => {
                let matchingInterfaces = this.allInterfacesMap.get(interfaceName);
                if (!matchingInterfaces || !matchingInterfaces.length) {
                    return;
                }
                if (matchingInterfaces.length > 1) {
                    throw new Error(`
Found multiple definitions of interface '${interfaceName}' 
implemented by entity '${className}'.  Interfaces implemented by entity 
classes must have globally unique names.`);
                }
                let anInterface = matchingInterfaces[0];
                anInterface.implementedBySet.add(entityCandidate);
                entityInterfaceMap[interfaceName] = anInterface;
            });
        }
        this.classifyEntityProperties(entityInterfaceMap);
        return entityMapByName;
    }
    classifyEntityProperties(entityInterfaceMap) {
        let classifiedEntitySet = new Set();
        for (let [candidateType, candidate] of this.entityCandidateMap) {
            classifiedEntitySet.add(candidate);
            let properties = candidate.docEntry.properties;
            if (!properties) {
                return;
            }
            const fileImports = candidate.docEntry.fileImports;
            properties.forEach((//
            property //
            ) => {
                let type = property.type;
                if (endsWith(type, '[]')) {
                    property.isArray = true;
                    type = type.substr(0, type.length - 2);
                }
                else if (startsWith(type, 'Array<')) {
                    type = type.substr(6, type.length - 1);
                }
                property.nonArrayType = type;
                if (property.isTransient
                    && startsWith(type, '{') && endsWith(type, '}')) {
                    property.primitive = 'Json';
                    return;
                }
                property.decorators.filter(decorator => decorator.name === 'Column').forEach(decorator => {
                    decorator.values.filter(value => value.columnDefinition).forEach(value => {
                        property.columnDefinition = value.columnDefinition;
                    });
                });
                switch (type) {
                    case 'boolean':
                        property.primitive = 'boolean';
                        break;
                    case 'number':
                        property.primitive = 'number';
                        break;
                    case 'string':
                        property.primitive = 'string';
                        break;
                    case 'Date':
                        property.primitive = 'Date';
                        break;
                    case 'any':
                        property.primitive = 'any';
                        break;
                }
                const decorators = property.decorators;
                if (decorators.some(decorator => decorator.name === 'Json')) {
                    property.primitive = 'Json';
                }
                if (decorators.some(decorator => decorator.name === 'DbAny')) {
                    property.primitive = 'any';
                }
                if (decorators.some(decorator => decorator.name === 'DbBoolean')) {
                    property.primitive = 'boolean';
                }
                if (decorators.some(decorator => decorator.name === 'DbDate')) {
                    property.primitive = 'Date';
                }
                if (decorators.some(decorator => decorator.name === 'DbNumber')) {
                    property.primitive = 'number';
                }
                if (decorators.some(decorator => decorator.name === 'DbString')) {
                    property.primitive = 'string';
                }
                if (property.primitive) {
                    if (property.isArray) {
                        throw new Error(`
Arrays are currently not supported outside of @OneToMany.
Please use @Any().
						
File:     ${property.ownerEntity.path}
Property: ${property.name}
`);
                    }
                    return;
                }
                const objectMapFragments = type.split(':');
                if (objectMapFragments.length > 1) {
                    if (!property.isTransient) {
                        throw new Error(`
Non @Transient properties cannot be object maps.`);
                    }
                    property.isMap = true;
                    const objectMapValueFragment = objectMapFragments[objectMapFragments.length - 1];
                    property.mapValueType = objectMapValueFragment
                        .replace('}', '')
                        .replace(';', '')
                        .trim();
                    type = property.mapValueType;
                    property.mapValueIsPrimitive = isPrimitive(type);
                    const objectMapKeyNameFragment = objectMapFragments[0];
                    property.mapKeyName = objectMapKeyNameFragment
                        .replace('{', '')
                        .replace('[', '')
                        .trim();
                    const objectMapKeyTypeFragment = objectMapFragments[1];
                    property.mapKeyType = objectMapKeyTypeFragment
                        .replace(']', '')
                        .trim();
                }
                if (!property.mapValueIsPrimitive
                    && !fileImports.importMapByObjectAsName[type]
                    && candidateType !== type) {
                    throw new Error(`
Type '${type}' is not an import in ${candidate.path}.
All type references in entities must must be imported 
(needed for DDL hiding).`);
                }
                // Do not check transient properties
                if (property.isTransient) {
                    return;
                }
                const moduleImport = fileImports.importMapByObjectAsName[type];
                if (moduleImport && !moduleImport.isLocal) {
                    const projectName = this.getProjectReferenceFromPath(moduleImport.path);
                    property.fromProject = projectName;
                    if (!this.getReferencedApplication(projectName, property)) {
                        throw new Error(`
Processing property ${property.ownerEntity.type}.${property.name}
Could not find related application in project '${projectName}'
if using external primitive types did you forget to add @DbBoolean(),
@DbNumber(), @DbDate() or @DbString() decorator to this property?`);
                    }
                }
                else {
                    let verifiedEntity = this.entityCandidateMap.get(type);
                    if (verifiedEntity) {
                        property.entity = verifiedEntity;
                        return;
                    }
                    let anInterface = entityInterfaceMap[type];
                    if (anInterface) {
                        this.registerInterface(anInterface, property);
                        property.entity = anInterface.implementation;
                    }
                    else {
                        if (canBeInterface(type)) {
                            const entityType = getImplNameFromInterfaceName(type);
                            verifiedEntity = this.entityCandidateMap.get(entityType);
                            if (verifiedEntity) {
                                const externalInterface = new Interface(null, type);
                                externalInterface.implementation = verifiedEntity;
                                entityInterfaceMap[type] = externalInterface;
                                this.registerInterface(externalInterface, property);
                                property.entity = verifiedEntity;
                            }
                            else {
                                throw new Error(`
Did not find project-local Entity type: '${entityType}' (from interface ${type}).
Did you forget to decorate it with @Entity()?`);
                            }
                        }
                        else {
                            throw new Error(`
Did not find project-local Entity type: '${type}'.
Did you forget to decorate it with @Entity()?`);
                        }
                    }
                }
            });
        }
        return classifiedEntitySet;
    }
    getReferencedApplication(projectName, property) {
        const dbApplication = DB_APPLICATION_LOADER.getReferencedApplication(projectName, property);
        property.otherApplicationDbEntity = this.getOtherApplicationEntity(projectName, dbApplication, property);
        return dbApplication;
    }
    getProjectReferenceFromPath(path) {
        const pathFragments = path.split('/');
        if (path.indexOf('@') === 0) {
            return pathFragments[0] + '/' + pathFragments[1];
        }
        return pathFragments[0];
    }
    matchToExistingEntity(entityCandidate) {
        let existingCandidate = this.entityCandidateMap.get(entityCandidate.type);
        if (!existingCandidate) {
            return false;
        }
        return true;
    }
    async getMappedSuperclassFromProject(fileImports, type) {
        const moduleImport = fileImports.importMapByObjectAsName[type];
        if (!moduleImport || moduleImport.isLocal) {
            return null;
        }
        const projectName = this.getProjectReferenceFromPath(moduleImport.path);
        const projectMappedSuperclasses = this.mappedSuperClassMap[projectName];
        if (projectMappedSuperclasses) {
            return projectMappedSuperclasses[type];
        }
        // const pathsToReferencedApplications =
        // this.configuration.airport.node_modulesLinks.pathsToReferencedApplications
        let relatedMappedSuperclassesProject;
        // if (pathsToReferencedApplications && pathsToReferencedApplications[projectName]) {
        // 	let referencedApplicationRelativePath = '../../' +
        // pathsToReferencedApplications[projectName] for (let i = 0; i < 10; i++) {
        // referencedApplicationRelativePath = '../' + referencedApplicationRelativePath let
        // pathToMappedSuperclasses =
        // getFullPathFromRelativePath(referencedApplicationRelativePath, __filename) if
        // (fs.existsSync(pathToMappedSuperclasses) &&
        // fs.lstatSync(pathToMappedSuperclasses).isDirectory()) {
        // relatedMappedSuperclassesProject = require(pathToMappedSuperclasses) break } } }
        // else {
        relatedMappedSuperclassesProject = await import('file://' + process.cwd() + '/node_modules/' + projectName + '/dist/definition/mappedSuperclass.mjs');
        // }
        if (!relatedMappedSuperclassesProject) {
            throw new Error(`
Could not find related application project '${projectName}'`);
        }
        if (!relatedMappedSuperclassesProject.MAPPED_SUPERCLASS) {
            throw new Error(`
Could not find related Mapped Superclasses in project '${projectName}'`);
        }
        const mappedSuperClassMapForProject = {};
        for (const mappedSuperclass of relatedMappedSuperclassesProject.MAPPED_SUPERCLASS) {
            const entityCandidate = this.deserializeEntityCandidate(mappedSuperclass);
            mappedSuperClassMapForProject[mappedSuperclass.type] = entityCandidate;
        }
        this.mappedSuperClassMap[projectName] = mappedSuperClassMapForProject;
        return mappedSuperClassMapForProject[type];
    }
    deserializeEntityCandidate(serializedEntityCandidate) {
        const entityCandidate = new EntityCandidate(null, null, null);
        for (let key in serializedEntityCandidate) {
            entityCandidate[key] = serializedEntityCandidate[key];
        }
        if (entityCandidate.parentEntity) {
            entityCandidate.parentEntity = this.deserializeEntityCandidate(entityCandidate.parentEntity);
        }
        return entityCandidate;
    }
    getOtherApplicationEntity(projectName, dbApplication, property) {
        const type = property.nonArrayType;
        let otherApplicationDbEntity = dbApplication.currentVersion[0].applicationVersion
            .entityMapByName[type];
        if (!otherApplicationDbEntity) {
            if (canBeInterface(type)) {
                const relatedImplementationName = getImplNameFromInterfaceName(type);
                otherApplicationDbEntity = dbApplication.currentVersion[0].applicationVersion
                    .entityMapByName[relatedImplementationName];
                if (!otherApplicationDbEntity) {
                    throw new Error(`
Could not find entity '${relatedImplementationName}' 
(from interface ${type}) in project '${projectName}'`);
                }
            }
            else {
                throw new Error(`
Processing property ${property.ownerEntity.type}.${property.name}
Could not find entity '${type}' in project '${projectName}'
if using external primitive types did you forget to add @DbBoolean(), @DbNumber(), @DbDate() or @DbString() decorator to this property?`);
            }
        }
        return otherApplicationDbEntity;
    }
    registerInterface(anInterface, property) {
        if (anInterface.implementedBySet.size > 1) {
            let implementations = [];
            for (let entity of anInterface.implementedBySet) {
                implementations.push(entity.type);
            }
            throw new Error(`
Interface ${anInterface.name}, is implemented by more than one 
entity (${implementations.join(', ')}).  Interfaces used in relations can only be 
implemented by one entity.`);
        }
        let implementedEntity = anInterface.implementedBySet.values().next().value;
        property.entity = implementedEntity;
    }
}

class ImportManager {
    static resolveImports(sourceFile, filePath) {
        const importMapByObjectAsName = {};
        const importMapByModulePath = {};
        const fileImports = {
            importMapByObjectAsName,
            importMapByModulePath,
        };
        for (const anImport of sourceFile.imports) {
            const path = anImport.text;
            if (path.endsWith('../')) {
                throw new Error(`
Entity file source rule violation:
		File: ${filePath}
		
				Imports ending in a directory are not valid, 
				please import from a barrel or a file.
				
				NOTE: importing from the 'generated' barrel is not currently supported,
				please import from the specific generated files.
				
				NOTE: importing from the '.../index' file is not currently supported,
				please import from the specific generated files.
				
		Import:
			${path}
				
				`);
            }
            if (path.endsWith('./generated/generated')) {
                throw new Error(`
Entity file source rule violation:
		File: ${filePath}
		
				Importing from the 'generated' barrel is not currently supported,
				please import from the specific generated files.
				
		Import:
			${path}
				
				`);
            }
            if (path.endsWith('../index')) {
                throw new Error(`
Entity file source rule violation:
		File: ${filePath}
		
				Importing from the '.../index' file is not currently supported,
				please import from the specific generated files.
				
		Import:
			${path}
				
				`);
            }
            const isLocal = this.isLocalReference(path);
            const objectMapByAsName = {};
            const moduleImport = {
                fileImports,
                isLocal,
                objectMapByAsName,
                path,
            };
            importMapByModulePath[path] = moduleImport;
            const namedBindings = anImport.parent.importClause.namedBindings;
            if (!namedBindings || !namedBindings.elements) {
                continue;
            }
            for (const namedBinding of namedBindings.elements) {
                const asName = namedBinding.name.text;
                let sourceName = asName;
                if (namedBinding.propertyName) {
                    sourceName = namedBinding.propertyName.text;
                }
                const importedObject = {
                    asName,
                    moduleImport,
                    sourceName,
                };
                objectMapByAsName[asName] = importedObject;
                importMapByObjectAsName[asName] = moduleImport;
            }
        }
        return fileImports;
    }
    static isLocalReference(path) {
        return path.startsWith('.');
    }
}

/**
 * Created by Papa on 3/26/2016.
 */
class GlobalCandidates {
    constructor() {
        this.inheritanceMap = new Map();
    }
    get registry() {
        if (!this._registry) {
            this._registry = new EntityCandidateRegistry();
        }
        return this._registry;
    }
}
const GLOBAL_CANDIDATES = new GlobalCandidates();
var TsObjectType;
(function (TsObjectType) {
    TsObjectType["OBJECT_LITERAL"] = "OBJECT_LITERAL";
    TsObjectType["OBJECT_LITERAL_ARRAY"] = "OBJECT_LITERAL_ARRAY";
    TsObjectType["DECORATOR"] = "DECORATOR";
    TsObjectType["DECORATOR_ARRAY"] = "DECORATOR_ARRAY";
})(TsObjectType || (TsObjectType = {}));
const entityFileMap = {};
const fileImportsMapByFilePath = {};
function visitEntityFile(node, path) {
    let file = entityFileMap[path];
    if (!file) {
        file = {
            path,
            hasEntityCandidate: false,
            hasEnums: false,
            hasInterfaces: false
        };
        entityFileMap[path] = file;
    }
    const onlyClassInFileError = `
	Error in file:
${path}
	Cannot declare entities in same files as interfaces and enums (needed for DDL hiding).
	NOTE: Entity interface is already generated for you. If you need addition interfaces
	please put them into src/types.ts file.`;
    if (node.kind === tsc__default.SyntaxKind.ClassDeclaration) {
        if (file.hasEntityCandidate) {
            throw new Error(`Cannot declare more than one entity per file.`);
        }
        if (file.hasEnums || file.hasInterfaces) {
            throw new Error(onlyClassInFileError);
        }
        file.hasEntityCandidate = true;
        let fileImports = fileImportsMapByFilePath[path];
        if (!fileImports) {
            fileImports = ImportManager.resolveImports(node.parent, file.path);
            fileImportsMapByFilePath[path] = fileImports;
        }
        // This is a top level class, get its symbol
        let symbol = globalThis.checker
            .getSymbolAtLocation(node.name);
        const decorators = tsc__default.getDecorators(node);
        serializeClass$1(symbol, decorators, path, fileImports, node.parent);
        // if (serializedClass) {
        // 	 output.push(serializedClass)
        // }
        // No need to walk any further, class expressions/inner declarations
        // cannot be exported
    }
    else if (node.kind === tsc__default.SyntaxKind.InterfaceDeclaration) {
        if (file.hasEntityCandidate) {
            throw new Error(onlyClassInFileError);
        }
        file.hasInterfaces = true;
        // This is a top level interface, get its symbol
        let symbol = globalThis.checker
            .getSymbolAtLocation(node.name);
        registerInterface(symbol, path);
    }
    else if (node.kind === tsc__default.SyntaxKind.ModuleDeclaration) {
        // This is a namespace, visit its children
        // tsc.forEachChild(node, visit);
        throw new Error(`Namespaces are not supported in DDL.`);
    }
    else if (node.kind === tsc__default.SyntaxKind.EnumDeclaration) {
        if (file.hasEntityCandidate) {
            throw new Error(onlyClassInFileError);
        }
        file.hasEnums = true;
        let symbol = globalThis.checker
            .getSymbolAtLocation(node.name);
        GLOBAL_CANDIDATES.registry.enumMap.set(symbol.name, path);
    }
}
/** Serialize a symbol into a json object */
function serializeSymbol(symbol, parent = symbol.parent) {
    const declarations = symbol.declarations;
    let isGenerated = false;
    let allocationSize = undefined;
    let isId = false;
    let isMappedSuperclass = false;
    let isTransient = false;
    const decorators = [];
    let declaration;
    let optional;
    if (declarations && declarations.length === 1) {
        declaration = symbol.declarations[0];
        const tsDecorators = tsc__default.getDecorators(declaration);
        if (tsDecorators) {
            for (const tsDecorator of tsDecorators) {
                const decorator = serializeDecorator(tsDecorator);
                switch (decorator.name) {
                    case 'GeneratedValue':
                        isGenerated = true;
                        break;
                    case 'SequenceGenerator':
                        allocationSize = decorator.values[0].allocationSize;
                        break;
                    case 'Id':
                        isId = true;
                        break;
                    case 'MappedSuperclass':
                        isMappedSuperclass = true;
                        break;
                    // Skip fields marked with @Transient
                    case 'Transient':
                        isTransient = true;
                        break;
                }
                decorators.push(decorator);
            }
        }
    }
    // 		if (flags & 8 /* NoTruncation */) {
    // if (flags & 256 /* UseFullyQualifiedType */) {
    // if (flags & 4096 /* SuppressAnyReturnType */) {
    // if (flags & 1 /* WriteArrayAsGenericType */) {
    // if (flags & 64 /* WriteTypeArgumentsOfSignature */) {
    let type = globalThis.checker.typeToString(globalThis.checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration), parent);
    if (declaration) {
        optional = !!declaration.questionToken;
        if (type === 'any' && declaration) {
            if (declaration.type
                && declaration.type.typeName) {
                type = declaration.type.typeName.escapedText;
            }
            else if (declaration.type
                && declaration.type.kind === tsc__default.SyntaxKind.AnyKeyword) ;
            else {
                throw new Error(`Unsupported type for '${getSymbolLocationString(symbol, parent)}': ${type} (implicit if 'any')`);
            }
        }
        else if (type.match(/^\s*any\[\]\s*$/)) {
            if (declaration.type
                && declaration.type.elementType
                && declaration.type.elementType.typeName) {
                type = declaration.type.elementType.typeName.escapedText + '[]';
            }
            else {
                throw new Error(`Unsupported array type for '${getSymbolLocationString(symbol, parent)}': ${type}`);
            }
        }
        else if (type.match(/\]\s*:\s*any\s*;*\s*\}\s*$/)) {
            if (declaration.type
                && declaration.type.members
                && declaration.type.members[0]
                && declaration.type.members[0].type
                && declaration.type.members[0].type.typeName) {
                type = type.replace(/any\s*;*\s*\}\s*$/, declaration.type.members[0].type.typeName.escapedText + '}');
            }
            else {
                throw new Error(`Unsupported map type for '${getSymbolLocationString(symbol, parent)}': ${type}`);
            }
        }
        else if (type.match(/^\s*any\s*$/)) {
            throw new Error(`Unsupported type for '${getSymbolLocationString(symbol, parent)}': ${type}`);
        }
    }
    return {
        allocationSize,
        decorators,
        isGenerated,
        isId,
        isMappedSuperclass,
        isTransient,
        name: symbol.getName(),
        optional,
        // documentation:
        // tsc.displayPartsToString(symbol.getDocumentationComment(undefined)),
        type
    };
}
function getSymbolLocationString(symbol, parent) {
    let parentPrefix = 'unknown';
    if (parent.fileName) {
        parentPrefix = parent.fileName;
    }
    else if (parent.getName) {
        parentPrefix = parent.getName();
    }
    return `${parentPrefix} -> ${symbol.getName()}`;
}
function serializeMethodDefinition(symbol) {
    const name = symbol.getName();
    const parameters = [];
    const signature = symbol.valueDeclaration;
    const tsParams = signature.parameters;
    for (const tsParam of tsParams) {
        const typeInfo = getType(tsParam.type, 0);
        const name = tsParam.name.escapedText;
        const optional = tsParam.questionToken ? true : false;
        parameters.push({ ...typeInfo, name, optional });
    }
    const typeInfo = getType(signature.type, 0);
    const optional = signature.questionToken ? true : false;
    const returnType = { ...typeInfo, name, optional };
    return {
        name,
        parameters,
        returnType,
    };
}
function getType(tsType, arrayDepth) {
    let type = 'any';
    let primitive = null;
    let genericParams = [];
    const typeInfo = {
        type,
        primitive,
        arrayDepth,
        genericParams
    };
    if (!tsType) {
        return typeInfo;
    }
    switch (tsType.kind) {
        case tsc__default.SyntaxKind.ArrayType:
            return getType(tsType.elementType, ++arrayDepth);
        case tsc__default.SyntaxKind.AnyKeyword:
            return typeInfo;
        case tsc__default.SyntaxKind.BooleanKeyword:
            type = primitive = 'boolean';
            return { ...typeInfo, primitive, type };
        case tsc__default.SyntaxKind.NumberKeyword:
            type = primitive = 'number';
            return { ...typeInfo, primitive, type };
        case tsc__default.SyntaxKind.StringKeyword:
            type = primitive = 'string';
            return { ...typeInfo, primitive, type };
        case tsc__default.SyntaxKind.VoidKeyword:
            type = 'void';
            return { ...typeInfo, type };
        case tsc__default.SyntaxKind.TypeReference:
            const typeName = tsType.typeName;
            const typeArguments = tsType.typeArguments;
            if (typeArguments && typeArguments.length) {
                genericParams = typeArguments.map(genericParam => getType(genericParam, 0));
            }
            type = typeName.escapedText;
            return { ...typeInfo, type, genericParams };
        default:
            throw new Error(`Unsupported Syntax kind for method parameter/type: ${tsType.kind}`);
    }
}
function serializeDecorator(tsDecorator) {
    let expression = tsDecorator.expression;
    let decoratorName;
    if (expression.expression) {
        decoratorName = expression.expression.text;
    }
    else {
        decoratorName = expression.text;
    }
    let values = [];
    if (expression.arguments) {
        expression.arguments.forEach((argument) => {
            let value = parseObjectProperty(argument, TsObjectType.DECORATOR, decoratorName);
            if (value !== undefined) {
                values.push(value);
            }
        });
    }
    const decorator = {
        name: decoratorName,
        values: values
    };
    return decorator;
}
function parseObjectLiteralExpression(objLitExpr) {
    let object = {};
    if (objLitExpr.properties) {
        objLitExpr.properties.forEach((property) => {
            const propertyName = property.name.text;
            const initializer = property.initializer;
            const value = parseObjectProperty(initializer, TsObjectType.OBJECT_LITERAL, propertyName);
            object[propertyName] = value;
        });
    }
    return object;
}
function parseObjectProperty(initializer, objectType, objectName) {
    let value;
    switch (initializer.kind) {
        case tsc__default.SyntaxKind.Identifier:
            let identifier = initializer;
            switch (identifier.text) {
                case 'undefined':
                    value = undefined;
                    break;
                case 'NaN':
                    value = NaN;
                    break;
                // Must be a variable declaration
                default:
                    value = 'var ' + identifier.text;
                    break;
            }
            break;
        case tsc__default.SyntaxKind.NullKeyword:
            value = null;
            break;
        case tsc__default.SyntaxKind.RegularExpressionLiteral:
            let regExp = initializer;
            value = convertRegExpStringToObject(regExp.text);
            break;
        case tsc__default.SyntaxKind.StringLiteral:
        case tsc__default.SyntaxKind.NoSubstitutionTemplateLiteral:
            value = initializer.text;
            break;
        case tsc__default.SyntaxKind.TrueKeyword:
            value = true;
            break;
        case tsc__default.SyntaxKind.FalseKeyword:
            value = false;
            break;
        case tsc__default.SyntaxKind.NumericLiteral:
            let numberText = initializer.text;
            if (numberText.indexOf('.') > 0) {
                value = parseFloat(numberText);
            }
            else {
                value = parseInt(numberText);
            }
            break;
        case tsc__default.SyntaxKind.NewExpression:
            let newExpression = initializer;
            let type = newExpression.expression.text;
            value = 'new ' + type;
            break;
        case tsc__default.SyntaxKind.ObjectLiteralExpression:
            value = parseObjectLiteralExpression(initializer);
            break;
        case tsc__default.SyntaxKind.ArrayLiteralExpression:
            value = [];
            let arrayLiteral = initializer;
            arrayLiteral.elements.forEach((element) => {
                let arrayObjectType = objectType;
                switch (objectType) {
                    case TsObjectType.DECORATOR:
                        arrayObjectType = TsObjectType.DECORATOR_ARRAY;
                        break;
                    case TsObjectType.OBJECT_LITERAL:
                        arrayObjectType = TsObjectType.OBJECT_LITERAL_ARRAY;
                        break;
                }
                let arrayValue = parseObjectProperty(element, arrayObjectType, objectName);
                value.push(arrayValue);
            });
            break;
        case tsc__default.SyntaxKind.PropertyAccessExpression:
            value = convertPropertyAccessExpressionToString(initializer);
            break;
        case tsc__default.SyntaxKind.CallExpression:
            throw new Error(`Function calls are not allowed as parameter values.`);
        case tsc__default.SyntaxKind.BinaryExpression:
            throw new Error(`Expression are not allowed as parameter values.`);
        case tsc__default.SyntaxKind.ArrowFunction:
            const arrowFunction = initializer;
            for (const parameter of arrowFunction.parameters) {
                if (!parameter.name || !parameter.type) {
                    throw new Error(`Uxpected @Table property indexes:${getExpectedPropertyIndexesFormatMessage()}`);
                }
            }
            const parameters = arrowFunction.parameters.map(parameter => ({
                name: parameter.name.escapedText,
                type: parameter.type.typeName.escapedText
            }));
            let body;
            try {
                body = parseObjectProperty(arrowFunction.body, TsObjectType.OBJECT_LITERAL, null);
            }
            catch (e) {
                throw new Error(`Uxpected @Table property indexes:${getExpectedPropertyIndexesFormatMessage()}`);
            }
            value = {
                body,
                parameters
            };
            if (objectType == TsObjectType.DECORATOR && objectName === 'WhereJoinTable') {
                const printer = tsc__default.createPrinter({
                    newLine: tsc__default.NewLineKind.LineFeed,
                    removeComments: true
                });
                /*
                TODO: rethink how we can import @WhereJoinTable code
                const fileImports = [];
                for (let filePath in currentFileImports.importMapByModulePath) {
                    const moduleImport = currentFileImports.importMapByModulePath[filePath];
                    if (moduleImport.isLocal) {
                        continue;
                    }
                    let importsFromFile = [];
                    for (let asName in moduleImport.objectMapByAsName) {
                        const importedObject = moduleImport.objectMapByAsName[asName];
                        if (importedObject.asName === importedObject.sourceName) {
                            importsFromFile.push(importedObject.asName);
                        } else {
                            importsFromFile.push(`${importedObject.sourceName} as ${importedObject.asName}`);
                        }
                    }
                    const importsFragment = importsFromFile.join(', ');
                    const importStatement = `import { ${importsFragment} } from '${moduleImport.path}';`;
                    fileImports.push(importStatement);
                }
                const globalImports = fileImports.join('\r\n');

                const typescriptDefinition = printer.printNode(ts.EmitHint.Expression, initializer, currentSourceFile);
                const whereJoinTableFunction =
                    `const WhereJoinTableFunction = (${typescriptDefinition});`;

                const tempFile = `${globalImports}

${whereJoinTableFunction}
export default WhereJoinTableFunction`;

                const compilerOptions = {module: ts.ModuleKind.CommonJS};
                const transpilationResult = tsc.transpileModule(tempFile, {
                    compilerOptions: compilerOptions,
                    moduleName: "WhereJoinTableModule"
                });
                value = transpilationResult.outputText;
                */
                // For now allow only and, or & not functions and everything from
                // airport reference (and nothing else)
                const typescriptDefinition = printer.printNode(tsc__default.EmitHint.Expression, initializer, globalThis.currentSourceFile);
                const compilerOptions = { module: tsc.ModuleKind.CommonJS };
                const transpilationResult = tsc__default.transpileModule(typescriptDefinition, {
                    compilerOptions: compilerOptions,
                    moduleName: 'WhereJoinTableModule'
                });
                value = transpilationResult.outputText;
            }
            break;
        default:
            let objectTypeDescription = '';
            switch (objectType) {
                case TsObjectType.OBJECT_LITERAL:
                    objectTypeDescription = 'object literal';
                    break;
                case TsObjectType.OBJECT_LITERAL_ARRAY:
                    objectTypeDescription = 'object literal array';
                    break;
                case TsObjectType.DECORATOR:
                    objectTypeDescription = 'decorator';
                    break;
                case TsObjectType.DECORATOR_ARRAY:
                    objectTypeDescription = 'decorator array';
                    break;
            }
            throw new Error(`Unsupported property initializer.kind: ${initializer.kind}
				 for ${objectTypeDescription}: ${objectName}`);
    }
    return value;
}
function convertPropertyAccessExpressionToString(propAccessExrp) {
    let leftHandExrp = propAccessExrp.expression;
    let suffix = '.' + propAccessExrp.name.text;
    if (leftHandExrp.text) {
        return `${leftHandExrp.text}${suffix}`;
    }
    else {
        return convertPropertyAccessExpressionToString(leftHandExrp) + suffix;
    }
}
function convertRegExpStringToObject(regExpString) {
    let firstIndexOfSlash = regExpString.indexOf('/');
    if (firstIndexOfSlash < 0) {
        return new RegExp(regExpString);
    }
    let lastIndexOfSlash = regExpString.lastIndexOf('/');
    if (firstIndexOfSlash === lastIndexOfSlash) {
        return new RegExp(regExpString);
    }
    let regExpFragments = regExpString.split('/');
    return new RegExp(regExpFragments[1], regExpFragments[2]);
}
function forEach(collection, callback) {
    if (collection instanceof Map) {
        for (let [key, value] of collection.entries()) {
            callback(key, value);
        }
    }
    else {
        for (let memberName in collection) {
            callback(memberName, collection[memberName]);
        }
    }
}
/** Serialize a class symbol information */
function serializeClass$1(symbol, decorators, classPath, fileImports, file) {
    const details = serializeSymbol(symbol, file);
    details.fileImports = fileImports;
    let properties = [];
    let methodSignatures = [];
    let ids = [];
    forEach(symbol.members, (memberName, member) => {
        if (member.valueDeclaration) {
            switch (member.valueDeclaration.kind) {
                case tsc__default.SyntaxKind.PropertyDeclaration:
                    console.log(`Property: ${memberName}`);
                    let propertySymbolDescriptor = serializeSymbol(member, file);
                    if (propertySymbolDescriptor) {
                        if (propertySymbolDescriptor.isId) {
                            ids.push(propertySymbolDescriptor);
                        }
                        properties.push(propertySymbolDescriptor);
                    }
                    break;
                case tsc__default.SyntaxKind.MethodDeclaration:
                    console.log(`Method: ${memberName}`);
                    const isPublic = !member.valueDeclaration.modifiers
                        || member.valueDeclaration.modifiers.filter(modifier => modifier.kind === tsc__default.SyntaxKind.PrivateKeyword
                            || modifier.kind === tsc__default.SyntaxKind.ProtectedKeyword).length < 1;
                    if (isPublic) {
                        methodSignatures.push(serializeMethodDefinition(member));
                    }
                    break;
                case tsc__default.SyntaxKind.GetAccessor:
                    // 		if (flags & 8 /* NoTruncation */) {
                    // if (flags & 256 /* UseFullyQualifiedType */) {
                    // if (flags & 4096 /* SuppressAnyReturnType */) {
                    // if (flags & 1 /* WriteArrayAsGenericType */) {
                    // if (flags & 64 /* WriteTypeArgumentsOfSignature */) {
                    let type = globalThis.checker.typeToString(globalThis.checker.getTypeOfSymbolAtLocation(member, member.valueDeclaration), file);
                    properties.push({
                        decorators: [],
                        isTransient: true,
                        name: member.getName(),
                        optional: true,
                        // documentation:
                        // tsc.displayPartsToString(symbol.getDocumentationComment(undefined)),
                        type
                    });
                    break;
            }
        }
        else if (member.declarations) {
            // declaration (constructor, method)
            if (member.declarations.length === 1 && member.declarations[0].kind === tsc__default.SyntaxKind.Constructor) ;
            else {
                throw new Error('Not implemented');
            }
        }
        else {
            // value declaration (properity)
            throw new Error('Not implemented');
        }
    });
    details.properties = properties;
    details.methodSignatures = methodSignatures;
    // Get the construct signatures
    let constructorType = globalThis.checker
        .getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
    details.constructors = constructorType.getConstructSignatures().map(serializeSignature);
    let parentClassName = getParentClassName(symbol);
    let parentClassImport;
    if (parentClassName) {
        parentClassImport = getParentClassImport(symbol, parentClassName);
    }
    let entityDecorator = isDecoratedAsEntity(decorators);
    let classInheritanceEntry = GLOBAL_CANDIDATES.inheritanceMap[details.name];
    if (classInheritanceEntry != undefined) {
        throw new Error(`Found duplicate entity '${details.name}'. 
			Non-unique class names are not supported`);
    }
    if (entityDecorator) {
        let entityCandidate = EntityCandidate.create(details.name, classPath, parentClassName, parentClassImport, entityDecorator.isSuperclass);
        entityCandidate.docEntry = details;
        entityCandidate.ids = ids;
        entityCandidate.implementedInterfaceNames = getImplementedInterfaces(symbol);
        details.properties.forEach(property => {
            property.ownerEntity = entityCandidate;
        });
        GLOBAL_CANDIDATES.registry.addCandidate(entityCandidate);
        GLOBAL_CANDIDATES.inheritanceMap[details.name] = parentClassName;
        if (GLOBAL_CANDIDATES.inheritanceMap[parentClassName] == undefined) {
            GLOBAL_CANDIDATES.inheritanceMap[parentClassName] = null;
        }
    }
    else if (classInheritanceEntry == null) {
        GLOBAL_CANDIDATES.inheritanceMap[details.name] = parentClassName;
    }
    return details;
}
function registerInterface(symbol, classPath) {
    let anInterface = new Interface(classPath, symbol.name);
    let interfaces = GLOBAL_CANDIDATES.registry.allInterfacesMap.get(symbol.name);
    if (!interfaces) {
        interfaces = [];
        GLOBAL_CANDIDATES.registry.allInterfacesMap.set(symbol.name, interfaces);
    }
    interfaces.push(anInterface);
}
/** Serialize a signature (call or construct) */
function serializeSignature(signature) {
    return {
        parameters: signature.parameters.map(serializeSymbol),
        returnType: globalThis.checker.typeToString(signature.getReturnType()),
        // documentation:
        // tsc.displayPartsToString(signature.getDocumentationComment(undefined))
    };
}

const currentApplicationApi = {
    apiObjectMap: {}
};
const currentApiFileSignatureMap = {};
const printer = tsc__default.createPrinter({
    newLine: tsc__default.NewLineKind.LineFeed,
    removeComments: true
});
function visitApiFile(node, path) {
    let fileObject = currentApiFileSignatureMap[path];
    if (!fileObject) {
        const pathFragments = normalizePath(path).split('/');
        fileObject = {
            apiClasses: [],
            fileName: pathFragments[pathFragments.length - 1],
            imports: null,
            otherMemberDefinitions: []
        };
        currentApiFileSignatureMap[path] = fileObject;
    }
    switch (node.kind) {
        case tsc__default.SyntaxKind.ClassDeclaration:
            const classNode = node;
            const symbol = globalThis.checker.getSymbolAtLocation(classNode.name);
            if (!fileObject.imports) {
                fileObject.imports = ImportManager
                    .resolveImports(symbol.valueDeclaration.parent, path);
            }
            // This is a top level class, get its symbol
            const className = classNode.name.escapedText;
            const apiArtifacts = serializeClass(symbol, className);
            if (apiArtifacts) {
                currentApplicationApi.apiObjectMap[className] = apiArtifacts.apiObject;
                fileObject.apiClasses.push(apiArtifacts.apiClass);
            }
            break;
        case tsc__default.SyntaxKind.EnumDeclaration:
        case tsc__default.SyntaxKind.InterfaceDeclaration:
            fileObject.otherMemberDefinitions.push(printer.printNode(tsc__default.EmitHint.Unspecified, node, globalThis.currentSourceFile));
            break;
        default:
            return;
    }
}
function serializeClass(symbol, className, path) {
    const apiObject = {
        operationMap: {}
    };
    const apiClass = {
        className,
        apiSignatures: []
    };
    let numApiMethods = 0;
    forEach$1(symbol.members, (memberName, member) => {
        if (!member.valueDeclaration) {
            return {};
        }
        switch (member.valueDeclaration.kind) {
            case tsc__default.SyntaxKind.MethodDeclaration:
                let methodDescriptor = serializeMethod(symbol, className, memberName, member);
                if (methodDescriptor && methodDescriptor.isApiMethod) {
                    numApiMethods++;
                    apiObject.operationMap[memberName] = {
                        isAsync: methodDescriptor.isAsync,
                        parameters: methodDescriptor.parameters.map(text => ({
                            kind: undefined,
                            isRest: false,
                            text
                        }))
                    };
                    apiClass.apiSignatures.push({
                        isAsync: methodDescriptor.isAsync,
                        name: methodDescriptor.name,
                        parameters: methodDescriptor.parameters,
                        returnType: methodDescriptor.returnType
                    });
                }
                break;
        }
    });
    return numApiMethods ? {
        apiClass,
        apiObject
    } : null;
}
function serializeMethod(symbol, className, name, member) {
    const decorators = tsc__default.getDecorators(member.valueDeclaration);
    if (!decorators) {
        return;
    }
    let isApiMethod = false;
    let isAsync = false;
    for (let modifier of member.declarations[0].modifiers) {
        if (modifier.kind === tsc__default.SyntaxKind.AsyncKeyword) {
            isAsync = true;
        }
    }
    decorators.forEach(decorator => {
        // decorator.expression.kind = 196 CallExpression
        // decorator.expression.expression.kind = 75 Identifier
        let decoratorNameExpression = decorator.expression.expression;
        const decoratorNameParts = [];
        while (decoratorNameExpression) {
            if (decoratorNameExpression.escapedText) {
                decoratorNameParts.unshift(decoratorNameExpression.escapedText);
            }
            else if (decoratorNameExpression.name) {
                decoratorNameParts.unshift(decoratorNameExpression.name.escapedText);
            }
            decoratorNameExpression = decoratorNameExpression.expression;
        }
        const decoratorName = decoratorNameParts.join('.');
        switch (decoratorName) {
            case 'Api':
                isApiMethod = true;
                break;
        }
    });
    if (!isApiMethod) {
        return;
    }
    // const name: string = member.escapedName as any;
    const declaration = member.valueDeclaration;
    const parameters = [];
    for (const parameter of declaration.parameters) {
        if (!parameter.type) {
            throw new Error(`Parameter type is not specified for:

class ${className}
    @Api()
    ${name}(
        ...
        ${parameter.name.escapedText}
        ...
    )

`);
        }
        parameters.push(printer.printNode(tsc__default.EmitHint.Unspecified, parameter, globalThis.currentSourceFile));
    }
    if (!declaration.type) {
        throw new Error(`Return type is not specified for:

class ${className}
    @Api()
    ${name}

`);
    }
    const returnType = printer.printNode(tsc__default.EmitHint.Unspecified, declaration.type, globalThis.currentSourceFile);
    return {
        isApiMethod,
        isAsync,
        name,
        parameters,
        returnType
    };
}

const additionalFileProcessors = [];
function addFileProcessor(fileProcessor) {
    additionalFileProcessors.push(fileProcessor);
}
/** Generate documention for all classes in a set of .ts files */
async function generateDefinitions(fileNames, options, configuration, applicationMapByProjectName) {
    // Build a program using the set of root file names in fileNames
    let program = tsc__default.createProgram(fileNames, options);
    globalThis.checker = program.getTypeChecker();
    // Get the checker, we will use it to find more about classes
    GLOBAL_CANDIDATES.registry.configuration = configuration;
    DB_APPLICATION_LOADER.setApplicationMap(applicationMapByProjectName);
    // const daoFileMap: { [classPath: string]: DaoFile } = {}
    const sourceFiles = program.getSourceFiles();
    // Visit every sourceFile in the program
    for (const sourceFile of sourceFiles) {
        if (sourceFile.fileName.indexOf('node_modules') > -1
            || sourceFile.fileName.indexOf('src/generated') > -1) {
            continue;
        }
        globalThis.currentSourceFile = sourceFile;
        // Walk the tree to searchOne for classes
        tsc__default.forEachChild(sourceFile, visit);
    }
    // print out the doc
    // fs.writeFileSync("classes.json", JSON.stringify(output, undefined, 4));
    const entityCandidateMap = await GLOBAL_CANDIDATES.registry
        .matchVerifiedEntities();
    for (const additionalFileProcessor of additionalFileProcessors) {
        await additionalFileProcessor.finishProcessing();
    }
    return entityCandidateMap;
}
/** visit nodes finding exported classes */
function visit(node) {
    let path = getClassPath(node.parent);
    // Only top level entities are supported
    if (!path) {
        return;
    }
    // Do not process libraries
    if (path.indexOf('node_modules') > -1) {
        return;
    }
    // Do not process files outside of the project (possible with MS Rush setup)
    if (path.indexOf(process.cwd() + '/src') > -1
        && path.indexOf(process.cwd() + '\\src') > -1) {
        return;
    }
    // if (path.indexOf(globalThis.configuration.airport.node_modulesLinks.pathToProject) == -1) {
    // 	return
    // }
    if (globalThis.configuration.airport.daoDir
        && path.indexOf(globalThis.configuration.airport.daoDir) > 0) {
        visitDaoFile(node, path);
    }
    else if (path.indexOf(globalThis.configuration.airport.ddlDir) > 0) {
        visitEntityFile(node, path);
    }
    else if (globalThis.configuration.airport.apiDir
        && path.indexOf(globalThis.configuration.airport.apiDir) > 0) {
        visitApiFile(node, path);
    }
    for (const fileProcessor of additionalFileProcessors) {
        let normalizedPath = normalizePath(path);
        if (normalizedPath.indexOf(fileProcessor.getDir()) > -1) {
            fileProcessor.process(node, path);
        }
    }
    // not needed as long as classes with APIS are referenced in
    // client side tokens via their interfaces
    // visitInterfaceCandidateFile(node, path)
}

const Y = {
    airportSelectField: true,
    insert: true,
    update: false
};
const ALL_FIELDS = {
    __allFields__: true
};
function convertToY(object) {
    object.airportSelectField = true;
}
function isY(object) {
    return object && object.airportSelectField === true;
}
function isN(object) {
    return object && object.airportSelectField === false;
}
function isID(object) {
    return object && object.airportSelectField === 'ID';
}
function cleanErrorMessageSelectStatement(errorMessageSelectStatement) {
    for (let propertyName in errorMessageSelectStatement) {
        let property = errorMessageSelectStatement[propertyName];
        if (!(property instanceof Object)) {
            continue;
        }
        if (property.hasOwnProperty("airportSelectField")) {
            switch (property.airportSelectField) {
                case "LID":
                    errorMessageSelectStatement[propertyName] = "LID";
                    break;
                case true:
                    errorMessageSelectStatement[propertyName] = "Y";
                    break;
                case false:
                    errorMessageSelectStatement[propertyName] = "N";
                    break;
            }
        }
        else {
            cleanErrorMessageSelectStatement(property);
        }
    }
}
function getErrorMessageSelectStatement(jsonSelectClause) {
    const errorMessageSelectStatement = JSON.parse(JSON.stringify(jsonSelectClause));
    cleanErrorMessageSelectStatement(errorMessageSelectStatement);
    return JSON.stringify(errorMessageSelectStatement, null, 4);
}

/**
 * Created by Papa on 10/18/2016.
 */
const ALIASES = ['a', 'b', 'c', 'd', 'e',
    'f', 'g', 'h', 'i', 'j',
    'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z'];
class AliasCache {
    constructor(aliasPrefix = '') {
        this.aliasPrefix = aliasPrefix;
        this.reset();
    }
    getFollowingAlias() {
        let currentAlias = this.lastAlias;
        for (var i = 2; i >= 0; i--) {
            let currentIndex = currentAlias[i];
            currentIndex = (currentIndex + 1) % 26;
            currentAlias[i] = currentIndex;
            if (currentIndex !== 0) {
                break;
            }
        }
        let aliasString = this.aliasPrefix;
        for (var i = 0; i < 3; i++) {
            aliasString += ALIASES[currentAlias[i]];
        }
        if (aliasString === 'add') {
            aliasString = this.getFollowingAlias();
        }
        return aliasString;
    }
    reset() {
        this.lastAlias = [-1, -1, -1];
    }
}
class AliasMap {
    constructor(aliasCache) {
        this.aliasCache = aliasCache;
        this.aliasMap = new Map();
    }
    getNextAlias(object) {
        if (this.hasAliasFor(object)) {
            return this.getExistingAlias(object);
        }
        let aliasString = this.aliasCache.getFollowingAlias();
        this.aliasMap.set(object, aliasString);
        return aliasString;
    }
    hasAliasFor(object) {
        return this.aliasMap.has(object);
    }
}
class EntityAliases extends AliasMap {
    constructor(entityAliasCache = new AliasCache('E'), columnAliasCache = new AliasCache('C'), parameterAliasCache = new AliasCache('P')) {
        super(entityAliasCache);
        this.columnAliasCache = columnAliasCache;
        this.parameterAliases = new ParameterAliases(parameterAliasCache);
    }
    getParams( //
    ) {
        return this.parameterAliases;
    }
    getNewFieldColumnAliases() {
        return new FieldColumnAliases(this, this.columnAliasCache);
    }
    getExistingAlias(entity) {
        if (!this.hasAliasFor(entity)) {
            throw new Error(`No alias found for entity ${entity.__driver__.dbEntity.name}`);
        }
        return this.aliasMap.get(entity);
    }
    getOnlyAlias( //
    ) {
        if (this.aliasMap.size !== 1) {
            return `Expecting only 1 entry in Field's alias map`;
        }
        return this.aliasMap.get(this.aliasMap.keys().next().value);
    }
}
class ParameterAliases extends AliasMap {
    constructor(aliasCache) {
        super(aliasCache);
    }
    getNextAlias(object) {
        if (this.hasAliasFor(object)) {
            return this.getExistingAlias(object).alias;
        }
        let aliasString = this.aliasCache.getFollowingAlias();
        let parameter = {
            alias: aliasString,
            value: object.value
        };
        this.aliasMap.set(object, parameter);
        return aliasString;
    }
    getExistingAlias(field) {
        if (!this.hasAliasFor(field)) {
            throw new Error(`No alias found for a parameter`);
        }
        return this.aliasMap.get(field);
    }
    getParameters( //
    ) {
        let parameters = {};
        this.aliasMap.forEach((value, key) => {
            parameters[value.alias] = value;
        });
        return parameters;
    }
}
class FieldColumnAliases extends AliasMap {
    constructor(_entityAliases, aliasCache) {
        super(aliasCache);
        this._entityAliases = _entityAliases;
    }
    get entityAliases( //
    ) {
        return this._entityAliases;
    }
    getExistingAlias(field) {
        if (!this.hasAliasFor(field)) {
            const qField = field;
            throw new Error(`No alias found for property ${qField.dbProperty.entity.name}.${qField.dbProperty.name}`);
        }
        return this.aliasMap.get(field);
    }
}

function QEntity(dbEntity, queryUtils, relationManager, fromClausePosition = [], dbRelation = null, joinType = null, QDriver = globalThis.QEntityDriver) {
    this.__driver__ = new QDriver(dbEntity, queryUtils, relationManager, fromClausePosition, dbRelation, joinType, this);
}
QEntity.prototype.FULL_JOIN = function (right) {
    return this.__driver__.join(right, JoinType.FULL_JOIN);
};
QEntity.prototype.INNER_JOIN = function (right) {
    return this.__driver__.join(right, JoinType.INNER_JOIN);
};
QEntity.prototype.LEFT_JOIN = function (right) {
    return this.__driver__.join(right, JoinType.LEFT_JOIN);
};
QEntity.prototype.RIGHT_JOIN = function (right) {
    return this.__driver__.join(right, JoinType.RIGHT_JOIN);
};
QEntity.prototype.equals = function (entity) {
    return globalThis.IOC
        .getSync(globalThis.QUERY_UTILS)
        .equals(entity, this);
};
QEntity.prototype.in = function (entities) {
    return globalThis.IOC
        .getSync(globalThis.QUERY_UTILS)
        .in(entities, this);
};

/**
 * Created by Papa on 4/21/2016.
 */
class Operation {
    constructor(category) {
        this.category = category;
    }
}

/**
 * Created by Papa on 4/21/2016.
 */
const AND = function (...ops) {
    return new LogicalOperation().AND(ops);
};
const OR = function (...ops) {
    return new LogicalOperation().OR(ops);
};
const NOT = function (op) {
    return new LogicalOperation().NOT(op);
};
class LogicalOperation extends Operation {
    constructor() {
        super(null);
    }
    static verifyChildOps(ops) {
        if (!ops || !ops.length) {
            throw new Error(`No child operations provided`);
        }
    }
    AND(ops) {
        return {
            c: OperationCategory.LOGICAL,
            o: SqlOperator.AND,
            v: ops
        };
    }
    OR(ops) {
        return {
            c: OperationCategory.LOGICAL,
            o: SqlOperator.OR,
            v: ops
        };
    }
    NOT(op) {
        return {
            c: OperationCategory.LOGICAL,
            o: SqlOperator.NOT,
            v: op
        };
    }
}

/**
 * Created by Papa on 4/26/2016.
 */
/*
 * Cannot use 'class' syntax because it brakes dynamic creation of subclasses.
 * With 'class' browser reports:
 *   Class constructor QRelation cannot be invoked without 'new'
 * When calling:
 *   Q...Relation.base.constructor.call(this, relation, qEntity)
 */
function QRelation(dbRelation, parentQ, applicationUtils, relationManager) {
    this.dbRelation = dbRelation;
    this.parentQ = parentQ;
    this.applicationUtils = applicationUtils;
    this.relationManager = relationManager;
}
QRelation.prototype.INNER_JOIN = function () {
    const newQEntity = this.getNewQEntity(JoinType.INNER_JOIN);
    this.parentQ.__driver__.childQEntities.push(newQEntity);
    return newQEntity;
};
QRelation.prototype.LEFT_JOIN = function () {
    const newQEntity = this.getNewQEntity(JoinType.LEFT_JOIN);
    this.parentQ.__driver__.childQEntities.push(newQEntity);
    return newQEntity;
};
QRelation.prototype.IS_NULL = function () {
    return this.nullOrNot(true);
};
QRelation.prototype.IS_NOT_NULL = function () {
    return this.nullOrNot(false);
};
QRelation.prototype.nullOrNot = function (isNull) {
    const dbRelation = this.dbRelation;
    const qEntityUtils = IOC.getSync(QEntityUtils);
    const operations = [];
    for (const propertyColumn of dbRelation.property.propertyColumns) {
        const columnField = qEntityUtils.getColumnQField(dbRelation.entity, dbRelation.property, this.parentQ, propertyColumn.column);
        operations.push(isNull
            ? columnField.IS_NULL()
            : columnField.IS_NOT_NULL());
    }
    if (operations.length > 1) {
        if (isNull) {
            return OR(...operations);
        }
        else {
            return AND(...operations);
        }
    }
    return operations[0];
};
QRelation.prototype.getNewQEntity = function (joinType) {
    const dbEntity = this.dbRelation.relationEntity;
    const qEntityConstructor = this.applicationUtils.getQEntityConstructor(this.dbRelation.relationEntity);
    let newQEntity = new qEntityConstructor(dbEntity, this.applicationUtils, this.relationManager, this.relationManager.getNextChildJoinPosition(this.parentQ.__driver__), this.dbRelation, joinType, this.applicationUtils, this.relationManager);
    newQEntity.__driver__.parentJoinEntity = this.parentQ;
    return newQEntity;
};
function QAirEntityRelation(dbRelation, parentQ, applicationUtils, relationManager) {
    QAirEntityRelation.base.constructor.call(this, dbRelation, parentQ, applicationUtils, relationManager);
}
const qAirEntityRelationMethods = {};
extend(QRelation, QAirEntityRelation, qAirEntityRelationMethods);
function QManyToOneAirEntityRelation(dbRelation, parentQ, applicationUtils, relationManager) {
    QAirEntityRelation.base.constructor.call(this, dbRelation, parentQ, applicationUtils, relationManager);
}
const qManyToOneAirEntityRelationMethods = {
    equals: function (entity) {
        return IOC.getSync(QUERY_UTILS).equals(entity, this);
    },
    IN: function (entitiesOrIds) {
        return IOC.getSync(QUERY_UTILS).in(entitiesOrIds, this);
    }
};
extend(QAirEntityRelation, QManyToOneAirEntityRelation, qManyToOneAirEntityRelationMethods);
function QManyToOneInternalRelation(dbRelation, parentQ, applicationUtils, relationManager) {
    QAirEntityRelation.base.constructor.call(this, dbRelation, parentQ, applicationUtils, relationManager);
}
const qManyToOneInternalRelationMethods = {
    equals: function (entityId) {
        return IOC.getSync(QUERY_UTILS).equalsInternal(entityId, this);
    },
    IN: function (entityIds) {
        return IOC.getSync(QUERY_UTILS).inInternal(entityIds, this);
    }
};
extend(QRelation, QManyToOneInternalRelation, qManyToOneInternalRelationMethods);

/**
 * Created by Papa on 10/25/2016.
 */
/*
 * Cannot use 'class' syntax because it brakes dynamic creation of subclasses.
 * With 'class' browser reports:
 *   Class constructor QRelation cannot be invoked without 'new'
 * When calling:
 *   Q...Relation.base.constructor.call(this, relation, qEntity)
 */
function QOneToManyRelation(dbRelation, parentQ, applicationUtils, repationManager) {
    QOneToManyRelation.base.constructor.call(this, dbRelation, parentQ, applicationUtils, repationManager);
}
const qOneToManyRelationMethods = {
/*
yourMethodName: function() {},
*/
};
extend(QRelation, QOneToManyRelation, qOneToManyRelationMethods);
function QAirEntityOneToManyRelation(dbRelation, parentQ, applicationUtils, repationManager) {
    QAirEntityOneToManyRelation.base.constructor.call(this, dbRelation, parentQ, applicationUtils, repationManager);
}
const qAirEntityOneToManyRelationMethods = {
/*
yourMethodName: function() {},
*/
};
extend(QAirEntityRelation, QAirEntityOneToManyRelation, qAirEntityOneToManyRelationMethods);

class ValueOperation extends Operation {
    constructor(category) {
        super(category);
        this.category = category;
        this.dictionaryToken = globalThis.AIRPORT_DOMAIN
            .app('ground-control').token('Dictionary');
    }
    equals(lValue, rValue) {
        const jsonRawValueOperation = {
            c: this.category,
            l: lValue,
            o: SqlOperator.EQUALS,
            r: rValue
        };
        this.addTrackedRepoIDs(lValue, rValue, jsonRawValueOperation);
        return jsonRawValueOperation;
    }
    addTrackedRepoIDs(lValue, rValue, jsonRawValueOperation) {
        const dictionary = globalThis.IOC
            .getSync(this.dictionaryToken);
        if (dictionary.isRepositoryGUIDProperty(lValue.dbProperty)) {
            let trackedRepoGUIDs;
            if (typeof rValue === 'string') {
                trackedRepoGUIDs = [rValue];
            }
            else if (rValue instanceof Array) {
                trackedRepoGUIDs = rValue;
            }
            jsonRawValueOperation.trackedRepoGUIDs = trackedRepoGUIDs;
        }
        else if (dictionary.isRepositoryLIDColumn(lValue.dbProperty, lValue.dbColumn)) {
            let trackedRepoLIDs;
            if (typeof rValue === 'number') {
                trackedRepoLIDs = [rValue];
            }
            else if (rValue instanceof Array) {
                trackedRepoLIDs = rValue;
            }
            jsonRawValueOperation.trackedRepoLocalIds = trackedRepoLIDs;
        }
    }
    greaterThan(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.GREATER_THAN,
            r: rValue
        };
    }
    greaterThanOrEquals(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.GREATER_THAN_OR_EQUALS,
            r: rValue
        };
    }
    IS_NOT_NULL(lValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.IS_NOT_NULL
        };
    }
    IS_NULL(lValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.IS_NULL
        };
    }
    IN(lValue, rValue) {
        const jsonRawValueOperation = {
            c: this.category,
            l: lValue,
            o: SqlOperator.IN,
            r: rValue
        };
        this.addTrackedRepoIDs(lValue, rValue, jsonRawValueOperation);
        return jsonRawValueOperation;
    }
    lessThan(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.LESS_THAN,
            r: rValue
        };
    }
    lessThanOrEquals(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.LESS_THAN_OR_EQUALS,
            r: rValue
        };
    }
    notEquals(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.NOT_EQUALS,
            r: lValue
        };
    }
    NOT_IN(lValue, rValue) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.NOT_IN,
            r: rValue
        };
    }
}

/**
 * Created by Papa on 6/20/2016.
 */
class BooleanOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.BOOLEAN);
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
class FieldInOrderBy {
    constructor(field, sortOrder) {
        this.field = field;
        this.sortOrder = sortOrder;
    }
    toJSON(columnAliases) {
        if (!columnAliases.hasAliasFor(this.field)) {
            throw new Error(`Field used in ORDER_BY clause is not present in SELECT clause`);
        }
        return {
            fa: columnAliases.getExistingAlias(this.field),
            so: this.sortOrder
        };
    }
    toEntityJSON() {
        let qField = this.field;
        return {
            fa: undefined,
            ci: qField.dbColumn.index,
            pi: qField.dbProperty.index,
            ti: qField.dbProperty.entity.index,
            si: qField.dbProperty.entity.applicationVersion._localId,
            so: this.sortOrder
        };
    }
}

/**
 * Created by Papa on 4/21/2016.
 */
class QField {
    constructor(dbColumn, dbProperty, q, objectType) {
        this.dbColumn = dbColumn;
        this.dbProperty = dbProperty;
        this.q = q;
        this.objectType = objectType;
        this.__appliedFunctions__ = [];
    }
    /**
     protected getFieldKey() {
        let rootEntityPrefix = columnAliases.entityAliases.getExistingAlias(this.parentQ.getRootJoinEntity());
        let key = `${relationManager.getPositionAlias(rootEntityPrefix, this.parentQ.fromClausePosition)}.${this.fieldName}`;
        return key;
    }
     */
    applySqlFunction(sqlFunctionCall) {
        let appliedField = this.getInstance();
        appliedField.__appliedFunctions__.push(sqlFunctionCall);
        return appliedField;
    }
    toJSON(columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        let alias;
        if (forSelectClause) {
            alias = columnAliases.getNextAlias(this);
        }
        let rootEntityPrefix;
        if (this.__fieldSubQuery__) {
            rootEntityPrefix = columnAliases.entityAliases.getOnlyAlias();
        }
        else {
            rootEntityPrefix = columnAliases.entityAliases.getExistingAlias(this.q.__driver__.getRootJoinEntity());
        }
        let jsonField = {
            appliedFunctions: this.appliedFunctionsToJson(this.__appliedFunctions__, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager),
            si: this.dbProperty.entity.applicationVersion._localId,
            ti: this.dbProperty.entity.index,
            fa: alias,
            pi: this.dbProperty.index,
            ci: this.dbColumn.index,
            ta: relationManager.getPositionAlias(rootEntityPrefix, this.q.__driver__.fromClausePosition),
            ot: this.objectType,
            dt: this.dbColumn.type
        };
        if (this.__fieldSubQuery__) {
            jsonField.fieldSubQuery = fieldUtils.getFieldQueryJson(this.__fieldSubQuery__, columnAliases.entityAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils);
            jsonField.ot = JSONClauseObjectType.FIELD_QUERY;
        }
        return jsonField;
    }
    ASC() {
        return new FieldInOrderBy(this, SortOrder.ASCENDING);
    }
    DESC() {
        return new FieldInOrderBy(this, SortOrder.DESCENDING);
    }
    addSubQuery(subQuery) {
        let appliedField = this.getInstance();
        appliedField.__fieldSubQuery__ = subQuery;
        return appliedField;
    }
    operableFunctionToJson(functionObject, columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        let alias;
        if (forSelectClause) {
            alias = columnAliases.getNextAlias(this);
        }
        return {
            appliedFunctions: this.appliedFunctionsToJson(this.__appliedFunctions__, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager),
            fa: alias,
            ot: this.objectType,
            dt: this.dbColumn.type,
            v: this.valueToJSON(functionObject, columnAliases, false, true, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager)
        };
    }
    copyFunctions(field) {
        field.__appliedFunctions__ = this.__appliedFunctions__.slice();
        return field;
    }
    appliedFunctionsToJson(appliedFunctions, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        if (!appliedFunctions) {
            return appliedFunctions;
        }
        return appliedFunctions.map((appliedFunction) => {
            return this.functionCallToJson(appliedFunction, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        });
    }
    functionCallToJson(functionCall, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        let parameters;
        if (functionCall.p) {
            parameters = functionCall.p.map((parameter) => {
                return this.valueToJSON(parameter, columnAliases, false, false, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
            });
        }
        return {
            ft: functionCall.ft,
            p: parameters
        };
    }
    valueToJSON(functionObject, columnAliases, forSelectClause, fromFunctionObject, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        if (!functionObject) {
            throw new Error(`Function object must be provided to valueToJSON function.`);
        }
        if (!fromFunctionObject && functionObject instanceof QField) {
            return functionObject.toJSON(columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        }
        let value = functionObject.value;
        switch (typeof value) {
            case 'boolean':
            case 'number':
            case 'string':
                return columnAliases.entityAliases.getParams()
                    .getNextAlias(functionObject);
            case 'object':
                if (value instanceof Date) {
                    return columnAliases.entityAliases.getParams()
                        .getNextAlias(functionObject);
                }
                else if (value instanceof Array) {
                    return columnAliases.entityAliases.getParams()
                        .getNextAlias(functionObject);
                }
                else if (value === null) {
                    return columnAliases.entityAliases.getParams()
                        .getNextAlias(functionObject);
                }
                else {
                    throw new Error(`Unexpected query parameter type allowed types are:
boolean | Date | Date[] | number | number[] | string | string[]
`);
                }
            case 'undefined':
                throw new Error(`Undefined is not allowed as a query parameter`);
            default:
                throw new Error(`Unexpected query parameter type allowed types are:
boolean | Date | Date[] | number | number[] | string | string[]
`);
        }
        // TODO: this never gets called, is this needed?
        /*
        if (value === null || value instanceof Date) {
            return columnAliases.entityAliases.getParams()
                .getNextAlias(functionObject as IQFunction<any>)
        }
        if (value instanceof QField) {
            return value.toJSON(columnAliases, forSelectClause, queryUtils, fieldUtils, relationManager)
        }
        // must be a field sub-query
        let rawFieldQuery: RawFieldQuery<any> = value
        return fieldUtils.getFieldQueryJson(
            rawFieldQuery, columnAliases.entityAliases, queryUtils)
         */
    }
}

/**
 * Created by Papa on 10/25/2016.
 */
class QOperableField extends QField {
    constructor(dbColumn, dbProperty, q, objectType, operation) {
        super(dbColumn, dbProperty, q, objectType);
        this.operation = operation;
    }
    equals(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.equals(this, value);
    }
    greaterThan(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.greaterThan(this, value);
    }
    greaterThanOrEquals(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.greaterThanOrEquals(this, value);
    }
    IS_NOT_NULL() {
        return this.operation.IS_NOT_NULL(this);
    }
    IS_NULL() {
        return this.operation.IS_NULL(this);
    }
    IN(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.IN(this, value);
    }
    lessThan(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.lessThan(this, value);
    }
    lessThanOrEquals(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.lessThanOrEquals(this, value);
    }
    notEquals(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.notEquals(this, value);
    }
    NOT_IN(values) {
        values = values.map((value) => {
            if (value instanceof Function) {
                return value();
            }
            return value;
        });
        return this.operation.NOT_IN(this, values);
    }
}

class QBooleanField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new BooleanOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QBooleanField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
}
class QBooleanFunction extends QBooleanField {
    constructor(value, isQueryParameter = false) {
        super({ type: SQLDataType.BOOLEAN }, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = value;
        this.isQueryParameter = isQueryParameter;
    }
    getInstance() {
        return this.copyFunctions(new QBooleanFunction(this.value));
    }
    toJSON(columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        let json = this.operableFunctionToJson(this, columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        if (this.isQueryParameter) {
            this.parameterAlias = json.v;
        }
        return json;
    }
}

/**
 * Created by Papa on 6/20/2016.
 */
class DateOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.DATE);
    }
}

class QDateField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new DateOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QDateField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
}
class QDateFunction extends QDateField {
    constructor(value, isQueryParameter = false) {
        super({ type: SQLDataType.DATE }, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = value;
        this.isQueryParameter = isQueryParameter;
    }
    getInstance() {
        return this.copyFunctions(new QDateFunction(this.value, this.isQueryParameter));
    }
    toJSON(columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        let json = this.operableFunctionToJson(this, columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        if (this.isQueryParameter) {
            this.parameterAlias = json.v;
        }
        return json;
    }
}
class QDateArrayFunction extends QDateFunction {
    constructor(value, isQueryParameter) {
        super(value, isQueryParameter);
        this.value = value;
    }
    getInstance() {
        return this.copyFunctions(new QDateArrayFunction(this.value, this.isQueryParameter));
    }
}

/**
 * Created by Papa on 6/20/2016.
 */
class NumberOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.NUMBER);
    }
}

class QNumberField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new NumberOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QNumberField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
}
class QNumberFunction extends QNumberField {
    constructor(value, isQueryParameter = false) {
        super({ type: SQLDataType.NUMBER }, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = value;
        this.isQueryParameter = isQueryParameter;
    }
    getInstance() {
        return this.copyFunctions(new QNumberFunction(this.value, this.isQueryParameter));
    }
    toJSON(columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        let json = this.operableFunctionToJson(this, columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        if (this.isQueryParameter) {
            this.parameterAlias = json.v;
        }
        return json;
    }
}
class QNumberArrayFunction extends QNumberFunction {
    constructor(value, isQueryParameter) {
        super(value, isQueryParameter);
        this.value = value;
    }
    getInstance() {
        return this.copyFunctions(new QNumberArrayFunction(this.value, this.isQueryParameter));
    }
}

/**
 * Created by Papa on 6/20/2016.
 */
class StringOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.STRING);
    }
    LIKE(lValue, rValue
    // TODO: implement ReqExp
    //| RegExp
    ) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.LIKE,
            r: rValue
        };
    }
}

class QStringField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new StringOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QStringField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
    LIKE(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.LIKE(this, value);
    }
}
class QStringFunction extends QStringField {
    constructor(value, isQueryParameter = false) {
        super({ type: SQLDataType.STRING }, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = value;
        this.isQueryParameter = isQueryParameter;
    }
    getInstance() {
        return this.copyFunctions(new QStringFunction(this.value, this.isQueryParameter));
    }
    toJSON(columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        let json = this.operableFunctionToJson(this, columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        if (this.isQueryParameter) {
            this.parameterAlias = json.v;
        }
        return json;
    }
}
class QStringArrayFunction extends QStringFunction {
    constructor(value, isQueryParameter) {
        super(value, isQueryParameter);
        this.value = value;
    }
    getInstance() {
        return this.copyFunctions(new QStringArrayFunction(this.value, this.isQueryParameter));
    }
}

/**
 * Created by papa on 7/13/17.
 */
class UntypedOperation extends ValueOperation {
    constructor() {
        super(OperationCategory.UNTYPED);
    }
    LIKE(lValue, rValue
    // TODO: implement ReqExp
    //| RegExp
    ) {
        return {
            c: this.category,
            l: lValue,
            o: SqlOperator.LIKE,
            r: rValue
        };
    }
}

class QUntypedField extends QOperableField {
    constructor(dbColumn, dbProperty, q, objectType = JSONClauseObjectType.FIELD) {
        super(dbColumn, dbProperty, q, objectType, new UntypedOperation());
    }
    getInstance(qEntity = this.q) {
        return this.copyFunctions(new QUntypedField(this.dbColumn, this.dbProperty, qEntity, this.objectType));
    }
    like(value) {
        if (value instanceof Function) {
            value = value();
        }
        return this.operation.LIKE(this, value);
    }
}

class QEntityUtils {
    getColumnQField(entity, property, q, column) {
        switch (column.type) {
            case SQLDataType.ANY:
                return new QUntypedField(column, property, q);
            case SQLDataType.BOOLEAN:
                return new QBooleanField(column, property, q);
            case SQLDataType.DATE:
                return new QDateField(column, property, q);
            case SQLDataType.NUMBER:
                return new QNumberField(column, property, q);
            case SQLDataType.JSON:
            case SQLDataType.STRING:
                return new QStringField(column, property, q);
            default:
                throw new Error(`Unsupported data type for property ${entity.applicationVersion.application.name}.${entity.name}.${property.name}`);
        }
    }
    getQRelation(entity, property, q, allQApps, applicationUtils, relationManager) {
        const relation = property.relation[0];
        switch (relation.relationType) {
            case EntityRelationType.MANY_TO_ONE:
                const relationEntity = relation.relationEntity;
                const relationApplication = relationEntity.applicationVersion.application;
                const qIdRelationConstructor = allQApps[relationApplication.index]
                    .__qIdRelationConstructors__[relationEntity.index];
                return new qIdRelationConstructor(relation.relationEntity, relation, q, applicationUtils, relationManager);
            case EntityRelationType.ONE_TO_MANY:
                if (entity.isAirEntity) {
                    return new QAirEntityOneToManyRelation(relation, q, applicationUtils, relationManager);
                }
                else {
                    return new QOneToManyRelation(relation, q, applicationUtils, relationManager);
                }
            default:
                throw new Error(`Unknown EntityRelationType: ${relation.relationType}.`);
        }
    }
    getQEntityConstructor(allQApps) {
        // ChildQEntity refers to the constructor
        var ChildQEntity = function (entity, applicationUtils, relationManager, nextChildJoinPosition, dbRelation, joinType) {
            ChildQEntity.base.constructor.call(this, entity, applicationUtils, relationManager, nextChildJoinPosition, dbRelation, joinType);
            const qEntityUtils = IOC.getSync(QEntityUtils);
            entity.properties.forEach((property) => {
                let qFieldOrRelation;
                if (property.relation && property.relation.length) {
                    qFieldOrRelation = qEntityUtils.getQRelation(entity, property, this, allQApps, applicationUtils, relationManager);
                    for (const propertyColumn of property.propertyColumns) {
                        qEntityUtils.addColumnQField(entity, property, this, propertyColumn.column);
                    }
                }
                else {
                    qFieldOrRelation = qEntityUtils.addColumnQField(entity, property, this, property.propertyColumns[0].column);
                }
                this[property.name] = qFieldOrRelation;
            });
            // entity.__qConstructor__ = ChildQEntity
        };
        const childQEntityMethods = {
        /*
        yourMethodName: function() {},
        */
        };
        extend(QEntity, ChildQEntity, childQEntityMethods);
        return ChildQEntity;
    }
    addColumnQField(entity, property, q, column) {
        const qFieldOrRelation = this.getColumnQField(entity, property, q, column);
        q.__driver__.allColumns[column.index]
            = qFieldOrRelation;
        if (column.idIndex || column.idIndex === 0) {
            q.__driver__.idColumns[column.idIndex]
                = qFieldOrRelation;
        }
        return qFieldOrRelation;
    }
    getQEntityIdRelationConstructor(dbEntity) {
        function QEntityIdRelation(entity, relation, qEntity, appliationUtils, relationManager) {
            QEntityIdRelation.base.constructor.call(this, relation, qEntity, appliationUtils, relationManager);
            const qEntityUtils = IOC.getSync(QEntityUtils);
            qEntityUtils.getQEntityIdFields(this, entity, qEntity, relation.property);
            // (<any>entity).__qConstructor__.__qIdRelationConstructor__ = QEntityIdRelation
        }
        const qEntityIdRelationMethods = {
        /*
        yourMethodName: function() {},
        */
        };
        if (dbEntity.isAirEntity) {
            extend(QManyToOneAirEntityRelation, QEntityIdRelation, qEntityIdRelationMethods);
        }
        else {
            extend(QManyToOneInternalRelation, QEntityIdRelation, qEntityIdRelationMethods);
        }
        return QEntityIdRelation;
    }
    /**
     * Set all fields behind an id relation.  For example
     *
     * QA.id
     *
     * or
     *
     * QA.rel1.id
     *
     * or
     *
     * QA.rel2.otherRel.id
     * QA.rel2.id
     *
     * @param addToObject  Object to add to (Ex: QA | QA.rel1 | QA.rel2.otherRel
     * @param relationEntity  Entity to which the fields belong (Ex: QA, QRel1, QRel2, QOtherRel)
     * @param utils
     * @param parentProperty  The parent property from which the current property was
     *    navigated to
     * @param relationColumnMap  DbColumn map for the current path of properties
     *  (QA.rel2.otherRel), keyed by the column from the One side of the relation
     */
    getQEntityIdFields(addToObject, relationEntity, qEntity, parentProperty, relationColumnMap) {
        if (!relationColumnMap) {
            const parentRelation = parentProperty.relation[0];
            const relationColumns = parentRelation.manyRelationColumns;
            relationColumnMap = new Map();
            for (const relationColumn of relationColumns) {
                relationColumnMap.set(relationColumn.oneColumn, relationColumn.manyColumn);
            }
        }
        relationEntity.properties.forEach((property) => {
            if (!property.isId && relationEntity.isAirEntity) {
                // Internal (non-AIR entity) relations may join by non-@Id()
                // Fields.  For example RepositoryReference join across 
                // repositories on GUIDs.
                return;
            }
            let qFieldOrRelation;
            // If it's a relation property (and therefore has backing columns)
            if (property.relation && property.relation.length) {
                const relation = property.relation[0];
                const relationColumns = relation.manyRelationColumns;
                let hasMatchingColumns = false;
                for (const relationColumn of relationColumns) {
                    if (relationColumnMap.has(relationColumn.manyColumn)) {
                        hasMatchingColumns = true;
                        const originalColumn = relationColumnMap.get(relationColumn.manyColumn);
                        // Remove the mapping of the parent relation
                        relationColumnMap.delete(relationColumn.manyColumn);
                        // And replace it with the nested relation
                        relationColumnMap.set(relationColumn.oneColumn, originalColumn);
                    }
                }
                if (!hasMatchingColumns) {
                    return;
                }
                qFieldOrRelation = this.getQEntityIdFields({}, relation.relationEntity, qEntity, parentProperty, relationColumnMap);
            }
            else {
                if (!relationColumnMap.has(property.propertyColumns[0].column)) {
                    // Only happens in internal (non-AIR entity) relations that do not
                    // rely on @Id() fields
                    return;
                }
                const originalColumn = relationColumnMap.get(property.propertyColumns[0].column);
                qFieldOrRelation = this.getColumnQField(relationEntity, parentProperty, qEntity, originalColumn);
            }
            addToObject[property.name] = qFieldOrRelation;
        });
        return addToObject;
    }
}

const tarmaqQuery = lib('tarmaq-query');
// Separating core-tokens from tokens removes circular dependencies
// at code initialization time
tarmaqQuery.register(QEntityUtils);
const ENTITY_UTILS = tarmaqQuery.token('EntityUtils');
const QUERY_UTILS = tarmaqQuery.token('QueryUtils');
globalThis.ENTITY_UTILS = ENTITY_UTILS;
globalThis.QUERY_UTILS = QUERY_UTILS;

/**
 * Created by Papa on 10/25/2016.
 */
function tree(query) {
    let queryDefinition;
    if (query instanceof Function) {
        queryDefinition = query();
    }
    else {
        queryDefinition = query;
    }
    let view = IOC.getSync(ENTITY_UTILS).getQTree([], queryDefinition);
    let customEntity = queryDefinition.SELECT;
    view = convertMappedEntitySelect(customEntity, queryDefinition, view, view, 'f');
    return view;
}
function convertMappedEntitySelect(customEntity, queryDefinition, view, selectProxy, fieldPrefix) {
    let fieldIndex = 0;
    for (let property in customEntity) {
        let alias = `${fieldPrefix}${++fieldIndex}`;
        let value = customEntity[property];
        if (IOC.getSync(ENTITY_UTILS).isQField(value)) {
            let field = value.getInstance(view);
            field.alias = alias;
            field.q = view;
            selectProxy[property] = field;
        }
        else {
            if (value instanceof Object && !(value instanceof Date)) {
                selectProxy[value] = convertMappedEntitySelect(value, queryDefinition, view, {}, `${alias}_`);
            }
            else {
                throw new Error(`All SELECT clause entries of a Mapped query must be Fields or Functions`);
            }
        }
    }
    return view;
}
/**
 * Sub-queries in SELECT clause
 * @param query
 * @returns {IQF}
 */
function field(query) {
    let queryDefinition;
    if (query instanceof Function) {
        queryDefinition = query();
    }
    else {
        queryDefinition = query;
    }
    let customField = queryDefinition.SELECT;
    customField = customField.addSubQuery(queryDefinition);
    // Field query cannot be joined to any other query so don't have set the positional fields
    return customField;
}
class JoinFields {
    constructor(joinFrom, joinTo) {
        this.joinFrom = joinFrom;
        this.joinTo = joinTo;
        if (!(IOC.getSync(ENTITY_UTILS).isQEntity(this.joinTo))) {
            throw new Error(`Right value in join must be a View or an Entity`);
        }
    }
    ON(joinOperation) {
        let joinChild = this.joinFrom;
        joinChild.__driver__.joinWhereClause = joinOperation(this.joinFrom, this.joinTo);
        return this.joinFrom;
    }
}

class QEntityDriver {
    constructor(dbEntity, queryUtils, relationManager, fromClausePosition = [], dbRelation = null, joinType = null, qEntity) {
        this.dbEntity = dbEntity;
        this.queryUtils = queryUtils;
        this.relationManager = relationManager;
        this.fromClausePosition = fromClausePosition;
        this.dbRelation = dbRelation;
        this.joinType = joinType;
        this.qEntity = qEntity;
        this.childQEntities = [];
        this.entityFieldMap = {};
        this.entityRelations = [];
        this.idColumns = [];
        this.allColumns = [];
        this.relations = [];
        this.currentChildIndex = -1;
    }
    getInstance() {
        const qEntityConstructor = this.queryUtils
            .getQEntityConstructor(this.dbEntity);
        let instance = new qEntityConstructor(this.dbEntity, this.queryUtils, this.relationManager, this.fromClausePosition, this.dbRelation, this.joinType);
        instance.__driver__.currentChildIndex = this.currentChildIndex;
        instance.__driver__.joinWhereClause = this.joinWhereClause;
        instance.__driver__.entityFieldMap = this.entityFieldMap;
        instance.__driver__.entityRelations = this.entityRelations;
        return instance;
    }
    /*
    addEntityRelation<R extends IQEntityInternal>(
        relation: IQInternalRelation<R>
    ): void {
        this.entityRelations[relation.parentRelationIndex] = relation;
    }

    addEntityField<T, IQF extends IQOperableFieldInternal<T, JSONBaseOperation, any, any>>(
        field: IQF
    ): void {
        this.entityFieldMap[field.fieldName] = field;
    }
    */
    /*
    getRelationPropertyName(): string {
        return QMetadataUtils.getRelationPropertyName(QMetadataUtils.getRelationByIndex(this.qEntity, this.relationIndex));
    }
*/
    getRelationJson(columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        // FIXME: this does not work for non-entity tree queries, as there is not dbEntity
        // see ApplicationDao.findMaxVersionedMapByApplicationAndDomain_Names for an example
        let jsonRelation = {
            currentChildIndex: this.currentChildIndex,
            ti: this.dbEntity.index,
            fromClausePosition: this.fromClausePosition,
            jt: this.joinType,
            rt: null,
            rep: columnAliases.entityAliases.getNextAlias(this.getRootJoinEntity()),
            si: this.dbEntity.applicationVersion.application.index
        };
        if (this.joinWhereClause) {
            this.getJoinRelationJson(jsonRelation, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        }
        else if (this.dbRelation) {
            this.getEntityRelationJson(jsonRelation);
        }
        else {
            this.getRootRelationJson(jsonRelation, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        }
        return jsonRelation;
    }
    getJoinRelationJson(jsonRelation, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        jsonRelation.rt = JSONRelationType.ENTITY_JOIN_ON;
        jsonRelation.joinWhereClause = queryUtils.whereClauseToJSON(this.joinWhereClause, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet);
        return jsonRelation;
    }
    getEntityRelationJson(jsonRelation) {
        jsonRelation.rt = JSONRelationType.ENTITY_APPLICATION_RELATION;
        jsonRelation.ri = this.dbRelation.index;
        // if (!this.dbRelation.whereJoinTable) {
        return jsonRelation;
        // }
        // let otmQEntity;
        // let mtoQEntity;
        // switch (this.dbRelation.relationType) {
        // 	case EntityRelationType.ONE_TO_MANY:
        // 		mtoQEntity = this.qEntity;
        // 		otmQEntity = this.parentJoinEntity;
        // 		break;
        // 	case EntityRelationType.MANY_TO_ONE:
        // 		otmQEntity = this.qEntity;
        // 		mtoQEntity = this.parentJoinEntity;
        // 		break;
        // 	default:
        // 		throw new Error(`Unknown EntityRelationType: ${this.dbRelation.relationType}`);
        // }
        //
        // let joinWhereClause = this.dbRelation.whereJoinTable.addToJoinFunction(otmQEntity,
        // mtoQEntity, this.airportDb, this.airportDb.F); jsonRelation.joinWhereClause    =
        // this.utils.Query.whereClauseToJSON(joinWhereClause, columnAliases);
        // jsonRelation.joinWhereClauseOperator   = this.dbRelation.joinFunctionWithOperator;  return
        // jsonRelation;
    }
    getRootRelationJson(jsonRelation, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        jsonRelation.rt = globalThis.IOC
            .getSync(globalThis.ENTITY_UTILS)
            // Removes circular dependency at code initialization time 
            .isQTree(this) ? JSONRelationType.SUB_QUERY_ROOT : JSONRelationType.ENTITY_ROOT;
        return jsonRelation;
    }
    getQ() {
        return this.qEntity;
    }
    join(right, joinType) {
        let joinChild = right
            .__driver__.getInstance();
        joinChild.__driver__.currentChildIndex = 0;
        let nextChildPosition = this.relationManager.getNextChildJoinPosition(this);
        joinChild.__driver__.fromClausePosition = nextChildPosition;
        joinChild.__driver__.joinType = joinType;
        joinChild.__driver__.parentJoinEntity = this.qEntity;
        this.qEntity.__driver__.childQEntities.push(joinChild);
        return new JoinFields(this.qEntity, joinChild);
    }
    isRootEntity() {
        return !this.parentJoinEntity;
    }
    getRootJoinEntity() {
        let rootEntity = this.qEntity;
        while (rootEntity.__driver__.parentJoinEntity) {
            rootEntity = rootEntity.__driver__.parentJoinEntity;
        }
        return rootEntity;
    }
}
globalThis.QEntityDriver = QEntityDriver;

/**
 * Created by Papa on 10/18/2016.
 */
class JoinTreeNode {
    constructor(jsonRelation, childNodes, parentNode) {
        this.jsonRelation = jsonRelation;
        this.childNodes = childNodes;
        this.parentNode = parentNode;
    }
    addChildNode(joinTreeNode) {
        let childFromClausePositionArray = joinTreeNode.jsonRelation.fromClausePosition;
        let childPosition = childFromClausePositionArray[childFromClausePositionArray.length - 1];
        this.childNodes[childPosition] = joinTreeNode;
    }
    getEntityRelationChildNode(dbRelation) {
        return this.getEntityRelationChildNodeByIndexes(dbRelation.property.entity.applicationVersion._localId, dbRelation.property.entity.index, dbRelation.index);
    }
    getEntityRelationChildNodeByIndexes(applicationIndex, tableIndex, relationIndex) {
        let matchingNodes = this.childNodes.filter((childNode) => {
            return childNode.jsonRelation.ri === relationIndex;
        });
        switch (matchingNodes.length) {
            case 0:
                break;
            case 1:
                return matchingNodes[0];
            default:
                throw new Error(`More than one child node matched relation property index '${relationIndex}'`);
        }
        // No node matched, this must be reference to a sub-entity in SELECT clause (in a Entity
        // query)
        let childPosition = this.jsonRelation.fromClausePosition.slice();
        childPosition.push(this.childNodes.length);
        let rootEntityPrefix;
        if (this.parentNode) {
            rootEntityPrefix = this.parentNode.jsonRelation.rep;
        }
        else {
            rootEntityPrefix = this.jsonRelation.rep;
        }
        let jsonEntityRelation = {
            currentChildIndex: 0,
            fromClausePosition: childPosition,
            ti: tableIndex,
            jt: JoinType.LEFT_JOIN,
            rt: JSONRelationType.ENTITY_APPLICATION_RELATION,
            rep: rootEntityPrefix,
            ri: relationIndex,
            si: applicationIndex
        };
        let childTreeNode = new JoinTreeNode(jsonEntityRelation, [], this);
        this.addChildNode(childTreeNode);
        return childTreeNode;
    }
}

function QTree(fromClausePosition = [], subQuery) {
    QTree.base.constructor.call(this, null, fromClausePosition, null, null, QTreeDriver);
    this.__driver__.subQuery = subQuery;
}
const qTreeMethods = {
/*
yourMethodName: function() {},
*/
};
globalThis.extend(QEntity, QTree, qTreeMethods);
class QTreeDriver extends QEntityDriver {
    getInstance() {
        let instance = super.getInstance();
        instance.__driver__
            .subQuery = this.subQuery;
        return instance;
    }
    // getRelationPropertyName(): string {
    // 	throw new Error(`not implemented`);
    // }
    getJoinRelationJson(jsonRelation, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        jsonRelation = super.getJoinRelationJson(jsonRelation, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        jsonRelation.rt = JSONRelationType.SUB_QUERY_JOIN_ON;
        jsonRelation.subQuery =
            // Removes circular dependency at code initialization time 
            globalThis.IOC.getSync(globalThis.ENTITY_UTILS).getTreeQuery(this.subQuery, columnAliases.entityAliases)
                .toJSON(queryUtils, fieldUtils, relationManager);
        return jsonRelation;
    }
    getRootRelationJson(jsonRelation, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        jsonRelation = super.getJoinRelationJson(jsonRelation, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        jsonRelation.rt = JSONRelationType.SUB_QUERY_ROOT;
        jsonRelation.subQuery =
            // Removes circular dependency at code initialization time 
            globalThis.IOC.getSync(globalThis.ENTITY_UTILS).getTreeQuery(this.subQuery, columnAliases.entityAliases)
                .toJSON(queryUtils, fieldUtils, relationManager);
        return jsonRelation;
    }
}

/**
 * Created by Papa on 11/29/2016.
 */
class QNullFunction extends QField {
    constructor() {
        super(null, null, null, JSONClauseObjectType.FIELD_FUNCTION);
        this.value = null;
    }
    getInstance() {
        return this.copyFunctions(new QNullFunction());
    }
    toJSON(columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager) {
        return this.operableFunctionToJson(this, columnAliases, forSelectClause, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
    }
}

/**
 * Created by Papa on 12/31/2016.
 */
const bool = function (primitive) {
    if (typeof primitive !== 'boolean') {
        throw new Error(`bool() accepts booleans only.`);
    }
    return new QBooleanFunction(primitive);
};
const date = function (primitive) {
    if (!(primitive instanceof Date)) {
        throw new Error(`date() accepts Dates only.`);
    }
    return new QDateFunction(primitive);
};
const num = function (primitive) {
    if (typeof primitive !== 'number') {
        throw new Error(`num() accepts numbers only.`);
    }
    return new QNumberFunction(primitive);
};
const str = function (primitive) {
    if (typeof primitive !== 'string') {
        throw new Error(`str() accepts strings only.`);
    }
    return new QStringFunction(primitive);
};
function wrapPrimitive(value) {
    switch (typeof value) {
        case 'boolean':
            return bool(value);
        case 'number':
            return num(value);
        case 'string':
            return str(value);
        case 'undefined':
            throw new Error(`Cannot use an 'undefined' value in an operation.`);
    }
    if (value === null) {
        return new QNullFunction();
    }
    if (value instanceof Date) {
        return date(value);
    }
    return value;
}
function getPrimitiveValue(value, dbColumn, rowIndex, datesToNumbers = true) {
    switch (dbColumn.type) {
        case SQLDataType.ANY: {
            assertDataType([
                'boolean', 'number', 'object', 'string'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.BOOLEAN: {
            assertDataType([
                'boolean'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.DATE: {
            assertDataType([
                'number', 'object'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.JSON: {
            assertDataType([
                'object'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.NUMBER: {
            assertDataType([
                'number'
            ], dbColumn, rowIndex, value);
            break;
        }
        case SQLDataType.STRING: {
            assertDataType([
                'string'
            ], dbColumn, rowIndex, value);
            break;
        }
        default:
            throw new Error('Unexpected SQLDataType: ' + dbColumn.type);
    }
    switch (typeof value) {
        case 'boolean':
            return value ? 1 : 0;
        case 'number':
        case 'string':
            // FIXME: prevent SQL injection
            return value;
        case 'object': {
            if (value === null) {
                return value;
            }
            if (value instanceof Date) {
                if (dbColumn.type !== SQLDataType.DATE) {
                    throw new Error(`Unexpected Date object for row: ${rowIndex + 1}, column: ${getColumnName(dbColumn)}`);
                }
                return datesToNumbers ? value.getTime() : value;
            }
            else {
                if (dbColumn.type !== SQLDataType.JSON) {
                    throw new Error(`Unexpected Json object for row: ${rowIndex + 1}, column: ${getColumnName(dbColumn)}`);
                }
                return JSON.stringify(value);
            }
        }
        case 'undefined':
            throw new Error(`Cannot use an 'undefined' value in an operation.`);
        default:
            throw new Error(`Unexpected object in operation.`);
    }
}
function assertDataType(typesOfData, dbColumn, rowIndex, value) {
    if (typesOfData.indexOf(typeof value) < -1) {
        const expectedDataTypes = typesOfData.join(', ');
        throw new Error(`Unexpected typeof value for row: ${rowIndex + 1}, column: ${getColumnName(dbColumn)}.  Expecting: ${expectedDataTypes}`);
    }
}
function getColumnName(dbColumn) {
    return dbColumn.name
        ? dbColumn.name
        : dbColumn.propertyColumns[0].property.name;
}

function getSqlFunctionCall(sqlFunction, parameters) {
    if (parameters) {
        parameters = parameters.map((parameter) => {
            switch (typeof parameter) {
                case 'boolean':
                    return bool(parameter);
                case 'number':
                    return num(parameter);
                case 'string':
                    return str(parameter);
                case 'undefined':
                    throw new Error(`'undefined' cannot be used as a function parameter`);
            }
            if (parameter instanceof Date) {
                return date(parameter);
            }
            return parameter;
        });
    }
    return {
        ft: sqlFunction,
        p: parameters
    };
}
const ABS = function (numeric) {
    if (numeric instanceof QNumberField) {
        return numeric.applySqlFunction(getSqlFunctionCall(SqlFunction.AVG));
    }
    else {
        return new QNumberFunction(numeric).applySqlFunction(getSqlFunctionCall(SqlFunction.ABS));
    }
};
const AVG = function (numeric) {
    if (numeric instanceof QNumberField) {
        return numeric.applySqlFunction(getSqlFunctionCall(SqlFunction.AVG));
    }
    else {
        return new QNumberFunction(numeric).applySqlFunction(getSqlFunctionCall(SqlFunction.AVG));
    }
};
function getFunctionObject(value) {
    switch (typeof value) {
        case 'boolean':
            return new QBooleanFunction(value);
        case 'number':
            return new QNumberFunction(value);
        case 'string':
            return new QStringFunction(value);
    }
    if (value instanceof Date) {
        return new QDateFunction(value);
    }
    let selectClause = value.SELECT;
    if (selectClause instanceof QDistinctFunction) {
        selectClause = selectClause.getSelectClause();
    }
    if (selectClause instanceof QBooleanField) {
        return new QBooleanFunction(value);
    }
    else if (selectClause instanceof QDateField) {
        return new QDateFunction(value);
    }
    else if (selectClause instanceof QNumberField) {
        return new QNumberFunction(value);
    }
    else if (selectClause instanceof QStringField) {
        return new QStringFunction(value);
    }
    throw new Error(`Function rValue must be a primitive, Date, Field or Field query`);
}
const COUNT = function (value) {
    if (value instanceof QOperableField) {
        return value.applySqlFunction(getSqlFunctionCall(SqlFunction.COUNT));
    }
    else {
        return getFunctionObject(value)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.COUNT));
    }
};
const MAX = function (value) {
    if (value instanceof QOperableField) {
        return value.applySqlFunction(getSqlFunctionCall(SqlFunction.MAX));
    }
    else {
        return getFunctionObject(value)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MAX));
    }
};
const MIN = function (value) {
    if (value instanceof QOperableField) {
        return value.applySqlFunction(getSqlFunctionCall(SqlFunction.MIN));
    }
    else {
        return getFunctionObject(value)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MIN));
    }
};
const SUM = function (numeric) {
    if (numeric instanceof QNumberField) {
        return numeric.applySqlFunction(getSqlFunctionCall(SqlFunction.SUM));
    }
    else {
        return new QNumberFunction(numeric)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.SUM));
    }
};
const PLUS = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.PLUS, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.PLUS, [numeric2]));
    }
};
const UCASE = function (stringValue) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.UCASE));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.UCASE));
    }
};
const LCASE = function (stringValue) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.LCASE));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.LCASE));
    }
};
const MID = function (stringValue, start, length) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.MID, [start, length]));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MID, [start, length]));
    }
};
const LEN = function (stringValue) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.LEN));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.LEN));
    }
};
const ROUND = function (numeric, digits = 0) {
    if (numeric instanceof QNumberField) {
        return numeric.applySqlFunction(getSqlFunctionCall(SqlFunction.ROUND, [digits]));
    }
    else {
        return new QNumberFunction(numeric)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.ROUND, [digits]));
    }
};
const NOW = function () {
    return new QDateFunction(null)
        .applySqlFunction(getSqlFunctionCall(SqlFunction.NOW));
};
const FORMAT = function (format, ...formatParameters) {
    if (format instanceof QStringField) {
        return format.applySqlFunction(getSqlFunctionCall(SqlFunction.FORMAT, formatParameters));
    }
    else {
        return new QStringFunction(format)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.FORMAT, formatParameters));
    }
};
const REPLACE = function (stringValue, toReplace, replaceWith) {
    if (stringValue instanceof QStringField) {
        return stringValue.applySqlFunction(getSqlFunctionCall(SqlFunction.REPLACE, [toReplace, replaceWith]));
    }
    else {
        return new QStringFunction(stringValue)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.REPLACE, [toReplace, replaceWith]));
    }
};
const TRIM = function (stringField) {
    if (stringField instanceof QStringField) {
        return stringField.applySqlFunction(getSqlFunctionCall(SqlFunction.TRIM));
    }
    else {
        return new QStringFunction(stringField)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.TRIM));
    }
};
class StandAloneFunction {
}
const DISTINCT = function (selectClause) {
    let distinctFunction = new QDistinctFunction(selectClause);
    distinctFunction.applySqlFunction(getSqlFunctionCall(SqlFunction.DISTINCT));
    return distinctFunction;
};
class QDistinctFunction extends StandAloneFunction {
    constructor(selectClause) {
        super();
        this.selectClause = selectClause;
        this.__appliedFunctions__ = [];
    }
    static getSelect(distinct) {
        return distinct.__appliedFunctions__[0].p[0];
    }
    applySqlFunction(sqlFunctionCall) {
        this.__appliedFunctions__.push(sqlFunctionCall);
        return this;
    }
    getSelectClause() {
        return this.selectClause;
    }
    toJSON(parsedSelectClause) {
        if (this.__appliedFunctions__.length != 1) {
            throw new Error(`Not expecting and parent or child functions on "distinct"`);
        }
        if (!this.selectClause) {
            throw new Error(`SELECT clause is missing in "distinct" function.`);
        }
        let appliedFunctions = [
            getSqlFunctionCall(SqlFunction.DISTINCT)
        ];
        return {
            appliedFunctions: appliedFunctions,
            dt: null,
            fa: null,
            ot: JSONClauseObjectType.DISTINCT_FUNCTION,
            v: parsedSelectClause
        };
    }
}
const EXISTS = function (rawQuery) {
    let selectClause = rawQuery.SELECT;
    if (!selectClause) {
        throw new Error(`Sub-Query must have SELECT clause defined to be used in EXITS function`);
    }
    let existsFunction = new QExistsFunction(rawQuery);
    return existsFunction.applySqlFunction(getSqlFunctionCall(SqlFunction.EXISTS));
};
class QExistsFunction extends StandAloneFunction {
    constructor(subQuery) {
        super();
        this.subQuery = subQuery;
        this.__appliedFunctions__ = [];
        this.operator = SqlOperator.EXISTS;
        this.o = SqlOperator.EXISTS;
        this.category = OperationCategory.FUNCTION;
        this.c = OperationCategory.FUNCTION;
    }
    applySqlFunction(sqlFunctionCall) {
        this.__appliedFunctions__.push(sqlFunctionCall);
        return this;
    }
    getQuery() {
        return this.subQuery;
    }
    toJSON(parsedQuery) {
        if (this.__appliedFunctions__.length != 1) {
            throw new Error(`Not expecting and parent or child functions on "exists"`);
        }
        if (!this.subQuery) {
            throw new Error(`Subquery is not defined in "exists" function.`);
        }
        let appliedFunctions = [
            getSqlFunctionCall(SqlFunction.EXISTS)
        ];
        return {
            c: this.category,
            ob: {
                appliedFunctions: appliedFunctions,
                dt: null,
                ot: JSONClauseObjectType.EXISTS_FUNCTION,
                v: parsedQuery
            },
            o: this.operator
        };
    }
}
// Algebra Operators
const DIVIDE = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.DIVIDE, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.DIVIDE, [numeric2]));
    }
};
const SUBTRACT = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.MINUS, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MINUS, [numeric2]));
    }
};
const MODULUS = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.MODULUS, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MODULUS, [numeric2]));
    }
};
const MULTIPLY = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.MULTIPLY, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.MULTIPLY, [numeric2]));
    }
};
const ADD = function (numeric1, numeric2) {
    if (numeric1 instanceof QNumberField) {
        return numeric1.applySqlFunction(getSqlFunctionCall(SqlFunction.PLUS, [numeric2]));
    }
    else {
        return new QNumberFunction(numeric1)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.PLUS, [numeric2]));
    }
};
const CONCAT = function (//
...fragments) {
    if (fragments.length > 2) {
        throw new Error(`Less than two operands passed to 'concat' function.`);
    }
    let firstFragment = fragments[0];
    let restOfFragments = fragments.slice(1);
    if (firstFragment instanceof QStringField) {
        return firstFragment.applySqlFunction(getSqlFunctionCall(SqlFunction.CONCATENATE, restOfFragments));
    }
    else {
        return new QStringFunction(firstFragment)
            .applySqlFunction(getSqlFunctionCall(SqlFunction.CONCATENATE, restOfFragments));
    }
};
/**
 * A
 * UNION
 * B
 */
const UNION = function (...rawQueries) {
    throw new Error('not implemented');
};
/**
 * A
 * UNION ALL
 * B
 */
const UNION_ALL = function (...rawQueries) {
    throw new Error('not implemented');
};
/**
 * A
 * INTERSECT
 * B
 */
const INTERSECT = function (...rawQueries) {
    throw new Error('not implemented');
};
/**
 * A
 * MINUS
 * B
 */
const EXCEPT = function (...rawQueries) {
    throw new Error('not implemented');
};
/**
 * A
 * MINUS
 * B
 */
const MINUS = EXCEPT;

/**
 * Created by Papa on 10/27/2016.
 */
class AbstractQuery {
    constructor(entityAliases = new EntityAliases(), columnAliases = entityAliases.getNewFieldColumnAliases(), trackedRepoGUIDSet = new Set(), trackedRepoLocalIdSet = new Set()) {
        this.entityAliases = entityAliases;
        this.columnAliases = columnAliases;
        this.trackedRepoGUIDSet = trackedRepoGUIDSet;
        this.trackedRepoLocalIdSet = trackedRepoLocalIdSet;
        this.isEntityQuery = false;
    }
    getParameters( //
    ) {
        return this.entityAliases.getParams().getParameters();
    }
    getNonEntityQuery(rawQuery, jsonQuery, createSelectCallback, queryUtils, fieldUtils, relationManager) {
        let from = this.fromClauseToJSON(rawQuery.FROM, queryUtils, fieldUtils, relationManager);
        jsonQuery.F = from;
        if (createSelectCallback) {
            createSelectCallback(jsonQuery);
        }
        jsonQuery.W = queryUtils.whereClauseToJSON(rawQuery.WHERE, this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet);
        jsonQuery.GB = this.groupByClauseToJSON(rawQuery.GROUP_BY);
        jsonQuery.H = queryUtils.whereClauseToJSON(rawQuery.HAVING, this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet);
        jsonQuery.OB = this.orderByClauseToJSON(rawQuery.ORDER_BY);
        jsonQuery.L = rawQuery.LIMIT;
        jsonQuery.O = rawQuery.OFFSET;
        return jsonQuery;
    }
    fromClauseToJSON(fromClause, queryUtils, fieldUtils, relationManager) {
        if (!fromClause) {
            if (this.isEntityQuery) {
                return [];
            }
            else {
                throw new Error('From clause must be present in a non-Entity based query.');
            }
        }
        return fromClause.map((fromEntity) => {
            if (!(IOC.getSync(ENTITY_UTILS).isQEntity(fromEntity))) {
                throw new Error(`FROM clause can contain only Views or Entities.`);
            }
            if (this.isEntityQuery) {
                if (IOC.getSync(ENTITY_UTILS).isQTree(fromEntity)) {
                    throw new Error(`Entity FROM clauses can contain only Entities.`);
                }
            }
            return fromEntity.__driver__
                .getRelationJson(this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        });
    }
    groupByClauseToJSON(groupBy) {
        if (!groupBy || !groupBy.length) {
            return null;
        }
        return groupBy.map((field) => {
            if (!this.columnAliases.hasAliasFor(field)) {
                throw new Error(`Field used in group by clause is not present in SELECT clause`);
            }
            return {
                fa: this.columnAliases.getExistingAlias(field)
            };
        });
    }
    orderByClauseToJSON(orderBy) {
        if (!orderBy || !orderBy.length) {
            return null;
        }
        return orderBy.map((field) => {
            return field.toJSON(this.columnAliases);
        });
    }
}

/**
 * Created by Papa on 11/17/2016.
 */
// FIXME: add support for a full blown INSERT VALUES, with expression support for VALUES
class AbstractInsertValues extends AbstractQuery {
    constructor(rawInsertValues, columnIndexes, entityAliases = new EntityAliases()) {
        super(entityAliases, entityAliases.getNewFieldColumnAliases());
        this.rawInsertValues = rawInsertValues;
        this.columnIndexes = columnIndexes;
    }
    validateColumn(dbColumn, dbEntity, columnName) {
        if (!dbColumn) {
            throw new Error(`
		Could not find column ${columnName} in entity: ${dbEntity.name}
				(table: ${dbEntity.tableConfig.name})
						`);
        }
        if (dbColumn.entity.applicationVersion.application.index !==
            dbEntity.applicationVersion.application.index
            || dbColumn.entity.index !== dbEntity.index) {
            const columnApplication = dbColumn.entity.applicationVersion.application;
            const entityApplication = dbEntity.applicationVersion.application;
            throw new Error(`Unexpected entity for column ${dbColumn.name}.
			Expecting:
				Domain: ${entityApplication.domain.name}
				Application: ${entityApplication.name}
				Entity: ${dbEntity.name}
			Found:
				Domain: ${columnApplication.domain.name}
				Application: ${columnApplication.name}
				Entity: ${dbColumn.entity.name}`);
        }
    }
    valuesToJSON(valueSets, dbColumns, queryUtils, fieldUtils, relationManager) {
        // let currentValueIndex = -1;
        // this.values           = [];
        return valueSets.map((valueSet, rowIndex) => {
            return valueSet.map((value, columnIndex) => {
                if (value === undefined) {
                    throw new Error(`Cannot use 'undefined' in VALUES clause.`);
                }
                if (!(value instanceof QField)) {
                    return getPrimitiveValue(value, dbColumns[columnIndex], rowIndex);
                    // this.values.push(getPrimitiveValue(value));
                    // return ++currentValueIndex;
                }
                else {
                    return value.toJSON(this.columnAliases, false, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
                }
            });
        });
    }
}

class AbstractUpdate extends AbstractQuery {
    constructor(rawUpdate, entityAliases = new EntityAliases()) {
        super(entityAliases, entityAliases.getNewFieldColumnAliases());
        this.rawUpdate = rawUpdate;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        return {
            U: this.rawUpdate.UPDATE
                .__driver__.getRelationJson(this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager),
            S: this.setToJSON(this.rawUpdate.SET, queryUtils, fieldUtils, relationManager),
            W: queryUtils.whereClauseToJSON(this.rawUpdate.WHERE, this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet)
        };
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
class Delete extends AbstractQuery {
    constructor(rawDelete, entityAliases = new EntityAliases()) {
        super(entityAliases, entityAliases.getNewFieldColumnAliases());
        this.rawDelete = rawDelete;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        return {
            DF: this.rawDelete.DELETE_FROM
                .__driver__.getRelationJson(this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager),
            W: queryUtils.whereClauseToJSON(this.rawDelete.WHERE, this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet)
        };
    }
}

/**
 * Created by Papa on 10/24/2016.
 */
const NON_ENTITY_SELECT_ERROR_MESSAGE = `Unsupported entry in Non-Entity SELECT clause, must be a(n): Entity Field | ManyToOne Relation | primitive wrapped by "bool","date","num","str" | query wrapped by "field"`;
class DistinguishableQuery extends AbstractQuery {
    constructor(entityAliases = new EntityAliases(), trackedRepoGUIDSet, trackedRepoLidSet) {
        super(entityAliases, entityAliases.getNewFieldColumnAliases(), trackedRepoGUIDSet, trackedRepoLidSet);
        this.isHierarchicalEntityQuery = false;
    }
    selectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager) {
        if (rawSelect instanceof QDistinctFunction) {
            if (this.isHierarchicalEntityQuery) {
                throw new Error(`Distinct cannot be used in SELECT of Hierarchical/Bridged Entity queries.`);
            }
            let rawInnerSelect = rawSelect.getSelectClause();
            let innerSelect = this.nonDistinctSelectClauseToJSON(rawInnerSelect, queryUtils, fieldUtils, relationManager);
            return rawSelect.toJSON(innerSelect);
        }
        else {
            return this.nonDistinctSelectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager);
        }
    }
}

/**
 * Created by Papa on 10/24/2016.
 */
const FIELD_IN_SELECT_CLAUSE_ERROR_MESSAGE = `Entity SELECT clauses can only contain fields assigned: null | undefined | boolean | Date | number | string | Relation SELECT`;
/**
 * A query whose SELECT facade is a collection of properties.
 */
class MappableQuery extends DistinguishableQuery {
    nonDistinctSelectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager) {
        let select = {};
        for (let property in rawSelect) {
            let value = rawSelect[property];
            if (value instanceof QField) {
                if (this.isEntityQuery) {
                    throw new Error(FIELD_IN_SELECT_CLAUSE_ERROR_MESSAGE);
                }
                // The same value may appear in the SELECT clause more than once.
                // In that case the last one will set the alias for all of them.
                // Because the alias only matters for GROUP_BY and ORDER_BY
                // that is OK.
                select[property] = value.toJSON(this.columnAliases, true, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
            }
            else if (value instanceof QOneToManyRelation
                || value instanceof QAirEntityOneToManyRelation) {
                throw new Error(`@OneToMany relation objects can cannot be used in SELECT clauses`);
            } // Must be a primitive
            else {
                let isChildObject = false;
                try {
                    // Must be an entity query here
                    switch (typeof value) {
                        case 'boolean':
                        case 'number':
                        case 'string':
                        case 'undefined':
                            continue;
                        case 'object':
                            if (value instanceof Date) {
                            }
                            else if (value === null) {
                            }
                            else {
                                isChildObject = true;
                                select[property] = this.nonDistinctSelectClauseToJSON(value, queryUtils, fieldUtils, relationManager);
                            }
                    }
                }
                finally {
                    if (!isChildObject && !this.isEntityQuery) {
                        throw new Error(NON_ENTITY_SELECT_ERROR_MESSAGE);
                    }
                }
            }
        }
        return select;
    }
}

/**
 * Created by Papa on 10/24/2016.
 */
class EntityQuery extends MappableQuery {
    constructor(rawQuery, trackedRepoGUIDSet) {
        super(new EntityAliases(), trackedRepoGUIDSet);
        this.rawQuery = rawQuery;
        this.isEntityQuery = true;
        this.isHierarchicalEntityQuery = true;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        return {
            S: this.selectClauseToJSON(this.rawQuery.SELECT, queryUtils, fieldUtils, relationManager),
            F: this.fromClauseToJSON(this.rawQuery.FROM, queryUtils, fieldUtils, relationManager),
            forUpdate: this.rawQuery.FOR_UPDATE,
            W: queryUtils.whereClauseToJSON(this.rawQuery.WHERE, this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet),
            OB: this.orderByClauseToJSON(this.rawQuery.ORDER_BY)
        };
    }
    nonDistinctSelectClauseToJSON(rawSelect) {
        for (let field in rawSelect) {
            let value = rawSelect[field];
            if (value instanceof QField) {
                throw new Error(`Field References cannot be used in Entity Queries`);
            }
            else if (value instanceof Object && !(value instanceof Date)) {
                this.nonDistinctSelectClauseToJSON(value);
            }
        }
        return rawSelect;
    }
    orderByClauseToJSON(orderBy) {
        if (!orderBy || !orderBy.length) {
            return null;
        }
        return orderBy.map((field) => {
            return field.toEntityJSON();
        });
    }
}
class LimitedEntityQuery extends EntityQuery {
    constructor(rawQuery) {
        super(rawQuery);
        this.rawQuery = rawQuery;
        this.isHierarchicalEntityQuery = false;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        let limitedJsonEntity = super.toJSON(queryUtils, fieldUtils, relationManager);
        limitedJsonEntity.L = this.rawQuery.LIMIT;
        limitedJsonEntity.O = this.rawQuery.OFFSET;
        return limitedJsonEntity;
    }
}

/**
 * Created by Papa on 10/24/2016.
 */
class FieldQuery extends DistinguishableQuery {
    // private qEntityMap: {[entityName: string]: QEntity<any>},
    //	private entitiesRelationPropertyMap: {[entityName: string]: {[propertyName: string]:
    // EntityRelationRecord}},
    //		private entitiesPropertyTypeMap: {[entityName: string]: {[propertyName: string]:
    // boolean}}
    constructor(rawQuery, entityAliases = new EntityAliases(), trackedRepoGUIDSet, trackedRepoLocalIdSet) {
        super(entityAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet);
        this.rawQuery = rawQuery;
    }
    nonDistinctSelectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager) {
        if (!(this.rawQuery.SELECT instanceof QField)) {
            throw new Error(NON_ENTITY_SELECT_ERROR_MESSAGE);
        }
        this.columnAliases.entityAliases.getNextAlias(this.rawQuery.SELECT.q.__driver__.getRootJoinEntity());
        const jsonClauseField = this.rawQuery.SELECT.toJSON(this.columnAliases, true, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        return jsonClauseField;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        let select = this.selectClauseToJSON(this.rawQuery.SELECT, queryUtils, fieldUtils, relationManager);
        let jsonFieldQuery = {
            S: select,
            forUpdate: this.rawQuery.FOR_UPDATE,
            ot: JSONClauseObjectType.FIELD_QUERY,
            dt: this.getClauseDataType()
        };
        return this.getNonEntityQuery(this.rawQuery, jsonFieldQuery, null, queryUtils, fieldUtils, relationManager);
    }
    getClauseDataType() {
        let selectField = this.rawQuery.SELECT;
        if (selectField instanceof QDistinctFunction) {
            selectField = selectField.getSelectClause();
        }
        if (selectField instanceof QBooleanField) {
            return SQLDataType.BOOLEAN;
        }
        else if (selectField instanceof QDateField) {
            return SQLDataType.DATE;
        }
        else if (selectField instanceof QNumberField) {
            return SQLDataType.NUMBER;
        }
        else if (selectField instanceof QStringField) {
            return SQLDataType.STRING;
        }
        else if (selectField instanceof QUntypedField) {
            return SQLDataType.ANY;
        }
        else {
            throw new Error(`Unsupported type of SELECT field in Field Query`);
        }
    }
}

// FIXME: add support for a full blown INSERT VALUES, with expression support for VALUES
class InsertColumnValues extends AbstractInsertValues {
    toJSON(queryUtils, fieldUtils, relationManager) {
        const entityDriver = this.rawInsertValues.INSERT_INTO.__driver__;
        const insertInto = entityDriver.getRelationJson(this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        const columnMap = entityDriver.dbEntity.columnMap;
        const dbColumns = [];
        const columnIndexes = this.columnIndexes ? this.columnIndexes : this.rawInsertValues.columns.map((columnName) => {
            const dbColumn = columnMap[columnName];
            this.validateColumn(dbColumn, entityDriver.dbEntity, columnName);
            dbColumns.push(dbColumn);
            return dbColumn.index;
        });
        return {
            II: insertInto,
            C: columnIndexes,
            V: this.valuesToJSON(this.rawInsertValues.VALUES, dbColumns, queryUtils, fieldUtils, relationManager)
        };
    }
}

/**
 * Created by Papa on 11/17/2016.
 */
// FIXME: add support for a full blown INSERT VALUES, with expression support for VALUES
class InsertValues extends AbstractInsertValues {
    toJSON(queryUtils, fieldUtils, relationManager) {
        const driver = this.rawInsertValues.INSERT_INTO
            .__driver__;
        const insertInto = driver.getRelationJson(this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        const dbColumns = [];
        let columnIndexes;
        if (this.columnIndexes) {
            columnIndexes = this.columnIndexes;
            for (let i = 0; i < columnIndexes.length; i++) {
                const dbColumn = driver.dbEntity.columns[columnIndexes[i]];
                this.validateColumn(dbColumn, driver.dbEntity);
                dbColumns.push(dbColumn);
            }
        }
        else {
            columnIndexes = this.rawInsertValues.columns.map(column => {
                const dbColumn = column.dbColumn;
                this.validateColumn(dbColumn, driver.dbEntity);
                dbColumns.push(dbColumn);
                return dbColumn.index;
            });
        }
        return {
            II: insertInto,
            C: columnIndexes,
            V: this.valuesToJSON(this.rawInsertValues.VALUES, dbColumns, queryUtils, fieldUtils, relationManager)
        };
    }
}

/**
 * Created by Papa on 10/23/2016.
 */
class SheetQuery extends DistinguishableQuery {
    constructor(rawQuery, trackedRepoGUIDSet, trackedRepoLocalIdSet) {
        super(new EntityAliases(), trackedRepoGUIDSet, trackedRepoLocalIdSet);
        this.rawQuery = rawQuery;
    }
    nonDistinctSelectClauseToJSON(rawSelect, queryUtils, fieldUtils, relationManager) {
        if (!(rawSelect instanceof Array)) {
            throw new Error(`Flat Queries an array of fields in SELECT clause.`);
        }
        return rawSelect.map((selectField) => {
            if (!(selectField instanceof QField)) {
                throw new Error(NON_ENTITY_SELECT_ERROR_MESSAGE);
            }
            this.columnAliases.entityAliases.getNextAlias(selectField.q.__driver__.getRootJoinEntity());
            const jsonClauseField = selectField.toJSON(this.columnAliases, true, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
            return jsonClauseField;
        });
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        let select = this.selectClauseToJSON(this.rawQuery.SELECT, queryUtils, fieldUtils, relationManager);
        let jsonFieldQuery = {
            S: select,
            forUpdate: this.rawQuery.FOR_UPDATE
        };
        return this.getNonEntityQuery(this.rawQuery, jsonFieldQuery, null, queryUtils, fieldUtils, relationManager);
    }
}

class TreeQuery extends MappableQuery {
    constructor(rawQuery, entityAliases = new EntityAliases(), trackedRepoGUIDSet) {
        super(entityAliases, trackedRepoGUIDSet);
        this.rawQuery = rawQuery;
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        let jsonMappedQuery = this.getNonEntityQuery(this.rawQuery, {}, (jsonQuery) => {
            jsonQuery.S = this.selectClauseToJSON(this.rawQuery.SELECT, queryUtils, fieldUtils, relationManager);
            jsonQuery.forUpdate = this.rawQuery.FOR_UPDATE;
        }, queryUtils, fieldUtils, relationManager);
        return jsonMappedQuery;
    }
}

class UpdateColumns extends AbstractUpdate {
    constructor(rawUpdate) {
        super(rawUpdate);
    }
    setToJSON(set, queryUtils, fieldUtils, relationManager) {
        const setClause = {};
        const dbEntity = this.rawUpdate.UPDATE
            .__driver__.dbEntity;
        const dbColumnMap = dbEntity.columnMap;
        const idDbColumnMap = dbEntity.idColumnMap;
        for (const columnName in set) {
            let value = set[columnName];
            if (value === undefined) {
                delete set[columnName];
                continue;
            }
            if (!dbColumnMap[columnName]) {
                throw new Error(`
	Unknown column: '${columnName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            if (idDbColumnMap[columnName]) {
                throw new Error(`
	Cannot update @Id columns:
	Column: '${columnName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            value = wrapPrimitive(value);
            if (!value.toJSON) {
                throw `Unexpected value ${JSON.stringify(value)} for property ${columnName} of entity ${dbEntity.name}`;
            }
            setClause[columnName] = value.toJSON(this.columnAliases, false, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager);
        }
        return setClause;
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
// FIXME: add support for a full blown UPDATE, with expression support for SET
class UpdateProperties extends AbstractUpdate {
    constructor(rawUpdate, trackedRepoGUIDSet) {
        super(rawUpdate);
    }
    toJSON(queryUtils, fieldUtils, relationManager) {
        return {
            U: this.rawUpdate.UPDATE
                .__driver__.getRelationJson(this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet, queryUtils, fieldUtils, relationManager),
            S: this.setToJSON(this.rawUpdate.SET, queryUtils, fieldUtils, relationManager),
            W: queryUtils.whereClauseToJSON(this.rawUpdate.WHERE, this.columnAliases, this.trackedRepoGUIDSet, this.trackedRepoLocalIdSet)
        };
    }
    setToJSON(rawSet, queryUtils, fieldUtils, relationManager) {
        const jsonSetClause = {};
        const dbEntity = this.rawUpdate.UPDATE.__driver__.dbEntity;
        const dbPropertyMap = dbEntity.propertyMap;
        this.setEntityFragmentsToJSON(rawSet, jsonSetClause, [], dbPropertyMap, [], queryUtils, fieldUtils, relationManager);
        return jsonSetClause;
    }
    setEntityFragmentsToJSON(rawSetFragment, jsonSetClause, dbPropertyChain, dbPropertyMap, childDbRelationChain, queryUtils, fieldUtils, relationManager) {
        const isTopLevelFragment = !dbPropertyMap.length;
        for (const propertyName in rawSetFragment) {
            const dbProperty = dbPropertyMap[propertyName];
            const dbEntity = dbProperty.entity;
            if (!dbProperty) {
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Unknown property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            if (isTopLevelFragment && dbProperty.isId) {
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Cannot update @Id properties:
	Property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            else if (!isTopLevelFragment && !dbProperty.isId) {
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Updated properties of nested entities must be @Id properties:
	Property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}').
				`);
            }
            const childDbPropertyChain = [...dbPropertyChain];
            childDbPropertyChain.push(dbProperty);
            this.setFragmentToJSON(rawSetFragment, jsonSetClause, childDbPropertyChain, propertyName, childDbRelationChain, queryUtils, fieldUtils, relationManager);
        }
    }
    setFragmentToJSON(rawSetFragment, jsonSetClause, dbPropertyChain, propertyName, dbRelationChain, queryUtils, fieldUtils, relationManager) {
        const dbProperty = dbPropertyChain[dbPropertyChain.length - 1];
        const dbEntity = dbProperty.entity;
        let value = rawSetFragment[propertyName];
        if (value === undefined) {
            delete rawSetFragment[propertyName];
            return;
        }
        value = wrapPrimitive(value);
        // If this is not a nested object definition
        if (value.toJSON) {
            if (dbProperty.propertyColumns.length !== 1) {
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Cannot update multi-column property to a single value:
	Property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}')
			has ${dbProperty.propertyColumns.length + 1} columns 
			but is being updates to a single value.
				`);
            }
            else {
                let dbColumn = dbProperty.propertyColumns[0].column;
                if (dbRelationChain.length) {
                    for (let i = dbRelationChain.length - 1; i >= 0; i--) {
                        const currentDbRelation = dbRelationChain[i];
                        const matchingManyRelationColumn = currentDbRelation.manyRelationColumns.filter((manyRelationColumn) => {
                            return manyRelationColumn.manyColumn.index ===
                                dbColumn.index;
                        })[0];
                        dbColumn = matchingManyRelationColumn.oneColumn;
                    }
                }
                if (jsonSetClause[dbColumn.name]) {
                    const firstProperty = dbPropertyChain[0];
                    throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

	Cannot update the same column multiple times in the same statement:
	Property: '${propertyName}' for entity: '${dbEntity.name}'
			(table: '${dbEntity.tableConfig.name}')
	maps to table: ${firstProperty.entity.tableConfig.name}, column: ${dbColumn.name}
		which has already been set in this update statement (above).
				`);
                }
                jsonSetClause[dbColumn.name] = value.toJSON(this.columnAliases, false, queryUtils, fieldUtils, relationManager);
                return;
            }
        }
        // This should be a nested property definition
        else {
            if (typeof value === 'object') {
                const dbRelation = dbProperty.relation[0];
                const childDbRelationChain = [...dbRelationChain];
                childDbRelationChain.push(dbRelation);
                switch (dbRelation.relationType) {
                    case EntityRelationType.MANY_TO_ONE: {
                        this.setEntityFragmentsToJSON(value, jsonSetClause, dbPropertyChain, dbRelation.relationEntity.propertyMap, childDbRelationChain, queryUtils, fieldUtils, relationManager);
                        break;
                    }
                    case EntityRelationType.ONE_TO_MANY:
                        // Not  nested property definition
                        throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

				Cannot update @OneToMany properties:
					Property: '${propertyName}' of entity: '${this.rawUpdate.UPDATE.__driver__.dbEntity.name}
					is a @OneToMany relation and cannot be updated since it is
					assumed to be based on @Id columns (which cannot be updated).'
				`);
                    default:
                        // Not  nested property definition
                        throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

				Undefined relation type: 
					Property: '${propertyName}' of entity: '${this.rawUpdate.UPDATE.__driver__.dbEntity.name}'
					is defined with an unknown type of a relation.  Expecting either
					@ManyToOne(...)
					or
					@OneToMany(...)
				`);
                }
                return;
            }
            else {
                // Not  nested property definition
                throw new Error(`
${this.getPropertyChainDesription(dbPropertyChain)}

				Unexpected value ${JSON.stringify(value)} 
					for property: '${propertyName}' of entity: '${this.rawUpdate.UPDATE.__driver__.dbEntity.name}'
				Expecting a nested property definition.
				`);
            }
        }
    }
    getPropertyChainDesription(dbPropertyChain) {
        const rootDbEntity = dbPropertyChain[0].entity;
        let prefix = '    ';
        let lastPrefix = '';
        let ending = `...
}`;
        let message = `
Updated Entity: ${rootDbEntity.name}, property chain:
{`;
        const maxChainDepth = dbPropertyChain.length;
        for (let i = 0; i < maxChainDepth; i++) {
            let dbProperty = dbPropertyChain[i];
            message += `${prefix}${dbProperty.name}: `;
            if (i + 1 < maxChainDepth) {
                message += `: {\n`;
            }
            else {
                message += 'VALUE';
            }
            ending = prefix + `...
${lastPrefix}}`;
            lastPrefix = prefix;
            prefix += '    ';
        }
        return `${message}
${ending}`;
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function isFunction(value) {
    return typeof value === 'function';
}

function createErrorClass(createImpl) {
    var _super = function (instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
}

var UnsubscriptionError = createErrorClass(function (_super) {
    return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors
            ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
            : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
    };
});

function arrRemove(arr, item) {
    if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
    }
}

var Subscription = (function () {
    function Subscription(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._teardowns = null;
    }
    Subscription.prototype.unsubscribe = function () {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) {
                    try {
                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                            var parent_1 = _parentage_1_1.value;
                            parent_1.remove(this);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                else {
                    _parentage.remove(this);
                }
            }
            var initialTeardown = this.initialTeardown;
            if (isFunction(initialTeardown)) {
                try {
                    initialTeardown();
                }
                catch (e) {
                    errors = e instanceof UnsubscriptionError ? e.errors : [e];
                }
            }
            var _teardowns = this._teardowns;
            if (_teardowns) {
                this._teardowns = null;
                try {
                    for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
                        var teardown_1 = _teardowns_1_1.value;
                        try {
                            execTeardown(teardown_1);
                        }
                        catch (err) {
                            errors = errors !== null && errors !== void 0 ? errors : [];
                            if (err instanceof UnsubscriptionError) {
                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                            }
                            else {
                                errors.push(err);
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return)) _b.call(_teardowns_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (errors) {
                throw new UnsubscriptionError(errors);
            }
        }
    };
    Subscription.prototype.add = function (teardown) {
        var _a;
        if (teardown && teardown !== this) {
            if (this.closed) {
                execTeardown(teardown);
            }
            else {
                if (teardown instanceof Subscription) {
                    if (teardown.closed || teardown._hasParent(this)) {
                        return;
                    }
                    teardown._addParent(this);
                }
                (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
        }
    };
    Subscription.prototype._hasParent = function (parent) {
        var _parentage = this._parentage;
        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
    };
    Subscription.prototype._addParent = function (parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription.prototype._removeParent = function (parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
            this._parentage = null;
        }
        else if (Array.isArray(_parentage)) {
            arrRemove(_parentage, parent);
        }
    };
    Subscription.prototype.remove = function (teardown) {
        var _teardowns = this._teardowns;
        _teardowns && arrRemove(_teardowns, teardown);
        if (teardown instanceof Subscription) {
            teardown._removeParent(this);
        }
    };
    Subscription.EMPTY = (function () {
        var empty = new Subscription();
        empty.closed = true;
        return empty;
    })();
    return Subscription;
}());
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
    return (value instanceof Subscription ||
        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
}
function execTeardown(teardown) {
    if (isFunction(teardown)) {
        teardown();
    }
    else {
        teardown.unsubscribe();
    }
}

var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false,
};

var timeoutProvider = {
    setTimeout: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray([], __read(args)));
    },
    clearTimeout: function (handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined,
};

function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function () {
        {
            throw err;
        }
    });
}

function noop() { }

var context = null;
function errorContext(cb) {
    if (config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
            context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
            context = null;
            if (errorThrown) {
                throw error;
            }
        }
    }
    else {
        cb();
    }
}

var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
            _this.destination = destination;
            if (isSubscription(destination)) {
                destination.add(_this);
            }
        }
        else {
            _this.destination = EMPTY_OBSERVER;
        }
        return _this;
    }
    Subscriber.create = function (next, error, complete) {
        return new SafeSubscriber(next, error, complete);
    };
    Subscriber.prototype.next = function (value) {
        if (this.isStopped) ;
        else {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (this.isStopped) ;
        else {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (this.isStopped) ;
        else {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
        }
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        try {
            this.destination.error(err);
        }
        finally {
            this.unsubscribe();
        }
    };
    Subscriber.prototype._complete = function () {
        try {
            this.destination.complete();
        }
        finally {
            this.unsubscribe();
        }
    };
    return Subscriber;
}(Subscription));
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var next;
        if (isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            (next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete);
            var context_1;
            if (_this && config.useDeprecatedNextContext) {
                context_1 = Object.create(observerOrNext);
                context_1.unsubscribe = function () { return _this.unsubscribe(); };
            }
            else {
                context_1 = observerOrNext;
            }
            next = next === null || next === void 0 ? void 0 : next.bind(context_1);
            error = error === null || error === void 0 ? void 0 : error.bind(context_1);
            complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
        }
        _this.destination = {
            next: next ? wrapForErrorHandling(next) : noop,
            error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler),
            complete: complete ? wrapForErrorHandling(complete) : noop,
        };
        return _this;
    }
    return SafeSubscriber;
}(Subscriber));
function wrapForErrorHandling(handler, instance) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        try {
            handler.apply(void 0, __spreadArray([], __read(args)));
        }
        catch (err) {
            {
                reportUnhandledError(err);
            }
        }
    };
}
function defaultErrorHandler(err) {
    throw err;
}
var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop,
};

var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

function identity(x) {
    return x;
}

function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}

var Observable = (function () {
    function Observable(subscribe) {
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
        errorContext(function () {
            var _a = _this, operator = _a.operator, source = _a.source;
            subscriber.add(operator
                ?
                    operator.call(subscriber, source)
                : source
                    ?
                        _this._subscribe(subscriber)
                    :
                        _this._trySubscribe(subscriber));
        });
        return subscriber;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.error(err);
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable.prototype[observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
}

function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
    return function (source) {
        if (hasLift(source)) {
            return source.lift(function (liftedSource) {
                try {
                    return init(liftedSource, this);
                }
                catch (err) {
                    this.error(err);
                }
            });
        }
        throw new TypeError('Unable to lift unknown Observable type');
    };
}

var OperatorSubscriber = (function (_super) {
    __extends(OperatorSubscriber, _super);
    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this._next = onNext
            ? function (value) {
                try {
                    onNext(value);
                }
                catch (err) {
                    destination.error(err);
                }
            }
            : _super.prototype._next;
        _this._error = onError
            ? function (err) {
                try {
                    onError(err);
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._error;
        _this._complete = onComplete
            ? function () {
                try {
                    onComplete();
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._complete;
        return _this;
    }
    OperatorSubscriber.prototype.unsubscribe = function () {
        var _a;
        var closed = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    };
    return OperatorSubscriber;
}(Subscriber));

var ObjectUnsubscribedError = createErrorClass(function (_super) {
    return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = 'ObjectUnsubscribedError';
        this.message = 'object unsubscribed';
    };
});

var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype._throwIfClosed = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
    };
    Subject.prototype.next = function (value) {
        var _this = this;
        errorContext(function () {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
                var copy = _this.observers.slice();
                try {
                    for (var copy_1 = __values(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {
                        var observer = copy_1_1.value;
                        observer.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return)) _a.call(copy_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    };
    Subject.prototype.error = function (err) {
        var _this = this;
        errorContext(function () {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.hasError = _this.isStopped = true;
                _this.thrownError = err;
                var observers = _this.observers;
                while (observers.length) {
                    observers.shift().error(err);
                }
            }
        });
    };
    Subject.prototype.complete = function () {
        var _this = this;
        errorContext(function () {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.isStopped = true;
                var observers = _this.observers;
                while (observers.length) {
                    observers.shift().complete();
                }
            }
        });
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = this.closed = true;
        this.observers = null;
    };
    Object.defineProperty(Subject.prototype, "observed", {
        get: function () {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
    });
    Subject.prototype._trySubscribe = function (subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject.prototype._subscribe = function (subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
    };
    Subject.prototype._innerSubscribe = function (subscriber) {
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        return hasError || isStopped
            ? EMPTY_SUBSCRIPTION
            : (observers.push(subscriber), new Subscription(function () { return arrRemove(observers, subscriber); }));
    };
    Subject.prototype._checkFinalizedStatuses = function (subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
            subscriber.error(thrownError);
        }
        else if (isStopped) {
            subscriber.complete();
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject.prototype.error = function (err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject.prototype.complete = function () {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject;
}(Subject));

var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: false,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
            throw thrownError;
        }
        this._throwIfClosed();
        return _value;
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, (this._value = value));
    };
    return BehaviorSubject;
}(Subject));

var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

function isInteropObservable(input) {
    return isFunction(input[observable]);
}

function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = getSymbolIterator();

function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    reader = readableStream.getReader();
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, , 9, 10]);
                    _b.label = 2;
                case 2:
                    return [4, __await(reader.read())];
                case 3:
                    _a = _b.sent(), value = _a.value, done = _a.done;
                    if (!done) return [3, 5];
                    return [4, __await(void 0)];
                case 4: return [2, _b.sent()];
                case 5: return [4, __await(value)];
                case 6: return [4, _b.sent()];
                case 7:
                    _b.sent();
                    return [3, 2];
                case 8: return [3, 10];
                case 9:
                    reader.releaseLock();
                    return [7];
                case 10: return [2];
            }
        });
    });
}
function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

function innerFrom(input) {
    if (input instanceof Observable) {
        return input;
    }
    if (input != null) {
        if (isInteropObservable(input)) {
            return fromInteropObservable(input);
        }
        if (isArrayLike(input)) {
            return fromArrayLike(input);
        }
        if (isPromise(input)) {
            return fromPromise(input);
        }
        if (isAsyncIterable(input)) {
            return fromAsyncIterable(input);
        }
        if (isIterable(input)) {
            return fromIterable(input);
        }
        if (isReadableStreamLike(input)) {
            return fromReadableStreamLike(input);
        }
    }
    throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
    return new Observable(function (subscriber) {
        var obs = obj[observable]();
        if (isFunction(obs.subscribe)) {
            return obs.subscribe(subscriber);
        }
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    });
}
function fromArrayLike(array) {
    return new Observable(function (subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    });
}
function fromPromise(promise) {
    return new Observable(function (subscriber) {
        promise
            .then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, reportUnhandledError);
    });
}
function fromIterable(iterable) {
    return new Observable(function (subscriber) {
        var e_1, _a;
        try {
            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                var value = iterable_1_1.value;
                subscriber.next(value);
                if (subscriber.closed) {
                    return;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        subscriber.complete();
    });
}
function fromAsyncIterable(asyncIterable) {
    return new Observable(function (subscriber) {
        process$1(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
    });
}
function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process$1(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function () {
        var value, e_2_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 5, 6, 11]);
                    asyncIterable_1 = __asyncValues(asyncIterable);
                    _b.label = 1;
                case 1: return [4, asyncIterable_1.next()];
                case 2:
                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                    value = asyncIterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return [2];
                    }
                    _b.label = 3;
                case 3: return [3, 1];
                case 4: return [3, 11];
                case 5:
                    e_2_1 = _b.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 11];
                case 6:
                    _b.trys.push([6, , 9, 10]);
                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                    return [4, _a.call(asyncIterable_1)];
                case 7:
                    _b.sent();
                    _b.label = 8;
                case 8: return [3, 10];
                case 9:
                    if (e_2) throw e_2.error;
                    return [7];
                case 10: return [7];
                case 11:
                    subscriber.complete();
                    return [2];
            }
        });
    });
}

function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) { delay = 0; }
    if (repeat === void 0) { repeat = false; }
    var scheduleSubscription = scheduler.schedule(function () {
        work();
        if (repeat) {
            parentSubscription.add(this.schedule(null, delay));
        }
        else {
            this.unsubscribe();
        }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
        return scheduleSubscription;
    }
}

function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return operate(function (source, subscriber) {
        source.subscribe(new OperatorSubscriber(subscriber, function (value) { return executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
    });
}

function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return operate(function (source, subscriber) {
        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
    });
}

function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

function scheduleArray(input, scheduler) {
    return new Observable(function (subscriber) {
        var i = 0;
        return scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
            }
            else {
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    this.schedule();
                }
            }
        });
    });
}

function scheduleIterable(input, scheduler) {
    return new Observable(function (subscriber) {
        var iterator$1;
        executeSchedule(subscriber, scheduler, function () {
            iterator$1 = input[iterator]();
            executeSchedule(subscriber, scheduler, function () {
                var _a;
                var value;
                var done;
                try {
                    (_a = iterator$1.next(), value = _a.value, done = _a.done);
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                }
            }, 0, true);
        });
        return function () { return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return(); };
    });
}

function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable(function (subscriber) {
        executeSchedule(subscriber, scheduler, function () {
            var iterator = input[Symbol.asyncIterator]();
            executeSchedule(subscriber, scheduler, function () {
                iterator.next().then(function (result) {
                    if (result.done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(result.value);
                    }
                });
            }, 0, true);
        });
    });
}

function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable(input)) {
            return scheduleObservable(input, scheduler);
        }
        if (isArrayLike(input)) {
            return scheduleArray(input, scheduler);
        }
        if (isPromise(input)) {
            return schedulePromise(input, scheduler);
        }
        if (isAsyncIterable(input)) {
            return scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable(input)) {
            return scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike(input)) {
            return scheduleReadableStreamLike(input, scheduler);
        }
    }
    throw createInvalidObservableTypeError(input);
}

function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

function map(project, thisArg) {
    return operate(function (source, subscriber) {
        var index = 0;
        source.subscribe(new OperatorSubscriber(subscriber, function (value) {
            subscriber.next(project.call(thisArg, value, index++));
        }));
    });
}

function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === void 0) { keySelector = identity; }
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return operate(function (source, subscriber) {
        var previousKey;
        var first = true;
        source.subscribe(new OperatorSubscriber(subscriber, function (value) {
            var currentKey = keySelector(value);
            if (first || !comparator(previousKey, currentKey)) {
                first = false;
                previousKey = currentKey;
                subscriber.next(value);
            }
        }));
    });
}
function defaultCompare(a, b) {
    return a === b;
}

const airApi = {
    setQApp: function (qApplication) { },
    dS: function (__dbApplication__, dbEntityId) { return true; },
    ddS: function (__dbApplication__, dbEntityId) { return true; }
};
function loadGlobalAirApi() {
    globalThis.airApi = airApi;
}

class AirEntityUtils {
    getCreatedBy(airEntity) {
        return airEntity.actor.userAccount;
    }
    encodeId(idObject) {
        if (!idObject.repository
            || !idObject.repository.GUID
            || !idObject.actor
            || !idObject.actor.GUID
            || !idObject._actorRecordId) {
            return null;
        }
        if (typeof idObject.repository.GUID !== 'string') {
            throw Error(`Type of "repository.GUID" property is not a string.`);
        }
        if (typeof idObject.actor.GUID !== 'string') {
            throw Error(`Type of "actor.GUID" property is not a string.`);
        }
        if (typeof idObject._actorRecordId !== 'number') {
            throw Error(`Type of "_actorRecordId" property is not a number.`);
        }
        return idObject.repository.GUID + '-' + idObject.actor.GUID + '-' + idObject._actorRecordId;
    }
    parseEGUID(idString) {
        const idStringFragments = idString.split('-');
        if (idStringFragments.length !== 11) {
            throw new Error('Invalid Entity Id, expecting ${repository.GUID}-${actor.GUID}-${_actorRecordId}');
        }
        const repositoryGUIDFragments = [];
        for (let i = 0; i < 5; i++) {
            repositoryGUIDFragments.push(idStringFragments[i]);
        }
        const actorGUIDFragments = [];
        for (let i = 5; i < 10; i++) {
            actorGUIDFragments.push(idStringFragments[i]);
        }
        return {
            repository: {
                GUID: repositoryGUIDFragments.join('-')
            },
            actor: {
                GUID: actorGUIDFragments.join('-')
            },
            _actorRecordId: parseInt(idStringFragments[10])
        };
    }
    setId(idString, airEntity) {
        if (!idString) {
            return;
        }
        let airEntityId = this.parseEGUID(idString);
        if (!airEntity.repository) {
            airEntity.repository = {
                GUID: airEntityId.repository.GUID
            };
        }
        else {
            airEntity.repository.GUID = airEntityId.repository.GUID;
        }
        if (!airEntity.actor) {
            airEntity.actor = {
                GUID: airEntityId.repository.GUID
            };
        }
        else {
            airEntity.actor.GUID = airEntityId.actor.GUID;
        }
        airEntity._actorRecordId = airEntityId._actorRecordId;
    }
}

// This library is used in UI/Client bundles and does does not include @airport/direction-indicator
// dependency injection library
if (globalThis.AIR_ENTITY_UTILS) {
    globalThis.AIR_ENTITY_UTILS.setClass(AirEntityUtils);
}

class LookupProxy {
    ensureContext(context) {
        return doEnsureContext(context);
    }
    constructor(dao) {
        this.dao = dao;
    }
    async lookup(rawQuery, queryResultType, search, one, QueryClass, context, mapResults) {
        return await this.dao.lookup.lookup(rawQuery, queryResultType, search, one, QueryClass, context, mapResults);
    }
}
class Lookup {
    ensureContext(context) {
        return doEnsureContext(context);
    }
    async lookup(rawQuery, queryResultType, search, one, QueryClass, context) {
        let query;
        let theRawQuery = this.entityUtils.getRawQuery(rawQuery);
        this.entityUtils.ensureAllQEntitiesInFromClause(theRawQuery);
        if (QueryClass) {
            const rawNonEntityQuery = this.entityUtils.getQuery(theRawQuery);
            query = new QueryClass(rawNonEntityQuery);
        }
        else {
            query = this.entityUtils.getEntityQuery(theRawQuery);
        }
        let queryMethod;
        if (search) {
            if (one) {
                queryMethod = this.queryFacade.searchOne;
            }
            else {
                queryMethod = this.queryFacade.search;
            }
        }
        else {
            if (one) {
                queryMethod = this.queryFacade.findOne;
            }
            else {
                queryMethod = this.queryFacade.find;
            }
        }
        let result = await queryMethod.call(this.queryFacade, query, queryResultType, context);
        if (!one && !result) {
            result = [];
        }
        return result;
    }
}
function doEnsureContext(context) {
    if (!context) {
        context = {};
    }
    if (!context.startedAt) {
        context.startedAt = new Date();
    }
    return context;
}

class EntityLookup extends LookupProxy {
    constructor(dbEntity, dao, mapResults = EntityLookup.mapResults) {
        super(dao);
        this.dbEntity = dbEntity;
        this.mapResults = mapResults;
    }
    setNoCache(ChildClass) {
        return new ChildClass(this.dbEntity, this.dao, this.mapResults);
    }
    async entityLookup(rawEntityQuery, queryResultType, search, one, context) {
        context.dbEntity = this.dbEntity;
        rawEntityQuery = IOC.getSync(ENTITY_UTILS)
            .ensureId(rawEntityQuery);
        const result = await this.lookup(rawEntityQuery, queryResultType, search, one, null, context, this.mapResults);
        if (search) {
            throw new Error(`Search operations are not yet supported`);
        }
        else {
            this.dao.updateCacheManager.saveOriginalValues(result, context.dbEntity);
        }
        return result;
    }
}
EntityLookup.mapResults = false;

/**
 * Created by Papa on 11/12/2016.
 */
class EntityFind extends EntityLookup {
    async graph(rawGraphQuery, context) {
        return await this.find(rawGraphQuery, QueryResultType.ENTITY_GRAPH, context);
    }
    async tree(rawTreeQuery, context) {
        return await this.find(rawTreeQuery, QueryResultType.ENTITY_TREE, context);
    }
    async find(rawEntityQuery, queryResultType, context) {
        return await this.entityLookup(rawEntityQuery, queryResultType, false, false, this.ensureContext(context));
    }
    noCache() {
        return this.setNoCache(EntityFind);
    }
}

/**
 * Created by Papa on 11/12/2016.
 */
class EntityFindOne extends EntityLookup {
    async graph(rawGraphQuery, context) {
        return await this.findOne(rawGraphQuery, QueryResultType.ENTITY_GRAPH, context);
    }
    async tree(rawTreeQuery, context) {
        return await this.findOne(rawTreeQuery, QueryResultType.ENTITY_TREE, context);
    }
    // TODO: return Observable from deep within the framework
    // and detect changes to the underlying data
    async findOne(rawEntityQuery, queryResultType, context) {
        return await this.entityLookup(rawEntityQuery, queryResultType, false, true, this.ensureContext(context));
    }
    noCache() {
        return this.setNoCache(EntityFindOne);
    }
}

/**
 * Created by Papa on 11/12/2016.
 */
class NonEntityFind extends Lookup {
    field(rawFieldQuery, context) {
        return this.find(rawFieldQuery, QueryResultType.FIELD, FieldQuery, context);
    }
    sheet(rawSheetQuery, cursorSize, callback, context) {
        if (cursorSize || callback) {
            throw new Error(`Implement!`);
        }
        return this.find(rawSheetQuery, QueryResultType.SHEET, SheetQuery, context);
    }
    tree(rawTreeQuery, context) {
        return this.find(rawTreeQuery, QueryResultType.TREE, TreeQuery, context);
    }
    find(rawNonEntityQuery, queryResultType, QueryClass, context) {
        return this.lookup(rawNonEntityQuery, queryResultType, false, false, QueryClass, this.ensureContext(context));
    }
}

/**
 * Created by Papa on 11/12/2016.
 */
class NonEntityFindOne extends Lookup {
    field(rawFieldQuery, context) {
        return this.findOne(rawFieldQuery, QueryResultType.FIELD, FieldQuery, context);
    }
    sheet(rawSheetQuery, context) {
        return this.findOne(rawSheetQuery, QueryResultType.SHEET, SheetQuery, context);
    }
    tree(rawTreeQuery, context) {
        return this.findOne(rawTreeQuery, QueryResultType.TREE, TreeQuery, context);
    }
    findOne(rawNonEntityQuery, queryResultType, QueryClass, context) {
        return this.lookup(rawNonEntityQuery, queryResultType, false, true, QueryClass, this.ensureContext(context));
    }
}

/**
 * Created by Papa on 11/12/2016.
 */
class NonEntitySearch extends Lookup {
    field(rawFieldQuery, context) {
        return from(this.search(rawFieldQuery, QueryResultType.FIELD, FieldQuery, context));
    }
    sheet(rawSheetQuery, context) {
        return from(this.search(rawSheetQuery, QueryResultType.SHEET, SheetQuery, context));
    }
    tree(rawTreeQuery, context) {
        return from(this.search(rawTreeQuery, QueryResultType.TREE, TreeQuery, context));
    }
    search(rawNonEntityQuery, queryResultType, QueryClass, context) {
        return this.lookup(rawNonEntityQuery, queryResultType, true, false, QueryClass, this.ensureContext(context));
    }
}

/**
 * Created by Papa on 11/12/2016.
 */
class NonEntitySearchOne extends Lookup {
    field(rawFieldQuery, context) {
        return from(this.searchOne(rawFieldQuery, QueryResultType.FIELD, FieldQuery, context));
    }
    sheet(rawSheetQuery, context) {
        return from(this.searchOne(rawSheetQuery, QueryResultType.SHEET, SheetQuery, context));
    }
    tree(rawTreeQuery, context) {
        return from(this.searchOne(rawTreeQuery, QueryResultType.TREE, TreeQuery, context));
    }
    searchOne(rawNonEntityQuery, queryResultType, QueryClass, context) {
        return this.lookup(rawNonEntityQuery, queryResultType, true, true, QueryClass, this.ensureContext(context));
    }
}

/**
 * Created by Papa on 12/11/2016.
 */
class EntityDatabaseFacade {
    // search: IEntitySearch<Entity, Array<Entity>, EntitySelect>;
    // searchOne: IEntitySearchOne<Entity, EntitySelect>;
    constructor(dbEntity, Q, dao) {
        this.dbEntity = dbEntity;
        this.Q = Q;
        this.dao = dao;
        this.find = new EntityFind(this.dbEntity, dao);
        this.findOne = new EntityFindOne(this.dbEntity, dao);
        // this.search = new EntitySearch<Entity, Array<Entity>, EntitySelect>(
        //   this.dbEntity, updateCacheManager);
        // this.searchOne = new EntitySearchOne(this.dbEntity, updateCacheManager);
    }
    get FROM() {
        return this.Q[this.dbEntity.name];
    }
    async insertColumnValues(rawInsertColumnValues, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.insertColumnValues(rawInsertColumnValues, ctx);
        });
    }
    async insertValues(rawInsertValues, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.insertValues(rawInsertValues, ctx);
        });
    }
    async insertColumnValuesGenerateIds(rawInsertColumnValues, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.insertColumnValuesGenerateIds(rawInsertColumnValues, ctx);
        });
    }
    async insertValuesGenerateIds(rawInsertValues, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.insertValuesGenerateIds(rawInsertValues, ctx);
        });
    }
    async updateColumnsWhere(rawUpdateColumns, ctx, trackedRepoGUIDSet) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.updateColumnsWhere(rawUpdateColumns, ctx, trackedRepoGUIDSet);
        });
    }
    async updateWhere(rawUpdate, ctx, trackedRepoGUIDSet) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.updateWhere(rawUpdate, ctx, trackedRepoGUIDSet);
        });
    }
    async deleteWhere(rawDelete, ctx, trackedRepoGUIDSet) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.deleteWhere(rawDelete, ctx, trackedRepoGUIDSet);
        });
    }
    async save(entity, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.save(entity, ctx);
        });
    }
    /**
     * @return ISaveResult object with metadata on saved objects
     */
    async saveToDestination(repositoryDestination, entity, ctx) {
        return await this.withDbEntity(ctx, async (databaseFacade, ctx) => {
            return await databaseFacade.saveToDestination(repositoryDestination, entity, ctx);
        });
    }
    async withDbEntity(ctx, callback) {
        if (!ctx) {
            ctx = {};
        }
        if (!ctx.startedAt) {
            ctx.startedAt = new Date();
        }
        const previousEntity = ctx.dbEntity;
        ctx.dbEntity = this.dbEntity;
        try {
            return await callback(this.dao.databaseFacade, ctx);
        }
        finally {
            ctx.dbEntity = previousEntity;
        }
    }
}

class FieldsSelect {
    constructor(dbEntity) {
        this.dbEntity = dbEntity;
    }
    get ids() {
        const propertyNames = this.dbEntity.properties
            .filter(property => property.isId)
            .map(property => property.name);
        return this.getSelect(propertyNames, false);
    }
    get fields() {
        const propertyNames = this.dbEntity.properties
            .filter(property => !property.relation || !property.relation.length)
            .map(property => property.name);
        return this.getSelect(propertyNames, false);
    }
    get manyToOnes() {
        return this.getRelationSelect(EntityRelationType.MANY_TO_ONE);
    }
    get oneToManys() {
        return this.getRelationSelect(EntityRelationType.ONE_TO_MANY);
    }
    getRelationSelect(relationType) {
        const propertyNames = this.dbEntity.properties
            .filter(property => property.relation
            && property.relation.length
            && property.relation[0].relationType === relationType)
            .map(property => property.name);
        return this.getSelect(propertyNames, true);
    }
    getSelect(propertyNames, forRelations) {
        const selectFragment = {};
        for (const propertyName of propertyNames) {
            selectFragment[propertyName] = forRelations ? {} : Y;
        }
        return selectFragment;
    }
}

/**
 * Created by Papa on 8/26/2017.
 */
class Dao {
    static BaseSave(config) {
        return function (target, propertyKey) {
            // No runtime logic required.
        };
    }
    constructor(dbEntityId, Q, internal = false) {
        this.internal = internal;
        const dbEntity = Q.__dbApplication__.currentVersion[0]
            .applicationVersion.entities[dbEntityId];
        // TODO: figure out how to inject EntityDatabaseFacade and dependencies
        this.db = new EntityDatabaseFacade(dbEntity, Q, this);
        this.SELECT = new FieldsSelect(dbEntity);
    }
    mapById(entities) {
        const map = new Map();
        for (const entity of entities) {
            map.set(entity.id, entity);
        }
        return map;
    }
    async count(context) {
        throw new Error(`Not Implemented`);
    }
    exists(entityId, context) {
        throw new Error(`Not Implemented`);
    }
    async findAll(entityIds, context, cacheForUpdate = false) {
        if (entityIds) {
            throw new Error(`Not implemented`);
        }
        return await this.db.find.graph({
            SELECT: {},
            FROM: [this.db.FROM],
        }, context);
    }
    async findAllAsTrees(entityIds, context, cacheForUpdate = false) {
        if (entityIds) {
            throw new Error(`Not implemented`);
        }
        return await this.db.find.tree({
            SELECT: {},
            FROM: [this.db.FROM],
        }, context);
    }
    async findOne(AirEntityId, forUpdate = false, context) {
        if (!this.db.dbEntity.isAirEntity) {
            throw new Error(`Dao.findOne can only be called for Repository Entities.`);
        }
        const idObject = AirEntityId;
        let q;
        return await this.db.findOne.graph({
            SELECT: {
                '*': Y
            },
            FROM: [
                q = this.db.FROM
            ],
            WHERE: q.equals(idObject),
            FOR_UPDATE: forUpdate
        }, context);
    }
    async findIn(airEntityIds, forUpdate, context) {
        if (!this.db.dbEntity.isAirEntity) {
            throw new Error(`Dao.findIn can only be called for Repository Entities.`);
        }
        let q;
        return await this.db.find.graph({
            SELECT: {
                '*': Y
            },
            FROM: [
                q = this.db.FROM
            ],
            WHERE: q.IN(airEntityIds),
            FOR_UPDATE: forUpdate
        }, context);
    }
    async save(entity, context) {
        return await this.db.save(entity, this.ensureContext(context));
    }
    markForDeletion(entityIdInfo, context) {
        if (entityIdInfo instanceof Array) {
            for (const anEntity of entityIdInfo) {
                this.entityStateManager.markForDeletion(anEntity);
            }
        }
        else {
            this.entityStateManager.markForDeletion(entityIdInfo);
        }
    }
    _repositoryId() {
        return {
            actor: {
                _localId: Y
            },
            _actorRecordId: Y,
            ageSuitability: Y,
            repository: {
                _localId: Y
            }
        };
    }
    /**
     * The Promise based API for all Entity 'find' (find many) queries.
     */
    async _find(rawGraphQuery, ctx) {
        return await this.db.find.graph(rawGraphQuery, ctx);
    }
    /**
     * The Promise based API for all Entity 'findOne' that also
     * ensures that the record is unique.  If multiple records
     * are found the ones with older createdAt values are deleted.
     */
    async _findUnique(rawGraphQuery, ctx) {
        const records = await this.db.find.graph(rawGraphQuery, ctx);
        if (!records.length) {
            return null;
        }
        if (records.length > 1) {
            // Remove older agreement records
            records.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
            for (let i = 1; i < records.length; i++) {
                this.markForDeletion(records[i]);
            }
            await this.save(records);
        }
        return records[0];
    }
    /**
     * The Promise based API for all Entity 'findOne' queries.
     */
    async _findOne(rawGraphQuery, ctx) {
        return await this.db.findOne.graph(rawGraphQuery, ctx);
    }
    /**
     * The Observable based API for all Entity 'searchOne' (searchOne many) queries.
     */
    _search(rawGraphQuery, ctx) {
        throw new Error('Not implemented');
    }
    /**
     * The Observable based API for all Entity 'searchOne' queries.
     */
    _searchOne(rawGraphQuery, ctx) {
        throw new Error('Not implemented');
    }
    ensureContext(context) {
        return doEnsureContext(context);
    }
}

class DaoQueryDecorators {
    Graph(callback) {
        return function (target, propertyKey) {
            // No runtime logic required.
        };
    }
    Tree(callback) {
        return function (target, propertyKey) {
            // No runtime logic required.
        };
    }
}

const tarmaqDao = lib('tarmaq-dao');
tarmaqDao.register(Dao, Lookup, NonEntityFind, NonEntityFindOne, NonEntitySearch, NonEntitySearchOne);
const DATABASE_FACADE = tarmaqDao.token('DatabaseFacade');
const QUERY_FACADE = tarmaqDao.token('QueryFacade');
tarmaqDao.setDependencies(Dao, {
    databaseFacade: DATABASE_FACADE,
    entityStateManager: ENTITY_STATE_MANAGER,
    lookup: Lookup,
    updateCacheManager: UPDATE_CACHE_MANAGER
});

function diSet(dbApplication, dbEntityId // ApplicationEntity_LocalId
) {
    if ((!globalThis.inAppMode && !globalThis.SEQ_GEN)
        || !dbApplication) {
        return false;
    }
    const dbEntity = dbApplication.currentVersion[0]
        .applicationVersion.entities[dbEntityId];
    if (globalThis.inAppMode) {
        return !!dbEntity;
    }
    return globalThis.SEQ_GEN.exists(dbEntity);
}
function duoDiSet(dbApplication, dbEntityId) {
    return dbApplication && dbApplication.currentVersion[0]
        .applicationVersion.entities[dbEntityId];
}
loadGlobalAirApi();
globalThis.airApi.dS = diSet;
globalThis.airApi.ddS = duoDiSet;

const Api = function () {
    return function (target, propertyKey, descriptor) {
        // No runtime logic required.
        return null;
    };
};

var ApiObjectKind;
(function (ApiObjectKind) {
    ApiObjectKind["ARRAY"] = "ARRAY";
    ApiObjectKind["BOOLEAN"] = "BOOLEAN";
    ApiObjectKind["BOOLEAN_VALUE"] = "BOOLEAN_VALUE";
    ApiObjectKind["DATE"] = "DATE";
    ApiObjectKind["DB_ENTITY"] = "DB_ENTITY";
    ApiObjectKind["NUMBER"] = "NUMBER";
    ApiObjectKind["NUMBER_VALUE"] = "NUMBER_VALUE";
    ApiObjectKind["OBJECT"] = "OBJECT";
    ApiObjectKind["STRING"] = "STRING";
    ApiObjectKind["STRING_VALUE"] = "STRING_VALUE";
    ApiObjectKind["TYPE_UNION"] = "TYPE_UNION";
})(ApiObjectKind || (ApiObjectKind = {}));

class ApplicationUtils {
    getDbEntity(applicationIndex, tableIndex) {
        return this.airportDatabase.applications[applicationIndex].currentVersion[0]
            .applicationVersion.entities[tableIndex];
    }
    isActorId(columnName) {
        return columnName === this.dictionary.AirEntity.columns.ACTOR_LID;
    }
    isActorRecordId(columnName) {
        return columnName === this.dictionary.AirEntity.columns.ACTOR_RECORD_ID;
    }
    isRepositoryId(columnName) {
        return columnName === this.dictionary.AirEntity.columns.REPOSITORY_LID;
    }
    doCascade(dbRelation, crudOperation) {
        if (dbRelation.relationType !== EntityRelationType.ONE_TO_MANY) {
            return false;
        }
        if (!dbRelation.oneToManyElems) {
            return false;
        }
        switch (crudOperation) {
            case CRUDOperation.CREATE:
            case CRUDOperation.UPDATE:
            case CRUDOperation.DELETE:
                return true;
            default:
                throw new Error(`Unsupported CRUDOperation '${crudOperation}' for cascade check.`);
        }
    }
    getEntityConstructor(dbEntity) {
        const entityConstructor = this.airportDatabase.qApplications[dbEntity.applicationVersion.application.index]
            .__constructors__[dbEntity.name];
        return entityConstructor;
    }
    getNewEntity(dbEntity) {
        const entityConstructor = this.getEntityConstructor(dbEntity);
        if (!entityConstructor) {
            return {};
        }
        return new entityConstructor();
    }
    isIdEmpty(idValue) {
        return !idValue && idValue !== 0;
    }
    isEmpty(value) {
        return this.isIdEmpty(value) && value !== false && value !== '';
    }
    isRelationColumn(dbColumn) {
        return this.isManyRelationColumn(dbColumn)
            || this.isOneRelationColumn(dbColumn);
    }
    isManyRelationColumn(dbColumn) {
        return !!(dbColumn.manyRelationColumns && dbColumn.manyRelationColumns.length);
    }
    isOneRelationColumn(dbColumn) {
        return !!(dbColumn.oneRelationColumns && dbColumn.oneRelationColumns.length);
    }
    getOneSideEntityOfManyRelationColumn(dbColumn) {
        return dbColumn.manyRelationColumns[0].oneColumn.entity;
    }
    getColumnPropertyNameChainsAndValue(dbEntity, dbColumn, entityObject, forIdKey = false, generateNegativeIdsForMissing = true) {
        const columnValuesAndPaths = this.getColumnValuesAndPaths(dbColumn, entityObject, [], forIdKey, generateNegativeIdsForMissing);
        const firstColumnValueAndPath = columnValuesAndPaths[0];
        const propertyNameChains = [firstColumnValueAndPath.path];
        const value = firstColumnValueAndPath.value;
        columnValuesAndPaths.reduce((last, current) => {
            if (!this.utils.valuesEqual(last.value, current.value, true)) {
                throw new Error(`Values differ for ${dbEntity.name}.${dbColumn.name}:
						'${last.path.join('.')}' = ${last.value}
						'${current.path.join('.')}' = ${current.value}`);
            }
            propertyNameChains.push(current.path);
            return current;
        });
        return [propertyNameChains, value];
    }
    addRelationToEntitySelectClause(dbRelation, selectClause, allowDefaults = false) {
        this.forEachColumnTypeOfRelation(dbRelation, (dbColumn, propertyNameChains) => {
            let convertTo = true;
            let propertySelectClause = selectClause;
            const firstPropertyNameChain = propertyNameChains[0];
            firstPropertyNameChain.forEach((propertyNameLink, index) => {
                let propertyObject = propertySelectClause[propertyNameLink];
                if (!propertyObject) {
                    propertyObject = {};
                    this.entityStateManager.markAsStub(propertyObject);
                    propertySelectClause[propertyNameLink] = propertyObject;
                }
                else {
                    if (index < firstPropertyNameChain.length - 1) {
                        if (!(propertyObject instanceof Object) || propertyObject instanceof Date) {
                            throw new Error(`Invalid entry:
								...
								{
									...
									${propertyNameLink}: ${propertyObject}
								}
								in '${dbRelation.property.entity.name}.${dbRelation.property.name}',
								Property must be an Object.`);
                        }
                    }
                    else {
                        if (!allowDefaults && !isY(propertyObject)) {
                            const reason = dbRelation.property.isId
                                ? `'${dbRelation.property.entity.name}.${dbRelation.property.name}' is an @Id property`
                                : `'${dbRelation.property.entity.name}' has no @Id - all properties are treated as @Ids`;
                            throw new Error(`Defaults are not allowed in:
								...
								{
									...
									${propertyNameLink}: ${propertyObject}
								}
								${reason}.`);
                        }
                        convertTo = false;
                    }
                }
                propertySelectClause = propertyObject;
            });
            if (convertTo) {
                convertToY(propertySelectClause);
            }
        });
    }
    forEachColumnOfRelation(dbRelation, entity, callback, failOnNoValue = true) {
        const dbEntity = dbRelation.property.entity;
        for (const dbRelationColumn of dbRelation.manyRelationColumns) {
            const dbColumn = dbRelationColumn.manyColumn;
            const [propertyNameChains, value] = this.getColumnPropertyNameChainsAndValue(dbEntity, dbColumn, entity);
            if (callback(dbColumn, value, propertyNameChains)) {
                return;
            }
        }
    }
    forEachColumnTypeOfRelation(dbRelation, callback) {
        for (const dbRelationColumn of dbRelation.manyRelationColumns) {
            const dbColumn = dbRelationColumn.manyColumn;
            const propertyNameChains = this.getColumnPaths(dbColumn, []);
            if (callback(dbColumn, propertyNameChains)) {
                return;
            }
        }
    }
    getColumnValuesAndPaths(dbColumn, relationObject, breadCrumb, forIdKey = false, generateNegativeIdsForMissing = true
    // noIdValueCallback: {
    // 	(
    // 		relationColumn: DbColumn,
    // 		value: any,
    // 		propertyNameChains: string[][],
    // 	): void;
    // }
    ) {
        if (this.isManyRelationColumn(dbColumn)) {
            let columnValuesAndPaths = [];
            // If a column is part of a relation, it would be on the Many Side
            for (const dbRelationColumn of dbColumn.manyRelationColumns) {
                const dbProperty = dbRelationColumn.manyRelation.property;
                const relationBreadCrumb = [...breadCrumb];
                const propertyName = dbProperty.name;
                relationBreadCrumb.push(propertyName);
                const value = relationObject[propertyName];
                if (!value) {
                    if (forIdKey
                    // && this.handleNoId(dbColumn, dbProperty, relationBreadCrumb, value,
                    // noIdValueCallback)
                    ) {
                        throw new Error(`Cannot retrieve composite Id value, value chain '${relationBreadCrumb.join('.')}' is : ${value}.`);
                        // return null;
                    }
                    columnValuesAndPaths.push({
                        path: relationBreadCrumb,
                        value
                    });
                }
                else {
                    const otherEntityColumn = dbRelationColumn.oneColumn;
                    const relationValuesAndPaths = this.getColumnValuesAndPaths(otherEntityColumn, value, relationBreadCrumb, forIdKey);
                    columnValuesAndPaths = columnValuesAndPaths.concat(relationValuesAndPaths);
                }
            }
            return columnValuesAndPaths;
        }
        else {
            // If a column is not a part of (a) relation(s) then it is associated
            // to only one property
            const dbProperty = dbColumn.propertyColumns[0].property;
            const propertyBreadCrumb = [...breadCrumb];
            const propertyName = dbProperty.name;
            propertyBreadCrumb.push(propertyName);
            let value = relationObject[propertyName];
            if (forIdKey && this.isIdEmpty(value)) {
                if (dbColumn.isGenerated) {
                    if (generateNegativeIdsForMissing) {
                        value = --ApplicationUtils.TEMP_ID;
                    }
                    else {
                        value = null;
                    }
                    relationObject[propertyName] = value;
                }
                else {
                    // if (this.handleNoId(dbColumn, dbProperty, propertyBreadCrumb, value,
                    // noValueCallback)) { return null; }
                    throw new Error(`Cannot retrieve composite Id value, value chain '${propertyBreadCrumb.join('.')}' is : ${value}.`);
                }
            }
            return [{
                    path: propertyBreadCrumb,
                    value
                }];
        }
    }
    getColumnPaths(dbColumn, breadCrumb) {
        let columnValuesAndPaths = [];
        if (this.isManyRelationColumn(dbColumn)) {
            // If a column is part of a relation, it would be on the Many Side
            for (const dbRelationColumn of dbColumn.manyRelationColumns) {
                const dbProperty = dbRelationColumn.manyRelation.property;
                const relationBreadCrumb = [...breadCrumb];
                relationBreadCrumb.push(dbProperty.name);
                const otherEntityColumn = dbRelationColumn.oneColumn;
                const relationValuesAndPaths = this.getColumnPaths(otherEntityColumn, relationBreadCrumb);
                columnValuesAndPaths = columnValuesAndPaths.concat(relationValuesAndPaths);
            }
        }
        else {
            // If a column is not a part of (a) relation(s) then it is associated
            // to only one property
            const dbProperty = dbColumn.propertyColumns[0].property;
            const propertyBreadCrumb = [...breadCrumb];
            propertyBreadCrumb.push(dbProperty.name);
            columnValuesAndPaths.push(propertyBreadCrumb);
        }
        return columnValuesAndPaths;
    }
    handleNoId(dbColumn, dbProperty, propertyNameChains, value, noIdValueCallback) {
        if (noIdValueCallback) {
            if (!noIdValueCallback(dbColumn, value, propertyNameChains)) {
                return true;
            }
        }
        else {
            throw new Error(`Cannot retrieve composite Id value, value chain '${propertyNameChains.join('.')}' is : ${value}.`);
        }
        return false;
    }
}
ApplicationUtils.TEMP_ID = 0;

/**
 * Created by Papa on 6/14/2016.
 */
class EntityUtils {
    getObjectClassName(object) {
        if (typeof object != 'object' || object === null) {
            throw new Error(`Not an object instance`);
        }
        return this.getClassName(object.constructor);
    }
    getClassName(clazz) {
        if (typeof clazz != 'function') {
            throw new Error(`Not a constructor function`);
        }
        let className = clazz['name'];
        // let className = /(\w+)\(/.exec(clazz.toString())[1];
        return className;
    }
    exists(object) {
        return this.utils.objectExists(object);
    }
    /*
     static isBlank(
     object: any
     ) {
     for (let propertyName in object) {
     let property = object[propertyName];
     if (this.exists(property)) {
     if (property instanceof Array) {
     if (property.length > 0) {
     return false;
     }
     } else {
     return false;
     }
     }
     }
     return true;
     }
     */
    isAppliable(object) {
        return object instanceof QOperableField;
    }
    getQuery(query) {
        return this.getRawQuery(query);
    }
    ensureId(rawEntityQuery) {
        let theRawEntityQuery = this.getRawQuery(rawEntityQuery);
        this.ensureIdAtLevel(theRawEntityQuery.SELECT, theRawEntityQuery.FROM[0]);
        return theRawEntityQuery;
    }
    ensureIdAtLevel(selectClauseFragment, qEntity) {
        for (const propertyName in selectClauseFragment) {
            const subFragment = selectClauseFragment[propertyName];
            if (subFragment instanceof Object
                && typeof subFragment.airportSelectField !== 'boolean'
                && !subFragment.__allFields__) {
                let matchingQEntity;
                for (const childQEntity of qEntity.__driver__.childQEntities) {
                    if (childQEntity.__driver__.dbRelation.property.name === propertyName) {
                        matchingQEntity = childQEntity;
                        break;
                    }
                }
                if (matchingQEntity && matchingQEntity.__driver__.dbEntity.isAirEntity) {
                    this.ensureIdAtLevel(subFragment, matchingQEntity);
                }
            }
        }
        if (!qEntity.__driver__.dbEntity.isAirEntity || !selectClauseFragment.id) {
            return;
        }
        let repository = selectClauseFragment.repository;
        if (repository) {
            if (!(repository instanceof Object)) {
                throw new Error(`id queries must include a repository object in the SELECT clause.
It must be an Object with the id property.`);
            }
            repository.GUID = Y;
        }
        let actor = selectClauseFragment.actor;
        if (actor) {
            if (!(actor instanceof Object)) {
                throw new Error(`id queries must include an actor object in the SELECT clause.
It must be an Object with the id property.`);
            }
            actor.GUID = Y;
        }
        selectClauseFragment._actorRecordId = Y;
        this.ensureRepositoryAndActorJoin(qEntity);
    }
    ensureRepositoryAndActorJoin(qEntity) {
        let qActor, qRepository;
        let repositoryJoinFound = false;
        let actorJoinFound = false;
        for (const childQEntity of qEntity.__driver__.childQEntities) {
            const relationEntity = childQEntity.__driver__.dbRelation.relationEntity;
            if (this.dictionary.isActor(relationEntity)) {
                actorJoinFound = true;
                qActor = childQEntity;
            }
            else if (this.dictionary.isRepository(relationEntity)) {
                repositoryJoinFound = true;
                qRepository = childQEntity;
            }
        }
        if (!actorJoinFound) {
            qActor = qEntity.actor.LEFT_JOIN();
        }
        if (!repositoryJoinFound) {
            qRepository = qEntity.repository.LEFT_JOIN();
        }
        return {
            qActor,
            qRepository
        };
    }
    ensureAllQEntitiesInFromClause(rawQuery) {
        const allQEntities = new Set();
        for (let fromEntry of rawQuery.FROM) {
            let qEntity = fromEntry;
            allQEntities.add(qEntity);
        }
        for (let fromEntry of rawQuery.FROM) {
            this.doEnsureAllQEntitiesInFromClause(fromEntry, rawQuery.FROM, allQEntities);
        }
    }
    doEnsureAllQEntitiesInFromClause(parentQEntity, fromClause, allQEntities) {
        if (!parentQEntity.__driver__) {
            return;
        }
        if (!allQEntities.has(parentQEntity)) {
            allQEntities.add(parentQEntity);
            fromClause.push(parentQEntity);
        }
        if (!parentQEntity.__driver__.childQEntities) {
            return;
        }
        for (const childQEntity of parentQEntity.__driver__.childQEntities) {
            this.doEnsureAllQEntitiesInFromClause(childQEntity, fromClause, allQEntities);
        }
    }
    // Removes circular dependency at code initialization time
    getRawQuery(rawQuery) {
        if (rawQuery instanceof Function) {
            return rawQuery();
        }
        else {
            return rawQuery;
        }
    }
    // Removes circular dependency at code initialization time
    getEntityQuery(rawGraphQuery) {
        return new EntityQuery(this.getRawQuery(rawGraphQuery));
    }
    // Removes circular dependency at code initialization time
    getTreeQuery(rawQuery, entityAliases) {
        return new TreeQuery(rawQuery, entityAliases);
    }
    // Removes circular dependency at code initialization time
    isQEntity(qEntity) {
        return qEntity instanceof QEntity;
    }
    // Removes circular dependency at code initialization time
    isQTree(qEntity) {
        return qEntity instanceof QTreeDriver;
    }
    // Removes circular dependency at code initialization time
    getQTree(fromClausePosition, subQuery) {
        return new QTree(fromClausePosition, subQuery);
    }
    // Removes circular dependency at code initialization time
    isQField(qEntity) {
        return qEntity instanceof QField;
    }
}
ENTITY_UTILS.setClass(EntityUtils);

class FieldUtils {
    getFieldQueryJson(fieldSubQuery, entityAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, queryUtils) {
        let subSelectQuery = new FieldQuery(fieldSubQuery, entityAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet);
        return subSelectQuery.toJSON(queryUtils, this, this.relationManager);
    }
}

class QApplicationBuilderUtils {
    setQAppEntities(application, qApplication, allQApps, appliationUtils, relationManager) {
        // const entities = orderEntitiesByIdDependencies(application.currentVersion[0].applicationVersion.entities,
        // application)
        qApplication.__qIdRelationConstructors__ = [];
        qApplication.__qConstructors__ = {};
        // let haveMissingDependencies
        // do {
        // 	haveMissingDependencies = false
        // NOTE: only need to compute the keys of entities for Many-to-One(s)
        // Many-to-Ones must reference the table by primary key in order to
        // guarantee a single record.  Any other type of join may return multiple
        // records and is in fact a Many-to-Many
        application.currentVersion[0].applicationVersion.entities.forEach((
        // entities.forEach((
        entity) => {
            // NOTE: an @Id column is guaranteed to be present in only one property
            for (const idColumn of entity.idColumns) {
                if (idColumn.manyRelationColumns
                    && idColumn.manyRelationColumns.length) {
                    const oneColumn = idColumn.manyRelationColumns[0].oneColumn;
                    const relatedEntity = oneColumn.entity;
                    const relatedQApp = allQApps[relatedEntity.applicationVersion.application.index];
                    if (!relatedQApp) {
                        throw new Error(`QApp not yet initialized for ID relation:
						${entity.name}.${oneColumn.name}
						`);
                    }
                    // const manyColumn = idColumn.manyRelationColumns[0].manyColumn
                    // if (relatedEntity.id === manyColumn.entity.id
                    // 	&& relatedEntity.applicationVersion.application.index
                    // 	=== manyColumn.entity.applicationVersion.application.index) {
                    // 	continue
                    // }
                    // const relatedQEntityConstructor =
                    // qApplication.__qConstructors__[relatedEntity.index] if (!relatedQEntityConstructor)
                    // { throw new Error(`QEntity not yet initialized for ID relation:
                    // ${entity.name}.${manyColumn.name} `) haveMissingDependencies = true }
                }
            }
            const qIdRelationConstructor = this.qEntityUtils.getQEntityIdRelationConstructor(entity);
            qApplication.__qIdRelationConstructors__[entity.index] = qIdRelationConstructor;
            // TODO: compute many-to-many relations
            const qConstructor = this.qEntityUtils.getQEntityConstructor(allQApps);
            qApplication.__qConstructors__[entity.index] = qConstructor;
            if (!Object.getOwnPropertyNames(qApplication)
                .filter(propertyName => propertyName === entity.name).length) {
                Object.defineProperty(qApplication, entity.name, {
                    get: function () {
                        return new this.__qConstructors__[entity.index](entity, appliationUtils, relationManager);
                    }
                });
            }
        });
        // } while (haveMissingDependencies)
    }
    orderApplicationsInOrderOfPrecedence(applications) {
        const appWithDependenciesMap = new Map();
        const appsWithDependencies = applications.map(application => {
            const dependencies = new Set();
            for (const applicationReference of application.currentVersion[0]
                .applicationVersion.references) {
                dependencies.add({
                    index: applicationReference.referencedApplicationVersion.application.index
                });
            }
            const applicationWithDependencies = {
                application,
                dependencies
            };
            appWithDependenciesMap.set(application.index, applicationWithDependencies);
            return applicationWithDependencies;
        });
        for (let application of applications) {
            const appWithDependencies = appWithDependenciesMap.get(application.index);
            for (const dependency of appWithDependencies.dependencies) {
                dependency.appWithDependencies = appWithDependenciesMap.get(dependency.index);
            }
        }
        // Regular sort does not work since dependency tries can be complex and there is no way to 
        appsWithDependencies.sort((orderedApplication1, orderedApplication2) => {
            if (this.applicationDependsOn(orderedApplication1, orderedApplication2.application.index)) {
                return 1;
            }
            else if (this.applicationDependsOn(orderedApplication2, orderedApplication1.application.index)) {
                return -1;
            }
            return 0;
        });
        return appsWithDependencies.map(applicationWithDeps => applicationWithDeps.application);
    }
    applicationDependsOn(dependantApplication, dependsOnApplication_Index) {
        for (const dependency of dependantApplication.dependencies) {
            if (dependency.index == dependsOnApplication_Index) {
                return true;
            }
            if (dependency.appWithDependencies.dependencies.size) {
                if (this.applicationDependsOn(dependency.appWithDependencies, dependsOnApplication_Index)) {
                    return true;
                }
            }
        }
        return false;
    }
}

class QMetadataUtils {
    getAllColumns(qEntity) {
        return qEntity.__driver__.allColumns;
    }
    getAllNonGeneratedColumns(qEntity) {
        return this.getAllColumns(qEntity).filter(qField => !qField.dbColumn.isGenerated);
    }
    getAllInsertableColumns(qEntity) {
        return this.getAllColumns(qEntity).filter(qField => {
            if (qField.dbColumn.isGenerated) {
                return false;
            }
            if (qEntity.__driver__.dbEntity.isAirEntity) {
                switch (qField.dbColumn.name) {
                    case this.dictionary.AirEntity.columns.SYSTEM_WIDE_OPERATION_LID:
                        return false;
                }
            }
            return true;
        });
    }
    getDbEntity(qEntity) {
        return qEntity.__driver__.dbEntity;
    }
    getNewEntity(qEntity, airDb) {
        const dbEntity = qEntity.__driver__.dbEntity;
        const entityConstructor = airDb.qApplications[dbEntity.applicationVersion.application.index].__constructors__[dbEntity.name];
        if (!entityConstructor) {
            return {};
        }
        return new entityConstructor();
    }
}

class QueryUtils {
    equals(entityOrId, toObject // | IQRelation<IQ>
    ) {
        if (!entityOrId) {
            throw new Error(`null entity/Id is passed into 'equals' method`);
        }
        const { qActor, qRepository } = this.entityUtils.ensureRepositoryAndActorJoin(toObject);
        if (entityOrId instanceof QEntity) {
            const relationIdEntities = this.entityUtils
                .ensureRepositoryAndActorJoin(entityOrId);
            return AND(qRepository.GUID.equals(relationIdEntities.qRepository.repository.GUID), qActor.GUID.equals(relationIdEntities.qActor.actor.GUID), toObject._actorRecordId.equals(entityOrId._actorRecordId));
        }
        else {
            let entityId = this.validateEntityId(entityOrId);
            return AND(qRepository.GUID.equals(entityId.repository.GUID), qActor.GUID.equals(entityId.actor.GUID), toObject._actorRecordId.equals(entityId._actorRecordId));
        }
    }
    in(entitiesOrIds, toObject // | IQRelation<IQ>
    ) {
        if (!entitiesOrIds || !entitiesOrIds.length) {
            throw new Error(`null entity/Id array is passed into 'IN' method`);
        }
        let entityIds = entitiesOrIds.map(entityOrId => this.validateEntityId(entityOrId));
        const { qActor, qRepository } = this.entityUtils.ensureRepositoryAndActorJoin(toObject);
        const equalOperations = [];
        for (const entityId of entityIds) {
            equalOperations.push(AND(qRepository.GUID.equals(entityId.repository.GUID), qActor.GUID.equals(entityId.actor.GUID), toObject._actorRecordId.equals(entityId._actorRecordId)));
        }
        return OR(...equalOperations);
    }
    equalsInternal(entityId, toObject // | IQRelation<IQ>
    ) {
        const columnField = this.getGetSingleColumnRelationField(toObject);
        return columnField.equals(entityId);
    }
    inInternal(entityIds, toObject // | IQRelation<IQ>
    ) {
        if (!entityIds || !entityIds.length) {
            throw new Error(`null or empty Id array is passed into 'IN' method`);
        }
        const columnField = this.getGetSingleColumnRelationField(toObject);
        return columnField.IN(entityIds);
    }
    getGetSingleColumnRelationField(toObject // | IQRelation<IQ>
    ) {
        const qEntity = toObject;
        if (qEntity.__driver__.dbRelation.manyRelationColumns.length > 1) {
            throw new Error(`
Currently IN operation on internal (non AirEntity) entities
is supported only for single columm relations
			`);
        }
        qEntity.__driver__.dbRelation.property;
        const relationColumn = qEntity.__driver__.dbRelation.manyRelationColumns[0];
        return this.qEntityUtils.getColumnQField(qEntity.__driver__.dbEntity, qEntity.__driver__.dbRelation.property, qEntity, relationColumn.manyColumn);
    }
    validateEntityId(entityId) {
        if (typeof entityId === 'string') {
            return this.airEntityUtils.parseEGUID(entityId);
        }
        else {
            if (!entityId.repository
                || !entityId.repository.GUID
                || typeof entityId.repository.GUID !== 'string'
                || !entityId.actor
                || !entityId.actor.GUID
                || typeof entityId.actor.GUID !== 'number'
                || !entityId._actorRecordId
                || typeof entityId._actorRecordId !== 'number') {
                throw new Error(`Passed in AirEntity does not have
				the necessary fields to query by id.  Expecting:
					interface AnInterface extends AirEntity {
						repository: {
							GUID: string
						},
						actor: {
							GUID: string
						},
						_actorRecordId: number
					}
					`);
            }
            return entityId;
        }
    }
    whereClauseToJSON(whereClause, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet) {
        if (!whereClause) {
            return null;
        }
        let operation = whereClause;
        let jsonOperation = {
            c: operation.c,
            o: operation.o
        };
        switch (operation.c) {
            case OperationCategory.LOGICAL:
                let logicalOperation = operation;
                let jsonLogicalOperation = jsonOperation;
                switch (operation.o) {
                    case SqlOperator.NOT:
                        jsonLogicalOperation.v = this.whereClauseToJSON(logicalOperation.v, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet);
                        break;
                    case SqlOperator.AND:
                    case SqlOperator.OR:
                        jsonLogicalOperation.v = logicalOperation.v.map((value) => this.whereClauseToJSON(value, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet));
                        break;
                    default:
                        throw new Error(`Unsupported logical operation '${operation.o}'`);
                }
                break;
            case OperationCategory.FUNCTION:
                // TODO: verify that cast of Q object is valid
                let functionOperation = operation;
                let query = functionOperation.getQuery();
                let jsonQuery = IOC.getSync(ENTITY_UTILS).getTreeQuery(query, columnAliases.entityAliases).toJSON(this, this.fieldUtils, this.relationManager);
                jsonOperation = functionOperation.toJSON(jsonQuery);
                break;
            case OperationCategory.BOOLEAN:
            case OperationCategory.DATE:
            case OperationCategory.NUMBER:
            case OperationCategory.STRING:
            case OperationCategory.UNTYPED:
                let valueOperation = operation;
                // All Non logical or exists operations are value operations (equals, IS_NULL, LIKE,
                // etc.)
                let jsonValueOperation = jsonOperation;
                jsonValueOperation.l = this.convertLRValue(valueOperation.l, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet);
                if (operation.o === SqlOperator.IS_NOT_NULL
                    || operation.o === SqlOperator.IS_NULL) {
                    break;
                }
                let rValue = valueOperation.r;
                if (rValue instanceof Array) {
                    jsonValueOperation.r = rValue.map((anRValue) => {
                        return this.convertLRValue(anRValue, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet);
                    });
                }
                else {
                    jsonValueOperation.r = this.convertLRValue(rValue, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet);
                }
                for (const trackedRepoGUID of valueOperation.trackedRepoGUIDs) {
                    trackedRepoGUIDSet.add(trackedRepoGUID);
                }
                for (const trackedRepoLocalId of valueOperation.trackedRepoLocalIds) {
                    trackedRepoLocalIdSet.add(trackedRepoLocalId);
                }
                break;
        }
        return jsonOperation;
    }
    getQEntityConstructor(dbEntity) {
        return this.airportDatabase.qApplications[dbEntity.applicationVersion.application.index]
            .__qConstructors__[dbEntity.index];
    }
    getIdKey(entityObject, dbEntity, failOnNoId = true, 
    // noIdValueCallback: {
    // 	(
    // 		relationColumn: DbColumn,
    // 		value: any,
    // 		propertyNameChains: string[][],
    // 	): boolean;
    // } = null,
    idValueCallback) {
        const keys = this.getIdKeyInfo(entityObject, dbEntity, failOnNoId, idValueCallback);
        return keys.arrayByIdColumnIndex.join('|');
    }
    getIdKeyInfo(entityObject, dbEntity, failOnNoId = true, idValueCallback) {
        if (!dbEntity.idColumns.length) {
            if (failOnNoId) {
                throw new Error(`@Id is not defined on entity '${dbEntity.name}'.`);
            }
            return null;
        }
        const idKeys = {
            arrayByIdColumnIndex: [],
            mapByIdColumnName: {}
        };
        for (const dbColumn of dbEntity.idColumns) {
            const [propertyNameChains, idValue] = this.applicationUtils.getColumnPropertyNameChainsAndValue(dbEntity, dbColumn, entityObject, true, failOnNoId);
            idValueCallback && idValueCallback(dbColumn, idValue, propertyNameChains);
            idKeys.arrayByIdColumnIndex.push(idValue);
            idKeys.mapByIdColumnName[dbColumn.name] = idValue;
        }
        return idKeys;
    }
    getSheetSelectFromSetClause(dbEntity, qEntity, setClause, errorPrefix) {
        const selectClause = [];
        let actorIdColumnIndex;
        let actorRecordIdColumnIndex;
        let repositoryIdColumnIndex;
        let systemWideOperationIdColumn;
        for (const columnIndex in dbEntity.columns) {
            const dbColumn = dbEntity.columns[columnIndex];
            let dbProperty;
            const isIdColumn = dbColumn.propertyColumns.some(propertyColumn => {
                dbProperty = propertyColumn.property;
                return dbProperty.isId;
            });
            let nonIdColumnSet = false;
            if (isIdColumn) {
                if (setClause[dbColumn.name]) {
                    throw new Error(errorPrefix + `Cannot update @Id column '${dbColumn.name}' 
of property '${dbEntity.name}.${dbProperty.name}'.`);
                }
                this.addColumnToSheetSelect(dbColumn, qEntity, selectClause);
            }
            else if (setClause[dbColumn.name]) {
                nonIdColumnSet = true;
                this.addColumnToSheetSelect(dbColumn, qEntity, selectClause);
                // } else {
                // entitySelectClause[dbColumn.index] = null;
            }
            const inQueryColumnIndex = selectClause.length - 1;
            const AirEntity = this.dictionary.AirEntity;
            switch (dbColumn.name) {
                case AirEntity.columns.ACTOR_LID:
                    actorIdColumnIndex = inQueryColumnIndex;
                    break;
                case AirEntity.columns.ACTOR_RECORD_ID:
                    actorRecordIdColumnIndex = inQueryColumnIndex;
                    break;
                case AirEntity.columns.REPOSITORY_LID:
                    repositoryIdColumnIndex = inQueryColumnIndex;
                    break;
                case AirEntity.columns.SYSTEM_WIDE_OPERATION_LID:
                    if (nonIdColumnSet) {
                        throw new Error(errorPrefix +
                            `Cannot update 'systemWideOperationId' of Repository Entities.`);
                    }
                    systemWideOperationIdColumn = dbColumn;
                    break;
            }
        }
        return {
            actorIdColumnIndex,
            actorRecordIdColumnIndex,
            repositoryIdColumnIndex,
            selectClause,
            systemWideOperationIdColumn
        };
    }
    addColumnToSheetSelect(dbColumn, qEntity, entitySelectClause) {
        if (this.applicationUtils.isManyRelationColumn(dbColumn)) {
            const columnPaths = this.applicationUtils.getColumnPaths(dbColumn, []);
            const firstColumnPath = columnPaths[0];
            let relationColumn = qEntity[firstColumnPath[0]];
            firstColumnPath.reduce((last, current) => {
                relationColumn = relationColumn[current];
                return current;
            });
            entitySelectClause.push(relationColumn);
        }
        else {
            entitySelectClause.push(qEntity[dbColumn.propertyColumns[0].property.name]);
        }
    }
    /*
        private addColumnToEntitySelect(
            dbColumn: DbColumn,
            entitySelectClause: any,
        ) {
            const dbRelation = dbColumn.relation;
            if (dbRelation) {
                let selectClauseFragment = entitySelectClause;
                let lastSelectClauseFragment;
                let sourceColumn = dbColumn;
                let lastPropertyName;
                do {
                    lastPropertyName = sourceColumn.property.name;
                    lastSelectClauseFragment = selectClauseFragment;
                    if (!lastSelectClauseFragment[lastPropertyName]) {
                        selectClauseFragment = {};
                        lastSelectClauseFragment[lastPropertyName] = selectClauseFragment;
                    } else {
                        selectClauseFragment = lastSelectClauseFragment[lastPropertyName];
                    }
                    const relationColumn = sourceColumn.relation.relationColumns.filter(
                        relationColumn => relationColumn.ownColumn.index === sourceColumn.index)[0];
                    sourceColumn = relationColumn.relationColumn;
                } while (sourceColumn.relation);
                lastSelectClauseFragment[lastPropertyName] = null;
            } else {
                entitySelectClause[dbColumn.property.name] = null;
            }
        }
    */
    convertLRValue(value, columnAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet) {
        value = wrapPrimitive(value);
        switch (typeof value) {
            case 'undefined':
                throw new Error(`'undefined' is not a valid L or R value`);
            default:
                if (value instanceof QOperableField) {
                    return value.toJSON(columnAliases, false, trackedRepoGUIDSet, trackedRepoLocalIdSet, this, this.fieldUtils, this.relationManager);
                } // Must be a Field Query
                else {
                    let rawFieldQuery = value;
                    return this.fieldUtils.getFieldQueryJson(rawFieldQuery, columnAliases.entityAliases, trackedRepoGUIDSet, trackedRepoLocalIdSet, this);
                }
        }
    }
}

const databaseState = {
    applications: [],
    entityMap: new Map(),
    functions: {
        ABS,
        ADD,
        AVG,
        CONCAT,
        COUNT,
        DISTINCT,
        DIVIDE,
        EXISTS,
        FORMAT,
        INTERSECT,
        LCASE,
        LEN,
        ROUND,
        MAX,
        MID,
        MIN,
        MINUS,
        MODULUS,
        MULTIPLY,
        NOW,
        REPLACE,
        SUBTRACT,
        SUM,
        TRIM,
        UCASE,
        UNION,
        UNION_ALL,
        // logical operators
        AND,
        NOT,
        OR,
        // primitive wrappers
        bool,
        date,
        num,
        str,
        wrapPrimitive,
    },
    qApplications: [],
    QM: {},
};

class DatabaseStore {
    constructor() {
        this.databaseState = databaseState;
    }
    get applications() {
        return this.databaseState.applications;
    }
    get entityMap() {
        return this.databaseState.entityMap;
    }
    get functions() {
        return this.databaseState.functions;
    }
    get qApplications() {
        return this.databaseState.qApplications;
    }
    get QM() {
        return this.databaseState.QM;
    }
}

class RelationManager {
    getPositionAlias(rootEntityPrefix, fromClausePosition) {
        return `${rootEntityPrefix}_${fromClausePosition.join('_')}`;
    }
    getAlias(jsonRelation) {
        return this.getPositionAlias(jsonRelation.rep, jsonRelation.fromClausePosition);
    }
    getParentAlias(jsonRelation) {
        let fromClausePosition = jsonRelation.fromClausePosition;
        if (fromClausePosition.length === 0) {
            throw new Error(`Cannot find alias of a parent entity for the root entity`);
        }
        return this.getPositionAlias(jsonRelation.rep, fromClausePosition.slice(0, fromClausePosition.length - 1));
    }
    createRelatedQEntity(joinRelation, context) {
        const dbEntity = this.applicationUtils.getDbEntity(joinRelation.si, joinRelation.ti);
        let QEntityConstructor = this.queryUtils.getQEntityConstructor(dbEntity);
        return new QEntityConstructor(dbEntity, this.queryUtils, this, joinRelation.fromClausePosition, dbEntity.relations[joinRelation.ri], joinRelation.jt);
    }
    getNextChildJoinPosition(joinParentDriver) {
        let nextChildJoinPosition = joinParentDriver.fromClausePosition.slice();
        nextChildJoinPosition.push(++joinParentDriver.currentChildIndex);
        return nextChildJoinPosition;
    }
}

class SystemWideOperationIdUtils {
    async getSysWideOpId() {
        const sequences = await this.getSysWideOpIds(1);
        return sequences[0];
    }
    async getSysWideOpIds(numSequencesNeeded) {
        const airport = this.dictionary.airport;
        const SystemWideOperationId = this.dictionary.SystemWideOperationId;
        return await this.sequenceGenerator
            .generateSequenceNumbersForColumn(airport.DOMAIN_NAME, airport.apps.AIRPORT_CODE.name, SystemWideOperationId.name, SystemWideOperationId.columns.SYSTEM_WIDE_OPERATION_LID, numSequencesNeeded);
    }
}

class Utils {
    strsToNums(strings) {
        return strings.map(str => parseInt(str));
    }
    objectExists(object) {
        return object !== null && object !== undefined;
    }
    valuesEqual(value1, value2, checkChildObjects = false) {
        if (typeof value1 === 'object') {
            if (value1 instanceof Date) {
                if (value2 instanceof Date) {
                    return value1.getTime() === value2.getTime();
                }
                else {
                    return false;
                }
            }
            else {
                if (typeof value2 !== 'object') {
                    return false;
                }
                if (!checkChildObjects) {
                    // Skip child objects
                    return true;
                }
                let checkedKeys = {};
                for (let key in value1) {
                    checkedKeys[key] = true;
                    if (!this.valuesEqual(value1[key], value2[key], checkChildObjects)) {
                        return false;
                    }
                }
                for (let key in value2) {
                    if (!checkedKeys[key]) {
                        return false;
                    }
                }
                return true;
            }
        }
        if (!value1) {
            if (value1 === '') {
                return value2 === '';
            }
            else if (value1 === false) {
                return value2 === false;
            }
            else if (value1 === 0) {
                return value2 === 0;
            }
            if (value2 === '' || value2 === false || value2 === 0) {
                return false;
            }
            // treat undefined and null as same value
            return (!value2);
        }
        if (!value2) {
            return false;
        }
        return value1 === value2;
    }
    compareNumbers(number1, number2) {
        if (number1 < number2) {
            return -1;
        }
        if (number1 > number2) {
            return 1;
        }
        return 0;
    }
}

const airTrafficControl = lib('air-traffic-control');

// Separating core-tokens from tokens removes circular dependencies
// at code initialization time
airTrafficControl.register(Utils);
ENTITY_UTILS.setDependencies({
    dictionary: Dictionary,
    utils: Utils
});
QUERY_UTILS.setClass(QueryUtils);

airTrafficControl.register(ApplicationUtils, DatabaseStore, FieldUtils, QApplicationBuilderUtils, QMetadataUtils, RelationManager, SystemWideOperationIdUtils);
const AIRPORT_DATABASE = airTrafficControl.token('AirportDatabase');
const API_REGISTRY = airTrafficControl.token('ApiRegistry');
const API_VALIDATOR = airTrafficControl.token('ApiValidator');
const REPOSITORY_LOADER = airTrafficControl.token('RepositoryLoader');
AIRPORT_DATABASE.setDependencies({
    appliationUtils: ApplicationUtils,
    databaseFacade: DATABASE_FACADE,
    databaseStore: DatabaseStore,
    dictionary: Dictionary,
    dbApplicationUtils: DbApplicationUtils,
    find: NonEntityFind,
    findOne: NonEntityFindOne,
    qApplicationBuilderUtils: QApplicationBuilderUtils,
    relationManager: RelationManager,
    search: NonEntitySearch,
    searchOne: NonEntitySearchOne
});
API_REGISTRY.setDependencies({
    containerAccessor: ContainerAccessor
});
airTrafficControl.setDependencies(ApplicationUtils, {
    airportDatabase: AIRPORT_DATABASE,
    dictionary: Dictionary,
    entityStateManager: ENTITY_STATE_MANAGER,
    qEntityUtils: QEntityUtils,
    utils: Utils
});
DATABASE_FACADE.setDependencies({
    applicationUtils: ApplicationUtils,
    entityStateManager: ENTITY_STATE_MANAGER,
    transactionalConnector: TRANSACTIONAL_CONNECTOR,
    updateCacheManager: UPDATE_CACHE_MANAGER
});
airTrafficControl.setDependencies(FieldUtils, {
    relationManager: RelationManager
});
airTrafficControl.setDependencies(Lookup, {
    entityUtils: ENTITY_UTILS,
    queryFacade: QUERY_FACADE
});
airTrafficControl.setDependencies(QApplicationBuilderUtils, {
    qEntityUtils: QEntityUtils
});
airTrafficControl.setDependencies(QMetadataUtils, {
    dictionary: Dictionary
});
QUERY_FACADE.setDependencies({
    fieldUtils: FieldUtils,
    queryUtils: QUERY_UTILS,
    relationManager: RelationManager,
    transactionalConnector: TRANSACTIONAL_CONNECTOR
});
QUERY_UTILS.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: ApplicationUtils,
    dictionary: Dictionary,
    entityUtils: ENTITY_UTILS,
    fieldUtils: FieldUtils,
    relationManager: RelationManager,
    airEntityUtils: AIR_ENTITY_UTILS
});
airTrafficControl.setDependencies(RelationManager, {
    applicationUtils: ApplicationUtils,
    queryUtils: QUERY_UTILS
});
airTrafficControl.setDependencies(SystemWideOperationIdUtils, {
    dictionary: Dictionary,
    sequenceGenerator: SEQUENCE_GENERATOR,
});
UPDATE_CACHE_MANAGER.setDependencies({
    applicationUtils: ApplicationUtils,
    entityStateManager: ENTITY_STATE_MANAGER,
});

globalThis.airApi.setQApp = function (qApplication) {
    IOC.eventuallyGet(AIRPORT_DATABASE).then((airportDatabase) => {
        airportDatabase.setQApp(qApplication);
    });
};

class Sequence {
}

/**
 * No actual records are inserted into this table, only used for the sequence
 */
class SystemWideOperationId {
}

/**
 * A record of the Terminal running (being up at a given point in time)
 */
class TerminalRun {
}

const __constructors__$8 = {
    Sequence,
    SystemWideOperationId,
    TerminalRun
};
const Q_airport____at_airport_slash_airport_dash_code = {
    __constructors__: __constructors__$8,
    domain: 'airport',
    name: '@airport/airport-code'
};
function airport____at_airport_slash_airport_dash_code_diSet(dbEntityId) {
    return globalThis.airApi.dS(Q_airport____at_airport_slash_airport_dash_code.__dbApplication__, dbEntityId);
}
if (globalThis.airApi) {
    globalThis.airApi.setQApp(Q_airport____at_airport_slash_airport_dash_code);
}

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$6 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q_airport____at_airport_slash_airport_dash_code);
    }
}
class BaseSequenceDao extends SQDIDao$6 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airport_dash_code_diSet(0);
    }
    constructor() {
        super(0);
    }
}
BaseSequenceDao.Find = new DaoQueryDecorators();
BaseSequenceDao.FindOne = new DaoQueryDecorators();
BaseSequenceDao.Search = new DaoQueryDecorators();
BaseSequenceDao.SearchOne = new DaoQueryDecorators();
class BaseSystemWideOperationIdDao extends SQDIDao$6 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airport_dash_code_diSet(1);
    }
    constructor() {
        super(1);
    }
}
BaseSystemWideOperationIdDao.Find = new DaoQueryDecorators();
BaseSystemWideOperationIdDao.FindOne = new DaoQueryDecorators();
BaseSystemWideOperationIdDao.Search = new DaoQueryDecorators();
BaseSystemWideOperationIdDao.SearchOne = new DaoQueryDecorators();
class BaseTerminalRunDao extends SQDIDao$6 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airport_dash_code_diSet(2);
    }
    constructor() {
        super(2);
    }
}
BaseTerminalRunDao.Find = new DaoQueryDecorators();
BaseTerminalRunDao.FindOne = new DaoQueryDecorators();
BaseTerminalRunDao.Search = new DaoQueryDecorators();
BaseTerminalRunDao.SearchOne = new DaoQueryDecorators();

class TerminalRunDao extends BaseTerminalRunDao {
}

class SequenceDao extends BaseSequenceDao {
    static diSet() {
        return Q_airport____at_airport_slash_airport_dash_code.__dbApplication__ && !!Q_airport____at_airport_slash_airport_dash_code.__dbApplication__.currentVersion[0]
            .applicationVersion.entities[0];
    }
    async incrementCurrentValues(context) {
        const s = Q_airport____at_airport_slash_airport_dash_code.Sequence;
        await this.db.updateWhere({
            UPDATE: s,
            SET: {
                currentValue: PLUS(s.currentValue, s.incrementBy)
            }
        }, context);
    }
    async incrementSequence(context) {
        const s = Q_airport____at_airport_slash_airport_dash_code.Sequence;
        await this.db.updateWhere({
            UPDATE: s,
            SET: {
                currentValue: PLUS(s.currentValue, s.incrementBy)
            }
        }, context);
    }
}

const airportCode = lib('@airport/airport-code');
airportCode.register(SequenceDao, TerminalRunDao);

class Domain {
}

class Application {
    constructor() {
        this.versions = [];
        this.currentVersion = [];
    }
}

class VersionedApplicationObject {
}

class ApplicationColumn extends VersionedApplicationObject {
    constructor() {
        super(...arguments);
        this.propertyColumns = [];
        this.manyRelationColumns = [];
        this.oneRelationColumns = [];
        this.propertyColumnMap = {};
    }
}

class ApplicationCurrentVersion {
}

class ApplicationEntity extends VersionedApplicationObject {
    constructor() {
        super(...arguments);
        //
        // One-to-Many's
        //
        this.columns = [];
        // TODO: implement if needed
        // @OneToMany()
        // @JoinColumns([
        // 	{name: "APPLICATION_VERSION_LID"},
        // 	{name: "TABLE_INDEX", referencedColumnName: "INDEX"}
        // ])
        // @WhereJoinTable((
        // 	otm: QAppEntity,
        // 	mto: QAppColumn
        // ) => mto.idIndex.IS_NOT_NULL())
        // idColumns: ApplicationColumn[];
        this.operations = [];
        this.properties = [];
        this.relations = [];
        this.relationReferences = [];
        this.columnMap = {};
        this.idColumns = [];
        this.idColumnMap = {};
        this.propertyMap = {};
    }
}

class ApplicationOperation extends VersionedApplicationObject {
}

class ApplicationProperty extends VersionedApplicationObject {
    constructor() {
        super(...arguments);
        this.propertyColumns = [];
        this.relation = [];
    }
}

/**
 * Many-to-Many between Columns and properties
 */
class ApplicationPropertyColumn extends VersionedApplicationObject {
}

class ApplicationReference extends VersionedApplicationObject {
}

class ApplicationRelation extends VersionedApplicationObject {
    constructor() {
        super(...arguments);
        this.manyRelationColumns = [];
        this.oneRelationColumns = [];
    }
}

class ApplicationRelationColumn extends VersionedApplicationObject {
}

class ApplicationVersion {
    constructor() {
        this.entities = [];
        this.references = [];
        this.referencedBy = [];
        this.entityMapByName = {};
        this.referencesMapByName = {};
        this.referencedByMapByName = {};
    }
}

const __constructors__$7 = {
    Application,
    ApplicationColumn,
    ApplicationCurrentVersion,
    ApplicationEntity,
    ApplicationOperation,
    ApplicationProperty,
    ApplicationPropertyColumn,
    ApplicationReference,
    ApplicationRelation,
    ApplicationRelationColumn,
    ApplicationVersion,
    Domain,
    VersionedApplicationObject
};
const Q_airport____at_airport_slash_airspace = {
    __constructors__: __constructors__$7,
    domain: 'airport',
    name: '@airport/airspace'
};
function airport____at_airport_slash_airspace_diSet(dbEntityId) {
    return globalThis.airApi.dS(Q_airport____at_airport_slash_airspace.__dbApplication__, dbEntityId);
}
if (globalThis.airApi) {
    globalThis.airApi.setQApp(Q_airport____at_airport_slash_airspace);
}

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$5 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q_airport____at_airport_slash_airspace);
    }
}
class BaseApplicationDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(10);
    }
    constructor() {
        super(10);
    }
}
BaseApplicationDao.Find = new DaoQueryDecorators();
BaseApplicationDao.FindOne = new DaoQueryDecorators();
BaseApplicationDao.Search = new DaoQueryDecorators();
BaseApplicationDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationColumnDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(4);
    }
    constructor() {
        super(4);
    }
}
BaseApplicationColumnDao.Find = new DaoQueryDecorators();
BaseApplicationColumnDao.FindOne = new DaoQueryDecorators();
BaseApplicationColumnDao.Search = new DaoQueryDecorators();
BaseApplicationColumnDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationCurrentVersionDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(9);
    }
    constructor() {
        super(9);
    }
}
BaseApplicationCurrentVersionDao.Find = new DaoQueryDecorators();
BaseApplicationCurrentVersionDao.FindOne = new DaoQueryDecorators();
BaseApplicationCurrentVersionDao.Search = new DaoQueryDecorators();
BaseApplicationCurrentVersionDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationEntityDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(6);
    }
    constructor() {
        super(6);
    }
}
BaseApplicationEntityDao.Find = new DaoQueryDecorators();
BaseApplicationEntityDao.FindOne = new DaoQueryDecorators();
BaseApplicationEntityDao.Search = new DaoQueryDecorators();
BaseApplicationEntityDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationOperationDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(5);
    }
    constructor() {
        super(5);
    }
}
BaseApplicationOperationDao.Find = new DaoQueryDecorators();
BaseApplicationOperationDao.FindOne = new DaoQueryDecorators();
BaseApplicationOperationDao.Search = new DaoQueryDecorators();
BaseApplicationOperationDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationPropertyDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(2);
    }
    constructor() {
        super(2);
    }
}
BaseApplicationPropertyDao.Find = new DaoQueryDecorators();
BaseApplicationPropertyDao.FindOne = new DaoQueryDecorators();
BaseApplicationPropertyDao.Search = new DaoQueryDecorators();
BaseApplicationPropertyDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationPropertyColumnDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(3);
    }
    constructor() {
        super(3);
    }
}
BaseApplicationPropertyColumnDao.Find = new DaoQueryDecorators();
BaseApplicationPropertyColumnDao.FindOne = new DaoQueryDecorators();
BaseApplicationPropertyColumnDao.Search = new DaoQueryDecorators();
BaseApplicationPropertyColumnDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationReferenceDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(7);
    }
    constructor() {
        super(7);
    }
}
BaseApplicationReferenceDao.Find = new DaoQueryDecorators();
BaseApplicationReferenceDao.FindOne = new DaoQueryDecorators();
BaseApplicationReferenceDao.Search = new DaoQueryDecorators();
BaseApplicationReferenceDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationRelationDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(1);
    }
    constructor() {
        super(1);
    }
}
BaseApplicationRelationDao.Find = new DaoQueryDecorators();
BaseApplicationRelationDao.FindOne = new DaoQueryDecorators();
BaseApplicationRelationDao.Search = new DaoQueryDecorators();
BaseApplicationRelationDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationRelationColumnDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(0);
    }
    constructor() {
        super(0);
    }
}
BaseApplicationRelationColumnDao.Find = new DaoQueryDecorators();
BaseApplicationRelationColumnDao.FindOne = new DaoQueryDecorators();
BaseApplicationRelationColumnDao.Search = new DaoQueryDecorators();
BaseApplicationRelationColumnDao.SearchOne = new DaoQueryDecorators();
class BaseApplicationVersionDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(8);
    }
    constructor() {
        super(8);
    }
}
BaseApplicationVersionDao.Find = new DaoQueryDecorators();
BaseApplicationVersionDao.FindOne = new DaoQueryDecorators();
BaseApplicationVersionDao.Search = new DaoQueryDecorators();
BaseApplicationVersionDao.SearchOne = new DaoQueryDecorators();
class BaseDomainDao extends SQDIDao$5 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_airspace_diSet(11);
    }
    constructor() {
        super(11);
    }
}
BaseDomainDao.Find = new DaoQueryDecorators();
BaseDomainDao.FindOne = new DaoQueryDecorators();
BaseDomainDao.Search = new DaoQueryDecorators();
BaseDomainDao.SearchOne = new DaoQueryDecorators();

class DomainDao extends BaseDomainDao {
    async findByIdIn(domainIds) {
        let d;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                d = Q_airport____at_airport_slash_airspace.Domain
            ],
            WHERE: d._localId.IN(domainIds)
        });
    }
    async findMapByNameWithNames(domainNames) {
        let d;
        const domains = await this.db.find.tree({
            SELECT: {},
            FROM: [d = Q_airport____at_airport_slash_airspace.Domain],
            WHERE: d.name.IN(domainNames)
        });
        const domainMapByNameWithNames = new Map();
        for (const domain of domains) {
            domainMapByNameWithNames.set(domain.name, domain);
        }
        return domainMapByNameWithNames;
    }
    async findOneByName(name) {
        let d;
        return await this.db.findOne.tree({
            SELECT: {},
            FROM: [d = Q_airport____at_airport_slash_airspace.Domain],
            WHERE: d.name.equals(name)
        });
    }
    async findByNames(names) {
        let d;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [d = Q_airport____at_airport_slash_airspace.Domain],
            WHERE: d.name.IN(names)
        });
    }
    async findByName(name) {
        let d;
        return await this.db.findOne.tree({
            SELECT: {},
            FROM: [d = Q_airport____at_airport_slash_airspace.Domain],
            WHERE: d.name.equals(name)
        });
    }
    async checkAndInsertIfNeeded(domains, context) {
        const existingDomains = await this.findByIdIn(domains.map(domain => domain._localId));
        const existingDomainMap = new Map();
        for (const existingDomain of existingDomains) {
            existingDomainMap.set(existingDomain._localId, existingDomain);
        }
        const newDomains = [];
        for (const domain of domains) {
            if (!existingDomainMap.has(domain._localId)) {
                newDomains.push(domain);
            }
        }
        if (!newDomains.length) {
            return;
        }
        let d;
        const VALUES = [];
        for (const domain of newDomains) {
            VALUES.push([
                domain._localId, domain.name
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: d = Q_airport____at_airport_slash_airspace.Domain,
            columns: [
                d._localId,
                d.name,
            ],
            VALUES
        }, context);
    }
    async insert(domains) {
        let d;
        const VALUES = [];
        for (const domain of domains) {
            VALUES.push([
                domain.name
            ]);
        }
        const ids = await this.db.insertValuesGenerateIds({
            INSERT_INTO: d = Q_airport____at_airport_slash_airspace.Domain,
            columns: [
                d.name
            ],
            VALUES
        });
        for (let i = 0; i < domains.length; i++) {
            let domain = domains[i];
            domain._localId = ids[i][0];
        }
    }
}

class ApplicationColumnDao extends BaseApplicationColumnDao {
    async findAllForEntities(entityIds) {
        let c;
        return this.db.find.tree({
            SELECT: {},
            FROM: [
                c = Q_airport____at_airport_slash_airspace.ApplicationColumn
            ],
            WHERE: c.entity._localId.IN(entityIds)
        });
    }
    async insert(applicationColumns, context) {
        let sc;
        const VALUES = [];
        for (const applicationColumn of applicationColumns) {
            VALUES.push([
                applicationColumn._localId, applicationColumn.index,
                this.datastructureUtils.undefinedToNull(applicationColumn.idIndex),
                applicationColumn.isGenerated,
                this.datastructureUtils.undefinedToNull(applicationColumn.allocationSize),
                applicationColumn.name,
                applicationColumn.notNull,
                this.datastructureUtils.undefinedToNull(applicationColumn.precision),
                this.datastructureUtils.undefinedToNull(applicationColumn.scale),
                applicationColumn.type,
                applicationColumn.entity._localId,
                applicationColumn.deprecatedSinceVersion ? applicationColumn.deprecatedSinceVersion._localId : null,
                applicationColumn.removedInVersion ? applicationColumn.removedInVersion._localId : null,
                applicationColumn.sinceVersion ? applicationColumn.sinceVersion._localId : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: sc = Q_airport____at_airport_slash_airspace.ApplicationColumn,
            columns: [
                sc._localId,
                sc.index,
                sc.idIndex,
                sc.isGenerated,
                sc.allocationSize,
                sc.name,
                sc.notNull,
                sc.precision,
                sc.scale,
                sc.type,
                sc.entity._localId,
                sc.deprecatedSinceVersion._localId,
                sc.removedInVersion._localId,
                sc.sinceVersion._localId
            ],
            VALUES
        }, context);
    }
}

class ApplicationDao extends BaseApplicationDao {
    async findAllActive() {
        return this.db.find.tree({
            SELECT: {},
            FROM: [
                Q_airport____at_airport_slash_airspace.Application
            ]
        });
    }
    async findAllWithJson() {
        let a;
        return this.db.find.tree({
            SELECT: {
                ...ALL_FIELDS,
                // currentVersion: {
                // 	applicationVersion: {
                // 		_localId: Y,
                // 		jsonApplication: Y
                // 	}
                // }
                versions: {
                    _localId: Y,
                    jsonApplication: Y
                }
            },
            FROM: [
                a = Q_airport____at_airport_slash_airspace.Application,
                // cv = a.currentVersion.INNER_JOIN(),
                // av = cv.applicationVersion.INNER_JOIN()
                a.versions.INNER_JOIN()
            ]
        });
    }
    async findMapByVersionIds(applicationVersionIds) {
        const applicationMapByIndex = new Map();
        let s, sv;
        const applications = await this.db.find.tree({
            SELECT: {
                index: Y,
                domain: {
                    _localId: Y,
                    name: Y
                },
                name: Y,
                fullName: Y,
                versions: {
                    _localId: Y,
                    majorVersion: Y,
                    minorVersion: Y,
                    patchVersion: Y
                }
            },
            FROM: [
                s = Q_airport____at_airport_slash_airspace.Application,
                sv = s.versions.INNER_JOIN()
            ],
            WHERE: sv._localId.IN(applicationVersionIds)
        });
        for (const application of applications) {
            for (const applicationVersion of application.versions) {
                applicationMapByIndex.set(applicationVersion._localId, application);
            }
        }
        return applicationMapByIndex;
    }
    async findMaxIndex() {
        const s = Q_airport____at_airport_slash_airspace.Application;
        return await this.airportDatabase.findOne.field({
            SELECT: MAX(s.index),
            FROM: [
                s
            ]
        });
    }
    async findMaxVersionedMapByApplicationAndDomain_Names(applicationDomain_Names, applicationNames) {
        const maxVersionedMapByApplicationAndDomain_Names = new Map();
        let sv;
        let s;
        let d;
        let sMaV;
        let sMiV;
        const applicationLookupRecords = await this.airportDatabase.find.tree({
            FROM: [
                sMiV = tree({
                    FROM: [
                        sMaV = tree({
                            FROM: [
                                s = Q_airport____at_airport_slash_airspace.Application,
                                sv = s.versions.INNER_JOIN(),
                                d = s.domain.INNER_JOIN()
                            ],
                            SELECT: {
                                index: s.index,
                                domainId: d._localId,
                                domainName: d.name,
                                name: s.name,
                                majorVersion: MAX(sv.majorVersion),
                                minorVersion: sv.minorVersion,
                                patchVersion: sv.patchVersion,
                            },
                            WHERE: AND(d.name.IN(applicationDomain_Names), s.name.IN(applicationNames)),
                            GROUP_BY: [
                                s.index,
                                d._localId,
                                d.name,
                                s.name,
                                sv.minorVersion,
                                sv.patchVersion,
                            ]
                        })
                    ],
                    SELECT: {
                        index: sMaV.index,
                        domainId: sMaV.domainId,
                        domainName: sMaV.domainName,
                        name: sMaV.name,
                        majorVersion: sMaV.majorVersion,
                        minorVersion: MAX(sMaV.minorVersion),
                        patchVersion: sMaV.patchVersion,
                    },
                    GROUP_BY: [
                        sMaV.index,
                        sMaV.domainId,
                        sMaV.domainName,
                        sMaV.name,
                        sMaV.majorVersion,
                        sMaV.patchVersion
                    ]
                })
            ],
            SELECT: {
                index: sMiV.index,
                domain: {
                    _localId: sMiV.domainId,
                    name: sMiV.domainName
                },
                name: sMiV.name,
                majorVersion: sMiV.majorVersion,
                minorVersion: sMiV.minorVersion,
                patchVersion: MAX(sMiV.patchVersion),
            },
            GROUP_BY: [
                sMiV.index,
                sMiV.domainId,
                sMiV.domainName,
                sMiV.name,
                sMiV.majorVersion,
                sMiV.minorVersion
            ]
        });
        for (const applicationLookupRecord of applicationLookupRecords) {
            this.datastructureUtils.ensureChildJsMap(maxVersionedMapByApplicationAndDomain_Names, applicationLookupRecord.domain.name)
                .set(applicationLookupRecord.name, applicationLookupRecord);
        }
        return maxVersionedMapByApplicationAndDomain_Names;
    }
    async setStatusByIndexes(indexes, status) {
        let s;
        await this.db.updateWhere({
            UPDATE: s = Q_airport____at_airport_slash_airspace.Application,
            SET: {
                status
            },
            WHERE: s.index.IN(indexes)
        });
    }
    async findMapByFullNames(fullApplication_Names) {
        const mapByFullName = new Map();
        let s;
        const records = await this.db.find.tree({
            SELECT: {},
            FROM: [
                s = Q_airport____at_airport_slash_airspace.Application
            ],
            WHERE: s.fullName.IN(fullApplication_Names)
        });
        for (const record of records) {
            mapByFullName.set(record.fullName, record);
        }
        return mapByFullName;
    }
    async findByDomain_NamesAndApplication_Names(domainNames, applicationNames) {
        let s;
        let d;
        return await this.db.find.tree({
            SELECT: {
                index: Y,
                domain: {
                    _localId: Y,
                    name: Y
                },
                fullName: Y,
                name: Y
            },
            FROM: [
                s = Q_airport____at_airport_slash_airspace.Application,
                d = s.domain.INNER_JOIN()
            ],
            WHERE: AND(d.name.IN(domainNames), s.name.IN(applicationNames))
        });
    }
    async findOneByDomain_NameAndApplication_Name(domainName, applicationName) {
        let s;
        let d;
        return await this.db.findOne.tree({
            SELECT: {
                domain: {
                    name: Y
                },
                fullName: Y,
                index: Y,
                name: Y
            },
            FROM: [
                s = Q_airport____at_airport_slash_airspace.Application,
                d = s.domain.INNER_JOIN()
            ],
            WHERE: AND(d.name.equals(domainName), s.name.equals(applicationName))
        });
    }
    async findByIndex(index) {
        let a;
        return await this.db.findOne.tree({
            SELECT: {
                ...ALL_FIELDS,
                domain: {}
            },
            FROM: [
                a = Q_airport____at_airport_slash_airspace.Application,
                a.domain.INNER_JOIN()
            ],
            WHERE: a.index.equals(index)
        });
    }
    async insert(applications, context) {
        let a;
        const VALUES = [];
        for (const application of applications) {
            VALUES.push([
                application.index, application.domain._localId, application.scope,
                application.fullName, application.name,
                // application.packageName,
                application.status, application.signature
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: a = Q_airport____at_airport_slash_airspace.Application,
            columns: [
                a.index,
                a.domain._localId,
                a.scope,
                a.fullName,
                a.name,
                // a.packageName,
                a.status,
                a.signature
            ],
            VALUES
        }, context);
    }
}

class ApplicationEntityDao extends BaseApplicationEntityDao {
    async findAllForApplicationVersions(applicationVersionIds) {
        let se;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                se = Q_airport____at_airport_slash_airspace.ApplicationEntity
            ],
            WHERE: se.applicationVersion._localId.IN(applicationVersionIds)
        });
    }
    async insert(applicationEntities, context) {
        let se;
        const VALUES = [];
        for (const applicationEntity of applicationEntities) {
            VALUES.push([
                applicationEntity._localId, applicationEntity.index,
                applicationEntity.isLocal, applicationEntity.isAirEntity,
                applicationEntity.name, applicationEntity.tableConfig,
                applicationEntity.applicationVersion._localId,
                applicationEntity.deprecatedSinceVersion ? applicationEntity.deprecatedSinceVersion._localId : null,
                applicationEntity.removedInVersion ? applicationEntity.removedInVersion._localId : null,
                applicationEntity.sinceVersion ? applicationEntity.sinceVersion._localId : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: se = Q_airport____at_airport_slash_airspace.ApplicationEntity,
            columns: [
                se._localId,
                se.index,
                se.isLocal,
                se.isAirEntity,
                se.name,
                se.tableConfig,
                se.applicationVersion._localId,
                se.deprecatedSinceVersion._localId,
                se.removedInVersion._localId,
                se.sinceVersion._localId
            ],
            VALUES
        }, context);
    }
}

class ApplicationPropertyColumnDao extends BaseApplicationPropertyColumnDao {
    async findAllForColumns(columnIds) {
        let rc;
        return this.db.find.tree({
            SELECT: {},
            FROM: [
                rc = Q_airport____at_airport_slash_airspace.ApplicationPropertyColumn
            ],
            WHERE: rc.column._localId.IN(columnIds)
        });
    }
    async insert(applicationPropertyColumns, context) {
        let spc;
        const VALUES = [];
        for (const applicationPropertyColumn of applicationPropertyColumns) {
            VALUES.push([
                applicationPropertyColumn.column._localId, applicationPropertyColumn.property._localId,
                applicationPropertyColumn.deprecatedSinceVersion ? applicationPropertyColumn.deprecatedSinceVersion._localId : null,
                applicationPropertyColumn.removedInVersion ? applicationPropertyColumn.removedInVersion._localId : null,
                applicationPropertyColumn.sinceVersion ? applicationPropertyColumn.sinceVersion._localId : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: spc = Q_airport____at_airport_slash_airspace.ApplicationPropertyColumn,
            columns: [
                spc.column._localId,
                spc.property._localId,
                spc.deprecatedSinceVersion._localId,
                spc.removedInVersion._localId,
                spc.sinceVersion._localId
            ],
            VALUES
        }, context);
    }
}

class ApplicationPropertyDao extends BaseApplicationPropertyDao {
    async findAllForEntities(entityIds) {
        let p;
        return this.db.find.tree({
            SELECT: {},
            FROM: [
                p = Q_airport____at_airport_slash_airspace.ApplicationProperty
            ],
            WHERE: p.entity._localId.IN(entityIds)
        });
    }
    async insert(applicationProperties, context) {
        let sp;
        const VALUES = [];
        for (const applicationProperty of applicationProperties) {
            VALUES.push([
                applicationProperty._localId, applicationProperty.index,
                applicationProperty.name, applicationProperty.isId,
                applicationProperty.entity._localId,
                applicationProperty.deprecatedSinceVersion ? applicationProperty.deprecatedSinceVersion._localId : null,
                applicationProperty.removedInVersion ? applicationProperty.removedInVersion._localId : null,
                applicationProperty.sinceVersion ? applicationProperty.sinceVersion._localId : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: sp = Q_airport____at_airport_slash_airspace.ApplicationProperty,
            columns: [
                sp._localId,
                sp.index,
                sp.name,
                sp.isId,
                sp.entity._localId,
                sp.deprecatedSinceVersion._localId,
                sp.removedInVersion._localId,
                sp.sinceVersion._localId
            ],
            VALUES
        }, context);
    }
}

class ApplicationReferenceDao extends BaseApplicationReferenceDao {
    async findAllForApplicationVersions(applicationVersionIds) {
        let sr;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                sr = Q_airport____at_airport_slash_airspace.ApplicationReference
            ],
            WHERE: sr.ownApplicationVersion._localId.IN(applicationVersionIds)
        });
    }
    async insert(applicationReferences, context) {
        let sr;
        const VALUES = [];
        for (const applicationReference of applicationReferences) {
            VALUES.push([
                applicationReference.ownApplicationVersion._localId,
                applicationReference.referencedApplicationVersion._localId,
                applicationReference.index,
                applicationReference.deprecatedSinceVersion ? applicationReference.deprecatedSinceVersion._localId : null,
                applicationReference.removedInVersion ? applicationReference.removedInVersion._localId : null,
                applicationReference.sinceVersion ? applicationReference.sinceVersion._localId : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: sr = Q_airport____at_airport_slash_airspace.ApplicationReference,
            columns: [
                sr.ownApplicationVersion._localId,
                sr.referencedApplicationVersion._localId,
                sr.index,
                sr.deprecatedSinceVersion._localId,
                sr.removedInVersion._localId,
                sr.sinceVersion._localId
            ],
            VALUES
        }, context);
    }
}

class ApplicationRelationColumnDao extends BaseApplicationRelationColumnDao {
    async findAllForColumns(columnIds) {
        let rc;
        return this.db.find.tree({
            SELECT: {},
            FROM: [
                rc = Q_airport____at_airport_slash_airspace.ApplicationRelationColumn
            ],
            WHERE: OR(rc.oneColumn._localId.IN(columnIds), rc.manyColumn._localId.IN(columnIds))
        });
    }
    async insert(applicationRelationColumns, context) {
        let src;
        const VALUES = [];
        for (const applicationRelationColumn of applicationRelationColumns) {
            VALUES.push([
                applicationRelationColumn._localId,
                applicationRelationColumn.manyColumn ? applicationRelationColumn.manyColumn._localId : null,
                applicationRelationColumn.oneColumn ? applicationRelationColumn.oneColumn._localId : null,
                applicationRelationColumn.manyRelation ? applicationRelationColumn.manyRelation._localId : null,
                applicationRelationColumn.oneRelation ? applicationRelationColumn.oneRelation._localId : null,
                applicationRelationColumn.parentRelation ? applicationRelationColumn.parentRelation._localId : null,
                applicationRelationColumn.deprecatedSinceVersion ? applicationRelationColumn.deprecatedSinceVersion._localId : null,
                applicationRelationColumn.removedInVersion ? applicationRelationColumn.removedInVersion._localId : null,
                applicationRelationColumn.sinceVersion ? applicationRelationColumn.sinceVersion._localId : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: src = Q_airport____at_airport_slash_airspace.ApplicationRelationColumn,
            columns: [
                src._localId,
                src.manyColumn._localId,
                src.oneColumn._localId,
                src.manyRelation._localId,
                src.oneRelation._localId,
                src.parentRelation._localId,
                src.deprecatedSinceVersion._localId,
                src.removedInVersion._localId,
                src.sinceVersion._localId
            ],
            VALUES
        }, context);
    }
}

class ApplicationRelationDao extends BaseApplicationRelationDao {
    async findAllForProperties(propertyIds) {
        let r;
        return this.db.find.tree({
            SELECT: {},
            FROM: [
                r = Q_airport____at_airport_slash_airspace.ApplicationRelation
            ],
            WHERE: r.property._localId.IN(propertyIds)
        });
    }
    async findAllByLocalIdsWithApplications(localIds) {
        let r, e, av, a;
        return this.db.find.tree({
            SELECT: {
                _localId: Y,
                entity: {
                    applicationVersion: {
                        application: {
                            domain: {
                                name: Y
                            },
                            name: Y
                        },
                        integerVersion: Y
                    }
                }
            },
            FROM: [
                r = Q_airport____at_airport_slash_airspace.ApplicationRelation,
                e = r.entity.LEFT_JOIN(),
                av = e.applicationVersion.LEFT_JOIN(),
                a = av.application.LEFT_JOIN(),
                a.domain.LEFT_JOIN()
            ],
            WHERE: r._localId.IN(localIds)
        });
    }
    async insert(applicationRelations, context) {
        let sr;
        const VALUES = [];
        for (const applicationRelation of applicationRelations) {
            VALUES.push([
                applicationRelation._localId, applicationRelation.index,
                applicationRelation.property._localId,
                this.datastructureUtils.undefinedToNull(applicationRelation.foreignKey),
                this.datastructureUtils.undefinedToNull(applicationRelation.manyToOneElems),
                this.datastructureUtils.undefinedToNull(applicationRelation.oneToManyElems),
                applicationRelation.relationType, applicationRelation.isId,
                applicationRelation.entity._localId, applicationRelation.relationEntity._localId,
                applicationRelation.deprecatedSinceVersion ? applicationRelation.deprecatedSinceVersion._localId : null,
                applicationRelation.removedInVersion ? applicationRelation.removedInVersion._localId : null,
                applicationRelation.sinceVersion ? applicationRelation.sinceVersion._localId : null,
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: sr = Q_airport____at_airport_slash_airspace.ApplicationRelation,
            columns: [
                sr._localId,
                sr.index,
                sr.property._localId,
                sr.foreignKey,
                sr.manyToOneElems,
                sr.oneToManyElems,
                sr.relationType,
                sr.isId,
                sr.entity._localId,
                sr.relationEntity._localId,
                sr.deprecatedSinceVersion._localId,
                sr.removedInVersion._localId,
                sr.sinceVersion._localId
            ],
            VALUES
        }, context);
    }
}

class ApplicationVersionDao extends BaseApplicationVersionDao {
    /*
    async findAllLatestForApplication_Indexes(
        applicationIndexes: Application_Index[]
    ): Promise<DbApplicationVersion[]> {
        let sv: QAppVersion

        return await this.db.find.tree({
            FROM: [
                sv = Q.ApplicationVersion
            ],
            SELECT: {},
            WHERE: AND(
                sv._localId.IN(this._localIdsForMaxVersionSelect()),
                sv.application.index.IN(applicationIndexes)
            )
        })
    }
    */
    async findAllActiveOrderByApplication_IndexAndId() {
        let av, a;
        return await this.db.find.tree({
            FROM: [
                av = Q_airport____at_airport_slash_airspace.ApplicationVersion,
                a = av.application.INNER_JOIN()
            ],
            SELECT: {},
            ORDER_BY: [
                a.index.ASC(),
                av._localId.DESC()
            ]
        });
    }
    async findByDomain_NamesAndApplication_Names(domainNames, applicationNames) {
        let av;
        let a;
        let d;
        return await this.db.find.tree({
            SELECT: {
                _localId: Y,
                integerVersion: Y,
                application: {
                    domain: {
                        name: Y
                    },
                    fullName: Y,
                    name: Y
                }
            },
            FROM: [
                av = Q_airport____at_airport_slash_airspace.ApplicationVersion,
                a = av.application.INNER_JOIN(),
                d = a.domain.INNER_JOIN()
            ],
            WHERE: AND(d.name.IN(domainNames), a.name.IN(applicationNames)),
            ORDER_BY: [
                d.name.DESC(),
                a.name.DESC()
            ]
        });
    }
    /*
    async findMaxVersionedMapByApplicationAndDomain_Names(
        applicationDomain_Names: Domain_Name[],
        applicationNames: Application_Name[]
    ): Promise<Map<Domain_Name, Map<Application_Name, DbApplicationVersion>>> {
        const maxVersionedMapByApplicationAndDomain_Names
                  : Map<Domain_Name, Map<Application_Name, DbApplicationVersion>>
                  = new Map()

        let sv: QAppVersion
        let s: QApp
        let d: QDomain

        const maxApplicationVersions: DbApplicationVersion[] = <any>await this.db.find.tree({
            SELECT: {
                integerVersion: Y,
                majorVersion: Y,
                minorVersion: Y,
                patchVersion: Y,
                application: {
                    index: Y,
                    name: Y,
                    domain: {
                        _localId: Y,
                        name: Y
                    }
                },
                _localId: Y
            },
            FROM: [
                sv = Q.ApplicationVersion,
                s = sv.application.INNER_JOIN(),
                d = s.domain.INNER_JOIN()
            ],
            WHERE: AND(
                sv._localId.IN(this._localIdsForMaxVersionSelect()),
                d.name.IN(applicationDomain_Names),
                s.name.IN(applicationNames)
            ),
        })

        for (const maxApplicationVersion of maxApplicationVersions) {
            const application = maxApplicationVersion.application
            this.utils.ensureChildJsMap(
                maxVersionedMapByApplicationAndDomain_Names, application.domain.name)
                .set(application.name, maxApplicationVersion)
        }


        return maxVersionedMapByApplicationAndDomain_Names
    }

    private idsForMaxVersionSelect(): RawFieldQuery<IQNumberField> {
        let svMax
        let sv2: QAppVersion

        return field({
            FROM: [
                svMax = tree({
                    FROM: [
                        sv2 = Q.ApplicationVersion
                    ],
                    SELECT: DISTINCT({
                        integerVersion: max(sv2.integerVersion),
                        _localId: sv2._localId,
                        applicationIndex: sv2.application.index
                    })
                })
            ],
            SELECT: svMax._localId
        })
    }
*/
    async insert(applicationVersions, context) {
        let sv;
        const VALUES = [];
        for (const applicationVersion of applicationVersions) {
            VALUES.push([
                applicationVersion._localId, applicationVersion.integerVersion,
                applicationVersion.versionString, applicationVersion.majorVersion,
                applicationVersion.minorVersion, applicationVersion.patchVersion,
                applicationVersion.application.index, applicationVersion.jsonApplication
            ]);
        }
        await this.db.insertValuesGenerateIds({
            INSERT_INTO: sv = Q_airport____at_airport_slash_airspace.ApplicationVersion,
            columns: [
                sv._localId,
                sv.integerVersion,
                sv.versionString,
                sv.majorVersion,
                sv.minorVersion,
                sv.patchVersion,
                sv.application.index,
                sv.jsonApplication
            ],
            VALUES: VALUES
        }, context);
    }
}

const application$5 = {
    name: '@airport/airspace',
    domain: {
        name: 'airport'
    }
};

const airspace = app(application$5);
airspace.register(DomainDao, ApplicationColumnDao, ApplicationDao, ApplicationEntityDao, ApplicationPropertyColumnDao, ApplicationPropertyDao, ApplicationReferenceDao, ApplicationRelationColumnDao, ApplicationRelationDao, ApplicationVersionDao);
airspace.setDependencies(ApplicationColumnDao, {
    datastructureUtils: DatastructureUtils
});
airspace.setDependencies(ApplicationDao, {
    airportDatabase: AIRPORT_DATABASE,
    datastructureUtils: DatastructureUtils
});

var IsolateMessageType;
(function (IsolateMessageType) {
    IsolateMessageType["ADD_REPOSITORY"] = "ADD_REPOSITORY";
    IsolateMessageType["APP_INITIALIZING"] = "APP_INITIALIZING";
    IsolateMessageType["APP_INITIALIZED"] = "APP_INITIALIZED";
    IsolateMessageType["CALL_API"] = "CALL_API";
    IsolateMessageType["DELETE_WHERE"] = "DELETE_WHERE";
    IsolateMessageType["FIND"] = "FIND";
    IsolateMessageType["FIND_ONE"] = "FIND_ONE";
    IsolateMessageType["GET_LATEST_APPLICATION_VERSION_BY_APPLICATION_NAME"] = "GET_LATEST_APPLICATION_VERSION_BY_APPLICATION_NAME";
    IsolateMessageType["INSERT_VALUES"] = "INSERT_VALUES";
    IsolateMessageType["INSERT_VALUES_GET_IDS"] = "INSERT_VALUES_GET_IDS";
    IsolateMessageType["RETRIEVE_DOMAIN"] = "RETRIEVE_DOMAIN";
    IsolateMessageType["SEARCH"] = "SEARCH";
    IsolateMessageType["SEARCH_ONE"] = "SEARCH_ONE";
    IsolateMessageType["SEARCH_UNSUBSCRIBE"] = "UNSUBSCRIBE";
    IsolateMessageType["SAVE"] = "SAVE";
    IsolateMessageType["SAVE_TO_DESTINATION"] = "SAVE_TO_DESTINATION";
    IsolateMessageType["UPDATE_VALUES"] = "UPDATE_VALUES";
})(IsolateMessageType || (IsolateMessageType = {}));

/**
 * Created by Papa on 4/16/2017.
 */
var AirEntityType;
(function (AirEntityType) {
    AirEntityType["NOT_AIR_ENTITY"] = "NOT_AIR_ENTITY";
    AirEntityType["AIR_ENTITY"] = "AIR_ENTITY";
})(AirEntityType || (AirEntityType = {}));

var AppState;
(function (AppState) {
    AppState["NOT_INITIALIED"] = "NOT_INITIALIED";
    AppState["START_INITIALIZING"] = "START_INITIALIZING";
    AppState["INITIALIZING_IN_PROGRESS"] = "INITIALIZING_IN_PROGRESS";
    AppState["INITIALIZED"] = "INITIALIZED";
})(AppState || (AppState = {}));

class TerminalState {
    init() {
        this.terminalState = globalThis.internalTerminalState;
        let subscription = this.terminalState.subscribe((theState) => {
            setTimeout(() => {
                this.terminalState.next({
                    ...theState,
                    internalConnector: {
                        ...theState.internalConnector,
                        internalCredentials: {
                            ...theState.internalConnector.internalCredentials,
                            domain: this.appTrackerUtils.getInternalDomain()
                        }
                    }
                });
                subscription.unsubscribe();
            }, 10);
        });
    }
}

class TerminalStore {
    get state() {
        return this.terminalState.terminalState;
    }
    async init() {
        this.getTerminalState = this.selectorManager.createRootSelector(this.state);
        this.getApplicationActors = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.applicationActors);
        this.getApplicationInitializer = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.applicationInitializer);
        this.getApplicationActorMapByDomainAndApplication_Names = this.selectorManager.createSelector(this.getApplicationActors, applicationActors => {
            const applicationActorsByDomainAndApplication_Names = new Map();
            for (const applicationActor of applicationActors) {
                const applicationActorMapForDomain = this.datastructureUtils.ensureChildJsMap(applicationActorsByDomainAndApplication_Names, applicationActor.application.domain.name);
                let actorsForApplication = applicationActorMapForDomain
                    .get(applicationActor.application.name);
                if (!actorsForApplication) {
                    actorsForApplication = [];
                    applicationActorMapForDomain.set(applicationActor.application.name, actorsForApplication);
                }
                actorsForApplication.push(applicationActor);
            }
            return applicationActorsByDomainAndApplication_Names;
        });
        this.getDomains = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.domains);
        this.getDomainMapByName = this.selectorManager.createSelector(this.getDomains, domains => {
            const domainsByName = new Map();
            for (const domain of domains) {
                domainsByName.set(domain.name, domain);
            }
            return domainsByName;
        });
        this.getFrameworkActor = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.frameworkActor);
        this.getInternalConnector = this.selectorManager.createSelector(this.getTerminalState, terminalState => terminalState.internalConnector);
        this.getIsServer = this.selectorManager.createSelector(this.getTerminalState, terminalState => terminalState.isServer);
        this.getLastIds = this.selectorManager.createSelector(this.getTerminalState, terminalState => terminalState.lastIds);
        this.getLatestApplicationVersionMapByNames = this.selectorManager.createSelector(this.getDomains, domains => {
            const latestApplicationVersionMapByNames = new Map();
            for (const domain of domains) {
                const mapForDomain = this.datastructureUtils.ensureChildJsMap(latestApplicationVersionMapByNames, domain.name);
                for (const application of domain.applications) {
                    mapForDomain.set(application.name, application.currentVersion[0].applicationVersion);
                }
            }
            return latestApplicationVersionMapByNames;
        });
        this.getLatestApplicationVersionMapByApplication_FullName = this.selectorManager.createSelector(this.getLatestApplicationVersionMapByNames, (latestApplicationVersionMapByNames) => {
            const latestApplicationVersionMapByApplication_FullName = new Map();
            for (const applicationVersionsForDomain_Name of latestApplicationVersionMapByNames.values()) {
                for (const applicationVersion of applicationVersionsForDomain_Name.values()) {
                    latestApplicationVersionMapByApplication_FullName.set(applicationVersion.application.fullName, applicationVersion);
                }
            }
            return latestApplicationVersionMapByApplication_FullName;
        });
        this.getAllApplicationVersionsByIds = this.selectorManager.createSelector(this.getDomains, domains => {
            const allApplicationVersionsByIds = [];
            for (const domain of domains) {
                for (const application of domain.applications) {
                    for (const applicationVersion of application.versions) {
                        allApplicationVersionsByIds[applicationVersion._localId] = applicationVersion;
                    }
                }
            }
            return allApplicationVersionsByIds;
        });
        this.getLatestApplicationVersionsByApplication_Indexes = this.selectorManager.createSelector(this.getDomains, domains => {
            const latestApplicationVersionsByApplication_Indexes = [];
            for (const domain of domains) {
                for (const application of domain.applications) {
                    latestApplicationVersionsByApplication_Indexes[application.index]
                        = application.currentVersion[0].applicationVersion;
                }
            }
            return latestApplicationVersionsByApplication_Indexes;
        });
        this.getApplicationMapByFullName = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.applicationMapByFullName);
        this.getApplications = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.applications);
        this.getAllEntities = this.selectorManager.createSelector(this.getLatestApplicationVersionsByApplication_Indexes, latestApplicationVersionsByApplication_Indexes => {
            const allEntities = [];
            for (const latestApplicationVersion of latestApplicationVersionsByApplication_Indexes) {
                if (!latestApplicationVersion) {
                    continue;
                }
                for (const entity of latestApplicationVersion.entities) {
                    allEntities[entity._localId] = entity;
                }
            }
            return allEntities;
        });
        this.getAllColumns = this.selectorManager.createSelector(this.getAllEntities, allEntities => {
            const allColumns = [];
            for (const entity of allEntities) {
                if (!entity) {
                    continue;
                }
                for (const column of entity.columns) {
                    allColumns[column._localId] = column;
                }
            }
            return allColumns;
        });
        this.getAllRelations = this.selectorManager.createSelector(this.getAllEntities, allEntities => {
            const allRelations = [];
            for (const entity of allEntities) {
                if (!entity) {
                    continue;
                }
                for (const relation of entity.relations) {
                    allRelations[relation._localId] = relation;
                }
            }
            return allRelations;
        });
        this.getReceiver = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.receiver);
        this.getSequenceGenerator = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.sequenceGenerator);
        this.getTerminal = this.selectorManager.createSelector(this.getTerminalState, terminalState => terminalState.terminal);
        this.getTransactionManager = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.transactionManager);
        this.getWebReceiver = this.selectorManager.createSelector(this.getTerminalState, terminal => terminal.webReceiver);
    }
    tearDown() {
    }
}

/**
 * For logic classes to be hot-swappable for quick upgrades all state is contained
 * in one non-reloadable BehaviorSubject.
 */
globalThis.internalTerminalState = new BehaviorSubject({
    applicationActors: [],
    applicationInitializer: {
        applicationWindowMap: new Map(),
        initializingApplicationMap: new Map()
    },
    applicationMapByFullName: new Map(),
    applications: [],
    domains: [],
    frameworkActor: null,
    internalConnector: {
        dbName: '',
        internalCredentials: {
            application: null,
            domain: null,
            methodName: null,
            objectName: null
        },
        serverUrl: ''
    },
    isServer: false,
    lastIds: {
        columns: 0,
        domains: 0,
        entities: 0,
        properties: 0,
        relations: 0,
        relationColumns: 0,
        applications: 0,
        applicationVersions: 0
    },
    receiver: {
        initializedApps: new Set(),
        initializingApps: new Set(),
    },
    sequenceGenerator: {
        sequences: [],
        sequenceBlocks: [],
        generatingSequenceNumbers: false
    },
    terminal: null,
    transactionManager: {
        pendingTransactionQueue: [],
        rootTransactionInProgressMap: new Map(),
        transactionInProgressMap: new Map()
    },
    webReceiver: {
        domainPrefix: '',
        localDomain: '',
        mainDomainFragments: [],
        onClientMessageCallback: null,
        pendingApplicationCounts: new Map(),
        pendingHostCounts: new Map(),
        pendingInterAppApiCallMessageMap: new Map(),
        subsriptionMap: new Map()
    }
});

const internalUserState = new BehaviorSubject({
    allSessions: [],
    sessionMapByAccountPublicSigningKey: new Map()
});

class UserState {
    constructor() {
        this.userState = internalUserState;
    }
}

class UserStore {
    get state() {
        return this.userState.userState;
    }
    async init() {
        this.getUserState = this.selectorManager.createRootSelector(this.state);
        this.getAllSessions = this.selectorManager.createSelector(this.getUserState, userState => userState.allSessions);
        this.getSessionMapByAccountPublicSigningKey = this.selectorManager.createSelector(this.getUserState, userState => userState.sessionMapByAccountPublicSigningKey);
    }
}

class SelectorManager {
    createSelector(...args) {
        if (args.length < 2 || args.length > 6) {
            throw new Error(`Invalid createSelector call, Expecting 1 to 5 selectors and a callback.`);
        }
        const inputSelectors = args.slice(0, args.length - 1);
        const callback = args[args.length - 1];
        let sourceObservable;
        if (inputSelectors.length > 1) {
            // TODO: check if this will work
            sourceObservable = from(inputSelectors.map(selector => selector.observable));
        }
        else {
            sourceObservable = inputSelectors[0].observable;
        }
        let observable = sourceObservable.pipe(
        // share() TODO: implement once RxJs support is added
        distinctUntilChanged(), map(value => callback(value)));
        return this.getSelector(observable);
    }
    createRootSelector(stateObservable) {
        return this.getSelector(stateObservable);
    }
    getSelector(observable) {
        let selector = (function (
        // otherStateObservable?: Observable<SV>
        ) {
            let currentValue;
            observable.subscribe(value => currentValue = value).unsubscribe();
            return currentValue;
        });
        selector.observable = observable;
        return selector;
    }
}

class AbstractApplicationLoader {
    constructor(application) {
        this.application = application;
        this.initializing = false;
    }
    async load(lastIds) {
        if (this.initializing) {
            return;
        }
        this.initializing = true;
        const lastTerminalState = this.terminalStore.getTerminalState();
        this.terminalStore.state.next({
            ...lastTerminalState,
            lastIds
        });
        await this.applicationInitializer.initializeForAIRportApp(this.application);
        this.apiRegistry.initialize(this.application.versions[0].api);
    }
    async initialize() {
    }
    getApplication() {
        return this.application;
    }
}

const terminalMap = lib('terminal-map');
terminalMap.register(SelectorManager, TerminalState, TerminalStore, UserState, UserStore);
const APPLICATION_LOADER = terminalMap.token('ApplicationLoader');
const APPLICATION_INITIALIZER = terminalMap.token('ApplicationInitializer');
const DOMAIN_RETRIEVER = terminalMap.token('DomainRetriever');
const HISTORY_MANAGER = terminalMap.token('HistoryManager');
const LOCAL_API_SERVER = terminalMap.token('LocalAPIServer');
const STORE_DRIVER = terminalMap.token('StoreDriver');
const TERMINAL_SESSION_MANAGER = terminalMap.token('TerminalSessionManager');
const TRANSACTION_MANAGER = terminalMap.token('TransactionManager');
const TRANSACTIONAL_RECEIVER = terminalMap.token('TransactionalReceiver');
const TRANSACTIONAL_SERVER = terminalMap.token('TransactionalServer');
APPLICATION_INITIALIZER.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    sequenceGenerator: SEQUENCE_GENERATOR,
    terminalStore: TerminalStore
});
DOMAIN_RETRIEVER.setDependencies({
    transactionalConnector: TRANSACTIONAL_CONNECTOR
});
terminalMap.setDependencies(TerminalState, {
    appTrackerUtils: AppTrackerUtils
});
terminalMap.setDependencies(TerminalStore, {
    datastructureUtils: DatastructureUtils,
    selectorManager: SelectorManager,
    terminalState: TerminalState
});
TRANSACTION_MANAGER.setDependencies({
    storeDriver: STORE_DRIVER,
    terminalStore: TerminalStore
});
TRANSACTIONAL_RECEIVER.setDependencies({
    applicationInitializer: APPLICATION_INITIALIZER,
    dbApplicationUtils: DbApplicationUtils,
});
TRANSACTIONAL_SERVER.setDependencies({
    terminalStore: TerminalStore,
    transactionManager: TRANSACTION_MANAGER
});
terminalMap.setDependencies(UserStore, {
    selectorManager: SelectorManager,
    userState: UserState
});
APPLICATION_LOADER.setClass(AbstractApplicationLoader);
APPLICATION_LOADER.setDependencies({
    applicationInitializer: APPLICATION_INITIALIZER,
    terminalStore: TerminalStore,
    apiRegistry: API_REGISTRY,
});

class SqlSchemaBuilder {
    async build(jsonApplication, existingApplicationMap, newJsonApplicationMap, isFeatureApp, context) {
        await this.createApplication(jsonApplication, context);
        const jsonApplicationVersion = this.applicationReferenceUtils
            .getCurrentJsonApplicationVersion(jsonApplication);
        for (const jsonEntity of jsonApplicationVersion.entities) {
            await this.buildTable(jsonApplication, jsonApplicationVersion, jsonEntity, existingApplicationMap, context);
        }
        const relatedJsonApplicationMap = new Map();
        for (const jsonEntity of jsonApplicationVersion.entities) {
            await this.buildForeignKeys(jsonApplication, jsonApplicationVersion, jsonEntity, existingApplicationMap, newJsonApplicationMap, relatedJsonApplicationMap, context);
        }
        this.applicationReferenceUtils.checkFrameworkReferences(jsonApplication, (jsonApplication, jsonApplicationVersion, jsonRelation) => {
            return this.getRelationInfo(jsonApplication, jsonApplicationVersion, jsonRelation, existingApplicationMap, newJsonApplicationMap, relatedJsonApplicationMap);
        });
    }
    async buildTable(jsonApplication, jsonApplicationVersion, jsonEntity, existingApplicationMap, context) {
        const primaryKeyColumnNames = [];
        const tableColumnsDdl = jsonEntity.columns.map((jsonColumn) => {
            let columnDdl = `${jsonColumn.name} ${this.getColumnSuffix(jsonApplication, jsonEntity, jsonColumn)}`;
            if (this.isPrimaryKeyColumn(jsonEntity, jsonColumn)) {
                primaryKeyColumnNames.push(jsonColumn.name);
            }
            return columnDdl;
        });
        const createTableSuffix = this.getCreateTableSuffix(jsonApplication, jsonEntity);
        const tableName = this.storeDriver.getTableName(jsonApplication, jsonApplicationVersion.integerVersion, jsonEntity, context);
        let primaryKeySubStatement = ``;
        if (primaryKeyColumnNames.length) {
            primaryKeySubStatement = this.getPrimaryKeyStatement(primaryKeyColumnNames);
        }
        const createTableDdl = `CREATE TABLE ${tableName} (
		${tableColumnsDdl.join(',\n')}${primaryKeySubStatement}
		)${createTableSuffix}`;
        await this.storeDriver.query(QueryType.DDL, createTableDdl, [], context, false);
        let indexNumber = 0;
        if (jsonEntity.tableConfig.columnIndexes) {
            for (const indexConfig of jsonEntity.tableConfig.columnIndexes) {
                const createIndexDdl = this.getIndexSql('idx_' + tableName + '_' + (++indexNumber), tableName, indexConfig.columnList, indexConfig.unique);
                await this.storeDriver.query(QueryType.DDL, createIndexDdl, [], context, false);
            }
        }
        if (jsonEntity.tableConfig.propertyIndexes) {
            for (const indexConfig of jsonEntity.tableConfig.propertyIndexes) {
                const columnNameList = [];
                for (const jsonColumn of jsonEntity.columns) {
                    for (const propertyRef of jsonColumn.propertyRefs) {
                        if (propertyRef.index === indexConfig.propertyIndex) {
                            columnNameList.push(jsonColumn.name);
                            break;
                        }
                    }
                }
                const createIndexDdl = this.getIndexSql('idx_' + tableName + '_' + (++indexNumber), tableName, columnNameList, indexConfig.unique);
                await this.storeDriver.query(QueryType.DDL, createIndexDdl, [], context, false);
            }
        }
        //
    }
    getRelationInfo(jsonApplication, jsonApplicationVersion, jsonRelation, existingApplicationMap, newJsonApplicationMap, relatedJsonApplicationMap) {
        let relatedJsonApplication;
        let relatedJsonEntity;
        if (jsonRelation.relationTableApplication_Index
            || jsonRelation.relationTableApplication_Index === 0) {
            const referencedApplication = jsonApplicationVersion
                .referencedApplications[jsonRelation.relationTableApplication_Index];
            let relatedApplication_FullName = this.dbApplicationUtils
                .getApplication_FullNameFromDomainAndName(referencedApplication.domain, referencedApplication.name);
            relatedJsonApplication = relatedJsonApplicationMap.get(relatedApplication_FullName);
            if (!relatedJsonApplication) {
                const relatedApplication = existingApplicationMap.get(relatedApplication_FullName);
                if (relatedApplication) {
                    // FIXME: this should be looked up though currentVersion - make sure it's populated
                    // relatedJsonApplication = relatedApplication.currentVersion[0].applicationVersion.jsonApplication
                    relatedJsonApplication = relatedApplication.versions[0].jsonApplication;
                }
                else {
                    relatedJsonApplication = newJsonApplicationMap.get(relatedApplication_FullName);
                }
                if (!relatedJsonApplication) {
                    throw new Error(`Could not find related application ${relatedApplication_FullName}
          in either existing applications or newly installing applications.`);
                }
                relatedJsonApplicationMap.set(relatedApplication_FullName, relatedJsonApplication);
            }
            const relatedApplicationVersion = relatedJsonApplication
                .versions[relatedJsonApplication.versions.length - 1];
            relatedJsonEntity = relatedApplicationVersion.entities[jsonRelation.relationTableIndex];
        }
        else {
            relatedJsonApplication = jsonApplication;
            relatedJsonEntity = jsonApplicationVersion.entities[jsonRelation.relationTableIndex];
        }
        return {
            relatedJsonApplication,
            relatedJsonEntity
        };
    }
    getApplicationVersion(jsonApplication) {
        return jsonApplication.versions[jsonApplication.versions.length - 1];
    }
    async buildForeignKeys(jsonApplication, jsonApplicationVersion, jsonEntity, existingApplicationMap, newJsonApplicationMap, relatedJsonApplicationMap, context) {
        if (!jsonEntity.relations || !jsonEntity.relations.length) {
            return;
        }
        const applicationVersion = this.getApplicationVersion(jsonApplication);
        const tableName = this.storeDriver.getTableName(jsonApplication, jsonApplicationVersion.integerVersion, jsonEntity, context);
        for (const jsonRelation of jsonEntity.relations) {
            if (jsonRelation.relationType !== EntityRelationType.MANY_TO_ONE) {
                continue;
            }
            const { relatedJsonApplication, relatedJsonEntity } = this.getRelationInfo(jsonApplication, applicationVersion, jsonRelation, existingApplicationMap, newJsonApplicationMap, relatedJsonApplicationMap);
            let foreignKeyColumnNames = [];
            for (const jsonColumn of jsonEntity.columns) {
                for (const propertyRef of jsonColumn.propertyRefs) {
                    if (propertyRef.index === jsonRelation.propertyRef.index) {
                        foreignKeyColumnNames.push(jsonColumn.name);
                        break;
                    }
                }
            }
            const referencedTableName = this.storeDriver
                .getTableName(relatedJsonApplication, applicationVersion.integerVersion, relatedJsonEntity, context);
            let referencedColumnNames = [];
            for (const relatedIdColumnRef of relatedJsonEntity.idColumnRefs) {
                referencedColumnNames.push(relatedJsonEntity.columns[relatedIdColumnRef.index].name);
            }
            const foreignKeySql = this.getForeignKeySql(tableName, 'fk_' + tableName + '_foreignKeyNumber', foreignKeyColumnNames, referencedTableName, referencedColumnNames);
            if (foreignKeySql) {
                await this.storeDriver.query(QueryType.DDL, foreignKeySql, [], context, false);
            }
        }
    }
    async buildForeignKeysForTable() {
    }
    isPrimaryKeyColumn(jsonEntity, jsonColumn) {
        return jsonColumn.propertyRefs.some((propertyRef) => {
            const jsonProperty = jsonEntity.properties[propertyRef.index];
            if (jsonProperty.isId) {
                return true;
            }
        });
    }
    /*
    protected abstract isForeignKey(
      jsonEntity: JsonApplicationEntity,
      jsonColumn: JsonApplicationColumn
    ): boolean
    */
    getPrimaryKeyStatement(columnNames) {
        return `,
			PRIMARY KEY (
			${columnNames.join(',\n')}
			)`;
    }
}

class ApplicationChecker {
    async check(jsonApplication) {
        if (!jsonApplication) {
            throw new Error(`Json Application not provided`);
        }
        if (!(jsonApplication.versions instanceof Array)) {
            throw new Error('application.versions is not an array');
        }
        if (jsonApplication.versions.length !== 1) {
            // FIXME: add support for application versioning
            throw new Error('Currently only 1 version of application is supported');
        }
        await this.checkDomain(jsonApplication);
    }
    async checkDomain(jsonApplication) {
        // TODO: implement domain checking
    }
    async checkDependencies(jsonApplications) {
        const allReferencedApplicationMap = new Map();
        const referencedApplicationMapByApplication = new Map();
        for (const jsonApplication of jsonApplications) {
            const lastJsonApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
            const referencedApplicationMapForApplication = this.datastructureUtils.ensureChildJsMap(this.datastructureUtils.ensureChildJsMap(referencedApplicationMapByApplication, jsonApplication.domain), jsonApplication.name);
            for (const jsonReferencedApplication of lastJsonApplicationVersion.referencedApplications) {
                this.datastructureUtils.ensureChildJsMap(allReferencedApplicationMap, jsonReferencedApplication.domain).set(jsonReferencedApplication.name, jsonReferencedApplication);
                this.datastructureUtils.ensureChildJsMap(referencedApplicationMapForApplication, jsonReferencedApplication.domain).set(jsonReferencedApplication.name, jsonReferencedApplication);
            }
        }
        this.pruneInGroupReferences(jsonApplications, allReferencedApplicationMap, referencedApplicationMapByApplication);
        await this.pruneReferencesToExistingApplications(jsonApplications, allReferencedApplicationMap, referencedApplicationMapByApplication);
        const applicationsWithValidDependencies = [];
        const applicationsInNeedOfAdditionalDependencies = [];
        const neededDependencies = [];
        for (const dependenciesForDomain of allReferencedApplicationMap.values()) {
            for (const dependency of dependenciesForDomain.values()) {
                neededDependencies.push(dependency);
            }
        }
        for (const jsonApplication of jsonApplications) {
            const referencedApplicationMapForApplication = referencedApplicationMapByApplication.get(jsonApplication.domain).get(jsonApplication.name);
            if (this.hasReferences(referencedApplicationMapForApplication)) {
                applicationsInNeedOfAdditionalDependencies.push(jsonApplication);
            }
            else {
                applicationsWithValidDependencies.push(jsonApplication);
            }
        }
        return {
            applicationsWithValidDependencies,
            applicationsInNeedOfAdditionalDependencies,
            neededDependencies
        };
    }
    pruneInGroupReferences(jsonApplications, allReferencedApplicationMap, referencedApplicationMapByApplication) {
        for (const jsonApplication of jsonApplications) {
            // Remove every in-group reference for this application
            for (const [_domainName, referenceMapForApplicationsOfDomain] of referencedApplicationMapByApplication) {
                for (const [_applicationName, applicationsReferencedByAGivenApplication] of referenceMapForApplicationsOfDomain) {
                    const applicationReferencesForDomain = applicationsReferencedByAGivenApplication.get(jsonApplication.domain);
                    if (applicationReferencesForDomain) {
                        applicationReferencesForDomain.delete(jsonApplication.name);
                    }
                }
            }
            const allApplicationReferencesForDomain = allReferencedApplicationMap.get(jsonApplication.domain);
            if (allApplicationReferencesForDomain) {
                allApplicationReferencesForDomain.delete(jsonApplication.name);
            }
        }
    }
    async pruneReferencesToExistingApplications(jsonApplications, allReferencedApplicationMap, referencedApplicationMapByApplication) {
        const existingApplicationInfo = await this.findExistingApplications(allReferencedApplicationMap);
        for (const applicationName of existingApplicationInfo.existingApplicationMapByName.keys()) {
            const coreDomainAndApplication_Names = existingApplicationInfo.coreDomainAndApplication_NamesByApplication_Name.get(applicationName);
            // Remove every reference for this existing application
            for (const referenceMapForApplicationsOfDomain of referencedApplicationMapByApplication.values()) {
                for (const applicationsReferencedByAGivenApplication of referenceMapForApplicationsOfDomain.values()) {
                    const applicationReferencesForDomain = applicationsReferencedByAGivenApplication.get(coreDomainAndApplication_Names.domain);
                    if (applicationReferencesForDomain) {
                        applicationReferencesForDomain.delete(coreDomainAndApplication_Names.application);
                    }
                }
            }
            const allApplicationReferencesForDomain = allReferencedApplicationMap.get(coreDomainAndApplication_Names.domain);
            if (allApplicationReferencesForDomain) {
                allApplicationReferencesForDomain.delete(coreDomainAndApplication_Names.application);
            }
        }
    }
    async findExistingApplications(allReferencedApplicationMap) {
        const fullApplication_Names = [];
        const coreDomainAndApplication_NamesByApplication_Name = new Map();
        for (const [domainName, allReferencedApplicationsForDomain] of allReferencedApplicationMap) {
            for (const [coreApplication_Name, referencedApplication] of allReferencedApplicationsForDomain) {
                const fullApplication_Name = this.dbApplicationUtils.
                    getApplication_FullName(referencedApplication);
                fullApplication_Names.push(fullApplication_Name);
                coreDomainAndApplication_NamesByApplication_Name.set(fullApplication_Name, {
                    domain: domainName,
                    application: coreApplication_Name
                });
            }
        }
        let existingApplicationMapByName;
        if (!fullApplication_Names.length) {
            existingApplicationMapByName = new Map();
        }
        else {
            existingApplicationMapByName = await this.applicationDao.findMapByFullNames(fullApplication_Names);
        }
        return {
            coreDomainAndApplication_NamesByApplication_Name,
            existingApplicationMapByName
        };
    }
    hasReferences(referencedApplicationMap) {
        for (const referencesForDomain of referencedApplicationMap.values()) {
            for (const _ of referencesForDomain) {
                return true;
            }
        }
        return false;
    }
}

class ApplicationLocator {
    // private terminalStore: ITerminalStore
    locateExistingApplicationVersionRecord(jsonApplication, terminalStore) {
        const applicationVersionsForDomain_Name = terminalStore
            .getLatestApplicationVersionMapByNames().get(jsonApplication.domain);
        if (!applicationVersionsForDomain_Name) {
            return null;
        }
        const fullApplication_Name = this.dbApplicationUtils.
            getApplication_FullNameFromDomainAndName(jsonApplication.domain, jsonApplication.name);
        const latestApplicationVersionForApplication = applicationVersionsForDomain_Name.get(fullApplication_Name);
        const jsonApplicationVersion = jsonApplication.versions[0];
        if (latestApplicationVersionForApplication
            && latestApplicationVersionForApplication.integerVersion !== jsonApplicationVersion.integerVersion) {
            throw new Error(`Multiple versions of applications are not yet supported`);
        }
        return latestApplicationVersionForApplication;
    }
    async locateLatestApplicationVersionByApplication_Name(fullApplication_Name, terminalStore) {
        return terminalStore.getLatestApplicationVersionMapByApplication_FullName()
            .get(fullApplication_Name);
    }
}

class ApplicationComposer {
    async compose(jsonApplications, context) {
        // NOTE: application name contains domain name as a prefix
        const jsonApplicationMapByFullName = new Map();
        const terminalStore = context.terminalStore;
        const allDomains = terminalStore.getDomains().slice();
        const domainMapByName = new Map();
        for (const domain of allDomains) {
            domainMapByName.set(domain.name, domain);
        }
        const allApplications = terminalStore.getApplications().slice();
        // NOTE: application fullName contains domain name as a prefix
        const applicationMapByFullName = new Map();
        for (const application of allApplications) {
            applicationMapByFullName.set(application.fullName, application);
        }
        const newLatestApplicationVersions = [];
        const newApplicationVersionMapByApplication_Name = new Map();
        const newEntitiesMapByApplication_Name = new Map();
        const newPropertiesMap = new Map();
        const newRelationsMap = new Map();
        const newColumnsMap = new Map();
        const added = {
            columns: [],
            domains: [],
            entities: [],
            latestApplicationVersions: [],
            properties: [],
            propertyColumns: [],
            relationColumns: [],
            relations: [],
            applicationReferences: [],
            applications: [],
            applicationVersions: []
        };
        const allApplicationVersionsByIds = [...terminalStore.getAllApplicationVersionsByIds()];
        const all = {
            columns: [],
            domains: [],
            entities: [],
            latestApplicationVersions: [],
            properties: [],
            propertyColumns: [],
            relationColumns: [],
            relations: [],
            applicationReferences: [],
            applications: [],
            applicationVersions: [] //
        };
        const allDdlObjects = {
            all,
            allApplicationVersionsByIds,
            added
        };
        for (const jsonApplication of jsonApplications) {
            jsonApplicationMapByFullName.set(this.dbApplicationUtils.
                getApplication_FullName(jsonApplication), jsonApplication);
            const domain = await this.composeDomain(jsonApplication.domain, allDomains, added.domains, domainMapByName);
            const application = this.composeApplication(domain, jsonApplication, allApplications, added.applications, applicationMapByFullName);
            this.composeApplicationVersion(jsonApplication, application, newLatestApplicationVersions, added.applicationVersions, newApplicationVersionMapByApplication_Name);
        }
        const { newApplicationReferenceMap, newApplicationReferences } = await this.composeApplicationReferences(jsonApplicationMapByFullName, newApplicationVersionMapByApplication_Name, terminalStore, allDdlObjects, context.deepTraverseReferences);
        added.applicationReferences = newApplicationReferences;
        for (const applicationVersion of allApplicationVersionsByIds) {
            if (applicationVersion) {
                this.addApplicationVersionObjects(applicationVersion, all);
            }
        }
        for (const jsonApplication of jsonApplications) {
            const fullApplication_Name = this.dbApplicationUtils.
                getApplication_FullName(jsonApplication);
            jsonApplicationMapByFullName.set(fullApplication_Name, jsonApplication);
            const domain = domainMapByName.get(jsonApplication.domain);
            const application = applicationMapByFullName.get(this.dbApplicationUtils.
                getApplication_FullName(jsonApplication));
            if (!application.index) {
                jsonApplication.lastIds = {
                    ...this.terminalStore.getLastIds()
                };
                application.index = ++this.terminalStore.getLastIds().applications;
            }
            if (!domain._localId) {
                domain._localId = ++this.terminalStore.getLastIds().domains;
            }
            const applicationVersion = newApplicationVersionMapByApplication_Name.get(application.fullName);
            if (!applicationVersion._localId) {
                applicationVersion._localId = ++this.terminalStore.getLastIds().applicationVersions;
                applicationVersion.jsonApplication = jsonApplication;
            }
            this.composeApplicationEntities(jsonApplication, applicationVersion, newEntitiesMapByApplication_Name, added.entities);
            this.composeApplicationProperties(jsonApplication, added.properties, newPropertiesMap, newEntitiesMapByApplication_Name);
            await this.composeApplicationRelations(jsonApplication, added.relations, newRelationsMap, newEntitiesMapByApplication_Name, newPropertiesMap, newApplicationReferenceMap, terminalStore, allDdlObjects);
            this.composeApplicationColumns(jsonApplication, added.columns, newColumnsMap, added.propertyColumns, newEntitiesMapByApplication_Name, newPropertiesMap);
            await this.composeApplicationRelationColumns(jsonApplication, added.relationColumns, newApplicationVersionMapByApplication_Name, newApplicationReferenceMap, newRelationsMap, newColumnsMap, terminalStore, allDdlObjects);
        }
        this.addObjects(allDdlObjects.added, allDdlObjects.all);
        for (const applicationVersion of allDdlObjects.all.applicationVersions) {
            allDdlObjects.allApplicationVersionsByIds[applicationVersion._localId] = applicationVersion;
        }
        return allDdlObjects;
    }
    async getExistingLatestApplicationVersion(referencedApplication_Name, allDdlObjects) {
        for (const latestApplicationVersion of allDdlObjects.all.latestApplicationVersions) {
            if (latestApplicationVersion.application.fullName == referencedApplication_Name) {
                return latestApplicationVersion;
            }
        }
        throw new Error(`Cannot find application "${referencedApplication_Name}".`);
    }
    addApplicationVersionObjects(applicationVersion, ddlObjects) {
        let foundDomain = false;
        for (const domain of ddlObjects.domains) {
            if (domain.name === applicationVersion.application.domain.name) {
                foundDomain = true;
                break;
            }
        }
        if (!foundDomain) {
            ddlObjects.domains.push(applicationVersion.application.domain);
        }
        let foundApplication = false;
        for (const application of ddlObjects.applications) {
            if (application.domain === applicationVersion.application.domain
                && application.name === applicationVersion.application.name) {
                foundApplication = true;
                break;
            }
        }
        if (!foundApplication) {
            ddlObjects.applications.push(applicationVersion.application);
        }
        ddlObjects.applicationVersions.push(applicationVersion);
        ddlObjects.latestApplicationVersions.push(applicationVersion);
        ddlObjects.applicationReferences = ddlObjects.applicationReferences
            .concat(applicationVersion.references);
        ddlObjects.entities = ddlObjects.entities.concat(applicationVersion.entities);
        for (const entity of applicationVersion.entities) {
            ddlObjects.columns = ddlObjects.columns.concat(entity.columns);
            ddlObjects.properties = ddlObjects.properties.concat(entity.properties);
            let entityPropertyColumns = [];
            for (const property of entity.properties) {
                entityPropertyColumns = entityPropertyColumns
                    .concat(property.propertyColumns);
            }
            ddlObjects.propertyColumns = ddlObjects.propertyColumns
                .concat(entityPropertyColumns);
            ddlObjects.relations = ddlObjects.relations.concat(entity.relations);
            let entityRelationColumns = [];
            for (const relation of entity.relations) {
                entityRelationColumns = entityRelationColumns
                    .concat(relation.manyRelationColumns);
            }
            ddlObjects.relationColumns = ddlObjects.relationColumns
                .concat(entityRelationColumns);
        }
    }
    addObjects(fromObjects, toObjects) {
        toObjects.columns = toObjects.columns.concat(fromObjects.columns);
        for (const fromDomain of fromObjects.domains) {
            let foundDomain = false;
            for (const toDomain of toObjects.domains) {
                if (toDomain.name === fromDomain.name) {
                    foundDomain = true;
                    break;
                }
            }
            if (!foundDomain) {
                toObjects.domains.push(fromDomain);
            }
        }
        toObjects.entities = toObjects.entities.concat(fromObjects.entities);
        toObjects.latestApplicationVersions = toObjects.latestApplicationVersions
            .concat(fromObjects.latestApplicationVersions);
        toObjects.properties = toObjects.properties.concat(fromObjects.properties);
        toObjects.propertyColumns = toObjects.propertyColumns
            .concat(fromObjects.propertyColumns);
        toObjects.relationColumns = toObjects.relationColumns
            .concat(fromObjects.relationColumns);
        toObjects.relations = toObjects.relations.concat(fromObjects.relations);
        for (const fromApplication of fromObjects.applications) {
            let foundApplication = false;
            for (const toApplication of toObjects.applications) {
                if (toApplication.domain === fromApplication.domain
                    && toApplication.name === fromApplication.name) {
                    foundApplication = true;
                    break;
                }
            }
            if (!foundApplication) {
                toObjects.applications.push(fromApplication);
            }
        }
        toObjects.applicationReferences = toObjects.applicationReferences
            .concat(fromObjects.applicationReferences);
        toObjects.applicationVersions = toObjects.applicationVersions
            .concat(fromObjects.applicationVersions);
    }
    async composeDomain(domainName, allDomains, newDomains, domainMapByName) {
        let domain = await this.domainRetriever.retrieveDomain(domainName, domainMapByName, allDomains, newDomains);
        if (!domain) {
            domain = {
                _localId: null,
                name: domainName,
                applications: []
            };
            allDomains.push(domain);
            newDomains.push(domain);
            domainMapByName.set(domainName, domain);
        }
        return domain;
    }
    composeApplication(domain, jsonApplication, allApplications, newApplications, applicationMapByFullName) {
        const fullApplication_Name = this.dbApplicationUtils.
            getApplication_FullName(jsonApplication);
        let application = applicationMapByFullName.get(fullApplication_Name);
        if (!application) {
            application = {
                domain,
                index: null,
                fullName: fullApplication_Name,
                name: jsonApplication.name,
                scope: 'public',
                signature: 'localhost',
                status: ApplicationStatus.CURRENT,
            };
            allApplications.push(application);
            newApplications.push(application);
            applicationMapByFullName.set(fullApplication_Name, application);
        }
        return application;
    }
    composeApplicationVersion(jsonApplication, application, newLatestApplicationVersions, newApplicationVersions, newApplicationVersionMapByApplication_Name) {
        // Application versions are guaranteed to be new
        let newApplicationVersion;
        for (const applicationVersion of jsonApplication.versions) {
            const versionParts = applicationVersion.versionString.split('.');
            newApplicationVersion = {
                _localId: null,
                integerVersion: applicationVersion.integerVersion,
                versionString: applicationVersion.versionString,
                majorVersion: parseInt(versionParts[0]),
                minorVersion: parseInt(versionParts[1]),
                patchVersion: parseInt(versionParts[2]),
                application,
                jsonApplication,
                entities: [],
                references: [],
                referencedBy: [],
                entityMapByName: {},
                referencesMapByName: {},
                referencedByMapByName: {},
            };
            if (application.versions) {
                application.versions.push(newApplicationVersion);
            }
            else {
                application.versions = [newApplicationVersion];
            }
            newApplicationVersions.push(newApplicationVersion);
        }
        let newApplicationCurrentVersion = {
            application,
            applicationVersion: newApplicationVersion
        };
        // needed for normalOperation only
        application.currentVersion = [newApplicationCurrentVersion];
        newLatestApplicationVersions.push(newApplicationVersion);
        newApplicationVersionMapByApplication_Name.set(application.fullName, newApplicationVersion);
        return newApplicationVersion;
    }
    async composeApplicationReferences(jsonApplicationMapByName, newApplicationVersionMapByApplication_Name, terminalStore, allDdlObjects, deepTraverseReferences) {
        const newApplicationReferenceMap = new Map();
        const newApplicationReferenceLookup = new Map();
        const newApplicationReferences = [];
        for (const [applicationName, ownApplicationVersion] of newApplicationVersionMapByApplication_Name) {
            const application = ownApplicationVersion.application;
            const jsonApplication = jsonApplicationMapByName.get(application.fullName);
            const lastJsonApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
            const applicationReferences = this.datastructureUtils.ensureChildArray(newApplicationReferenceMap, applicationName);
            const applicationReferenceLookup = this.datastructureUtils.ensureChildJsSet(newApplicationReferenceLookup, applicationName);
            for (const jsonReferencedApplication of lastJsonApplicationVersion.referencedApplications) {
                const referencedApplication_FullName = this.dbApplicationUtils.
                    getApplication_FullName(jsonReferencedApplication);
                let referencedApplicationVersion = newApplicationVersionMapByApplication_Name.get(referencedApplication_FullName);
                if (!referencedApplicationVersion) {
                    referencedApplicationVersion = await this.applicationLocator.locateLatestApplicationVersionByApplication_Name(referencedApplication_FullName, terminalStore);
                    if (!referencedApplicationVersion) {
                        throw new Error(`Could not locate application:
						${referencedApplication_FullName}
						in either existing applications or applications being currently processed`);
                    }
                    this.addApplicationVersionObjects(referencedApplicationVersion, allDdlObjects.all);
                    if (deepTraverseReferences) {
                        // This should cause another iteration over the outer loop to process newly added ApplicationVersion
                        jsonApplicationMapByName.set(referencedApplication_FullName, referencedApplicationVersion.jsonApplication);
                        newApplicationVersionMapByApplication_Name.set(referencedApplication_FullName, referencedApplicationVersion);
                    }
                }
                const applicationReference = {
                    index: jsonReferencedApplication.index,
                    ownApplicationVersion,
                    referencedApplicationVersion
                };
                if (!applicationReferenceLookup.has(jsonReferencedApplication.index)) {
                    applicationReferenceLookup.add(jsonReferencedApplication.index);
                    newApplicationReferences.push(applicationReference);
                    applicationReferences.push(applicationReference);
                }
            }
        }
        return {
            newApplicationReferenceMap,
            newApplicationReferences
        };
    }
    composeApplicationEntities(jsonApplication, applicationVersion, newEntitiesMapByApplication_Name, newEntities) {
        const applicationName = this.dbApplicationUtils.
            getApplication_FullName(jsonApplication);
        let index = 0;
        // TODO: verify that jsonApplication.versions is always ordered ascending
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const newApplicationEntities = [];
        for (const jsonEntity of jsonEntities) {
            const entity = {
                _localId: ++this.terminalStore.getLastIds().entities,
                index: index++,
                applicationVersion,
                isLocal: jsonEntity.isLocal,
                isAirEntity: jsonEntity.isAirEntity,
                name: jsonEntity.name,
                tableConfig: jsonEntity.tableConfig,
                // columns: [],
                // columnMap: {},
                // idColumns: [],
                // idColumnMap: {},
                // relations: [],
                // properties: [],
                // propertyMap: {}
            };
            // applicationVersion.entities.push(entity)
            newApplicationEntities.push(entity);
            newEntities.push(entity);
        }
        newEntitiesMapByApplication_Name.set(applicationName, newApplicationEntities);
        applicationVersion.entities = newApplicationEntities;
    }
    composeApplicationProperties(jsonApplication, newProperties, newPropertiesMap, newEntitiesMapByApplication_Name) {
        const applicationName = this.dbApplicationUtils.
            getApplication_FullName(jsonApplication);
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const entities = newEntitiesMapByApplication_Name.get(applicationName);
        const propertiesByEntityIndex = this.datastructureUtils.ensureChildArray(newPropertiesMap, applicationName);
        jsonEntities.forEach((jsonEntity, tableIndex) => {
            const entity = entities[tableIndex];
            const propertiesForEntity = [];
            propertiesByEntityIndex[tableIndex]
                = propertiesForEntity;
            let index = 0;
            for (const jsonProperty of jsonEntity.properties) {
                const property = {
                    _localId: ++this.terminalStore.getLastIds().properties,
                    index,
                    entity,
                    name: jsonProperty.name,
                    isId: jsonProperty.isId,
                };
                propertiesForEntity[index] = property;
                index++;
                newProperties.push(property);
            }
        });
    }
    async composeApplicationRelations(jsonApplication, newRelations, newRelationsMap, newEntitiesMapByApplication_Name, newPropertiesMap, newApplicationReferenceMap, terminalStore, allDdlObjects) {
        const applicationName = this.dbApplicationUtils.
            getApplication_FullName(jsonApplication);
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const entitiesForApplication = newEntitiesMapByApplication_Name.get(applicationName);
        const propertiesByEntityIndex = newPropertiesMap.get(applicationName);
        const relationsByEntityIndex = this.datastructureUtils.ensureChildArray(newRelationsMap, applicationName);
        const referencesForApplication = newApplicationReferenceMap.get(applicationName);
        for (let tableIndex = 0; tableIndex < jsonEntities.length; tableIndex++) {
            const jsonEntity = jsonEntities[tableIndex];
            const propertiesForEntity = propertiesByEntityIndex[tableIndex];
            const relationsForEntity = [];
            relationsByEntityIndex[tableIndex]
                = relationsForEntity;
            const entity = entitiesForApplication[tableIndex];
            let index = 0;
            for (const jsonRelation of jsonEntity.relations) {
                const property = propertiesForEntity[jsonRelation.propertyRef.index];
                let referencedApplication_Name = applicationName;
                if (jsonRelation.relationTableApplication_Index
                    || jsonRelation.relationTableApplication_Index === 0) {
                    const applicationReference = referencesForApplication[jsonRelation.relationTableApplication_Index];
                    referencedApplication_Name = applicationReference.referencedApplicationVersion.application.fullName;
                }
                let entitiesArray = newEntitiesMapByApplication_Name.get(referencedApplication_Name);
                if (!entitiesArray) {
                    const applicationVersion = await this.getExistingLatestApplicationVersion(referencedApplication_Name, allDdlObjects);
                    entitiesArray = applicationVersion.entities;
                }
                const relationEntity = entitiesArray[jsonRelation.relationTableIndex];
                const relation = {
                    entity,
                    _localId: ++terminalStore.getLastIds().relations,
                    index,
                    foreignKey: jsonRelation.foreignKey,
                    isId: property.isId,
                    manyToOneElems: jsonRelation.manyToOneElems,
                    property,
                    oneToManyElems: jsonRelation.oneToManyElems,
                    relationEntity,
                    relationType: jsonRelation.relationType,
                    // oneRelationColumns: [],
                    // manyRelationColumns: []
                };
                // property.relation               = [relation]
                // relationEntity.relations.push(relation)
                relationsForEntity[index] = relation;
                index++;
                newRelations.push(relation);
            }
        }
    }
    composeApplicationColumns(jsonApplication, newColumns, newColumnsMap, newPropertyColumns, newEntitiesMapByApplication_Name, newPropertiesMap) {
        const applicationName = this.dbApplicationUtils.
            getApplication_FullName(jsonApplication);
        const columnsByTable = [];
        newColumnsMap.set(applicationName, columnsByTable);
        const entitiesForApplication = newEntitiesMapByApplication_Name.get(applicationName);
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const propertiesForApplication = newPropertiesMap.get(applicationName);
        jsonEntities.forEach((jsonEntity, tableIndex) => {
            const entity = entitiesForApplication[tableIndex];
            const columnsForTable = [];
            columnsByTable[tableIndex] = columnsForTable;
            const idColumnIndexes = [];
            jsonEntity.idColumnRefs.forEach((idColumnRef, idColumnIndex) => {
                idColumnIndexes[idColumnRef.index] = idColumnIndex;
            });
            const propertiesForEntity = propertiesForApplication[tableIndex];
            jsonEntity.columns.forEach((jsonColumn, index) => {
                const idColumndIndex = idColumnIndexes[index];
                const column = {
                    allocationSize: jsonColumn.allocationSize,
                    entity,
                    _localId: ++this.terminalStore.getLastIds().columns,
                    idIndex: idColumndIndex,
                    index,
                    isGenerated: jsonColumn.isGenerated,
                    manyRelationColumns: [],
                    name: jsonColumn.name,
                    notNull: jsonColumn.notNull,
                    oneRelationColumns: [],
                    precision: jsonColumn.precision,
                    propertyColumns: [],
                    scale: jsonColumn.scale,
                    type: jsonColumn.type,
                };
                columnsForTable[index] = column;
                newColumns.push(column);
                jsonColumn.propertyRefs.forEach((propertyReference) => {
                    const property = propertiesForEntity[propertyReference.index];
                    const propertyColumn = {
                        column,
                        property
                    };
                    newPropertyColumns.push(propertyColumn);
                });
            });
        });
    }
    async composeApplicationRelationColumns(jsonApplication, newRelationColumns, newApplicationVersionMapByApplication_Name, newApplicationReferenceMap, newRelationsMap, newColumnsMap, terminalStore, allDdlObjects) {
        const applicationName = this.dbApplicationUtils.
            getApplication_FullName(jsonApplication);
        const currentApplicationVersion = jsonApplication.versions[jsonApplication.versions.length - 1];
        const jsonEntities = currentApplicationVersion.entities;
        const columnsForApplication = newColumnsMap.get(applicationName);
        const relationsForApplication = newRelationsMap.get(applicationName);
        const applicationReferencesForApplication = newApplicationReferenceMap.get(applicationName);
        for (let tableIndex = 0; tableIndex < jsonEntities.length; tableIndex++) {
            const jsonEntity = jsonEntities[tableIndex];
            const columnsForEntity = columnsForApplication[tableIndex];
            const relationsForEntity = relationsForApplication[tableIndex];
            for (let index = 0; index < jsonEntity.columns.length; index++) {
                const jsonColumn = jsonEntity.columns[index];
                const manyColumn = columnsForEntity[index];
                for (const jsonRelationColumn of jsonColumn.manyRelationColumnRefs) {
                    const manyRelation = relationsForEntity[jsonRelationColumn.manyRelationIndex];
                    // if (!manyRelation.manyRelationColumns) {
                    // 	manyRelation.manyRelationColumns = []
                    // }
                    let oneRelationApplicationVersion;
                    if (jsonRelationColumn.oneApplication_Index
                        || jsonRelationColumn.oneApplication_Index === 0) {
                        const applicationReference = applicationReferencesForApplication[jsonRelationColumn.oneApplication_Index];
                        oneRelationApplicationVersion = applicationReference.referencedApplicationVersion;
                    }
                    else {
                        oneRelationApplicationVersion = newApplicationVersionMapByApplication_Name.get(applicationName);
                    }
                    const referencedApplication_Name = oneRelationApplicationVersion.application.fullName;
                    const oneTableColumnsMapForApplication = newColumnsMap.get(referencedApplication_Name);
                    let oneTableColumns;
                    let oneTableRelations;
                    if (oneTableColumnsMapForApplication) {
                        oneTableColumns = oneTableColumnsMapForApplication[jsonRelationColumn.oneTableIndex];
                        oneTableRelations = newRelationsMap.get(oneRelationApplicationVersion.application.fullName)[jsonRelationColumn.oneTableIndex];
                    }
                    else {
                        const applicationVersion = await this.getExistingLatestApplicationVersion(referencedApplication_Name, allDdlObjects);
                        const entitiesArray = applicationVersion.entities;
                        const entity = entitiesArray[jsonRelationColumn.oneTableIndex];
                        oneTableColumns = entity.columns;
                        oneTableRelations = entity.relations;
                    }
                    const oneColumn = oneTableColumns[jsonRelationColumn.oneColumnIndex];
                    // if (!jsonRelationColumn.oneApplication_Index
                    // 	&& !oneColumn.oneRelationColumns) {
                    // 	oneColumn.oneRelationColumns = []
                    // }
                    const oneRelation = oneTableRelations[jsonRelationColumn.oneRelationIndex];
                    // if (!jsonRelationColumn.oneApplication_Index
                    // 	&& !oneRelation.oneRelationColumns) {
                    // 	oneRelation.oneRelationColumns = []
                    // }
                    const relationColumn = {
                        _localId: ++terminalStore.getLastIds().relationColumns,
                        manyColumn,
                        manyRelation,
                        oneColumn,
                        oneRelation,
                        // FIXME: figure out how to many OneToMany-only relations
                        parentRelation: manyRelation
                    };
                    newRelationColumns.push(relationColumn);
                }
                manyColumn.manyRelationColumns = []; // relationColumns
            }
        }
    }
}

class ApplicationRecorder {
    async record(ddlObjects, 
    // normalOperation: boolean,
    context) {
        await this.transactionManager.transactInternal(async () => {
            // FIXME: add support for real application versioning
            this.setDefaultVersioning(ddlObjects);
            const domainDao = await this.getdomainDaoAsync();
            await domainDao.checkAndInsertIfNeeded(ddlObjects.domains, context);
            await this.applicationDao.insert(ddlObjects.applications, context);
            await this.applicationVersionDao.insert(ddlObjects.applicationVersions, context);
            await this.applicationReferenceDao.insert(ddlObjects.applicationReferences, context);
            await this.applicationEntityDao.insert(ddlObjects.entities, context);
            await this.applicationPropertyDao.insert(ddlObjects.properties, context);
            await this.applicationRelationDao.insert(ddlObjects.relations, context);
            await this.applicationColumnDao.insert(ddlObjects.columns, context);
            await this.applicationPropertyColumnDao.insert(ddlObjects.propertyColumns, context);
            await this.applicationRelationColumnDao.insert(ddlObjects.relationColumns, context);
        }, null, context);
    }
    setDefaultVersioning(ddlObjects) {
        for (const applicationReference of ddlObjects.applicationReferences) {
            applicationReference.deprecatedSinceVersion = null;
            applicationReference.removedInVersion = null;
            applicationReference.sinceVersion = applicationReference.ownApplicationVersion;
        }
        for (const entity of ddlObjects.entities) {
            entity.deprecatedSinceVersion = null;
            entity.removedInVersion = null;
            entity.sinceVersion = entity.applicationVersion;
        }
        for (const property of ddlObjects.properties) {
            property.deprecatedSinceVersion = null;
            property.removedInVersion = null;
            property.sinceVersion = property.entity.applicationVersion;
        }
        for (const relation of ddlObjects.relations) {
            relation.deprecatedSinceVersion = null;
            relation.removedInVersion = null;
            relation.sinceVersion = relation.entity.applicationVersion;
        }
        for (const column of ddlObjects.columns) {
            column.deprecatedSinceVersion = null;
            column.removedInVersion = null;
            column.sinceVersion = column.entity.applicationVersion;
        }
        for (const propertyColumn of ddlObjects.propertyColumns) {
            propertyColumn.deprecatedSinceVersion = null;
            propertyColumn.removedInVersion = null;
            propertyColumn.sinceVersion = propertyColumn.property.entity.applicationVersion;
        }
        for (const relationColumn of ddlObjects.relationColumns) {
            relationColumn.deprecatedSinceVersion = null;
            relationColumn.removedInVersion = null;
            relationColumn.sinceVersion = relationColumn.parentRelation.entity.applicationVersion;
        }
    }
    async bulkCreate(dao, entities, context) {
        await dao.save(entities, context);
    }
}

class ApplicationInitializer {
    addNewApplicationVersionsToAll(ddlObjects) {
        for (const applicationVersion of ddlObjects.added.applicationVersions) {
            ddlObjects.allApplicationVersionsByIds[applicationVersion._localId] = applicationVersion;
        }
    }
    async hydrate(jsonApplications, context) {
        await this.stage(jsonApplications, context);
        // Hydrate all DDL objects and Sequences
        const ddlObjects = await this.queryObjectInitializer.initialize();
        this.addNewApplicationVersionsToAll(ddlObjects);
        this.setAirDbApplications(ddlObjects);
        await this.sequenceGenerator.initialize(context);
    }
    /*
     * Initialization scenarios:
     *
     * Brand new install - initialize BLUEPRINT applications
     * Install new App - initialize New application (and any new dependency applications)
     * Reload existing install - hydrate all applications
     * Reload exiting App - nothing to do
     */
    async initialize(jsonApplications, context, checkDependencies, loadExistingApplications, areFeatureApps) {
        const applicationsWithValidDependencies = await this.
            getApplicationsWithValidDependencies(jsonApplications, checkDependencies);
        const existingApplicationMap = new Map();
        if (loadExistingApplications) {
            const applications = await this.applicationDao.findAllWithJson();
            for (const application of applications) {
                existingApplicationMap.set(application.fullName, application);
            }
        }
        const newJsonApplicationMap = new Map();
        for (const jsonApplication of jsonApplications) {
            const existingApplication = existingApplicationMap.get(this.dbApplicationUtils.
                getApplication_FullName(jsonApplication));
            if (existingApplication) {
                jsonApplication.lastIds = existingApplication.versions[0].jsonApplication.lastIds;
            }
            else {
                newJsonApplicationMap.set(this.dbApplicationUtils.
                    getApplication_FullName(jsonApplication), jsonApplication);
            }
        }
        let checkedApplicationsWithValidDependencies = [];
        for (const jsonApplication of applicationsWithValidDependencies) {
            const existingApplication = existingApplicationMap.get(this.dbApplicationUtils.
                getApplication_FullName(jsonApplication));
            if (!existingApplication) {
                checkedApplicationsWithValidDependencies.push(jsonApplication);
                await this.applicationBuilder.build(jsonApplication, existingApplicationMap, newJsonApplicationMap, areFeatureApps, context);
            }
        }
        const allDdlObjects = await this.applicationComposer.compose(checkedApplicationsWithValidDependencies, {
            terminalStore: this.terminalStore
        });
        this.addNewApplicationVersionsToAll(allDdlObjects);
        this.queryObjectInitializer.generateQObjectsAndPopulateStore(allDdlObjects);
        this.setAirDbApplications(allDdlObjects);
        await this.transactionManager.transactInternal(async (_transaction, context) => {
            const newSequences = await this.applicationBuilder.buildAllSequences(applicationsWithValidDependencies, context);
            await this.sequenceGenerator.initialize(context, newSequences);
            await this.applicationRecorder.record(allDdlObjects.added, context);
        }, null, context);
    }
    async isApplicationIsInstalled(domain, fullApplication_Name) {
        if (!fullApplication_Name) {
            return false;
        }
        if (this.appTrackerUtils.isInternalDomain(domain)) {
            return true;
        }
        return !!this.terminalStore.getApplicationInitializer()
            .applicationWindowMap.get(fullApplication_Name);
    }
    async ensureApplicationIsInstalled(domainName, applicationName) {
        const isInternalDomain = await this.appTrackerUtils
            .isInternalDomain(domainName);
        if (isInternalDomain) {
            return true;
        }
        const fullApplication_Name = this.dbApplicationUtils.
            getApplication_FullNameFromDomainAndName(domainName, applicationName);
        const applicationInitializing = this.terminalStore.getApplicationInitializer()
            .initializingApplicationMap.get(fullApplication_Name);
        if (applicationInitializing) {
            return false;
        }
        const isApplicationLoaded = this.isAppLoaded(fullApplication_Name);
        if (!isApplicationLoaded) {
            this.terminalStore.getApplicationInitializer()
                .initializingApplicationMap.set(fullApplication_Name, true);
            await this.nativeInitializeApplication(domainName, applicationName, fullApplication_Name);
        }
        return true;
    }
    async installApplication(domainName, applicationName) {
        let appIsInstalled = false;
        do {
            appIsInstalled = await this.ensureApplicationIsInstalled(domainName, applicationName);
            if (!appIsInstalled) {
                await new Promise(resolve => {
                    setTimeout(_ => {
                        resolve();
                    }, 100);
                });
            }
        } while (!appIsInstalled);
    }
    async initializeForAIRportApp(jsonApplication) {
        const applicationsWithValidDependencies = await this.
            getApplicationsWithValidDependencies([jsonApplication], false);
        const ddlObjects = await this.applicationComposer.compose(applicationsWithValidDependencies, {
            deepTraverseReferences: true,
            terminalStore: this.terminalStore
        });
        this.addNewApplicationVersionsToAll(ddlObjects);
        this.queryObjectInitializer.generateQObjectsAndPopulateStore(ddlObjects);
        this.setAirDbApplications(ddlObjects);
    }
    async stage(jsonApplications, context) {
        // Temporarily Initialize application DDL objects and Sequences to allow for normal hydration
        const tempDdlObjects = await this.applicationComposer.compose(jsonApplications, {
            terminalStore: this.terminalStore
        });
        this.addNewApplicationVersionsToAll(tempDdlObjects);
        this.queryObjectInitializer.generateQObjectsAndPopulateStore(tempDdlObjects);
        this.setAirDbApplications(tempDdlObjects);
        const newSequences = await this.applicationBuilder.stageSequences(jsonApplications, context);
        await this.sequenceGenerator.tempInitialize(context, newSequences);
    }
    async wait(milliseconds) {
        return new Promise((resolve, _reject) => {
            setTimeout(() => {
                resolve();
            }, milliseconds);
        });
    }
    async getApplicationsWithValidDependencies(jsonApplications, checkDependencies) {
        const jsonApplicationsToInstall = [];
        for (const jsonApplication of jsonApplications) {
            await this.applicationChecker.check(jsonApplication);
            const existingApplication = this.applicationLocator.locateExistingApplicationVersionRecord(jsonApplication, this.terminalStore);
            if (existingApplication) {
                // Nothing needs to be done, we already have this application version
                continue;
            }
            jsonApplicationsToInstall.push(jsonApplication);
        }
        let applicationsWithValidDependencies;
        if (checkDependencies) {
            const applicationReferenceCheckResults = await this.applicationChecker
                .checkDependencies(jsonApplicationsToInstall);
            if (applicationReferenceCheckResults.applicationsInNeedOfAdditionalDependencies.length) {
                // const
                for (let i = 0; i < applicationReferenceCheckResults.neededDependencies.length; i++) {
                    const neededDependency = applicationReferenceCheckResults.neededDependencies[i];
                    const fullApplication_Name = this.dbApplicationUtils.
                        getApplication_FullName(neededDependency);
                    await this.nativeInitializeApplication(neededDependency.domain, neededDependency.name, fullApplication_Name);
                }
            }
            applicationsWithValidDependencies = [
                ...applicationReferenceCheckResults.applicationsWithValidDependencies,
                ...applicationReferenceCheckResults.applicationsInNeedOfAdditionalDependencies
            ];
        }
        else {
            applicationsWithValidDependencies = jsonApplicationsToInstall;
        }
        return applicationsWithValidDependencies;
    }
    setAirDbApplications(ddlObjects) {
        for (let application of ddlObjects.all.applications) {
            this.airportDatabase.applications[application.index] = application;
        }
    }
}

// TODO: probably not needed, included application source populates itself
// May be needed to populate applications from the database
class AirportDatabasePopulator {
    populate() {
        // FIXME: implement
        // this.airDb.applications
        // this.airDb.qApplications
    }
}

class DdlObjectLinker {
    link(allDdlObjects) {
        const { all, allApplicationVersionsByIds, added } = allDdlObjects;
        const { latestApplicationVersions, properties, relations, applicationReferences, applications } = added;
        this.linkDomainsAndApplicationsAndVersions(allApplicationVersionsByIds, all.domains, applications, latestApplicationVersions, applicationReferences);
        const entityArrayById = this.linkEntities(allApplicationVersionsByIds, all.entities, added.entities);
        const { propertyMapById, relationMapById } = this.linkPropertiesAndRelations(properties, relations, entityArrayById);
        this.linkColumns(propertyMapById, relationMapById, allDdlObjects, entityArrayById);
    }
    linkDomainsAndApplicationsAndVersions(allApplicationVersionsByIds, domains, applications, latestApplicationVersions, applicationReferences) {
        const domainMapById = new Map();
        domains.forEach((domain) => {
            domainMapById.set(domain._localId, domain);
        });
        const applicationMapByIndex = new Map();
        applications.forEach((application) => {
            applicationMapByIndex.set(application.index, application);
            const domain = domainMapById.get(application.domain._localId);
            application.domain = domain;
            domain.applications.push(application);
        });
        latestApplicationVersions.forEach((applicationVersion) => {
            const application = applicationMapByIndex.get(applicationVersion.application.index);
            let applicationCurrentVersion = {
                application,
                applicationVersion
            };
            application.currentVersion = [applicationCurrentVersion];
            application.versions = [applicationVersion];
            applicationVersion.application = application;
            applicationVersion.entities = [];
            applicationVersion.references = [];
            applicationVersion.referencedBy = [];
            applicationVersion.entityMapByName = {};
            applicationVersion.referencesMapByName = {};
            applicationVersion.referencedByMapByName = {};
        });
        applicationReferences.forEach((applicationReference) => {
            const ownApplicationVersion = allApplicationVersionsByIds[applicationReference.ownApplicationVersion._localId];
            const referencedApplicationVersion = allApplicationVersionsByIds[applicationReference.referencedApplicationVersion._localId];
            ownApplicationVersion.references[applicationReference.index] = applicationReference;
            ownApplicationVersion.referencesMapByName[referencedApplicationVersion.application.fullName] = applicationReference;
            referencedApplicationVersion.referencedBy.push(applicationReference);
            referencedApplicationVersion.referencedByMapByName[ownApplicationVersion.application.fullName] = applicationReference;
            applicationReference.ownApplicationVersion = ownApplicationVersion;
            applicationReference.referencedApplicationVersion = referencedApplicationVersion;
        });
    }
    linkEntities(allApplicationVersionsByIds, allEntities, // All of the entities of newly created applications
    addedEntities // All of the entities of newly created applications
    // from the latest available versions
    ) {
        const entityArrayById = [];
        allEntities.forEach((entity) => {
            entityArrayById[entity._localId] = entity;
        });
        addedEntities.forEach((entity) => {
            const applicationVersion = allApplicationVersionsByIds[entity.applicationVersion._localId];
            entity.applicationVersion = applicationVersion;
            applicationVersion.entities[entity.index] = entity;
            applicationVersion.entityMapByName[entity.name] = entity;
            entityArrayById[entity._localId] = entity;
            entity.columns = [];
            entity.properties = [];
            entity.relations = [];
            entity.relationReferences = [];
            entity.columnMap = {};
            entity.idColumns = [];
            entity.idColumnMap = {};
            entity.propertyMap = {};
        });
        return entityArrayById;
    }
    linkPropertiesAndRelations(properties, relations, entityArrayById) {
        const propertyMapById = new Map();
        properties.forEach((property) => {
            // Entity is already property wired in
            const entity = entityArrayById[property.entity._localId];
            entity.properties[property.index] = property;
            entity.propertyMap[property.name] = property;
            property.entity = entity;
            property.propertyColumns = [];
            propertyMapById.set(property._localId, property);
        });
        const relationMapById = new Map();
        relations.forEach((relation) => {
            const entity = entityArrayById[relation.entity._localId];
            entity.relations[relation.index] = relation;
            let relationEntity = entityArrayById[relation.relationEntity._localId];
            if (!relationEntity) {
                relationEntity = this.terminalStore.getAllEntities()[relation.relationEntity._localId];
            }
            relationEntity.relationReferences.push(relation);
            const property = propertyMapById.get(relation.property._localId);
            relation.property = property;
            property.relation = [relation];
            relation.entity = entity;
            relation.relationEntity = relationEntity;
            relation.manyRelationColumns = [];
            relation.oneRelationColumns = [];
            relationMapById.set(relation._localId, relation);
        });
        return {
            propertyMapById, relationMapById
        };
    }
    linkColumns(propertyMapById, relationMapById, allDdlObjects, entityArrayById) {
        const columnMapById = new Map();
        allDdlObjects.all.columns.forEach((column) => {
            columnMapById.set(column._localId, column);
        });
        allDdlObjects.added.columns.forEach((column) => {
            columnMapById.set(column._localId, column);
            const entity = entityArrayById[column.entity._localId];
            entity.columns[column.index] = column;
            entity.columnMap[column.name] = column;
            if (column.idIndex || column.idIndex === 0) {
                entity.idColumns[column.idIndex] = column;
                entity.idColumnMap[column.name] = column;
            }
            column.entity = entity;
        });
        allDdlObjects.added.propertyColumns.forEach((propertyColumn) => {
            const column = columnMapById.get(propertyColumn.column._localId);
            column.propertyColumns.push(propertyColumn);
            const property = propertyMapById.get(propertyColumn.property._localId);
            property.propertyColumns.push(propertyColumn);
            propertyColumn.column = column;
            propertyColumn.property = property;
        });
        allDdlObjects.added.relationColumns.forEach((relationColumn) => {
            let manyColumn = columnMapById.get(relationColumn.manyColumn._localId);
            if (!manyColumn) {
                manyColumn = this.terminalStore.getAllColumns()[relationColumn.manyColumn._localId];
            }
            manyColumn.manyRelationColumns.push(relationColumn);
            let oneColumn = columnMapById.get(relationColumn.oneColumn._localId);
            if (!oneColumn) {
                oneColumn = this.terminalStore.getAllColumns()[relationColumn.oneColumn._localId];
            }
            oneColumn.oneRelationColumns.push(relationColumn);
            let manyRelation;
            if (relationColumn.manyRelation && relationColumn.manyRelation._localId) {
                manyRelation = relationMapById.get(relationColumn.manyRelation._localId);
                if (!manyRelation) {
                    manyRelation = this.terminalStore.getAllRelations()[relationColumn.manyRelation._localId];
                }
                manyRelation.manyRelationColumns.push(relationColumn);
            }
            let oneRelation;
            if (relationColumn.oneRelation && relationColumn.oneRelation._localId) {
                oneRelation = relationMapById.get(relationColumn.oneRelation._localId);
                if (!oneRelation) {
                    oneRelation = this.terminalStore.getAllRelations()[relationColumn.oneRelation._localId];
                }
                oneRelation.oneRelationColumns.push(relationColumn);
            }
            relationColumn.manyColumn = manyColumn;
            relationColumn.manyRelation = manyRelation;
            relationColumn.oneColumn = oneColumn;
            relationColumn.oneRelation = oneRelation;
        });
    }
}

class DdlObjectRetriever {
    async retrieveDdlObjects() {
        const applications = await this.applicationDao.findAllActive();
        const applicationIndexes = [];
        const domainIdSet = new Set();
        applications.forEach(application => {
            applicationIndexes.push(application.index);
            domainIdSet.add(application.domain._localId);
        });
        applications.sort((application1, application2) => {
            return application1.index - application2.index;
        });
        const domains = await this.domainDao.findByIdIn(Array.from(domainIdSet));
        const allApplicationVersions = await this.applicationVersionDao
            .findAllActiveOrderByApplication_IndexAndId();
        let lastApplication_Index;
        // const allApplicationVersionsByIds: DbApplicationVersion[] = []
        const latestApplicationVersions = [];
        const applicationVersions = [];
        for (const applicationVersion of allApplicationVersions) {
            if (applicationVersion.application.index !== lastApplication_Index) {
                latestApplicationVersions.push(applicationVersion);
            }
            // allApplicationVersionsByIds[applicationVersion._localId] = applicationVersion
            lastApplication_Index = applicationVersion.application.index;
            applicationVersions.push(applicationVersion);
        }
        const latestApplicationVersion_LocalIds = latestApplicationVersions.map(applicationVersion => applicationVersion._localId);
        const applicationReferences = await this.applicationReferenceDao
            .findAllForApplicationVersions(latestApplicationVersion_LocalIds);
        const entities = await this.applicationEntityDao
            .findAllForApplicationVersions(latestApplicationVersion_LocalIds);
        const entityIds = entities.map(entity => entity._localId);
        /*
        const entityIds = entities.map(
    entity => {
        if (entity.tableConfig) {
            entity.tableConfig = JSON.parse(entity.tableConfig as any)
        }
        return entity._localId
    })
         */
        const properties = await this.applicationPropertyDao
            .findAllForEntities(entityIds);
        const propertyIds = properties.map(property => property._localId);
        const relations = await this.applicationRelationDao
            .findAllForProperties(propertyIds);
        const columns = await this.applicationColumnDao
            .findAllForEntities(entityIds);
        const columnIds = columns.map(column => column._localId);
        const propertyColumns = await this.applicationPropertyColumnDao
            .findAllForColumns(columnIds);
        const relationColumns = await this.applicationRelationColumnDao
            .findAllForColumns(columnIds);
        const lastTerminalState = this.terminalStore.getTerminalState();
        const lastIds = {
            columns: columns.length,
            domains: domains.length,
            entities: entities.length,
            properties: properties.length,
            relationColumns: relationColumns.length,
            relations: relations.length,
            applications: applications.length,
            applicationVersions: applicationVersions.length,
        };
        this.terminalStore.state.next({
            ...lastTerminalState,
            lastIds
        });
        return {
            // allDomains: domains,
            // allApplications: applications,
            // allApplicationVersionsByIds,
            columns,
            domains,
            entities,
            latestApplicationVersions,
            properties,
            propertyColumns,
            relationColumns,
            relations,
            applicationReferences,
            applications,
            applicationVersions
        };
    }
}

class QueryEntityClassCreator {
    createAll(applications) {
        const applicationsToCreate = this.qApplicationBuilderUtils
            .orderApplicationsInOrderOfPrecedence(applications);
        applicationsToCreate.map(dbApplication => this.create(dbApplication));
    }
    create(dbApplication) {
        let qApplication = this.airportDatabase.QM[dbApplication.fullName];
        // If the Application API source has already been loaded
        if (qApplication) {
            qApplication.__dbApplication__ = dbApplication;
        }
        else {
            qApplication = {
                __constructors__: {},
                __qConstructors__: {},
                __dbApplication__: dbApplication,
                name: dbApplication.name,
                domain: dbApplication.domain.name
            };
            this.airportDatabase.QM[dbApplication.fullName] = qApplication;
        }
        this.airportDatabase.Q[dbApplication.index] = qApplication;
        this.qApplicationBuilderUtils.setQAppEntities(dbApplication, qApplication, this.airportDatabase.qApplications, this.applicationUtils, this.relationManager);
        return qApplication;
    }
}

class QueryObjectInitializer {
    generateQObjectsAndPopulateStore(allDdlObjects) {
        this.ddlObjectLinker.link(allDdlObjects);
        this.queryEntityClassCreator.createAll(allDdlObjects.all.applications);
        const lastTerminalState = this.terminalStore.getTerminalState();
        const existingDomainMap = {};
        for (const domain of lastTerminalState.domains) {
            existingDomainMap[domain.name] = domain;
        }
        for (const domain of allDdlObjects.added.domains) {
            delete existingDomainMap[domain.name];
        }
        const unmodifiedDomains = [];
        for (const domainName in existingDomainMap) {
            unmodifiedDomains.push(existingDomainMap[domainName]);
        }
        const existingApplicationMap = {};
        for (const application of lastTerminalState.applications) {
            existingApplicationMap[application.fullName] = application;
        }
        for (const application of allDdlObjects.added.applications) {
            delete existingApplicationMap[application.fullName];
            lastTerminalState.applicationMapByFullName
                .set(application.fullName, application);
        }
        const unmodifiedApplications = [];
        for (const applicationName in existingApplicationMap) {
            unmodifiedApplications.push(existingApplicationMap[applicationName]);
        }
        this.terminalStore.state.next({
            ...lastTerminalState,
            domains: [
                ...unmodifiedDomains,
                ...allDdlObjects.added.domains
            ],
            applicationMapByFullName: lastTerminalState.applicationMapByFullName,
            applications: [
                ...unmodifiedApplications,
                ...allDdlObjects.added.applications
            ]
        });
    }
    async initialize() {
        const ddlObjects = await this.ddlObjectRetriever.retrieveDdlObjects();
        const allApplicationVersionsByIds = [];
        for (const applicationVersion of ddlObjects.applicationVersions) {
            allApplicationVersionsByIds[applicationVersion._localId] = applicationVersion;
        }
        let allDdlObjects = {
            all: ddlObjects,
            allApplicationVersionsByIds,
            added: ddlObjects
        };
        this.generateQObjectsAndPopulateStore(allDdlObjects);
        return allDdlObjects;
    }
}

const takeoff = lib('takeoff');
const tokens = takeoff.register(AirportDatabasePopulator, 'ApplicationBuilder', ApplicationInitializer, ApplicationChecker, ApplicationComposer, ApplicationLocator, ApplicationRecorder, DdlObjectLinker, DdlObjectRetriever, QueryEntityClassCreator, QueryObjectInitializer, SqlSchemaBuilder);
const APPLICATION_BUILDER = tokens.ApplicationBuilder;
// Needed as a token in @airport/web-tower (platforms/web-tower)
tokens.ApplicationLocator;
takeoff.setDependencies(ApplicationInitializer, {
    airportDatabase: AIRPORT_DATABASE,
    applicationBuilder: APPLICATION_BUILDER,
    applicationChecker: ApplicationChecker,
    applicationComposer: ApplicationComposer,
    applicationDao: ApplicationDao,
    applicationLocator: ApplicationLocator,
    applicationRecorder: ApplicationRecorder,
    appTrackerUtils: AppTrackerUtils,
    dbApplicationUtils: DbApplicationUtils,
    queryObjectInitializer: QueryObjectInitializer,
    sequenceGenerator: SEQUENCE_GENERATOR,
    terminalStore: TerminalStore,
    transactionManager: TRANSACTION_MANAGER
});
APPLICATION_BUILDER.setDependencies({
    airportDatabase: AIRPORT_DATABASE
});
takeoff.setDependencies(ApplicationChecker, {
    applicationDao: ApplicationDao,
    datastructureUtils: DatastructureUtils,
    dbApplicationUtils: DbApplicationUtils
});
takeoff.setDependencies(ApplicationComposer, {
    applicationLocator: ApplicationLocator,
    datastructureUtils: DatastructureUtils,
    dbApplicationUtils: DbApplicationUtils,
    domainRetriever: DOMAIN_RETRIEVER,
    terminalStore: TerminalStore
});
takeoff.setDependencies(ApplicationLocator, {
    dbApplicationUtils: DbApplicationUtils,
});
takeoff.setDependencies(ApplicationRecorder, {
    applicationColumnDao: ApplicationColumnDao,
    applicationDao: ApplicationDao,
    applicationEntityDao: ApplicationEntityDao,
    applicationPropertyColumnDao: ApplicationPropertyColumnDao,
    applicationPropertyDao: ApplicationPropertyDao,
    applicationRecorder: ApplicationRecorder,
    applicationReferenceDao: ApplicationReferenceDao,
    applicationRelationColumnDao: ApplicationRelationColumnDao,
    applicationRelationDao: ApplicationRelationDao,
    applicationVersionDao: ApplicationVersionDao,
    domainDao: DomainDao,
    transactionManager: TRANSACTION_MANAGER
});
takeoff.setDependencies(DdlObjectLinker, {
    terminalStore: TerminalStore
});
takeoff.setDependencies(DdlObjectRetriever, {
    applicationColumnDao: ApplicationColumnDao,
    applicationDao: ApplicationDao,
    applicationEntityDao: ApplicationEntityDao,
    applicationPropertyColumnDao: ApplicationPropertyColumnDao,
    applicationPropertyDao: ApplicationPropertyDao,
    applicationReferenceDao: ApplicationReferenceDao,
    applicationRelationColumnDao: ApplicationRelationColumnDao,
    applicationRelationDao: ApplicationRelationDao,
    applicationVersionDao: ApplicationVersionDao,
    domainDao: DomainDao
});
takeoff.setDependencies(QueryEntityClassCreator, {
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: ApplicationUtils,
    qApplicationBuilderUtils: QApplicationBuilderUtils,
    relationManager: RelationManager,
});
takeoff.setDependencies(QueryObjectInitializer, {
    ddlObjectLinker: DdlObjectLinker,
    ddlObjectRetriever: DdlObjectRetriever,
    queryEntityClassCreator: QueryEntityClassCreator,
    terminalStore: TerminalStore
});
takeoff.setDependencies(SqlSchemaBuilder, {
    airportDatabase: AIRPORT_DATABASE,
    applicationReferenceUtils: ApplicationReferenceUtils,
    dbApplicationUtils: DbApplicationUtils,
    sequenceDao: SequenceDao,
    storeDriver: STORE_DRIVER
});

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

/**
 * Created by Papa on 4/17/2017.
 */
/**
 * Marks a group of mutation history changes.
 */
class OperationHistory$1 {
    constructor() {
        this.recordHistory = [];
    }
}

class RecordHistory$1 {
    constructor() {
        this.newValues = [];
        this.oldValues = [];
    }
}

/**
 * Created by Papa on 9/15/2016.
 */
/**
 * Currently, syncing databases are always SqLite dbs.  This means
 * we don't need to store types for values.  If a need arises type
 * specific FieldChange classes can always be added.  Having
 * VARCHAR and NUMBER should suffice for other db implementations.
 * NUMBER covers (dates, booleans and numbers).  Maybe REALs will
 * also be required.
 */
class RecordHistoryNewValue$1 {
}

/**
 * Created by Papa on 9/15/2016.
 */
/**
 * Currently, syncing databases are always SqLite dbs.  This means
 * we don't need to store types for values.  If a need arises type
 * specific FieldChange classes can always be added.  Having
 * VARCHAR and NUMBER should suffice for other db implementations.
 * NUMBER covers (dates, booleans and numbers).  Maybe REALs will
 * also be required.
 */
class RecordHistoryOldValue$1 {
}

/**
 * Created by Papa on 9/15/2016.
 */
/**
 * An entry in repository Transaction History/Log.
 * The main synchronization unit exchanged between terminals.
 */
class RepositoryTransactionHistory$1 {
    constructor(data) {
        this.repositoryTransactionType = RepositoryTransactionType.LOCAL;
        this.operationHistory = [];
        // Tracked only in the Terminal database where originally added, for the
        // purpose of sending out synchronization messages
        // IS resent in RepositorySynchronizationMessage
        this.newRepositoryMemberInvitations = [];
        // Tracked only in the Terminal database where originally added, for the
        // purpose of sending out synchronization messages
        // IS resent in RepositorySynchronizationMessage
        this.newRepositoryMemberAcceptances = [];
        // Tracked only in the Terminal database where originally added, for the
        // purpose of sending out synchronization messages
        // IS NOT implemented (currently)
        this.newRepositoryMemberUpdates = [];
        // Tracked only in the Terminal database where originally added, for the
        // purpose of sending out synchronization messages
        // IS NOT resent in RepositorySynchronizationMessage
        this.newRepositoryMembers = [];
        if (!data) {
            return;
        }
        this._localId = data._localId;
        this.transactionHistory = data.transactionHistory;
        this.repository = data.repository;
        this.saveTimestamp = data.saveTimestamp;
        this.operationHistory = data.operationHistory;
    }
}

/**
 * Created by Papa on 5/1/2017./
 */
class TransactionHistory$1 {
    constructor() {
        this.applicationMap = new globalThis.SyncApplicationMap();
        this.allOperationHistory = [];
        this.allRecordHistory = [];
        this.allRecordHistoryNewValues = [];
        this.allRecordHistoryOldValues = [];
        this.allRepositoryMemberAcceptances = [];
        this.allRepositoryMemberInvitations = [];
        this.allRepositoryMembers = [];
    }
}

class Actor$1 {
}

/**
 * Created by Papa on 2/17/2017.
 */
// Used withint the framework because it imports from '@airport/travel-document-checkpoint/dist/app/bundle'
class InternalAirEntity$1 {
    constructor(entityId) {
        this.ageSuitability = 0;
        // TODO: if and when records are copied, make this a column
        // @Column({ name: 'COPIED', nullable: false })
        this.copied = false;
        this.createdAt = new Date();
        // Currently TypeScript does not support optional getters/setters
        // this is a workaround
        delete this.id;
        Object.defineProperty(this, 'id', {
            get() {
                return globalThis.IOC.getSync(globalThis.AIR_ENTITY_UTILS).encodeId(this);
            },
            set(idString) {
                globalThis.IOC.getSync(globalThis.AIR_ENTITY_UTILS).setId(idString, this);
            }
        });
        delete this.isNew;
        Object.defineProperty(this, 'isNew', {
            get() {
                return !!this._actorRecordId;
            }
        });
        delete this.createdBy;
        Object.defineProperty(this, 'createdBy', {
            get() {
                return this.actor.userAccount;
            }
        });
        this.id = entityId;
    }
}

/**
 * Created by Papa on 2/9/2017.
 */
class Repository$1 {
    constructor() {
        this._localId = null;
        // Local-only, represents state of the repository
        // false if only a reference stub is loaded
        this.isLoaded = true;
        this.repositoryMembers = [];
        this.repositoryTransactionHistory = [];
        this.repositoryApplications = [];
        this.repositoryClients = [];
        this.repositoryDatabases = [];
        this.repositoryTerminals = [];
        this.repositoryTypes = [];
    }
}

class RepositoryApplication$1 {
}

class RepositoryClient$1 {
}

class RepositoryDatabase$1 {
}

class RepositoryMember$1 {
    constructor() {
        this.updates = [];
    }
}

class RepositoryMemberAcceptance$1 {
}

class RepositoryMemberInvitation$1 {
}

class RepositoryMemberUpdate$1 {
}

class RepositoryTerminal$1 {
}

class RepositoryType$1 {
}

const __constructors__$6 = {
    Actor: Actor$1,
    InternalAirEntity: InternalAirEntity$1,
    OperationHistory: OperationHistory$1,
    RecordHistory: RecordHistory$1,
    RecordHistoryNewValue: RecordHistoryNewValue$1,
    RecordHistoryOldValue: RecordHistoryOldValue$1,
    Repository: Repository$1,
    RepositoryApplication: RepositoryApplication$1,
    RepositoryClient: RepositoryClient$1,
    RepositoryDatabase: RepositoryDatabase$1,
    RepositoryMember: RepositoryMember$1,
    RepositoryMemberAcceptance: RepositoryMemberAcceptance$1,
    RepositoryMemberInvitation: RepositoryMemberInvitation$1,
    RepositoryMemberUpdate: RepositoryMemberUpdate$1,
    RepositoryTerminal: RepositoryTerminal$1,
    RepositoryTransactionHistory: RepositoryTransactionHistory$1,
    RepositoryType: RepositoryType$1,
    TransactionHistory: TransactionHistory$1
};
const Q_airport____at_airport_slash_holding_dash_pattern$1 = {
    __constructors__: __constructors__$6,
    domain: 'airport',
    name: '@airport/holding-pattern'
};
function airport____at_airport_slash_holding_dash_pattern_diSet(dbEntityId) {
    return globalThis.airApi.dS(Q_airport____at_airport_slash_holding_dash_pattern$1.__dbApplication__, dbEntityId);
}
if (globalThis.airApi) {
    globalThis.airApi.setQApp(Q_airport____at_airport_slash_holding_dash_pattern$1);
}

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$4 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q_airport____at_airport_slash_holding_dash_pattern$1);
    }
}
class BaseActorDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(0);
    }
    constructor() {
        super(0);
    }
}
BaseActorDao.Find = new DaoQueryDecorators();
BaseActorDao.FindOne = new DaoQueryDecorators();
BaseActorDao.Search = new DaoQueryDecorators();
BaseActorDao.SearchOne = new DaoQueryDecorators();
class BaseOperationHistoryDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(16);
    }
    constructor() {
        super(16);
    }
}
BaseOperationHistoryDao.Find = new DaoQueryDecorators();
BaseOperationHistoryDao.FindOne = new DaoQueryDecorators();
BaseOperationHistoryDao.Search = new DaoQueryDecorators();
BaseOperationHistoryDao.SearchOne = new DaoQueryDecorators();
class BaseRecordHistoryDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(3);
    }
    constructor() {
        super(3);
    }
}
BaseRecordHistoryDao.Find = new DaoQueryDecorators();
BaseRecordHistoryDao.FindOne = new DaoQueryDecorators();
BaseRecordHistoryDao.Search = new DaoQueryDecorators();
BaseRecordHistoryDao.SearchOne = new DaoQueryDecorators();
class BaseRecordHistoryNewValueDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(1);
    }
    constructor() {
        super(1);
    }
}
BaseRecordHistoryNewValueDao.Find = new DaoQueryDecorators();
BaseRecordHistoryNewValueDao.FindOne = new DaoQueryDecorators();
BaseRecordHistoryNewValueDao.Search = new DaoQueryDecorators();
BaseRecordHistoryNewValueDao.SearchOne = new DaoQueryDecorators();
class BaseRecordHistoryOldValueDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(2);
    }
    constructor() {
        super(2);
    }
}
BaseRecordHistoryOldValueDao.Find = new DaoQueryDecorators();
BaseRecordHistoryOldValueDao.FindOne = new DaoQueryDecorators();
BaseRecordHistoryOldValueDao.Search = new DaoQueryDecorators();
BaseRecordHistoryOldValueDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(9);
    }
    constructor() {
        super(9);
    }
}
BaseRepositoryDao.Find = new DaoQueryDecorators();
BaseRepositoryDao.FindOne = new DaoQueryDecorators();
BaseRepositoryDao.Search = new DaoQueryDecorators();
BaseRepositoryDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryApplicationDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(8);
    }
    constructor() {
        super(8);
    }
}
BaseRepositoryApplicationDao.Find = new DaoQueryDecorators();
BaseRepositoryApplicationDao.FindOne = new DaoQueryDecorators();
BaseRepositoryApplicationDao.Search = new DaoQueryDecorators();
BaseRepositoryApplicationDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryClientDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(6);
    }
    constructor() {
        super(6);
    }
}
BaseRepositoryClientDao.Find = new DaoQueryDecorators();
BaseRepositoryClientDao.FindOne = new DaoQueryDecorators();
BaseRepositoryClientDao.Search = new DaoQueryDecorators();
BaseRepositoryClientDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryDatabaseDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(5);
    }
    constructor() {
        super(5);
    }
}
BaseRepositoryDatabaseDao.Find = new DaoQueryDecorators();
BaseRepositoryDatabaseDao.FindOne = new DaoQueryDecorators();
BaseRepositoryDatabaseDao.Search = new DaoQueryDecorators();
BaseRepositoryDatabaseDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryMemberDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(13);
    }
    constructor() {
        super(13);
    }
}
BaseRepositoryMemberDao.Find = new DaoQueryDecorators();
BaseRepositoryMemberDao.FindOne = new DaoQueryDecorators();
BaseRepositoryMemberDao.Search = new DaoQueryDecorators();
BaseRepositoryMemberDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryMemberAcceptanceDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(10);
    }
    constructor() {
        super(10);
    }
}
BaseRepositoryMemberAcceptanceDao.Find = new DaoQueryDecorators();
BaseRepositoryMemberAcceptanceDao.FindOne = new DaoQueryDecorators();
BaseRepositoryMemberAcceptanceDao.Search = new DaoQueryDecorators();
BaseRepositoryMemberAcceptanceDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryMemberInvitationDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(11);
    }
    constructor() {
        super(11);
    }
}
BaseRepositoryMemberInvitationDao.Find = new DaoQueryDecorators();
BaseRepositoryMemberInvitationDao.FindOne = new DaoQueryDecorators();
BaseRepositoryMemberInvitationDao.Search = new DaoQueryDecorators();
BaseRepositoryMemberInvitationDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryMemberUpdateDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(12);
    }
    constructor() {
        super(12);
    }
}
BaseRepositoryMemberUpdateDao.Find = new DaoQueryDecorators();
BaseRepositoryMemberUpdateDao.FindOne = new DaoQueryDecorators();
BaseRepositoryMemberUpdateDao.Search = new DaoQueryDecorators();
BaseRepositoryMemberUpdateDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryTerminalDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(7);
    }
    constructor() {
        super(7);
    }
}
BaseRepositoryTerminalDao.Find = new DaoQueryDecorators();
BaseRepositoryTerminalDao.FindOne = new DaoQueryDecorators();
BaseRepositoryTerminalDao.Search = new DaoQueryDecorators();
BaseRepositoryTerminalDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryTransactionHistoryDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(15);
    }
    constructor() {
        super(15);
    }
}
BaseRepositoryTransactionHistoryDao.Find = new DaoQueryDecorators();
BaseRepositoryTransactionHistoryDao.FindOne = new DaoQueryDecorators();
BaseRepositoryTransactionHistoryDao.Search = new DaoQueryDecorators();
BaseRepositoryTransactionHistoryDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryTypeDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(4);
    }
    constructor() {
        super(4);
    }
}
BaseRepositoryTypeDao.Find = new DaoQueryDecorators();
BaseRepositoryTypeDao.FindOne = new DaoQueryDecorators();
BaseRepositoryTypeDao.Search = new DaoQueryDecorators();
BaseRepositoryTypeDao.SearchOne = new DaoQueryDecorators();
class BaseTransactionHistoryDao extends SQDIDao$4 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_holding_dash_pattern_diSet(14);
    }
    constructor() {
        super(14);
    }
}
BaseTransactionHistoryDao.Find = new DaoQueryDecorators();
BaseTransactionHistoryDao.FindOne = new DaoQueryDecorators();
BaseTransactionHistoryDao.Search = new DaoQueryDecorators();
BaseTransactionHistoryDao.SearchOne = new DaoQueryDecorators();

class RecordHistoryNewValueDao extends BaseRecordHistoryNewValueDao {
    async findByRecordHistory_LocalIdIn(RecordHistory_LocalIds) {
        let rhnv;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                rhnv = Q_airport____at_airport_slash_holding_dash_pattern$1.RecordHistoryNewValue
            ],
            WHERE: rhnv.recordHistory._localId.IN(RecordHistory_LocalIds)
        });
    }
}

class RecordHistoryOldValueDao extends BaseRecordHistoryOldValueDao {
    async findByRecordHistory_LocalIdIn(RecordHistory_LocalIds) {
        let rhov;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                rhov = Q_airport____at_airport_slash_holding_dash_pattern$1.RecordHistoryOldValue
            ],
            WHERE: rhov.recordHistory._localId.IN(RecordHistory_LocalIds)
        });
    }
}

class RepositoryTransactionHistoryDao extends BaseRepositoryTransactionHistoryDao {
    /*
    async clearContentsWhereIdsIn(
        repositoryTransactionBlockIds: TmRepositoryTransactionBlockId[]
    ): Promise<void> {
        const rtb: QRepositoryTransactionBlock = Q.QRepositoryTransactionBlock
        await this.db.updateWhere({
            UPDATE: rtb,
            SET: {
                contents: null
            },
            WHERE: rtb._localId.IN(repositoryTransactionBlockIds)
        })
    }
    */
    async findWhereGUIDsIn(GUIDs) {
        let rth;
        return await this.db.find.tree({
            SELECT: {
                GUID: Y
            },
            FROM: [
                rth = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryTransactionHistory
            ],
            WHERE: rth.GUID.IN(GUIDs)
        });
    }
    async findAllLocalChangesForRecordIds(changedRecordIds) {
        const repositoryTransactionHistoryMapByRepositoryId = new Map();
        const rth = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryTransactionHistory;
        const th = rth.transactionHistory.INNER_JOIN();
        const oh = rth.operationHistory.LEFT_JOIN();
        const ae = oh.entity.LEFT_JOIN();
        const av = ae.applicationVersion.LEFT_JOIN();
        const rh = oh.recordHistory.LEFT_JOIN();
        const nv = rh.newValues.LEFT_JOIN();
        let _localId = Y;
        const repositoryEquals = [];
        for (const [repositoryId, idsForRepository] of changedRecordIds) {
            const recordMapForRepository = idsForRepository.actorRecordIdsByLocalIds;
            const entityEquals = [];
            for (const [entityId, recordMapForEntity] of recordMapForRepository) {
                const actorEquals = [];
                for (const [actorId, recordsForActor] of recordMapForEntity) {
                    actorEquals.push(AND(rh.actor._localId.equals(actorId), rh._actorRecordId.IN(Array.from(recordsForActor))));
                }
                entityEquals.push(AND(oh.entity._localId.equals(entityId), OR(...actorEquals)));
            }
            repositoryEquals.push(AND(rth.repository._localId.equals(repositoryId), rth.saveTimestamp.greaterThanOrEquals(idsForRepository.firstChangeTime), OR(...entityEquals)));
        }
        const repoTransHistories = await this.db.find.tree({
            SELECT: {
                ...ALL_FIELDS,
                operationHistory: {
                    orderNumber: Y,
                    changeType: Y,
                    entity: {
                        _localId,
                        // index: Y,
                        applicationVersion: {
                            _localId: Y,
                            // integerVersion: Y,
                            // application: {
                            // 	index: Y
                            // }
                        }
                    },
                    recordHistory: {
                        _localId,
                        newValues: {
                            columnIndex: Y,
                            newValue: Y
                        }
                    }
                }
            },
            FROM: [
                rth,
                th,
                oh,
                ae,
                av,
                rh,
                nv
            ],
            WHERE: AND(th.transactionType.equals(TransactionType.LOCAL), OR(...repositoryEquals)),
            // ORDER_BY: [
            // 	rth.repository._localId.ASC()
            // ]
        });
        for (const repoTransHistory of repoTransHistories) {
            this.datastructureUtils.ensureChildArray(repositoryTransactionHistoryMapByRepositoryId, repoTransHistory.repository._localId)
                .push(repoTransHistory);
            repoTransHistory.operationHistory.sort((rth1, rth2) => {
                if (rth1.orderNumber < rth2.orderNumber) {
                    return -1;
                }
                if (rth1.orderNumber > rth2.orderNumber) {
                    return 1;
                }
                return 0;
            });
        }
        return repositoryTransactionHistoryMapByRepositoryId;
    }
    async updateSyncTimestamp(repositoryTransactionHistory) {
        let rth;
        await this.db.updateWhere({
            UPDATE: rth = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryTransactionHistory,
            SET: {
                syncTimestamp: repositoryTransactionHistory.syncTimestamp
            },
            WHERE: rth._localId.equals(repositoryTransactionHistory._localId)
        });
    }
}

class ActorDao extends BaseActorDao {
    async findWithDetailsAndGlobalIdsByIds(actorIds) {
        return await this.findWithDetailsAndGlobalIdsByWhereClause((a) => a._localId.IN(actorIds));
    }
    async findOneByDomainAndApplication_Names_AccountPublicSigningKey_TerminalGUID(domainName, applicationName, accountPublicSigningKey, terminalGUID) {
        let act;
        let application;
        let domain;
        let terminal;
        let userAccount;
        return await this.db.findOne.tree({
            SELECT: {
                _localId: Y,
                application: {
                    domain: {
                        name: Y
                    },
                    fullName: Y,
                    index: Y,
                    name: Y
                },
                terminal: {},
                userAccount: {},
                GUID: Y
            },
            FROM: [
                act = Q_airport____at_airport_slash_holding_dash_pattern$1.Actor,
                application = act.application.LEFT_JOIN(),
                domain = application.domain.LEFT_JOIN(),
                terminal = act.terminal.LEFT_JOIN(),
                userAccount = act.userAccount.LEFT_JOIN()
            ],
            WHERE: AND(domain.name.equals(domainName), application.name.equals(applicationName), terminal.GUID.equals(terminalGUID), userAccount.accountPublicSigningKey.equals(accountPublicSigningKey))
        });
    }
    async findByGUIDs(actorGUIDs) {
        let a;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                a = Q_airport____at_airport_slash_holding_dash_pattern$1.Actor
            ],
            WHERE: a.GUID.IN(actorGUIDs)
        });
    }
    async findWithUserAccountBy_LocalIdIn(actor_localIds) {
        let a;
        return await this.db.find.graph({
            SELECT: {
                '*': Y,
                userAccount: {
                    accountPublicSigningKey: Y,
                    username: Y
                }
            },
            FROM: [
                a = Q_airport____at_airport_slash_holding_dash_pattern$1.Actor,
                a.userAccount.LEFT_JOIN()
            ],
            WHERE: a._localId.IN(actor_localIds)
        });
    }
    async insert(actors, context) {
        let a;
        const VALUES = [];
        for (const actor of actors) {
            VALUES.push([
                actor.GUID, actor.application.index,
                actor.userAccount._localId, actor.terminal._localId
            ]);
        }
        const _localIds = await this.db.insertValuesGenerateIds({
            INSERT_INTO: a = Q_airport____at_airport_slash_holding_dash_pattern$1.Actor,
            columns: [
                a.GUID,
                a.application.index,
                a.userAccount._localId,
                a.terminal._localId
            ],
            VALUES
        }, context);
        for (let i = 0; i < actors.length; i++) {
            let actor = actors[i];
            actor._localId = _localIds[i][0];
        }
    }
    async findWithDetailsAndGlobalIdsByWhereClause(getWhereClause) {
        let a;
        let ap;
        let t;
        const _localId = Y;
        const username = Y;
        const GUID = Y;
        return await this.db.find.tree({
            SELECT: {
                ...ALL_FIELDS,
                application: {
                    index: Y,
                    name: Y,
                    domain: {
                        name: Y
                    }
                },
                terminal: {
                    _localId: GUID,
                    owner: {
                        username,
                        GUID,
                    }
                },
                userAccount: {
                    _localId,
                    username,
                    GUID,
                }
            },
            FROM: [
                a = Q_airport____at_airport_slash_holding_dash_pattern$1.Actor,
                ap = a.application.LEFT_JOIN(),
                ap.domain.LEFT_JOIN(),
                t = a.terminal.LEFT_JOIN(),
                t.owner.LEFT_JOIN(),
                a.userAccount.LEFT_JOIN()
            ],
            WHERE: getWhereClause(a)
        });
    }
}

class RepositoryMemberAcceptanceDao extends BaseRepositoryMemberAcceptanceDao {
    async insert(repositoryMemberAcceptances, context) {
        let rma;
        const VALUES = [];
        for (const repositoryMemberAcceptance of repositoryMemberAcceptances) {
            VALUES.push([
                repositoryMemberAcceptance.createdAt,
                repositoryMemberAcceptance.acceptingRepositoryMember._localId,
                repositoryMemberAcceptance.addedInRepositoryTransactionHistory._localId
            ]);
        }
        const _localIds = await this.db.insertValuesGenerateIds({
            INSERT_INTO: rma = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryMemberAcceptance,
            columns: [
                rma.createdAt,
                rma.acceptingRepositoryMember._localId,
                rma.addedInRepositoryTransactionHistory._localId
            ],
            VALUES
        }, context);
        for (let i = 0; i < repositoryMemberAcceptances.length; i++) {
            let repositoryMemberAcceptance = repositoryMemberAcceptances[i];
            repositoryMemberAcceptance._localId = _localIds[i][0];
        }
    }
}

class RepositoryMemberDao extends BaseRepositoryMemberDao {
    async findByMemberPublicSigningKeys(memberPublicSigningKeys) {
        let rm;
        return await this._find({
            SELECT: {
                '*': Y,
                userAccount: {}
            },
            FROM: [
                rm = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryMember,
                rm.userAccount.LEFT_JOIN()
            ],
            WHERE: rm.memberPublicSigningKey.IN(memberPublicSigningKeys)
        });
    }
    async findForRepositoryLocalIdAndAccountPublicSingingKey(repositoryLocalId, accountPublicSigningKey) {
        let rm, ua;
        return await this._findOne({
            SELECT: {},
            FROM: [
                rm = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryMember,
                ua = rm.userAccount.LEFT_JOIN()
            ],
            WHERE: AND(rm.repository.equals(repositoryLocalId), ua.accountPublicSigningKey.equals(accountPublicSigningKey))
        });
    }
    async findForRepositoryLocalIdAndUserLocalId(repositoryLocalId, userLocalId) {
        let rm;
        return await this._findOne({
            SELECT: {},
            FROM: [
                rm = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryMember
            ],
            WHERE: AND(rm.repository.equals(repositoryLocalId), rm.userAccount.equals(userLocalId))
        });
    }
    async findForRepositoryLocalIdAndIvitationPublicSigningKey(repositoryLocalId, base64EncodedKeyInvitationPublicSigningKey) {
        let rm, rmi;
        return await this._findOne({
            SELECT: {},
            FROM: [
                rm = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryMember,
                rmi = rm.invitations.LEFT_JOIN()
            ],
            WHERE: AND(rm.repository.equals(repositoryLocalId), rmi.invitationPublicSigningKey.equals(base64EncodedKeyInvitationPublicSigningKey))
        });
    }
    async insert(repositoryMembers, context) {
        let rm;
        const VALUES = [];
        for (const repositoryMember of repositoryMembers) {
            VALUES.push([
                repositoryMember.isOwner,
                repositoryMember.isAdministrator, repositoryMember.canWrite,
                repositoryMember.memberPublicSigningKey, repositoryMember.status,
                repositoryMember.repository._localId,
                repositoryMember.userAccount._localId,
            ]);
        }
        const _localIds = await this.db.insertValuesGenerateIds({
            INSERT_INTO: rm = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryMember,
            columns: [
                rm.isOwner,
                rm.isAdministrator,
                rm.canWrite,
                rm.memberPublicSigningKey,
                rm.status,
                rm.repository._localId,
                rm.userAccount._localId
            ],
            VALUES
        }, context);
        for (let i = 0; i < repositoryMembers.length; i++) {
            let repositoryMember = repositoryMembers[i];
            repositoryMember._localId = _localIds[i][0];
        }
    }
    async updatePublicSigningKey(invitationPublicSigningKey, memberPublicSigningKey, context) {
        let rm, rmi;
        await this.db.updateColumnsWhere({
            UPDATE: rm = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryMember,
            SET: {
                MEMBER_PUBLIC_SIGNING_KEY: memberPublicSigningKey,
                STATUS: RepositoryMember_Status.JOINED
            },
            WHERE: EXISTS({
                FROM: [
                    rmi = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryMemberInvitation
                ],
                SELECT: rmi._localId,
                WHERE: AND(rmi.invitedRepositoryMember._localId.equals(rm._localId), rmi.invitationPublicSigningKey.equals(invitationPublicSigningKey))
            })
        }, context);
    }
}

class RepositoryMemberInvitationDao extends BaseRepositoryMemberInvitationDao {
    async insert(repositoryMemberInvitations, context) {
        let rmi;
        const VALUES = [];
        for (const repositoryMemberInvitation of repositoryMemberInvitations) {
            VALUES.push([
                repositoryMemberInvitation.createdAt,
                repositoryMemberInvitation.invitationPublicSigningKey,
                repositoryMemberInvitation.invitedRepositoryMember._localId,
                repositoryMemberInvitation.addedInRepositoryTransactionHistory._localId
            ]);
        }
        const _localIds = await this.db.insertValuesGenerateIds({
            INSERT_INTO: rmi = Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryMemberInvitation,
            columns: [
                rmi.createdAt,
                rmi.invitationPublicSigningKey,
                rmi.invitedRepositoryMember._localId,
                rmi.addedInRepositoryTransactionHistory._localId
            ],
            VALUES
        }, context);
        for (let i = 0; i < repositoryMemberInvitations.length; i++) {
            let repositoryMemberInvitation = repositoryMemberInvitations[i];
            repositoryMemberInvitation._localId = _localIds[i][0];
        }
    }
}

class RepositoryDao extends BaseRepositoryDao {
    async findRootRepositories() {
        let r;
        const repositories = await this._find({
            SELECT: {
                _localId: Y,
                ageSuitability: Y,
                createdAt: Y,
                GUID: Y,
                owner: {
                    username: Y,
                },
                '*': Y,
                uiEntryUri: Y
            },
            FROM: [
                r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository,
                r.owner.INNER_JOIN()
            ]
        });
        return repositories;
    }
    async findRepository(repositoryGUID) {
        let r;
        const repository = await this._findOne({
            SELECT: {
                _localId: Y,
                ageSuitability: Y,
                createdAt: Y,
                GUID: Y,
                isPublic: Y,
                owner: {
                    username: Y,
                },
                '*': Y,
                uiEntryUri: Y
            },
            FROM: [
                r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository,
                r.owner.INNER_JOIN()
            ],
            WHERE: r.GUID.equals(repositoryGUID)
        });
        return repository;
    }
    async getRepositoryLoadInfo(repositoryGUID, context) {
        let r;
        let rth;
        let th;
        return await this.db.findOne.tree({
            SELECT: {
                immutable: Y,
                repositoryTransactionHistory: {
                    saveTimestamp: Y
                }
            },
            FROM: [
                r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository,
                rth = r.repositoryTransactionHistory.INNER_JOIN(),
                th = rth.transactionHistory.INNER_JOIN()
            ],
            WHERE: AND(r.GUID.equals(repositoryGUID), th.transactionType.equals(TransactionType.REMOTE_SYNC))
        }, context);
    }
    async findReposWithDetailsAndSyncNodeIds(repositoryIds) {
        let r;
        const _localId = Y;
        const GUID = Y;
        return await this.db.find.tree({
            SELECT: {
                _localId,
                ageSuitability: Y,
                createdAt: Y,
                GUID,
                owner: {
                    accountPublicSigningKey: Y
                },
                uiEntryUri: Y
            },
            FROM: [
                r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository,
                r.owner.INNER_JOIN()
            ],
            WHERE: r._localId.IN(repositoryIds)
        });
    }
    async findWithOwnerBy_LocalIds(repositoryIds) {
        let r;
        return await this.db.find.tree({
            SELECT: {
                _localId: Y,
                ageSuitability: Y,
                createdAt: Y,
                GUID: Y,
                owner: {
                    accountPublicSigningKey: Y,
                    username: Y
                },
                uiEntryUri: Y
            },
            FROM: [
                r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository,
                r.owner.INNER_JOIN()
            ],
            WHERE: r._localId.IN(repositoryIds)
        });
    }
    async findWithOwnerBy_LocalIdIn(repository_localIds) {
        let r;
        return await this.db.find.graph({
            SELECT: {
                _localId: Y,
                ageSuitability: Y,
                createdAt: Y,
                GUID: Y,
                owner: {
                    accountPublicSigningKey: Y,
                    username: Y
                },
                uiEntryUri: Y
            },
            FROM: [
                r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository,
                r.owner.INNER_JOIN()
            ],
            WHERE: r._localId.IN(repository_localIds)
        });
    }
    async findByGUIDs(repositoryGUIDs) {
        let r;
        return await this.db.find.tree({
            SELECT: {
                _localId: Y,
                ageSuitability: Y,
                createdAt: Y,
                GUID: Y,
                '*': Y,
                uiEntryUri: Y
            },
            FROM: [
                r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository
            ],
            WHERE: r.GUID.IN(repositoryGUIDs)
        });
    }
    async findByGUIDsAndLocalIds(repositoryGUIDs, repositoryLocalIds) {
        let r;
        return await this.db.find.tree({
            SELECT: {
                _localId: Y,
                ageSuitability: Y,
                createdAt: Y,
                GUID: Y,
                '*': Y,
                uiEntryUri: Y
            },
            FROM: [
                r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository
            ],
            WHERE: OR(r.GUID.IN(repositoryGUIDs), r._localId.IN(repositoryLocalIds))
        });
    }
    async insert(repositories, context) {
        let r;
        const VALUES = [];
        for (const repository of repositories) {
            VALUES.push([
                repository.createdAt, repository.GUID, repository.ageSuitability,
                repository.source, repository.immutable, repository.owner._localId,
            ]);
        }
        const _localIds = await this.db.insertValuesGenerateIds({
            INSERT_INTO: r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository,
            columns: [
                r.createdAt,
                r.GUID,
                r.ageSuitability,
                r.source,
                r.immutable,
                r.owner._localId
            ],
            VALUES
        }, context);
        for (let i = 0; i < repositories.length; i++) {
            let repository = repositories[i];
            repository._localId = _localIds[i][0];
        }
    }
    async updateUiEntityUri(repositoryGuid, uiEntityUri) {
        let r;
        await this.db.updateColumnsWhere({
            UPDATE: r = Q_airport____at_airport_slash_holding_dash_pattern$1.Repository,
            SET: {
                UI_ENTRY_URI: uiEntityUri
            },
            WHERE: r.GUID.equals(repositoryGuid)
        });
    }
}

class OperationHistoryDuo {
    getNewRecord(entityChangeType, dbEntity, repositoryTransactionHistory, systemWideOperationId, rootTransaction) {
        let operationHistory = {
            changeType: entityChangeType,
            entity: dbEntity,
            _localId: undefined,
            orderNumber: ++rootTransaction.numberOfOperations,
            recordHistory: [],
            repositoryTransactionHistory: repositoryTransactionHistory,
            systemWideOperationId
        };
        return operationHistory;
    }
    sort(ew1, ew2) {
        let startId1 = ew1.orderNumber;
        let startId2 = ew2.orderNumber;
        if (startId1 > startId2) {
            return 1;
        }
        if (startId2 > startId1) {
            return -1;
        }
        return 0;
    }
    startRecordHistory(operationHistory, actorId, _actorRecordId) {
        const recordHistory = this.recordHistoryDuo.getNewRecord(actorId, _actorRecordId);
        recordHistory.operationHistory = operationHistory;
        operationHistory.recordHistory.push(recordHistory);
        operationHistory.repositoryTransactionHistory
            .transactionHistory.allRecordHistory.push(recordHistory);
        return recordHistory;
    }
}

class RecordHistoryDuo {
    getNewRecord(actorId, _actorRecordId) {
        const recordHistory = new RecordHistory$1();
        recordHistory._actorRecordId = _actorRecordId;
        recordHistory.actor = {
            _localId: actorId
        };
        return recordHistory;
    }
    addNewValue(recordHistory, dbColumn, newValue) {
        if (newValue === null) {
            // No need to record a null value
            return null;
        }
        const recordHistoryNewValue = this.recordHistoryNewValueDuo.getNewRecord(recordHistory, dbColumn, newValue);
        recordHistory.newValues.push(recordHistoryNewValue);
        this.ensureModifiedRepositoryLocalIdSet(recordHistory, dbColumn, newValue);
        recordHistory.operationHistory.repositoryTransactionHistory
            .transactionHistory.allRecordHistoryNewValues.push(recordHistoryNewValue);
        return recordHistoryNewValue;
    }
    addOldValue(recordHistory, dbColumn, oldValue) {
        if (oldValue === null) {
            // No need to record a null value
            return null;
        }
        const recordHistoryOldValue = this.recordHistoryOldValueDuo
            .getNewRecord(recordHistory, dbColumn, oldValue);
        recordHistory.oldValues.push(recordHistoryOldValue);
        this.ensureModifiedRepositoryLocalIdSet(recordHistory, dbColumn, oldValue);
        recordHistory.operationHistory.repositoryTransactionHistory
            .transactionHistory.allRecordHistoryOldValues.push(recordHistoryOldValue);
        return recordHistoryOldValue;
    }
    ensureModifiedRepositoryLocalIdSet(recordHistory, dbColumn, value) {
        if (this.dictionary.isRepositoryRelationColumn(dbColumn)) {
            recordHistory.operationHistory.repositoryTransactionHistory
                .modifiedRepository_LocalIdSet.add(value);
        }
    }
}

class RecordHistoryNewValueDuo {
    getNewRecord(recordHistory, dbColumn, newValue) {
        const recordHistoryNewValue = new RecordHistoryNewValue$1();
        recordHistoryNewValue.columnIndex = dbColumn.index;
        recordHistoryNewValue.recordHistory = recordHistory;
        recordHistoryNewValue.newValue = newValue;
        return recordHistoryNewValue;
    }
}

class RecordHistoryOldValueDuo {
    getNewRecord(recordHistory, dbColumn, oldValue) {
        const recordHistoryOldValue = new RecordHistoryOldValue$1();
        recordHistoryOldValue.columnIndex = dbColumn.index;
        recordHistoryOldValue.recordHistory = recordHistory;
        recordHistoryOldValue.oldValue = oldValue;
        return recordHistoryOldValue;
    }
}

class RepositoryTransactionHistoryDuo {
    getNewRecord(repositoryId, actor, isRepositoryCreation, isPublic) {
        let repositoryTransactionHistory = new RepositoryTransactionHistory$1();
        let saveTimestamp = new Date().getTime();
        repositoryTransactionHistory.saveTimestamp = saveTimestamp;
        repositoryTransactionHistory.actor = actor;
        repositoryTransactionHistory.GUID = v4();
        repositoryTransactionHistory.isRepositoryCreation = isRepositoryCreation;
        repositoryTransactionHistory.isPublic = isPublic;
        repositoryTransactionHistory.repository = new Repository$1();
        repositoryTransactionHistory.repository._localId = repositoryId;
        this.setModifiedRepository_LocalIdSet(repositoryTransactionHistory);
        return repositoryTransactionHistory;
    }
    setModifiedRepository_LocalIdSet(repositoryTransactionHistory) {
        repositoryTransactionHistory.modifiedRepository_LocalIdSet = new Set();
        repositoryTransactionHistory.modifiedRepository_LocalIdSet
            .add(repositoryTransactionHistory.repository._localId);
    }
    newRecord(data) {
        if (!data) {
            return null;
        }
        return { ...data };
    }
    sortRepoTransHistories(repoTransHistories, actorMapById) {
        repoTransHistories.sort((repoTransHistory1, repoTransHistory2) => {
            const syncTimeComparison = this.compareNumbers(repoTransHistory1.syncTimestamp, repoTransHistory2.syncTimestamp);
            if (syncTimeComparison) {
                return syncTimeComparison;
            }
            const saveTimeComparison = this.compareNumbers(repoTransHistory1.saveTimestamp, repoTransHistory2.saveTimestamp);
            if (saveTimeComparison) {
                return saveTimeComparison;
            }
            return 0;
        });
    }
    startOperation(repositoryTransactionHistory, systemWideOperationId, entityChangeType, dbEntity, rootTransaction) {
        let operationHistory = this.operationHistoryDuo.getNewRecord(entityChangeType, dbEntity, repositoryTransactionHistory, systemWideOperationId, rootTransaction);
        repositoryTransactionHistory.operationHistory.push(operationHistory);
        repositoryTransactionHistory
            .transactionHistory.allOperationHistory.push(operationHistory);
        return operationHistory;
    }
    compareDates(date1, date2) {
        const time1 = date1 ? date1.getTime() : -1;
        const time2 = date2 ? date2.getTime() : -1;
        return this.compareNumbers(time1, time2);
    }
    compareNumbers(number1, number2) {
        if (number1 < number2) {
            return -1;
        }
        if (number2 > number1) {
            return 1;
        }
        return 0;
    }
}

class TransactionHistoryDuo {
    getNewRecord(transactionType = TransactionType.LOCAL) {
        let transaction = new TransactionHistory$1();
        transaction.transactionType = TransactionType.LOCAL;
        return transaction;
    }
    async getRepositoryTransaction(transactionHistory, repositoryLocalId, actor, isRepositoryCreation, isPublic) {
        let repositoryTransactionHistory = transactionHistory.repositoryTransactionHistoryMap[repositoryLocalId];
        if (!repositoryTransactionHistory) {
            const userSession = await this.terminalSessionManager.getUserSession();
            const repositoryMember = await this.repositoryMemberDao.findForRepositoryLocalIdAndUserLocalId(repositoryLocalId, userSession.userAccount._localId);
            if (!repositoryMember) {
                throw new Error(`User '${userSession.userAccount.username}' is not a member of Repository '${repositoryLocalId}'`);
            }
            repositoryTransactionHistory = this.repositoryTransactionHistoryDuo.getNewRecord(repositoryLocalId, actor, isRepositoryCreation, isPublic);
            repositoryTransactionHistory.member = repositoryMember;
            transactionHistory.repositoryTransactionHistories.push(repositoryTransactionHistory);
            transactionHistory.repositoryTransactionHistoryMap[repositoryLocalId] = repositoryTransactionHistory;
            repositoryTransactionHistory.transactionHistory = transactionHistory;
        }
        return repositoryTransactionHistory;
    }
}

class RepositoryApi$1 {
    async findRootRepositories() {
        return await this.repositoryDao.findRootRepositories();
    }
    async findRepository(repositoryGUID) {
        return await this.repositoryDao.findRepository(repositoryGUID);
    }
    async create(repositoryName, isPublic) {
        let context = arguments[2];
        if (isPublic === undefined) {
            context = arguments[1];
            isPublic = false;
        }
        return await this.repositoryManager.createRepository(repositoryName, isPublic, context);
    }
    async setUiEntryUri(uiEntryUri, repository) {
        await this.repositoryManager.setUiEntryUri(uiEntryUri, repository, {});
    }
}

const application$4 = {
    name: '@airport/holding-pattern',
    domain: {
        name: 'airport'
    }
};

const holdingPattern = app(application$4);
const REPOSITORY_MANAGER = holdingPattern.token('RepositoryManager');
holdingPattern.register(ActorDao, OperationHistoryDuo, RecordHistoryDuo, RecordHistoryNewValueDao, RecordHistoryNewValueDuo, RecordHistoryOldValueDao, RecordHistoryOldValueDuo, RepositoryDao, RepositoryMemberDao, RepositoryTransactionHistoryDao, RepositoryTransactionHistoryDuo, TransactionHistoryDuo, RepositoryApi$1);
holdingPattern.setDependencies(ActorDao, {
    datastructureUtils: DatastructureUtils
});
holdingPattern.setDependencies(OperationHistoryDuo, {
    recordHistoryDuo: RecordHistoryDuo,
});
holdingPattern.setDependencies(RepositoryApi$1, {
    repositoryDao: RepositoryDao,
    repositoryManager: REPOSITORY_MANAGER,
});
holdingPattern.setDependencies(RecordHistoryDuo, {
    dictionary: Dictionary,
    recordHistoryNewValueDuo: RecordHistoryNewValueDuo,
    recordHistoryOldValueDuo: RecordHistoryOldValueDuo,
});
holdingPattern.setDependencies(RepositoryTransactionHistoryDao, {
    datastructureUtils: DatastructureUtils
});
holdingPattern.setDependencies(RepositoryTransactionHistoryDuo, {
    operationHistoryDuo: OperationHistoryDuo,
});
holdingPattern.setDependencies(TransactionHistoryDuo, {
    repositoryMemberDao: RepositoryMemberDao,
    repositoryTransactionHistoryDuo: RepositoryTransactionHistoryDuo,
    terminalSessionManager: TERMINAL_SESSION_MANAGER
});

class UserAccountApi {
    async findUserAccount(accountPublicSingingKey) {
        const userAccounts = await this.userAccountDao.findByAccountPublicSingingKeys([accountPublicSingingKey]);
        if (userAccounts.length) {
            return userAccounts[0];
        }
        return null;
    }
}

var AddUserAccountErrorCodes;
(function (AddUserAccountErrorCodes) {
    AddUserAccountErrorCodes["INVALID_BIRTH_MONTH"] = "INVALID_BIRTH_MONTH";
    AddUserAccountErrorCodes["INVALID_COUNTRY"] = "INVALID_COUNTRY";
    AddUserAccountErrorCodes["INVALID_EMAIL"] = "INVALID_EMAIL";
    AddUserAccountErrorCodes["INVALID_USERNAME"] = "INVALID_USERNAME";
})(AddUserAccountErrorCodes || (AddUserAccountErrorCodes = {}));
class UserAccountManager {
    async addUserAccount(username, accountPublicSigningKey, context) {
        const userAccount = {
            _localId: null,
            accountPublicSigningKey,
            username
        };
        await this.userAccountDao.save(userAccount, context);
        return {
            userAccount
        };
    }
}

class Client$1 {
}

class ClientType {
}

class Database {
}

class DatabaseType {
}

class Continent {
}

class Country {
}

class MetroArea {
}

class MetroAreaState {
}

class State {
}

/**
 * AIRport terminal where the Apps execute (a browser tab, native app, etc.)
 */
class Terminal {
    constructor() {
        this.isLocal = false;
    }
}

/**
 * Types applicable to terminals
 */
class TerminalType {
}

/**
 * Classification of Generic Types (which can be applied to any entities)
 */
class Classification {
}

/**
 * Generic Type (can be applied to any entities)
 */
class Type {
}

class TypeClassification {
}

class UserAccount {
}

const __constructors__$5 = {
    Classification,
    Client: Client$1,
    ClientType,
    Continent,
    Country,
    Database,
    DatabaseType,
    MetroArea,
    MetroAreaState,
    State,
    Terminal,
    TerminalType,
    Type,
    TypeClassification,
    UserAccount
};
const Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint = {
    __constructors__: __constructors__$5,
    domain: 'airport',
    name: '@airport/travel-document-checkpoint'
};
function airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(dbEntityId) {
    return globalThis.airApi.dS(Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint.__dbApplication__, dbEntityId);
}
if (globalThis.airApi) {
    globalThis.airApi.setQApp(Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint);
}

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$3 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint);
    }
}
class BaseClassificationDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(6);
    }
    constructor() {
        super(6);
    }
}
BaseClassificationDao.Find = new DaoQueryDecorators();
BaseClassificationDao.FindOne = new DaoQueryDecorators();
BaseClassificationDao.Search = new DaoQueryDecorators();
BaseClassificationDao.SearchOne = new DaoQueryDecorators();
class BaseClientDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(10);
    }
    constructor() {
        super(10);
    }
}
BaseClientDao.Find = new DaoQueryDecorators();
BaseClientDao.FindOne = new DaoQueryDecorators();
BaseClientDao.Search = new DaoQueryDecorators();
BaseClientDao.SearchOne = new DaoQueryDecorators();
class BaseClientTypeDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(9);
    }
    constructor() {
        super(9);
    }
}
BaseClientTypeDao.Find = new DaoQueryDecorators();
BaseClientTypeDao.FindOne = new DaoQueryDecorators();
BaseClientTypeDao.Search = new DaoQueryDecorators();
BaseClientTypeDao.SearchOne = new DaoQueryDecorators();
class BaseContinentDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(5);
    }
    constructor() {
        super(5);
    }
}
BaseContinentDao.Find = new DaoQueryDecorators();
BaseContinentDao.FindOne = new DaoQueryDecorators();
BaseContinentDao.Search = new DaoQueryDecorators();
BaseContinentDao.SearchOne = new DaoQueryDecorators();
class BaseCountryDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(4);
    }
    constructor() {
        super(4);
    }
}
BaseCountryDao.Find = new DaoQueryDecorators();
BaseCountryDao.FindOne = new DaoQueryDecorators();
BaseCountryDao.Search = new DaoQueryDecorators();
BaseCountryDao.SearchOne = new DaoQueryDecorators();
class BaseDatabaseDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(12);
    }
    constructor() {
        super(12);
    }
}
BaseDatabaseDao.Find = new DaoQueryDecorators();
BaseDatabaseDao.FindOne = new DaoQueryDecorators();
BaseDatabaseDao.Search = new DaoQueryDecorators();
BaseDatabaseDao.SearchOne = new DaoQueryDecorators();
class BaseDatabaseTypeDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(11);
    }
    constructor() {
        super(11);
    }
}
BaseDatabaseTypeDao.Find = new DaoQueryDecorators();
BaseDatabaseTypeDao.FindOne = new DaoQueryDecorators();
BaseDatabaseTypeDao.Search = new DaoQueryDecorators();
BaseDatabaseTypeDao.SearchOne = new DaoQueryDecorators();
class BaseMetroAreaDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(1);
    }
    constructor() {
        super(1);
    }
}
BaseMetroAreaDao.Find = new DaoQueryDecorators();
BaseMetroAreaDao.FindOne = new DaoQueryDecorators();
BaseMetroAreaDao.Search = new DaoQueryDecorators();
BaseMetroAreaDao.SearchOne = new DaoQueryDecorators();
class BaseMetroAreaStateDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(2);
    }
    constructor() {
        super(2);
    }
}
BaseMetroAreaStateDao.Find = new DaoQueryDecorators();
BaseMetroAreaStateDao.FindOne = new DaoQueryDecorators();
BaseMetroAreaStateDao.Search = new DaoQueryDecorators();
BaseMetroAreaStateDao.SearchOne = new DaoQueryDecorators();
class BaseStateDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(3);
    }
    constructor() {
        super(3);
    }
}
BaseStateDao.Find = new DaoQueryDecorators();
BaseStateDao.FindOne = new DaoQueryDecorators();
BaseStateDao.Search = new DaoQueryDecorators();
BaseStateDao.SearchOne = new DaoQueryDecorators();
class BaseTerminalDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(14);
    }
    constructor() {
        super(14);
    }
}
BaseTerminalDao.Find = new DaoQueryDecorators();
BaseTerminalDao.FindOne = new DaoQueryDecorators();
BaseTerminalDao.Search = new DaoQueryDecorators();
BaseTerminalDao.SearchOne = new DaoQueryDecorators();
class BaseTerminalTypeDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(13);
    }
    constructor() {
        super(13);
    }
}
BaseTerminalTypeDao.Find = new DaoQueryDecorators();
BaseTerminalTypeDao.FindOne = new DaoQueryDecorators();
BaseTerminalTypeDao.Search = new DaoQueryDecorators();
BaseTerminalTypeDao.SearchOne = new DaoQueryDecorators();
class BaseTypeDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(8);
    }
    constructor() {
        super(8);
    }
}
BaseTypeDao.Find = new DaoQueryDecorators();
BaseTypeDao.FindOne = new DaoQueryDecorators();
BaseTypeDao.Search = new DaoQueryDecorators();
BaseTypeDao.SearchOne = new DaoQueryDecorators();
class BaseTypeClassificationDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(7);
    }
    constructor() {
        super(7);
    }
}
BaseTypeClassificationDao.Find = new DaoQueryDecorators();
BaseTypeClassificationDao.FindOne = new DaoQueryDecorators();
BaseTypeClassificationDao.Search = new DaoQueryDecorators();
BaseTypeClassificationDao.SearchOne = new DaoQueryDecorators();
class BaseUserAccountDao extends SQDIDao$3 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_travel_dash_document_dash_checkpoint_diSet(0);
    }
    constructor() {
        super(0);
    }
}
BaseUserAccountDao.Find = new DaoQueryDecorators();
BaseUserAccountDao.FindOne = new DaoQueryDecorators();
BaseUserAccountDao.Search = new DaoQueryDecorators();
BaseUserAccountDao.SearchOne = new DaoQueryDecorators();

class TerminalDao extends BaseTerminalDao {
    async findByOwnerPublicKeysAndOwnGUIDs(accountPublicSigningKeys, GUIDs) {
        let t, ua;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                t = Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint.Terminal,
                ua = t.owner.LEFT_JOIN()
            ],
            WHERE: AND(ua.accountPublicSigningKey.IN(accountPublicSigningKeys), t.GUID.IN(GUIDs))
        });
    }
    async findByGUIDs(GUIDs) {
        let t;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                t = Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint.Terminal
            ],
            WHERE: t.GUID.IN(GUIDs)
        });
    }
    async insert(terminals, context) {
        const airport = this.dictionary.airport;
        const Terminal = this.dictionary.Terminal;
        const terminalLids = await this.sequenceGenerator
            .generateSequenceNumbersForColumn(airport.DOMAIN_NAME, airport.apps.TRAVEL_DOCUMENT_CHECKPOINT.name, Terminal.name, Terminal.columns.TERMINAL_LID, terminals.length);
        const VALUES = [];
        for (let i = 0; i < terminals.length; i++) {
            const terminal = terminals[i];
            terminal._localId = terminalLids[i];
            VALUES.push([
                terminalLids[i], terminal.GUID, terminal.owner._localId, false
            ]);
        }
        let t;
        await this.db.insertValues({
            INSERT_INTO: t = Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint.Terminal,
            columns: [
                t._localId,
                t.GUID,
                t.owner._localId,
                t.isLocal
            ],
            VALUES
        }, context);
    }
}

class UserAccountDao extends BaseUserAccountDao {
    async findByUserAccountNames(usernames) {
        let u;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                u = Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint.UserAccount
            ],
            WHERE: u.username.IN(usernames)
        });
    }
    async findByAccountPublicSingingKeys(accountPublicSingingKeys) {
        let u;
        return await this.db.find.tree({
            SELECT: {},
            FROM: [
                u = Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint.UserAccount
            ],
            WHERE: u.accountPublicSigningKey.IN(accountPublicSingingKeys)
        });
    }
    async insert(userAccounts, context) {
        const airport = this.dictionary.airport;
        const UserAccount = this.dictionary.UserAccount;
        const userAccountLids = await this.sequenceGenerator
            .generateSequenceNumbersForColumn(airport.DOMAIN_NAME, airport.apps.TRAVEL_DOCUMENT_CHECKPOINT.name, UserAccount.name, UserAccount.columns.USER_ACCOUNT_LID, userAccounts.length);
        const VALUES = [];
        for (let i = 0; i < userAccounts.length; i++) {
            const userAccount = userAccounts[i];
            userAccount._localId = userAccountLids[i];
            VALUES.push([
                userAccountLids[i], userAccount.accountPublicSigningKey, userAccount.username
            ]);
        }
        let u;
        await this.db.insertValues({
            INSERT_INTO: u = Q_airport____at_airport_slash_travel_dash_document_dash_checkpoint.UserAccount,
            columns: [
                u._localId,
                u.accountPublicSigningKey,
                u.username
            ],
            VALUES
        }, context);
    }
}

const application$3 = {
    name: '@airport/travel-document-checkpoint',
    domain: {
        name: 'airport'
    }
};

const travelDocumentCheckpoint = app(application$3);
travelDocumentCheckpoint.register(TerminalDao, UserAccountApi, UserAccountDao, UserAccountManager);
travelDocumentCheckpoint.setDependencies(TerminalDao, {
    airportDatabase: AIRPORT_DATABASE,
    dictionary: Dictionary,
    sequenceGenerator: SEQUENCE_GENERATOR
});
travelDocumentCheckpoint.setDependencies(UserAccountApi, {
    userAccountDao: UserAccountDao
});
travelDocumentCheckpoint.setDependencies(UserAccountDao, {
    airportDatabase: AIRPORT_DATABASE,
    dictionary: Dictionary,
    sequenceGenerator: SEQUENCE_GENERATOR
});
travelDocumentCheckpoint.setDependencies(UserAccountManager, {
    userAccountDao: UserAccountDao
});

/* eslint-disable */
const APPLICATION$7 = {
    "domain": "airport",
    "index": null,
    "name": "@airport/airport-code",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {}
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TABLE_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMN_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SEQUENCE_INCREMENT_BY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CURRENT_VALUE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Sequence",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "applicationIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": true,
                            "name": "tableIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": true,
                            "name": "columnIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "incrementBy",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "currentValue",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "SEQUENCES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "SYSTEM_WIDE_OPERATION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "SystemWideOperationId",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "SYSTEM_WIDE_OPERATION_LIDS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "TERMINAL_RUN_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATE_TIMESTAMP",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "RANDOM_NUMBER",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "TerminalRun",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "createTimestamp",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "randomNumber",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TERMINAL_RUNS",
                        "columnIndexes": []
                    },
                    "operations": {}
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION$6 = {
    "domain": "airport",
    "index": null,
    "name": "@airport/airspace",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {}
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_RELATION_COLUMN_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 4,
                                    "oneRelationIndex": 5,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "MANY_APPLICATION_COLUMN_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 4,
                                    "oneRelationIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ONE_APPLICATION_COLUMN_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 5,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneRelationIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "MANY_APPLICATION_RELATION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 6,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneRelationIndex": 7,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ONE_APPLICATION_RELATION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 7,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "PARENT_RELATION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationRelationColumn",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "manyColumn",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "oneColumn",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "manyRelation",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "oneRelation",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "parentRelation",
                            "relationRef": {
                                "index": 7
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_RELATION_COLUMNS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_RELATION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "RELATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "FOREIGN_KEY",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "MANY_TO_ONE_ELEMENTS",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ONE_TO_MANY_ELEMENTS",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "RELATION_TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 10
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 10,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 2,
                                    "oneRelationIndex": 5,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_PROPERTY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 11,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 7,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 11
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 12,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 5,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 8,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "RELATION_APPLICATION_ENTITY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 12
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationRelation",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "property",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 6,
                            "isId": false,
                            "name": "foreignKey",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 7,
                            "isId": false,
                            "name": "manyToOneElems",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 8,
                            "isId": false,
                            "name": "oneToManyElems",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 8
                            },
                            "index": 9,
                            "isId": false,
                            "name": "relationType",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 9
                            },
                            "index": 10,
                            "isId": false,
                            "name": "isId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 11,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 12,
                            "isId": false,
                            "name": "relationEntity",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 13,
                            "isId": false,
                            "name": "manyRelationColumns",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 14,
                            "isId": false,
                            "name": "oneRelationColumns",
                            "relationRef": {
                                "index": 7
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 11
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 12
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "manyRelation"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 13
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "oneRelation"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 14
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_RELATIONS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_PROPERTY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PROPERTY_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationProperty",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "isId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "propertyColumns",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "relation",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "property"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "property"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_PROPERTIES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 4,
                                    "oneRelationIndex": 4,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_COLUMN_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 2,
                                    "oneRelationIndex": 4,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_PROPERTY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        },
                        {
                            "index": 4
                        }
                    ],
                    "index": 3,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationPropertyColumn",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": true,
                            "name": "column",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": true,
                            "name": "property",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_PROPERTY_COLUMNS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_COLUMN_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMN_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ID_INDEX",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_GENERATED",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ALLOCATION_SIZE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NOT_NULL",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 10,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PRECISION",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 10
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 11,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SCALE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 11
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 12,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 12
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 13,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 4,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 13
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 4,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationColumn",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "idIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "isGenerated",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 7,
                            "isId": false,
                            "name": "allocationSize",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 8
                            },
                            "index": 8,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 9
                            },
                            "index": 9,
                            "isId": false,
                            "name": "notNull",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 10
                            },
                            "index": 10,
                            "isId": false,
                            "name": "precision",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 11
                            },
                            "index": 11,
                            "isId": false,
                            "name": "scale",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 12
                            },
                            "index": 12,
                            "isId": false,
                            "name": "type",
                            "sinceVersion": 1
                        },
                        {
                            "index": 13,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 14,
                            "isId": false,
                            "name": "propertyColumns",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 15,
                            "isId": false,
                            "name": "manyRelationColumns",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 16,
                            "isId": false,
                            "name": "oneRelationColumns",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 13
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "column"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 14
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "manyColumn"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 15
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "oneColumn"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 16
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_COLUMNS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_OPERATION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "RULE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 6,
                                    "oneRelationIndex": 5,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 5,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationOperation",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "type",
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 6,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 7,
                            "isId": false,
                            "name": "rule",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_OPERATIONS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_ENTITY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TABLE_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_LOCAL",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_AIR_ENTITY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TABLE_CONFIGURATION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneRelationIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 3
                        }
                    ],
                    "index": 6,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationEntity",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "isLocal",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "isAirEntity",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 7,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 8
                            },
                            "index": 8,
                            "isId": false,
                            "name": "tableConfig",
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "applicationVersion",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 10,
                            "isId": false,
                            "name": "columns",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 11,
                            "isId": false,
                            "name": "operations",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 12,
                            "isId": false,
                            "name": "properties",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 13,
                            "isId": false,
                            "name": "relations",
                            "relationRef": {
                                "index": 7
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 14,
                            "isId": false,
                            "name": "relationReferences",
                            "relationRef": {
                                "index": 8
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "entity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 10
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "entity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 11
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "entity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 12
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "entity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 13
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "relationEntity"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 14
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_ENTITIES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DEPRECATED_SINCE_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REMOVED_IN_APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SINCE_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_REFERENCE_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OWN_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneRelationIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REFERENCED_APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 4
                        },
                        {
                            "index": 5
                        }
                    ],
                    "index": 7,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationReference",
                    "properties": [
                        {
                            "index": 0,
                            "isId": false,
                            "name": "deprecatedSinceVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "name": "removedInVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "sinceVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": true,
                            "name": "ownApplicationVersion",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": true,
                            "name": "referencedApplicationVersion",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 5,
                            "isId": false,
                            "name": "index",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_REFERENCES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "allocationSize": 100,
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "INTEGER_VERSION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "VERSION_STRING",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "MAJOR_VERSION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "MINOR_VERSION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PATCH_VERSION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "JSON_APPLICATION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "JSON"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 10,
                                    "oneRelationIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 8,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationVersion",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "integerVersion",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "versionString",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "majorVersion",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "minorVersion",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "patchVersion",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "jsonApplication",
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "application",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "entities",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "references",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 10,
                            "isId": false,
                            "name": "referencedBy",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 10,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "applicationVersion"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "ownApplicationVersion"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 7,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "referencedApplicationVersion"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 10
                            },
                            "relationTableIndex": 7,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_VERSIONS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 10,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_VERSION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 9,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ApplicationCurrentVersion",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "application",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "applicationVersion",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 10,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATION_CURRENT_VERSIONS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "GUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SCOPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "APPLICATION_NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "FULL_APPLICATION_NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "STATUS",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SIGNATURE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 11,
                                    "oneRelationIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DOMAIN_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 10,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Application",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "index",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "GUID",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "scope",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "fullName",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "status",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "signature",
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "domain",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "versions",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "currentVersion",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 11,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "application"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "application"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "APPLICATIONS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "DOMAIN_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 11,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Domain",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "applications",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "domain"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 10,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "DOMAINS",
                        "columnIndexes": []
                    },
                    "operations": {}
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION$5 = {
    "domain": "airport",
    "index": null,
    "name": "@airport/travel-document-checkpoint",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {
                    "UserAccountApi": {
                        "operationMap": {
                            "findUserAccount": {
                                "isAsync": true,
                                "parameters": [
                                    {
                                        "isRest": false,
                                        "text": "accountPublicSingingKey: UserAccount_PublicSigningKey"
                                    }
                                ]
                            }
                        }
                    }
                }
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "USER_ACCOUNT_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ACCOUNT_PUBLIC_SIGNING_KEY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "USERNAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "UserAccount",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "accountPublicSigningKey",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "username",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "METRO_AREA_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "COUNTRY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "MetroArea",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "country",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "metroAreaStates",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "userAccounts",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "metroArea"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "metroArea"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "METRO_AREAS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 3,
                                    "oneRelationIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "STATE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneRelationIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "METRO_AREA_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "MetroAreaState",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "state",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "metroArea",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "METRO_AREA_STATES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "STATE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ABBREVIATION",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 4,
                                    "oneRelationIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "COUNTRY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 3,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "State",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "abbreviation",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "country",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "metroAreaStates",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "userAccounts",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "state"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "state"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "STATES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "COUNTRY_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ABBREVIATION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COUNTRY_NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 5,
                                    "oneRelationIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "CONTINENT_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 4,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Country",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "abbreviation",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "continent",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "states",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "userAccounts",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "country"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "country"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "COUNTRIES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CONTINENT_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CONTINENT_NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 5,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Continent",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "countries",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "userAccounts",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "continent"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "continent"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "CONTINENTS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CLASSIFICATION_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 6,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Classification",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "CLASSIFICATIONS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 6,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "CLASSIFICATION_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneRelationIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TYPE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 7,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "TypeClassification",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "classification",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "type",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TYPE_CLASSIFICATIONS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TYPE_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TYPE_NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 8,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Type",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "id",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "typeClassifications",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "type"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 7,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TYPES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 10,
                                    "oneRelationIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "CLIENT_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TYPE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 9,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "ClientType",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "client",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "type",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 10,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "CLIENT_TYPES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CLIENT_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CLIENT_DOMAIN",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CLIENT_GUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "CONTINENT_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "COUNTRY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "STATE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "METRO_AREA_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 10,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Client",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "domain",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "GUID",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "continent",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "country",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "state",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "metroArea",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "clientTypes",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "client"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "CLIENTS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 12,
                                    "oneRelationIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DATABASE_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TYPE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 11,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "DatabaseType",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "database",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "type",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 12,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "DATABASE_TYPE",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "DATABASE_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "DATABASE_DOMAIN",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "DATABASE_GUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "CONTINENT_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "COUNTRY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "STATE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "METRO_AREA_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 12,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Database",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "domain",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "GUID",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "continent",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "country",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "state",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "metroArea",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "databaseTypes",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "database"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 11,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "DATABASES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 14,
                                    "oneRelationIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TERMINAL_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TYPE_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 13,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "TerminalType",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "terminal",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "type",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 14,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TERMINAL_TYPES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "TERMINAL_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TERMINAL_GUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_LOCAL",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OWNER_USER_ACCOUNT_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "CONTINENT_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "COUNTRY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "STATE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "METRO_AREA_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 14,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Terminal",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "GUID",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "owner",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 3,
                            "isId": false,
                            "name": "isLocal",
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "continent",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "country",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "state",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "metroArea",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "terminalTypes",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "terminal"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 13,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TERMINALS",
                        "propertyIndexes": [
                            {
                                "propertyIndex": 1,
                                "unique": true
                            }
                        ]
                    },
                    "operations": {}
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION$4 = {
    "domain": "airport",
    "index": null,
    "name": "@airport/holding-pattern",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {
                    "RepositoryApi": {
                        "operationMap": {
                            "findRootRepositories": {
                                "isAsync": true,
                                "parameters": []
                            },
                            "create": {
                                "isAsync": true,
                                "parameters": [
                                    {
                                        "isRest": false,
                                        "text": "repositoryName: string"
                                    },
                                    {
                                        "isRest": false,
                                        "text": "isPublic?: Repository_IsPublic"
                                    }
                                ]
                            },
                            "setUiEntryUri": {
                                "isAsync": true,
                                "parameters": [
                                    {
                                        "isRest": false,
                                        "text": "uiEntryUri: string"
                                    },
                                    {
                                        "isRest": false,
                                        "text": "repository: IRepository"
                                    }
                                ]
                            }
                        }
                    }
                }
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ACTOR_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "GUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "USER_ACCOUNT_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 14,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TERMINAL_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 10,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_INDEX",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Actor",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "GUID",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "userAccount",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "terminal",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "application",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 0,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 14,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 10,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMN_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NEW_VALUE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "ANY"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 3,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_RECORD_HISTORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RecordHistoryNewValue",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "recordHistory",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 1,
                            "isId": true,
                            "name": "columnIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 2,
                            "isId": false,
                            "name": "newValue",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_RECORD_HISTORY_NEW_VALUES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMN_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "OLD_VALUE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "ANY"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 3,
                                    "oneRelationIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_RECORD_HISTORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RecordHistoryOldValue",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "recordHistory",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 1,
                            "isId": true,
                            "name": "columnIndex",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 2,
                            "isId": false,
                            "name": "oldValue",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_RECORD_HISTORY_OLD_VALUES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "allocationSize": 2000,
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "RECORD_HISTORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ACTOR_RECORD_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 16,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OPERATION_HISTORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 3,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RecordHistory",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "_actorRecordId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "actor",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "operationHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "newValues",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "oldValues",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 16,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "recordHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "recordHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_RECORD_HISTORY",
                        "columnIndexes": [
                            {
                                "name": "RCRD_HSTR_TO_OPRTN_HSTR_FX",
                                "columnList": [
                                    "OPERATION_HISTORY_LID"
                                ],
                                "unique": false
                            }
                        ]
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 9,
                                    "oneRelationIndex": 11,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TYPE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 4,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryType",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "type",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 8,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_TYPES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 9,
                                    "oneRelationIndex": 9,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 12,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "DATABASE_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 5,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryDatabase",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "database",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 12,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_DATABASES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 9,
                                    "oneRelationIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 10,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "CLIENT_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 6,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryClient",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "client",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 10,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_CLIENTS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 9,
                                    "oneRelationIndex": 10,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 14,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TERMINAL_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 7,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryTerminal",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "terminal",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 14,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_TERMINALS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 10,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_INDEX",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 9,
                                    "oneRelationIndex": 7,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 8,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryApplication",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "application",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 10,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_APPLICATIONS",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "AGE_SUITABILITY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATED_AT",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "DATE"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "FULL_APPLICATION_NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "GUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IMMUTABLE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_PUBLIC",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SOURCE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "UI_ENTRY_URI",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 10,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_LOADED",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 10
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 11,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OWNER_USER_ACCOUNT_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 11
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 12,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "CONTINENT_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 12
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 13,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "COUNTRY_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 13
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 14,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "STATE_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 14
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 15,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "METRO_AREA_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 15
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 9,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "Repository",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "ageSuitability",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "createdAt",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "fullApplicationName",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "GUID",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "immutable",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "isPublic",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 7,
                            "isId": false,
                            "name": "name",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 8
                            },
                            "index": 8,
                            "isId": false,
                            "name": "source",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 9
                            },
                            "index": 9,
                            "isId": false,
                            "name": "uiEntryUri",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 10
                            },
                            "index": 10,
                            "isId": false,
                            "name": "isLoaded",
                            "sinceVersion": 1
                        },
                        {
                            "index": 11,
                            "isId": false,
                            "name": "owner",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 12,
                            "isId": false,
                            "name": "continent",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 13,
                            "isId": false,
                            "name": "country",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 14,
                            "isId": false,
                            "name": "state",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 15,
                            "isId": false,
                            "name": "metroArea",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 16,
                            "isId": false,
                            "name": "repositoryMembers",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 17,
                            "isId": false,
                            "name": "repositoryTransactionHistory",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 18,
                            "isId": false,
                            "name": "repositoryApplications",
                            "relationRef": {
                                "index": 7
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 19,
                            "isId": false,
                            "name": "repositoryClients",
                            "relationRef": {
                                "index": 8
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 20,
                            "isId": false,
                            "name": "repositoryDatabases",
                            "relationRef": {
                                "index": 9
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 21,
                            "isId": false,
                            "name": "repositoryTerminals",
                            "relationRef": {
                                "index": 10
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 22,
                            "isId": false,
                            "name": "repositoryTypes",
                            "relationRef": {
                                "index": 11
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 11
                            },
                            "relationTableIndex": 0,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 12
                            },
                            "relationTableIndex": 5,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 13
                            },
                            "relationTableIndex": 4,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 14
                            },
                            "relationTableIndex": 3,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 15
                            },
                            "relationTableIndex": 1,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repository"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 16
                            },
                            "relationTableIndex": 13,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repository"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 17
                            },
                            "relationTableIndex": 15,
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repository"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 18
                            },
                            "relationTableIndex": 8,
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repository"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 19
                            },
                            "relationTableIndex": 6,
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repository"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 20
                            },
                            "relationTableIndex": 5,
                            "sinceVersion": 1
                        },
                        {
                            "index": 10,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repository"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 21
                            },
                            "relationTableIndex": 7,
                            "sinceVersion": 1
                        },
                        {
                            "index": 11,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repository"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 22
                            },
                            "relationTableIndex": 4,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_MEMBER_INVITATION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATED_AT",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "DATE"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "INVITATION_PUBLIC_SIGNING_KEY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 13,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACCEPTING_REPOSITORY_MEMBER_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 15,
                                    "oneRelationIndex": 6,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_TRANSACTION_HISTORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 10,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryMemberAcceptance",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "createdAt",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "invitationPublicSigningKey",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "acceptingRepositoryMember",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "addedInRepositoryTransactionHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 13,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 15,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_MEMBER_ACCEPTANCES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_MEMBER_INVITATION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATED_AT",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "DATE"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "INVITATION_PUBLIC_SIGNING_KEY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 13,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "INVITED_REPOSITORY_MEMBER_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 15,
                                    "oneRelationIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_TRANSACTION_HISTORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 11,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryMemberInvitation",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "createdAt",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "invitationPublicSigningKey",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "invitedRepositoryMember",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "addedInRepositoryTransactionHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 13,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 15,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_MEMBER_INVITATIONS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_MEMBER_UPDATE_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATED_AT",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_ADMINISTRATOR",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CAN_WRITE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 13,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "UPDATED_REPOSITORY_MEMBER_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 15,
                                    "oneRelationIndex": 7,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_TRANSACTION_HISTORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 12,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryMemberUpdate",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "createdAt",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "isAdministrator",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "canWrite",
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "updatedRepositoryMember",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "addedInRepositoryTransactionHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 13,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 15,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_MEMBER_UPDATES",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_MEMBER_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "MEMBER_PUBLIC_SIGNING_KEY",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_OWNER",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_ADMINISTRATOR",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CAN_WRITE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "STATUS",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 9,
                                    "oneRelationIndex": 5,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "USER_ACCOUNT_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 15,
                                    "oneRelationIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_TRANSACTION_HISTORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 13,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryMember",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "memberPublicSigningKey",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "isOwner",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "isAdministrator",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "canWrite",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "status",
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "repository",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "userAccount",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "addedInRepositoryTransactionHistory",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "acceptances",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 10,
                            "isId": false,
                            "name": "invitations",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 11,
                            "isId": false,
                            "name": "updates",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 0,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 15,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repositoryMember"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 10,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repositoryMember"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 10
                            },
                            "relationTableIndex": 11,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repositoryMember"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 11
                            },
                            "relationTableIndex": 12,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_MEMBERS",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "allocationSize": 100,
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "TRANSACTION_HISTORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TRANSACTION_TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 14,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "TransactionHistory",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "transactionType",
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "name": "repositoryTransactionHistories",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "transactionHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 15,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "TRANSACTION_HISTORY",
                        "columnIndexes": []
                    }
                },
                {
                    "columns": [
                        {
                            "allocationSize": 200,
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_TRANSACTION_HISTORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_TRANSACTION_TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SAVE_TIMESTAMP",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SYNC_TIMESTAMP",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "GUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_REPOSITORY_CREATION",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "IS_PUBLIC",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "INVITATION_PRIVATE_SIGNING_KEY",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 13,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_MEMBER_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 10,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 9,
                                    "oneRelationIndex": 6,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 10
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 11,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 14,
                                    "oneRelationIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "TRANSACTION_HISTORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 11
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 15,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RepositoryTransactionHistory",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "repositoryTransactionType",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "saveTimestamp",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "syncTimestamp",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "GUID",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "isRepositoryCreation",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "isPublic",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 7,
                            "isId": false,
                            "name": "invitationPrivateSigningKey",
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "actor",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "member",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 10,
                            "isId": false,
                            "name": "repository",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 11,
                            "isId": false,
                            "name": "transactionHistory",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 12,
                            "isId": false,
                            "name": "operationHistory",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 13,
                            "isId": false,
                            "name": "newRepositoryMemberInvitations",
                            "relationRef": {
                                "index": 5
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 14,
                            "isId": false,
                            "name": "newRepositoryMemberAcceptances",
                            "relationRef": {
                                "index": 6
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 15,
                            "isId": false,
                            "name": "newRepositoryMemberUpdates",
                            "relationRef": {
                                "index": 7
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 16,
                            "isId": false,
                            "name": "newRepositoryMembers",
                            "relationRef": {
                                "index": 8
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 13,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 10
                            },
                            "relationTableIndex": 9,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 11
                            },
                            "relationTableIndex": 14,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "repositoryTransactionHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 12
                            },
                            "relationTableIndex": 16,
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "addedInRepositoryTransactionHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 13
                            },
                            "relationTableIndex": 11,
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "addedInRepositoryTransactionHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 14
                            },
                            "relationTableIndex": 10,
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "addedInRepositoryTransactionHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 15
                            },
                            "relationTableIndex": 12,
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "addedInRepositoryTransactionHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 16
                            },
                            "relationTableIndex": 13,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_TRANSACTION_HISTORY",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "allocationSize": 600,
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "OPERATION_HISTORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ORDER_NUMBER",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CHANGE_TYPE",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SYSTEM_WIDE_OPERATION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 15,
                                    "oneRelationIndex": 4,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_TRANSACTION_HISTORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 16,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "OperationHistory",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "orderNumber",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "changeType",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "systemWideOperationId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "repositoryTransactionHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "recordHistory",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 6,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 15,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "operationHistory"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 3,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_OPERATION_HISTORY",
                        "columnIndexes": []
                    }
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [
                {
                    "domain": "airport",
                    "index": 0,
                    "name": "@airport/travel-document-checkpoint",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                },
                {
                    "domain": "airport",
                    "index": 1,
                    "name": "@airport/airspace",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                }
            ],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION$3 = {
    "domain": "airport",
    "index": null,
    "name": "@airport/layover",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {}
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "RECORD_UPDATE_STAGE_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ACTOR_RECORD_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "UPDATED_VALUE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "ANY"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 8,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_VERSION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_ENTITY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 9,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 4,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "APPLICATION_COLUMN_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 0,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "RecordUpdateStage",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "_actorRecordId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "updatedValue",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "applicationVersion",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "entity",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "repository",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "actor",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "column",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 8,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 6,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 9,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 0,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 4,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "RECORD_UPDATE_STAGE",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COLUMNINDEX",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 2,
                                    "oneRelationIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "SYNCHRONIZATION_CONFLICT_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        }
                    ],
                    "index": 1,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "SynchronizationConflictValues",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "synchronizationConflict",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 1,
                            "isId": true,
                            "name": "columnIndex",
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 2,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "SYNCHRONIZATION_CONFLICT_VALUES",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "SYNCHRONIZATION_CONFLICT_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "TYPE",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ACKNOWLEDGED",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "BOOLEAN"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 9,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OVERWRITTEN_RECORD_HISTORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 4
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 3,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "OVERWRITING_RECORD_HISTORY_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "SynchronizationConflict",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 0
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_localId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 1
                            },
                            "index": 1,
                            "isId": false,
                            "name": "type",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 2,
                            "isId": false,
                            "name": "acknowledged",
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "name": "repository",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "name": "overwrittenRecordHistory",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 5,
                            "isId": false,
                            "name": "overwritingRecordHistory",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "values",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 3
                            },
                            "relationTableIndex": 9,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 4
                            },
                            "relationTableIndex": 3,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 5
                            },
                            "relationTableIndex": 3,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "synchronizationConflict"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "SYNCHRONIZATION_CONFLICT",
                        "columnIndexes": []
                    },
                    "operations": {}
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [
                {
                    "domain": "airport",
                    "index": 0,
                    "name": "@airport/airspace",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                },
                {
                    "domain": "airport",
                    "index": 1,
                    "name": "@airport/holding-pattern",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                }
            ],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION$2 = {
    "domain": "airport",
    "index": null,
    "name": "@airport/session-state",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {
                    "SessionStateApi": {
                        "operationMap": {
                            "getLoggedInUser": {
                                "isAsync": true,
                                "parameters": []
                            }
                        }
                    }
                }
            },
            "entities": [],
            "integerVersion": 1,
            "referencedApplications": [],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION$1 = {
    "domain": "airport",
    "index": null,
    "name": "@airport/flight-recorder",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {}
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 9,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ACTOR_RECORD_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "AGE_SUITABILITY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATED_AT",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "DATE"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SYSTEM_WIDE_OPERATION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "COPY_ACTOR_RECORD_ID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 6,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "COPY_APPLICATION_ENTITY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "COPY_ACTOR_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 4,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 9,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "COPY_REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 0,
                    "isLocal": false,
                    "isAirEntity": true,
                    "name": "CopiedRecordLedger",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_actorRecordId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "actor",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "ageSuitability",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "createdAt",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "systemWideOperationId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "copyActorRecordId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "copyAppEntity",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 8,
                            "isId": false,
                            "name": "copyActor",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "copyRepository",
                            "relationRef": {
                                "index": 4
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 0,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 9,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 6,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 8
                            },
                            "relationTableIndex": 0,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 4,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 9,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "COPIED_RECORD_LEDGER",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 9,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ACTOR_RECORD_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "AGE_SUITABILITY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATED_AT",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "DATE"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SYSTEM_WIDE_OPERATION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 1,
                                    "oneColumnIndex": 3,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ONE_SIDE_APPLICATION_RELATION_LID",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 3,
                                    "oneApplication_Index": 1,
                                    "oneTableIndex": 9,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "RELATION_REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 1,
                    "isLocal": false,
                    "isAirEntity": true,
                    "name": "CrossRepositoryRelationLedger",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_actorRecordId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "actor",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "ageSuitability",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "createdAt",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "systemWideOperationId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 6,
                            "isId": false,
                            "name": "relation",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 7,
                            "isId": false,
                            "name": "relatedRepository",
                            "relationRef": {
                                "index": 3
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 0,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 9,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 6
                            },
                            "relationTableIndex": 1,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 3,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 7
                            },
                            "relationTableIndex": 9,
                            "relationTableApplication_Index": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "CROSS_REPOSITORY_RELATION_LEDGER",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 2,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_RECORD_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 1,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 2,
                    "isLocal": true,
                    "isAirEntity": false,
                    "name": "LocalCopyReplacementLedger",
                    "properties": [
                        {
                            "index": 0,
                            "isId": true,
                            "name": "copiedRecordLedger",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 0
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "LOCAL_COPY_REPLACEMENT_LEDGER",
                        "columnIndexes": []
                    },
                    "operations": {}
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [
                {
                    "domain": "airport",
                    "index": 0,
                    "name": "@airport/airspace",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                },
                {
                    "domain": "airport",
                    "index": 1,
                    "name": "@airport/holding-pattern",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                }
            ],
            "versionString": "1.0.0"
        }
    ]
};

/* eslint-disable */
const APPLICATION = {
    "domain": "airbridge",
    "index": null,
    "name": "@airbridge/keyring",
    "sinceVersion": 1,
    "versions": [
        {
            "api": {
                "apiObjectMap": {}
            },
            "entities": [
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 9,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ACTOR_RECORD_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "AGE_SUITABILITY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATED_AT",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "DATE"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SYSTEM_WIDE_OPERATION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "ENCRYPTION_KEY",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_GUID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PRIVATE_SIGNING_KEY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 9,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "PUBLIC_SIGNING_KEY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 9
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 10,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "REPOSITORY_NAME",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 10
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 11,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "KEY_RING_RID_1",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 11
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 12,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 1,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "KEY_RING_AID_1",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 11
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 13,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 2,
                                    "oneApplication_Index": null,
                                    "oneTableIndex": 1,
                                    "oneRelationIndex": 2,
                                    "oneColumnIndex": 2,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "KEY_RING_ARID_1",
                            "notNull": false,
                            "propertyRefs": [
                                {
                                    "index": 11
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 0,
                    "isLocal": false,
                    "isAirEntity": true,
                    "name": "RepositoryKey",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_actorRecordId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "actor",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "ageSuitability",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "createdAt",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "systemWideOperationId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "encryptionKey",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 7,
                            "isId": false,
                            "name": "repositoryGUID",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 8
                            },
                            "index": 8,
                            "isId": false,
                            "name": "privateSigningKey",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 9
                            },
                            "index": 9,
                            "isId": false,
                            "name": "publicSigningKey",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 10
                            },
                            "index": 10,
                            "isId": false,
                            "name": "repositoryName",
                            "sinceVersion": 1
                        },
                        {
                            "index": 11,
                            "isId": false,
                            "name": "keyRing",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 0,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 9,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 11
                            },
                            "relationTableIndex": 1,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "REPOSITORY_KEY",
                        "columnIndexes": []
                    },
                    "operations": {}
                },
                {
                    "columns": [
                        {
                            "index": 0,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 1,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 9,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "REPOSITORY_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 2
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 1,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [
                                {
                                    "manyRelationIndex": 0,
                                    "oneApplication_Index": 0,
                                    "oneTableIndex": 0,
                                    "oneColumnIndex": 0,
                                    "sinceVersion": 1
                                }
                            ],
                            "name": "ACTOR_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 1
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 2,
                            "isGenerated": true,
                            "manyRelationColumnRefs": [],
                            "name": "ACTOR_RECORD_ID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 0
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 3,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "AGE_SUITABILITY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 3
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 4,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "CREATED_AT",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 5
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "DATE"
                        },
                        {
                            "index": 5,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "SYSTEM_WIDE_OPERATION_LID",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "NUMBER"
                        },
                        {
                            "index": 6,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "EMAIL",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 6
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 7,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "EXTERNAL_PRIVATE_KEY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 7
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        },
                        {
                            "index": 8,
                            "isGenerated": false,
                            "manyRelationColumnRefs": [],
                            "name": "INTERNAL_PRIVATE_SIGNING_KEY",
                            "notNull": true,
                            "propertyRefs": [
                                {
                                    "index": 8
                                }
                            ],
                            "sinceVersion": 1,
                            "type": "STRING"
                        }
                    ],
                    "idColumnRefs": [
                        {
                            "index": 0
                        },
                        {
                            "index": 1
                        },
                        {
                            "index": 2
                        }
                    ],
                    "index": 1,
                    "isLocal": false,
                    "isAirEntity": true,
                    "name": "KeyRing",
                    "properties": [
                        {
                            "columnRef": {
                                "index": 2
                            },
                            "index": 0,
                            "isId": true,
                            "name": "_actorRecordId",
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "name": "actor",
                            "relationRef": {
                                "index": 0
                            },
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": true,
                            "name": "repository",
                            "relationRef": {
                                "index": 1
                            },
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 3
                            },
                            "index": 3,
                            "isId": false,
                            "name": "ageSuitability",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 4
                            },
                            "index": 4,
                            "isId": false,
                            "name": "createdAt",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 5
                            },
                            "index": 5,
                            "isId": false,
                            "name": "systemWideOperationId",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 6
                            },
                            "index": 6,
                            "isId": false,
                            "name": "email",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 7
                            },
                            "index": 7,
                            "isId": false,
                            "name": "externalPrivateKey",
                            "sinceVersion": 1
                        },
                        {
                            "columnRef": {
                                "index": 8
                            },
                            "index": 8,
                            "isId": false,
                            "name": "internalPrivateSigningKey",
                            "sinceVersion": 1
                        },
                        {
                            "index": 9,
                            "isId": false,
                            "name": "repositoryKeys",
                            "relationRef": {
                                "index": 2
                            },
                            "sinceVersion": 1
                        }
                    ],
                    "relations": [
                        {
                            "index": 0,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 1
                            },
                            "relationTableIndex": 0,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 1,
                            "isId": true,
                            "relationType": "MANY_TO_ONE",
                            "propertyRef": {
                                "index": 2
                            },
                            "relationTableIndex": 9,
                            "relationTableApplication_Index": 0,
                            "sinceVersion": 1
                        },
                        {
                            "index": 2,
                            "isId": false,
                            "oneToManyElems": {
                                "mappedBy": "keyRing"
                            },
                            "relationType": "ONE_TO_MANY",
                            "propertyRef": {
                                "index": 9
                            },
                            "relationTableIndex": 0,
                            "sinceVersion": 1
                        }
                    ],
                    "sinceVersion": 1,
                    "tableConfig": {
                        "name": "KEY_RING",
                        "columnIndexes": []
                    },
                    "operations": {}
                }
            ],
            "integerVersion": 1,
            "referencedApplications": [
                {
                    "domain": "airport",
                    "index": 0,
                    "name": "@airport/holding-pattern",
                    "sinceVersion": 1,
                    "versions": [
                        {
                            "entities": null,
                            "integerVersion": 1,
                            "referencedApplications": null,
                            "versionString": "1.0.0"
                        }
                    ]
                }
            ],
            "versionString": "1.0.0"
        }
    ]
};

const BLUEPRINT = [
    APPLICATION$7,
    APPLICATION$6,
    APPLICATION$5,
    APPLICATION$4,
    APPLICATION$3,
    APPLICATION$2,
    APPLICATION$1,
    APPLICATION
];

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BLUEPRINT: BLUEPRINT
});

class SynchronizationConflict {
}

class SynchronizationConflictValues {
}

var DataOrigin;
(function (DataOrigin) {
    DataOrigin["LOCAL"] = "LOCAL";
    DataOrigin["REMOTE"] = "REMOTE";
})(DataOrigin || (DataOrigin = {}));

var ApplicationChangeStatus;
(function (ApplicationChangeStatus) {
    ApplicationChangeStatus["CHANGE_NEEDED"] = "CHANGE_NEEDED";
    ApplicationChangeStatus["CHANGE_COMPLETED"] = "CHANGE_COMPLETED";
})(ApplicationChangeStatus || (ApplicationChangeStatus = {}));

/**
 * Used to temporarily store updates during application remotely synced updates
 * to the local terminal.  Values are deleted right after the remote sync updates
 * are applied.
 */
class RecordUpdateStage {
}

const __constructors__$4 = {
    RecordUpdateStage,
    SynchronizationConflict,
    SynchronizationConflictValues
};
const Q_airport____at_airport_slash_layover = {
    __constructors__: __constructors__$4,
    domain: 'airport',
    name: '@airport/layover'
};
function airport____at_airport_slash_layover_diSet(dbEntityId) {
    return globalThis.airApi.dS(Q_airport____at_airport_slash_layover.__dbApplication__, dbEntityId);
}
if (globalThis.airApi) {
    globalThis.airApi.setQApp(Q_airport____at_airport_slash_layover);
}

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$2 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q_airport____at_airport_slash_layover);
    }
}
class BaseRecordUpdateStageDao extends SQDIDao$2 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_layover_diSet(0);
    }
    constructor() {
        super(0);
    }
}
BaseRecordUpdateStageDao.Find = new DaoQueryDecorators();
BaseRecordUpdateStageDao.FindOne = new DaoQueryDecorators();
BaseRecordUpdateStageDao.Search = new DaoQueryDecorators();
BaseRecordUpdateStageDao.SearchOne = new DaoQueryDecorators();
class BaseSynchronizationConflictDao extends SQDIDao$2 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_layover_diSet(2);
    }
    constructor() {
        super(2);
    }
}
BaseSynchronizationConflictDao.Find = new DaoQueryDecorators();
BaseSynchronizationConflictDao.FindOne = new DaoQueryDecorators();
BaseSynchronizationConflictDao.Search = new DaoQueryDecorators();
BaseSynchronizationConflictDao.SearchOne = new DaoQueryDecorators();
class BaseSynchronizationConflictValuesDao extends SQDIDao$2 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_layover_diSet(1);
    }
    constructor() {
        super(1);
    }
}
BaseSynchronizationConflictValuesDao.Find = new DaoQueryDecorators();
BaseSynchronizationConflictValuesDao.FindOne = new DaoQueryDecorators();
BaseSynchronizationConflictValuesDao.Search = new DaoQueryDecorators();
BaseSynchronizationConflictValuesDao.SearchOne = new DaoQueryDecorators();

class SynchronizationConflictDao extends BaseSynchronizationConflictDao {
    async insert(synchronizationConflicts, context) {
        let sc;
        const VALUES = [];
        for (const synchronizationConflict of synchronizationConflicts) {
            VALUES.push([
                synchronizationConflict.type,
                synchronizationConflict.acknowledged,
                synchronizationConflict.repository._localId,
                synchronizationConflict.overwrittenRecordHistory._localId,
                synchronizationConflict.overwritingRecordHistory._localId
            ]);
        }
        const ids = await this.db.insertValuesGenerateIds({
            INSERT_INTO: sc = Q_airport____at_airport_slash_layover.SynchronizationConflict,
            columns: [
                sc.type,
                sc.acknowledged,
                sc.repository._localId,
                sc.overwrittenRecordHistory._localId,
                sc.overwritingRecordHistory._localId
            ],
            VALUES
        }, context);
        for (let i = 0; i < synchronizationConflicts.length; i++) {
            let synchronizationConflict = synchronizationConflicts[i];
            synchronizationConflict._localId = ids[i][0];
        }
    }
}

class SynchronizationConflictValuesDao extends BaseSynchronizationConflictValuesDao {
    async insert(synchronizationConflictValues, context) {
        let scv;
        const VALUES = [];
        for (const synchronizationConflictValue of synchronizationConflictValues) {
            VALUES.push([
                synchronizationConflictValue.synchronizationConflict._localId,
                synchronizationConflictValue.columnIndex
            ]);
        }
        await this.db.insertValues({
            INSERT_INTO: scv = Q_airport____at_airport_slash_layover.SynchronizationConflictValues,
            columns: [
                scv.synchronizationConflict._localId,
                scv.columnIndex
            ],
            VALUES
        }, context);
    }
}

class RecordUpdateStageDao extends BaseRecordUpdateStageDao {
    async insertValues(values, context) {
        const rus = Q_airport____at_airport_slash_layover.RecordUpdateStage;
        const columns = [
            rus.applicationVersion._localId,
            rus.entity._localId,
            rus.repository._localId,
            rus.actor._localId,
            rus._actorRecordId,
            rus.column._localId,
            rus.updatedValue
        ];
        return await this.db.insertValuesGenerateIds({
            INSERT_INTO: rus,
            columns,
            VALUES: values
        }, {
            ...context,
            generateOnSync: true
        });
    }
    async updateEntityWhereIds(applicationIndex, applicationVersionId, tableIndex, idMap, updatedColumnIndexes, context) {
        const dbEntity = this.airportDatabase.applications[applicationIndex].currentVersion[0]
            .applicationVersion.entities[tableIndex];
        const qEntity = this.airportDatabase.qApplications[applicationIndex][dbEntity.name];
        const repositoryEquals = [];
        const AirEntity = this.dictionary.AirEntity;
        for (const [repositoryId, idsForRepository] of idMap) {
            const actorEquals = [];
            for (const [actorId, idsForActor] of idsForRepository) {
                actorEquals.push(AND(qEntity[AirEntity.properties.actor]._localId.equals(actorId), qEntity[AirEntity.properties._actorRecordId].IN(Array.from(idsForActor))));
            }
            repositoryEquals.push(AND(qEntity[AirEntity.properties.repository]._localId.equals(repositoryId), OR(...actorEquals)));
        }
        const setClause = {};
        for (const columnIndex of updatedColumnIndexes) {
            const column = dbEntity.columns[columnIndex];
            let columnRus = Q_airport____at_airport_slash_layover.RecordUpdateStage;
            let columnSetClause = field({
                FROM: [
                    columnRus
                ],
                SELECT: columnRus.updatedValue,
                WHERE: AND(columnRus.applicationVersion._localId.equals(applicationVersionId), columnRus.entity._localId.equals(dbEntity.index), columnRus.repository._localId.equals(qEntity.repository._localId), columnRus.actor._localId.equals(qEntity.actor._localId), columnRus._actorRecordId.equals(qEntity._actorRecordId), columnRus.column._localId.equals(column.index))
            });
            setClause[column.name] = columnSetClause;
        }
        await this.db.updateColumnsWhere({
            UPDATE: qEntity,
            SET: setClause,
            WHERE: OR(...repositoryEquals)
        }, context);
    }
    async delete(context) {
        return await this.db.deleteWhere({
            DELETE_FROM: Q_airport____at_airport_slash_layover.RecordUpdateStage
        }, context);
    }
}

const layover = lib('@airport/layover');
layover.register(RecordUpdateStageDao, SynchronizationConflictDao, SynchronizationConflictValuesDao);
layover.setDependencies(RecordUpdateStageDao, {
    airportDatabase: AIRPORT_DATABASE,
    dictionary: Dictionary
});

class Client {
    constructor() {
        // encryptionKey = process.env.ENCRYPTION_KEY
        this.serverLocationProtocol = 'http://';
    }
    async getRepositoryTransactions(location, repositoryGUID, sinceSyncTimestamp = null) {
        try {
            const response = await this.sendMessage(location + '/read', {
                repositoryGUID,
                syncTimestamp: sinceSyncTimestamp
            });
            if (response.error) {
                console.error(response.error);
                return [];
            }
            return response.fragments;
        }
        catch (e) {
            console.error(e);
            return [];
        }
    }
    async sendRepositoryTransactions(location, repositoryGUID, messages) {
        try {
            const response = await this.sendMessage(location + '/write', {
                messages,
                repositoryGUID
            });
            if (response.error) {
                console.error(response.error);
                return 0;
            }
            return response.syncTimestamp;
        }
        catch (e) {
            console.error(e);
            return 0;
        }
    }
    async sendMessage(location, request) {
        let packagedMessage = JSON.stringify(request);
        // if (this.encryptionKey) {
        //     packagedMessage = await encryptString(
        //         packagedMessage, this.encryptionKey)
        // }
        const response = await fetch(this.serverLocationProtocol + location, {
            method: 'PUT',
            mode: 'cors',
            // cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            // credentials: 'same-origin',
            headers: {
                'Content-Type': 'application/json'
            },
            // redirect: 'follow', // manual, *follow, error
            // referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
            body: packagedMessage // body data type must match "Content-Type" header
        });
        // let unpackagedMessage = response.text()
        // if (this.encryptionKey) {
        //     unpackagedMessage = await decryptString(unpackagedMessage, this.encryptionKey)
        // }
        // return JSON.parse(unpackagedMessage)
        return response.json();
    }
}

// import {
//     decryptString,
//     encryptString,
// } from "string-cipher";
const client = lib('client');
client.register(Client);

var ConstraintMode;
(function (ConstraintMode) {
    ConstraintMode["CONSTRAINT"] = "CONSTRAINT";
    ConstraintMode["NO_CONSTRAINT"] = "NO_CONSTRAINT";
    ConstraintMode["PROVIDER_DEFAULT"] = "PROVIDER_DEFAULT";
})(ConstraintMode || (ConstraintMode = {}));
const Column = function (columnConfiguration) {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const DbString = function () {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const ManyToOne = function (elements) {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};
const OneToMany = function (elements) {
    return function (targetObject, propertyKey) {
        // No runtime logic required.
    };
};

/**
 * Created by Papa on 8/20/2016.
 */
const Entity = function () {
    return function (constructor) {
        // No runtime logic required.
    };
};
const Table = function (tableConfiguration) {
    return function (constructor) {
        // No runtime logic required.
    };
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate$1(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

let KeyRing = class KeyRing extends InternalAirEntity$1 {
    constructor() {
        super(...arguments);
        this.repositoryKeys = [];
    }
};
__decorate$1([
    Column(),
    DbString()
], KeyRing.prototype, "email", void 0);
__decorate$1([
    Column(),
    DbString()
], KeyRing.prototype, "externalPrivateKey", void 0);
__decorate$1([
    Column(),
    DbString()
], KeyRing.prototype, "internalPrivateSigningKey", void 0);
__decorate$1([
    OneToMany()
], KeyRing.prototype, "repositoryKeys", void 0);
KeyRing = __decorate$1([
    Entity(),
    Table()
], KeyRing);

let RepositoryKey = class RepositoryKey extends InternalAirEntity$1 {
};
__decorate$1([
    Column(),
    DbString()
], RepositoryKey.prototype, "encryptionKey", void 0);
__decorate$1([
    Column(),
    DbString()
], RepositoryKey.prototype, "repositoryGUID", void 0);
__decorate$1([
    Column(),
    DbString()
], RepositoryKey.prototype, "privateSigningKey", void 0);
__decorate$1([
    Column(),
    DbString()
], RepositoryKey.prototype, "publicSigningKey", void 0);
__decorate$1([
    Column(),
    DbString()
], RepositoryKey.prototype, "repositoryName", void 0);
__decorate$1([
    ManyToOne()
], RepositoryKey.prototype, "keyRing", void 0);
RepositoryKey = __decorate$1([
    Entity(),
    Table()
], RepositoryKey);

const __constructors__$3 = {
    KeyRing,
    RepositoryKey
};
const Q_airbridge____at_airbridge_slash_keyring = {
    __constructors__: __constructors__$3,
    domain: 'airbridge',
    name: '@airbridge/keyring'
};
function airbridge____at_airbridge_slash_keyring_diSet(dbEntityId) {
    return globalThis.airApi.dS(Q_airbridge____at_airbridge_slash_keyring.__dbApplication__, dbEntityId);
}
if (globalThis.airApi) {
    globalThis.airApi.setQApp(Q_airbridge____at_airbridge_slash_keyring);
}

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao$1 extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q_airbridge____at_airbridge_slash_keyring);
    }
}
class BaseKeyRingDao extends SQDIDao$1 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airbridge____at_airbridge_slash_keyring_diSet(1);
    }
    constructor() {
        super(1);
    }
}
BaseKeyRingDao.Find = new DaoQueryDecorators();
BaseKeyRingDao.FindOne = new DaoQueryDecorators();
BaseKeyRingDao.Search = new DaoQueryDecorators();
BaseKeyRingDao.SearchOne = new DaoQueryDecorators();
class BaseRepositoryKeyDao extends SQDIDao$1 {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airbridge____at_airbridge_slash_keyring_diSet(0);
    }
    constructor() {
        super(0);
    }
}
BaseRepositoryKeyDao.Find = new DaoQueryDecorators();
BaseRepositoryKeyDao.FindOne = new DaoQueryDecorators();
BaseRepositoryKeyDao.Search = new DaoQueryDecorators();
BaseRepositoryKeyDao.SearchOne = new DaoQueryDecorators();

let KeyRingDao = class KeyRingDao extends BaseKeyRingDao {
    async findKeyRing(externalPrivateKey) {
        let Q = Q_airbridge____at_airbridge_slash_keyring;
        let kr;
        return this._findOne({
            SELECT: {},
            FROM: [
                kr = Q.KeyRing
            ],
            WHERE: kr.externalPrivateKey.equals(externalPrivateKey)
        });
    }
};
KeyRingDao = __decorate$1([
    Injected()
], KeyRingDao);

let RepositoryKeyDao = class RepositoryKeyDao extends BaseRepositoryKeyDao {
    async findByRepositoryGUIDs(internalPrivateSingingKey, repositoryGUIDs) {
        let kr, rk;
        return await this._find({
            SELECT: {
                privateSigningKey: Y,
                repositoryGUID: Y,
            },
            FROM: [
                kr = Q_airbridge____at_airbridge_slash_keyring.KeyRing,
                rk = kr.repositoryKeys.LEFT_JOIN()
            ],
            WHERE: AND(kr.internalPrivateSigningKey.equals(internalPrivateSingingKey), rk.repositoryGUID.IN(repositoryGUIDs))
        });
    }
};
RepositoryKeyDao = __decorate$1([
    Injected()
], RepositoryKeyDao);

const application$2 = {
    name: '@airbridge/keyring',
    domain: {
        name: 'airbridge'
    }
};

let KeyRingManager = class KeyRingManager {
    async getKeyRing(userPrivateKey, privateMetaSigningKey, context) {
        await this.repositoryLoader.loadRepository('DEVSERVR_' + userPrivateKey, {});
        let keyRing = await this.keyRingDao.findKeyRing(userPrivateKey);
        if (!keyRing) {
            const keyRingContext = {
                ...context,
                applicationFullName: this.dbApplicationUtils.getApplication_FullName(application$2),
                newRepositoryGUID: 'DEVSERVR_' + userPrivateKey,
                forKeyRingRepository: true
            };
            keyRing = new KeyRing();
            keyRing.externalPrivateKey = userPrivateKey;
            keyRing.internalPrivateSigningKey = privateMetaSigningKey;
            const userSession = await this.terminalSessionManager.getUserSession();
            userSession.keyRing = keyRing;
            const repository = await this.repositoryManager
                .createRepository('Key ring', false, keyRingContext);
            keyRing.repository = repository;
            await this.keyRingDao.save(keyRing, keyRingContext);
        }
        return keyRing;
    }
    async addRepositoryKey(repositoryGUID, repositoryName) {
        // const encryptionKey = await this.keyUtils.getEncryptionKey()
        const signingKey = await this.keyUtils.getSigningKey();
        const userSession = await this.terminalSessionManager.getUserSession();
        if (!userSession) {
            throw new Error(`No User Session found`);
        }
        const keyRing = userSession.keyRing;
        if (!keyRing) {
            throw new Error(`No Key Ring found in User Session`);
        }
        const memberPublicSigningKey = signingKey.public;
        const repositoryKey = new RepositoryKey();
        repositoryKey.repositoryGUID = repositoryGUID;
        repositoryKey.keyRing = userSession.keyRing;
        repositoryKey.publicSigningKey = memberPublicSigningKey;
        repositoryKey.privateSigningKey = signingKey.private;
        repositoryKey.repositoryName = repositoryName;
        keyRing.repositoryKeys.push(repositoryKey);
        repositoryKey.repository = keyRing.repository;
        await this.repositoryKeyDao.save(repositoryKey);
        return memberPublicSigningKey;
    }
};
__decorate$1([
    Inject()
], KeyRingManager.prototype, "dbApplicationUtils", void 0);
__decorate$1([
    Inject()
], KeyRingManager.prototype, "keyRingDao", void 0);
__decorate$1([
    Inject()
], KeyRingManager.prototype, "keyUtils", void 0);
__decorate$1([
    Inject()
], KeyRingManager.prototype, "repositoryKeyDao", void 0);
__decorate$1([
    Inject()
], KeyRingManager.prototype, "repositoryLoader", void 0);
__decorate$1([
    Inject()
], KeyRingManager.prototype, "repositoryManager", void 0);
__decorate$1([
    Inject()
], KeyRingManager.prototype, "terminalSessionManager", void 0);
KeyRingManager = __decorate$1([
    Injected()
], KeyRingManager);

let MessageSigningManager = class MessageSigningManager {
    async signMessages(unsingedMessages) {
        const keyRing = (await this.terminalSessionManager.getUserSession()).keyRing;
        if (!keyRing) {
            throw new Error(`No KeyRing is not set on UserSession.`);
        }
        const repositoryGUIDSet = new Set();
        for (const unsignedMessage of unsingedMessages) {
            repositoryGUIDSet.add(unsignedMessage.data.history.repository.GUID);
        }
        const repositoryKeys = await this.repositoryKeyDao
            .findByRepositoryGUIDs(keyRing.internalPrivateSigningKey, Array.from(repositoryGUIDSet));
        const repositoryKeysByRepositoryGUIDs = new Map();
        for (const repositoryKey of repositoryKeys) {
            repositoryKeysByRepositoryGUIDs.set(repositoryKey.repository.GUID, repositoryKey);
        }
        for (const unsingedMessage of unsingedMessages) {
            const history = unsingedMessage.data.history;
            const repositoryKey = repositoryKeysByRepositoryGUIDs
                .get(history.repository.GUID);
            const contents = JSON.stringify(unsingedMessage);
            unsingedMessage.memberSignature = await this.keyUtils
                .sign(contents, repositoryKey.privateSigningKey);
            if (history.invitationPrivateSigningKey) {
                unsingedMessage.acceptanceSignature = await this.keyUtils
                    .sign(contents, history.invitationPrivateSigningKey);
            }
            if (history.invitationPrivateSigningKey || history.isRepositoryCreation) {
                unsingedMessage.userAccountSignature = await this.keyUtils
                    .sign(contents, keyRing.internalPrivateSigningKey);
            }
        }
    }
};
__decorate$1([
    Inject()
], MessageSigningManager.prototype, "keyUtils", void 0);
__decorate$1([
    Inject()
], MessageSigningManager.prototype, "repositoryKeyDao", void 0);
__decorate$1([
    Inject()
], MessageSigningManager.prototype, "terminalSessionManager", void 0);
MessageSigningManager = __decorate$1([
    Injected()
], MessageSigningManager);

const keyring = app(application$2);
keyring.register(KeyRingDao, KeyRingManager, MessageSigningManager, RepositoryKeyDao);
keyring.setDependencies(KeyRingManager, {
    dbApplicationUtils: DbApplicationUtils,
    keyRingDao: KeyRingDao,
    keyUtils: KeyUtils,
    repositoryKeyDao: RepositoryKeyDao,
    repositoryLoader: REPOSITORY_LOADER,
    repositoryManager: REPOSITORY_MANAGER,
    terminalSessionManager: TERMINAL_SESSION_MANAGER
});
keyring.setDependencies(MessageSigningManager, {
    terminalSessionManager: TERMINAL_SESSION_MANAGER
});

class DebugSynchronizationAdapter {
    async getTransactionsForRepository(repositoryGUID, sinceSyncTimestamp) {
        const location = this.getLocation(repositoryGUID);
        const response = await this.client.getRepositoryTransactions(location, repositoryGUID, sinceSyncTimestamp);
        const messages = [];
        // NOTE: syncTimestamp is populated here because file sharing mechanisms
        // (IPFS) won't be able to modify the messages themselves
        for (const fragment of response) {
            if (fragment.repositoryGUID !== repositoryGUID) {
                console.error(`Got a reponse fragment for repository ${fragment.repositoryGUID}.
    Expecting message fragments for repository: ${repositoryGUID}`);
                continue;
            }
            for (const message of fragment.messages) {
                message.syncTimestamp = fragment.syncTimestamp;
                messages.push(message);
            }
        }
        return messages;
    }
    async sendTransactions(repositoryGUID, messagesForRepository) {
        let allSent = true;
        try {
            if (!await this.sendTransactionsForRepository(repositoryGUID, messagesForRepository)) {
                allSent = false;
            }
        }
        catch (e) {
            console.error(e);
            allSent = false;
        }
        return allSent;
    }
    async sendTransactionsForRepository(repositoryGUID, messages) {
        if (!messages || !messages.length) {
            return false;
        }
        const location = this.getLocation(repositoryGUID);
        const syncTimestamp = await this.client.sendRepositoryTransactions(location, repositoryGUID, messages);
        if (!syncTimestamp) {
            return false;
        }
        for (const message of messages) {
            message.syncTimestamp = syncTimestamp;
        }
        return true;
    }
    getLocation(repositoryGUID) {
        // if (repositorySource !== 'DEVSERVR') {
        //     throw new Error(`DebugSynchronizationAdapter only supports DEVSERVR source`)
        // }
        return 'localhost:9000';
    }
}

class SynchronizationAdapterLoader {
    async load(repositoryGUID) {
        // switch (synchronizationSource) {
        //     case 'IPFS': {
        //         throw new Error(`Not Implemented`)
        //     }
        //     case 'DEVSERVR': {
        return this.debugSynchronizationAdapter;
        //     }
        //     default:
        //         throw new Error(`Unexpected synchronization source: ${synchronizationSource}`)
        // }
    }
}

class SyncInActorChecker {
    async ensureActors(data, context) {
        try {
            let actorGUIDs = [];
            let messageActorIndexMap = new Map();
            for (let i = 0; i < data.actors.length; i++) {
                const actor = data.actors[i];
                if (typeof actor.GUID !== 'string' || actor.GUID.length !== 36) {
                    throw new Error(`Invalid 'terminal.GUID'`);
                }
                this.checkActorApplication(actor, data);
                this.checkActorTerminal(actor, data);
                this.checkActorUserAccount(actor, data);
                actorGUIDs.push(actor.GUID);
                messageActorIndexMap.set(actor.GUID, i);
                // Make sure id field is not in the input
                delete actor._localId;
            }
            const actors = await this.actorDao.findByGUIDs(actorGUIDs);
            for (const actor of actors) {
                const messageUserAccountIndex = messageActorIndexMap.get(actor.GUID);
                data.actors[messageUserAccountIndex] = actor;
            }
            const missingActors = data.actors
                .filter(messageActor => !messageActor._localId);
            if (missingActors.length) {
                await this.actorDao.insert(missingActors, context);
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    checkActorApplication(actor, data) {
        if (typeof actor.application !== 'number') {
            throw new Error(`Expecting "in-message index" (number)
			in 'actor.terminal'`);
        }
        const application = data.applications[actor.application];
        if (!application) {
            throw new Error(`Did not find actor.application with "in-message index" ${actor.application}`);
        }
        actor.application = application;
    }
    checkActorTerminal(actor, data) {
        if (typeof actor.terminal !== 'number') {
            throw new Error(`Expecting "in-message index" (number)
			in 'actor.terminal'`);
        }
        const terminal = data.terminals[actor.terminal];
        if (!terminal) {
            throw new Error(`Did not find actor.terminal with "in-message index" ${actor.terminal}`);
        }
        actor.terminal = terminal;
    }
    checkActorUserAccount(actor, data) {
        if (typeof actor.userAccount !== 'number') {
            throw new Error(`Expecting "in-message index" (number)
			in 'actor.userAccount'`);
        }
        const userAccount = data.userAccounts[actor.userAccount];
        if (!userAccount) {
            throw new Error(`Did not find actor.userAccount with "in-message index" ${actor.userAccount}`);
        }
        actor.userAccount = userAccount;
    }
}

class SyncInApplicationChecker {
    async ensureApplications(data, context) {
        try {
            let applicationCheckMap = await this.checkApplicationsAndDomains(data, context);
            for (let i = 0; i < data.applications.length; i++) {
                let application = data.applications[i];
                data.applications[i] = applicationCheckMap
                    .get(application.domain.name).get(application.name)
                    .application;
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    async checkApplicationsAndDomains(data, context) {
        const { allApplication_Names, domainCheckMap, domainNames, applicationCheckMap } = this.getNames(data);
        const applications = await this.applicationDao
            .findByDomain_NamesAndApplication_Names(domainNames, allApplication_Names);
        for (let application of applications) {
            let domainName = application.domain.name;
            let applicationName = application.name;
            for (let [_, applicationCheck] of applicationCheckMap.get(domainName)) {
                if (applicationCheck.applicationName === applicationName) {
                    let domainCheck = domainCheckMap.get(domainName);
                    domainCheck.found = true;
                    domainCheck.domain = application.domain;
                    applicationCheck.found = true;
                    applicationCheck.application = application;
                }
            }
        }
        let domainsToCreate = [];
        for (let [name, domainCheck] of domainCheckMap) {
            if (domainCheck.found) {
                continue;
            }
            let domain = {
                _localId: null,
                name
            };
            domainCheck.domain = domain;
            domainsToCreate.push(domain);
        }
        if (domainsToCreate.length) {
            await this.domainDao.insert(domainsToCreate);
        }
        let applicationsToCreate = [];
        for (let [domainName, applicationChecksByName] of applicationCheckMap) {
            for (let [name, applicationCheck] of applicationChecksByName) {
                if (applicationCheck.found) {
                    continue;
                }
                let domain = domainCheckMap.get(domainName).domain;
                let application = {
                    domain,
                    index: null,
                    name,
                    scope: 'private',
                    status: ApplicationStatus.STUB,
                    signature: 'localhost'
                };
                applicationCheck.application = application;
                applicationsToCreate.push(application);
            }
        }
        if (applicationsToCreate.length) {
            await this.applicationDao.insert(applicationsToCreate, context);
        }
        return applicationCheckMap;
    }
    getNames(message) {
        if (!message.applications || !(message.applications instanceof Array)) {
            throw new Error(`Did not find applications in RepositorySynchronizationData.`);
        }
        const domainCheckMap = new Map();
        const applicationCheckMap = new Map();
        for (let application of message.applications) {
            if (typeof application !== 'object') {
                throw new Error(`Invalid ApplicationVersion.application`);
            }
            if (!application.name || typeof application.name !== 'string') {
                throw new Error(`Invalid ApplicationVersion.Application.name`);
            }
            const domain = application.domain;
            if (typeof domain !== 'object') {
                throw new Error(`Invalid ApplicationVersion.Application.Domain`);
            }
            if (!domain.name || typeof domain.name !== 'string') {
                throw new Error(`Invalid ApplicationVersion.Application.Domain.name`);
            }
            let applicationChecksForDomain = applicationCheckMap.get(domain.name);
            if (!applicationChecksForDomain) {
                applicationChecksForDomain = new Map();
                applicationCheckMap.set(domain.name, applicationChecksForDomain);
            }
            if (!applicationChecksForDomain.has(application.name)) {
                applicationChecksForDomain.set(application.name, {
                    applicationName: application.name,
                });
            }
            let domainCheck = domainCheckMap.get(domain.name);
            if (!domainCheck) {
                domainCheckMap.set(domain.name, {
                    domainName: domain.name
                });
            }
        }
        const domainNames = [];
        const allApplication_Names = [];
        for (const [domainName, applicationChecksForDomainMap] of applicationCheckMap) {
            domainNames.push(domainName);
            for (let [applicationName, _] of applicationChecksForDomainMap) {
                allApplication_Names.push(applicationName);
            }
        }
        return {
            allApplication_Names,
            domainCheckMap,
            domainNames,
            applicationCheckMap
        };
    }
}

class SyncInApplicationVersionChecker {
    async ensureApplicationVersions(
    // message: RepositorySynchronizationData,
    inMessageApplicationVersions, inMessageApplications, context) {
        let applicationCheckMap;
        try {
            applicationCheckMap = await this.checkVersionsApplicationsDomains(inMessageApplicationVersions, inMessageApplications);
            for (let i = 0; i < inMessageApplicationVersions.length; i++) {
                const applicationVersion = inMessageApplicationVersions[i];
                inMessageApplicationVersions[i] = applicationCheckMap
                    .get(applicationVersion.application.domain.name).get(applicationVersion.application.name)
                    .applicationVersion;
            }
        }
        catch (e) {
            console.error(e);
            return null;
        }
        return applicationCheckMap;
    }
    async checkVersionsApplicationsDomains(inMessageApplicationVersions, inMessageApplications) {
        const { allApplicationNames: allApplication_Names, domainNames, applicationVersionCheckMap } = this
            .getNames(inMessageApplicationVersions, inMessageApplications);
        await this.setApplicationVersions(domainNames, allApplication_Names, applicationVersionCheckMap);
        const domainWithNewApp_NameSet = new Set();
        const newApplicationNameSet = new Set();
        for (const [domainName, applicationChecks] of applicationVersionCheckMap) {
            for (let [_, applicationCheck] of applicationChecks) {
                if (!applicationCheck.found) {
                    domainWithNewApp_NameSet.add(domainName);
                    newApplicationNameSet.add(applicationCheck.applicationName);
                    await this.applicationInitializer.installApplication(domainName, applicationCheck.applicationName);
                }
            }
        }
        await this.setApplicationVersions(Array.from(domainWithNewApp_NameSet), Array.from(newApplicationNameSet), applicationVersionCheckMap);
        return applicationVersionCheckMap;
    }
    async setApplicationVersions(domainNames, allApplication_Names, applicationVersionCheckMap) {
        const existingApplicationVersions = await this.applicationVersionDao
            .findByDomain_NamesAndApplication_Names(domainNames, allApplication_Names);
        let lastDomainName;
        let lastApplicationName;
        for (let applicationVersion of existingApplicationVersions) {
            const domainName = applicationVersion.application.domain.name;
            const applicationName = applicationVersion.application.name;
            if (lastDomainName !== domainName && lastApplicationName !== applicationName) {
                const applicationVersionNumber = applicationVersion.integerVersion;
                const applicationVersionCheckMapForDomain = applicationVersionCheckMap.get(domainName);
                for (let [_, applicationCheck] of applicationVersionCheckMapForDomain) {
                    if (applicationCheck.applicationName === applicationName) {
                        applicationCheck.found = true;
                        if (applicationCheck.applicationVersionNumber > applicationVersionNumber) {
                            throw new Error(`Installed application ${applicationName} for domain ${domainName}
	is at a lower version ${applicationVersionNumber} than needed in message ${applicationCheck.applicationVersionNumber}.`);
                        }
                        applicationCheck.applicationVersion = applicationVersion;
                    }
                }
                lastDomainName = domainName;
                lastApplicationName = applicationName;
            }
        }
    }
    getNames(inMessageApplicationVersions, inMessageApplications) {
        if (!inMessageApplicationVersions || !(inMessageApplicationVersions instanceof Array)) {
            throw new Error(`Did not find applicationVersions in RepositorySynchronizationData.`);
        }
        const applicationVersionCheckMap = new Map();
        for (let applicationVersion of inMessageApplicationVersions) {
            if (!applicationVersion.integerVersion || typeof applicationVersion.integerVersion !== 'number') {
                throw new Error(`Invalid ApplicationVersion.integerVersion.`);
            }
            const application = inMessageApplications[applicationVersion.application];
            if (typeof application !== 'object') {
                throw new Error(`Invalid ApplicationVersion.application`);
            }
            applicationVersion.application = application;
            const domain = application.domain;
            let applicationChecksForDomain = applicationVersionCheckMap.get(domain.name);
            if (!applicationChecksForDomain) {
                applicationChecksForDomain = new Map();
                applicationVersionCheckMap.set(domain.name, applicationChecksForDomain);
            }
            if (!applicationChecksForDomain.has(application.name)) {
                applicationChecksForDomain.set(application.name, {
                    applicationName: application.name,
                    applicationVersionNumber: applicationVersion.integerVersion,
                    found: false
                });
            }
        }
        const domainNames = [];
        const allApplicationNames = [];
        for (const [domainName, applicationChecksForDomainMap] of applicationVersionCheckMap) {
            domainNames.push(domainName);
            for (let [applicationName, _] of applicationChecksForDomainMap) {
                allApplicationNames.push(applicationName);
            }
        }
        return {
            allApplicationNames: allApplicationNames,
            domainNames,
            applicationVersionCheckMap
        };
    }
}

class SyncInChecker {
    /**
     * Check the message and load all required auxiliary entities.
     */
    async checkData(message, context) {
        // FIXME: replace as many DB lookups as possible with Terminal State lookups
        let data = message.data;
        let serializedData = JSON.stringify(data);
        if (!await this.syncInUserAccountChecker.ensureUserAccounts(data, context)) {
            return {
                isValid: false
            };
        }
        if (!await this.syncInTerminalChecker.ensureTerminals(data, context)) {
            return {
                isValid: false
            };
        }
        if (!await this.syncInApplicationChecker.ensureApplications(data, context)) {
            return {
                isValid: false
            };
        }
        if (!await this.syncInActorChecker.ensureActors(data, context)) {
            return {
                isValid: false
            };
        }
        const repositoryAndMemberCheckResult = await this.syncInRepositoryChecker
            .checkRepositoriesAndMembers(message);
        if (!repositoryAndMemberCheckResult.isValid) {
            return {
                isValid: false
            };
        }
        for (const signatureCheck of repositoryAndMemberCheckResult.signatureChecks) {
            if (!this.keyUtils.verify(serializedData, signatureCheck.signatureToCheck, signatureCheck.publicSigningKey)) {
                console.error(`message.${signatureCheck.signatureName} is not valid.`);
                return {
                    isValid: false
                };
            }
        }
        if (!await this.syncInApplicationVersionChecker.ensureApplicationVersions(data.applicationVersions, data.applications, context)) {
            return {
                isValid: false
            };
        }
        const dataCheckResult = await this.syncInDataChecker.checkData(message, context);
        return {
            ...dataCheckResult,
            ...repositoryAndMemberCheckResult
        };
    }
    async checkReferencedApplicationRelations(data, _context) {
        // TODO: check referencedApplicationRelations
        data.referencedApplicationVersions;
        const applicationEntityMap = await this.syncInDataChecker.populateApplicationEntityMap(data.referencedApplicationVersions);
        const applicationRelationMap = new Map();
        for (let i = 0; i < data.referencedApplicationRelations.length; i++) {
            const referencedRelation = data.referencedApplicationRelations[i];
            if (typeof referencedRelation !== 'object') {
                throw new Error(`Invalid referencedApplicationRelations[${i}] objectg`);
            }
            if (typeof referencedRelation.index !== 'number') {
                throw new Error(`Expecting "index" (number)
					in 'referencedApplicationRelations[${i}].index'`);
            }
            const referencedEntity = referencedRelation.entity;
            if (typeof referencedEntity !== 'object') {
                throw new Error(`Invalid referencedApplicationRelations[${i}].entity`);
            }
            if (typeof referencedEntity.applicationVersion !== 'number') {
                throw new Error(`Expecting "in-message index" (number)
					in 'referencedApplicationRelations[${i}].entity.applicationVersion'`);
            }
            if (typeof referencedEntity.index !== 'number') {
                throw new Error(`Expecting "index" (number)
					in 'referencedApplicationRelations[${i}].entity.index'`);
            }
            const messageApplicationVersion = data
                .referencedApplicationVersions[referencedEntity.applicationVersion];
            if (!messageApplicationVersion) {
                throw new Error(`No Application Version with in-message index ${referencedEntity.applicationVersion}.
Declared in 'referencedApplicationRelations[${i}].entity.applicationVersion'`);
            }
            const applicationEntity = applicationEntityMap.get(messageApplicationVersion.application.domain.name)
                .get(messageApplicationVersion.application.name).get(referencedEntity.index);
            if (!applicationEntity) {
                throw new Error(`Invalid referencedApplicationRelations[${i}].entity.index: ${referencedEntity.index}`);
            }
            const applicationRelationsForEntityMap = this.datastructureUtils.ensureChildJsMap(applicationRelationMap, applicationEntity._localId);
            let applicationRelation = applicationRelationsForEntityMap.get(referencedRelation.index);
            if (applicationRelation) {
                throw new Error(`referencedApplicationRelations[${i}].index: ${referencedRelation.index} is defined more than once`);
            }
            for (const relation of applicationEntity.relations) {
                if (relation.index === referencedRelation.index) {
                    applicationRelation = relation;
                    break;
                }
            }
            if (!applicationRelation) {
                throw new Error(`Invalid referencedApplicationRelations[${i}].index: ${referencedRelation.index}`);
            }
            applicationRelationsForEntityMap.set(referencedRelation.index, applicationRelation);
            data.referencedApplicationRelations[i] = applicationRelation;
        }
    }
}

class SyncInDataChecker {
    /**
     * Every dataMessage.data.repoTransHistories array must be sorted before entering
     * this method.
     *
     * @param {IDataToTM[]} dataMessagesWithCompatibleApplications
     * @returns {DataCheckResults}
     */
    async checkData(message, context) {
        const history = message.data.history;
        let operationHistoryCheckResult;
        try {
            if (!history || typeof history !== 'object') {
                throw new Error(`Invalid RepositorySynchronizationData.history`);
            }
            if (typeof history.GUID !== 'string' || history.GUID.length !== 36) {
                throw new Error(`Invalid RepositorySynchronizationData.history.GUID`);
            }
            if (!history.operationHistory || !(history.operationHistory instanceof Array)) {
                throw new Error(`Invalid RepositorySynchronizationData.history.operationHistory`);
            }
            if (!history.saveTimestamp || typeof history.saveTimestamp !== 'number') {
                throw new Error(`Invalid RepositorySynchronizationData.history.saveTimestamp`);
            }
            if (history.transactionHistory) {
                throw new Error(`RepositorySynchronizationData.history.transactionHistory cannot be specified`);
            }
            if (history.repositoryTransactionType) {
                throw new Error(`RepositorySynchronizationData.history.repositoryTransactionType cannot be specified`);
            }
            if (history.syncTimestamp) {
                throw new Error(`RepositorySynchronizationData.history.syncTimestamp cannot be specified`);
            }
            const actor = message.data.actors[history.actor];
            if (!actor) {
                throw new Error(`Cannot find Actor for "in-message id"
RepositorySynchronizationData.history.actor`);
            }
            history.actor = actor;
            // Repository is already set in SyncInRepositoryChecker
            history.repositoryTransactionType = RepositoryTransactionType.REMOTE;
            history.syncTimestamp = message.syncTimestamp;
            delete history._localId;
            const applicationEntityMap = await this.populateApplicationEntityMap(message.data.applicationVersions);
            operationHistoryCheckResult = await this.checkOperationHistories(message.data, applicationEntityMap, context);
        }
        catch (e) {
            console.error(e);
            return {
                isValid: false
            };
        }
        return {
            ...operationHistoryCheckResult,
            isValid: true
        };
    }
    async populateApplicationEntityMap(messageApplicationVersions) {
        const applicationVersionsByIds = this.terminalStore.getAllApplicationVersionsByIds();
        const applicationEntityMap = new Map();
        for (const messageApplicationVersion of messageApplicationVersions) {
            const applicationVersion = applicationVersionsByIds[messageApplicationVersion._localId];
            for (const applicationEntity of applicationVersion.entities) {
                const entitiesForApplication = this.datastructureUtils.ensureChildJsMap(this.datastructureUtils.ensureChildJsMap(applicationEntityMap, applicationVersion.application.domain.name), applicationVersion.application.name);
                entitiesForApplication.set(applicationEntity.index, applicationEntity);
            }
        }
        return applicationEntityMap;
    }
    async checkOperationHistories(data, applicationEntityMap, context) {
        const forImmediateProcessing = [];
        const forDelayedProcessing = [];
        const history = data.history;
        if (!(history.operationHistory instanceof Array) || !history.operationHistory.length) {
            throw new Error(`Invalid RepositorySynchronizationData.history.operationHistory Array`);
        }
        const systemWideOperationIds = this.systemWideOperationIdUtils.getSysWideOpIds(history.operationHistory.length);
        let orderNumber = 0;
        for (let i = 0; i < history.operationHistory.length; i++) {
            const operationHistory = history.operationHistory[i];
            if (typeof operationHistory !== 'object') {
                throw new Error(`Invalid operationHistory[${i}]`);
            }
            if (operationHistory.orderNumber) {
                throw new Error(`RepositorySynchronizationData.history -> operationHistory[${i}].orderNumber cannot be specified,
the position of orderHistory record determines it's order`);
            }
            operationHistory.orderNumber = ++orderNumber;
            switch (operationHistory.changeType) {
                case ChangeType.DELETE_ROWS:
                case ChangeType.INSERT_VALUES:
                case ChangeType.UPDATE_ROWS:
                    break;
                default:
                    throw new Error(`Invalid operationHistory[${i}].changeType: ${operationHistory.changeType}`);
            }
            if (typeof operationHistory.entity !== 'object') {
                throw new Error(`Invalid operationHistory[${i}].entity`);
            }
            if (typeof operationHistory.entity.applicationVersion !== 'number') {
                throw new Error(`Expecting "in-message index" (number)
					in 'operationHistory[${i}].entity.applicationVersion'`);
            }
            const applicationVersion = data.applicationVersions[operationHistory.entity.applicationVersion];
            if (!applicationVersion) {
                throw new Error(`Invalid index into message.applicationVersions [${operationHistory.entity.applicationVersion}],
				in operationHistory[${i}].entity.applicationVersion`);
            }
            const applicationEntity = applicationEntityMap.get(applicationVersion.application.domain.name)
                .get(applicationVersion.application.name).get(operationHistory.entity.index);
            if (!applicationEntity) {
                throw new Error(`Invalid operationHistory[${i}].entity.index: ${operationHistory.entity.index}`);
            }
            operationHistory.entity = applicationEntity;
            if (operationHistory.repositoryTransactionHistory) {
                throw new Error(`RepositorySynchronizationData.history -> operationHistory[${i}].repositoryTransactionHistory cannot be specified`);
            }
            operationHistory.repositoryTransactionHistory = history;
            if (operationHistory.systemWideOperationId) {
                throw new Error(`RepositorySynchronizationData.history -> operationHistory[${i}].systemWideOperationId cannot be specified`);
            }
            operationHistory.systemWideOperationId = systemWideOperationIds[i];
            delete operationHistory._localId;
            const entityColumnMapsByIndex = {
                actorIds: new Map(),
                referencedRelationIds: new Map(),
                repositoryIds: new Map(),
                terminalIds: new Map(),
                userAccountIds: new Map()
            };
            for (const dbColumn of operationHistory.entity.columns) {
                if (this.applicationUtils.isManyRelationColumn(dbColumn)) {
                    const oneSideDbEntity = this.applicationUtils
                        .getOneSideEntityOfManyRelationColumn(dbColumn);
                    if (this.dictionary.isActor(oneSideDbEntity)) {
                        entityColumnMapsByIndex.actorIds.set(dbColumn.index, dbColumn);
                    }
                    else if (this.dictionary.isRepository(oneSideDbEntity)) {
                        entityColumnMapsByIndex.repositoryIds.set(dbColumn.index, dbColumn);
                    }
                    else if (this.dictionary.isTerminal(oneSideDbEntity)) {
                        entityColumnMapsByIndex.terminalIds.set(dbColumn.index, dbColumn);
                    }
                    else if (this.dictionary.isUserAccount(oneSideDbEntity)) {
                        entityColumnMapsByIndex.userAccountIds.set(dbColumn.index, dbColumn);
                    }
                    else if (this.dictionary.isApplicationRelation(oneSideDbEntity)) {
                        entityColumnMapsByIndex.referencedRelationIds.set(dbColumn.index, dbColumn);
                    }
                }
            }
            {
                forImmediateProcessing.push(operationHistory);
            }
            await this.checkRecordHistories(operationHistory, entityColumnMapsByIndex, data, context);
        }
        return {
            forImmediateProcessing,
            forDelayedProcessing
        };
    }
    async checkRecordHistories(operationHistory, entityColumnMapsByIndex, data, context) {
        const recordHistories = operationHistory.recordHistory;
        if (!(recordHistories instanceof Array) || !recordHistories.length) {
            throw new Error(`Inalid RepositorySynchronizationData.history -> operationHistory.recordHistory`);
        }
        for (const recordHistory of recordHistories) {
            if (!recordHistory._actorRecordId || typeof recordHistory._actorRecordId !== 'number') {
                throw new Error(`Invalid RepositorySynchronizationData.history -> operationHistory.recordHistory._actorRecordId`);
            }
            switch (operationHistory.changeType) {
                case ChangeType.INSERT_VALUES:
                    if (recordHistory.actor) {
                        throw new Error(`Cannot specify RepositorySynchronizationData.history -> operationHistory.recordHistory.actor
for ChangeType.INSERT_VALUES`);
                    }
                    recordHistory.actor = data.history.actor;
                    break;
                case ChangeType.DELETE_ROWS:
                case ChangeType.UPDATE_ROWS: {
                    // If no actor is present on record level its the same actor that created the repositoryTransactionHistory
                    if (recordHistory.actor === undefined) {
                        recordHistory.actor = data.history.actor;
                    }
                    else {
                        const actor = data.actors[recordHistory.actor];
                        if (!actor) {
                            throw new Error(`Did find Actor for "in-message id" in RepositorySynchronizationData.history -> operationHistory.actor`);
                        }
                        recordHistory.actor = actor;
                    }
                    break;
                }
            }
            if (recordHistory.operationHistory) {
                throw new Error(`RepositorySynchronizationData.history -> operationHistory.recordHistory.operationHistory cannot be specified`);
            }
            this.checkNewValues(recordHistory, entityColumnMapsByIndex, operationHistory, data);
            this.checkOldValues(recordHistory, entityColumnMapsByIndex, operationHistory, data);
            recordHistory.operationHistory = operationHistory;
            delete recordHistory._localId;
        }
    }
    checkNewValues(recordHistory, entityColumnMapsByIndex, operationHistory, data) {
        switch (operationHistory.changeType) {
            case ChangeType.DELETE_ROWS:
                if (recordHistory.newValues) {
                    throw new Error(`Cannot specify RepositorySynchronizationData.history -> operationHistory.recordHistory.newValues
for ChangeType.DELETE_ROWS`);
                }
                return;
            case ChangeType.INSERT_VALUES:
            case ChangeType.UPDATE_ROWS:
                if (!(recordHistory.newValues instanceof Array) || !recordHistory.newValues.length) {
                    throw new Error(`Must specify RepositorySynchronizationData.history -> operationHistory.recordHistory.newValues
for ChangeType.INSERT_VALUES|UPDATE_ROWS`);
                }
                break;
        }
        for (const newValue of recordHistory.newValues) {
            if (newValue.recordHistory) {
                throw new Error(`Cannot specify RepositorySynchronizationData.history -> operationHistory.recordHistory.newValues.recordHistory`);
            }
            newValue.recordHistory = recordHistory;
            if (typeof newValue.columnIndex !== 'number') {
                throw new Error(`Invalid RepositorySynchronizationData.history -> operationHistory.recordHistory.newValues.columnIndex`);
            }
            if (typeof newValue.newValue === undefined) {
                throw new Error(`Invalid RepositorySynchronizationData.history -> operationHistory.recordHistory.newValues.newValue`);
            }
        }
        for (const newValue of recordHistory.newValues) {
            this.checkRelatedObjectInNewValue(newValue, entityColumnMapsByIndex.actorIds, data.actors, 'actors');
            this.checkRelatedObjectInNewValue(newValue, entityColumnMapsByIndex.referencedRelationIds, data.referencedApplicationRelations, 'referencedApplicationRelations');
            this.checkRelatedObjectInNewValue(newValue, entityColumnMapsByIndex.repositoryIds, data.referencedRepositories, 'referencedRepositories');
            this.checkRelatedObjectInNewValue(newValue, entityColumnMapsByIndex.terminalIds, data.terminals, 'terminals');
            this.checkRelatedObjectInNewValue(newValue, entityColumnMapsByIndex.userAccountIds, data.userAccounts, 'userAccounts');
        }
    }
    checkOldValues(recordHistory, entityColumnMapsByIndex, operationHistory, data) {
        switch (operationHistory.changeType) {
            case ChangeType.DELETE_ROWS:
            case ChangeType.INSERT_VALUES:
                if (recordHistory.oldValues) {
                    throw new Error(`Cannot specify RepositorySynchronizationData.history -> operationHistory.recordHistory.oldValues
for ChangeType.DELETE_ROWS|INSERT_VALUES`);
                }
                return;
            case ChangeType.UPDATE_ROWS:
                if (!(recordHistory.newValues instanceof Array) || !recordHistory.oldValues.length) {
                    throw new Error(`Must specify RepositorySynchronizationData.history -> operationHistory.recordHistory.oldValues
for ChangeType.UPDATE_ROWS`);
                }
                break;
        }
        for (const oldValue of recordHistory.oldValues) {
            if (oldValue.recordHistory) {
                throw new Error(`Cannot specify RepositorySynchronizationData.history -> operationHistory.recordHistory.newValues.recordHistory`);
            }
            oldValue.recordHistory = recordHistory;
            if (typeof oldValue.columnIndex !== 'number') {
                throw new Error(`Invalid RepositorySynchronizationData.history -> operationHistory.recordHistory.oldValues.columnIndex`);
            }
            if (typeof oldValue.oldValue === undefined) {
                throw new Error(`Invalid RepositorySynchronizationData.history -> operationHistory.recordHistory.oldValues.oldValue`);
            }
        }
        for (const oldValue of recordHistory.oldValues) {
            this.checkRelatedObjectInOldValue(oldValue, entityColumnMapsByIndex.actorIds, data.actors, 'actors');
            this.checkRelatedObjectInOldValue(oldValue, entityColumnMapsByIndex.repositoryIds, data.referencedRepositories, 'referencedRepositories');
            this.checkRelatedObjectInOldValue(oldValue, entityColumnMapsByIndex.referencedRelationIds, data.referencedApplicationRelations, 'referencedApplicationRelations');
            this.checkRelatedObjectInOldValue(oldValue, entityColumnMapsByIndex.terminalIds, data.terminals, 'terminals');
            this.checkRelatedObjectInOldValue(oldValue, entityColumnMapsByIndex.userAccountIds, data.userAccounts, 'userAccounts');
        }
    }
    checkRelatedObjectInNewValue(newValue, entityIdColumnMapByIndex, entityArrayByInMessageIndex, inMessageEntityArrayName) {
        this.checkRelatedObject(newValue, 'newValue', entityIdColumnMapByIndex, entityArrayByInMessageIndex, inMessageEntityArrayName);
    }
    checkRelatedObjectInOldValue(oldValue, entityIdColumnMapByIndex, entityArrayByInMessageIndex, inMessageEntityArrayName) {
        this.checkRelatedObject(oldValue, 'oldValue', entityIdColumnMapByIndex, entityArrayByInMessageIndex, inMessageEntityArrayName);
    }
    checkRelatedObject(value, valueColumnName, entityIdColumnMapByIndex, entityArrayByInMessageIndex, inMessageEntityArrayName) {
        const relationIdColumn = entityIdColumnMapByIndex.get(value.columnIndex);
        if (relationIdColumn) {
            const sourceEntity = entityArrayByInMessageIndex[value[valueColumnName]];
            if (!sourceEntity) {
                throw new Error(`Invalid RepositorySynchronizationData.history -> operationHistory.recordHistory.newValues.newValue
Value is for ${relationIdColumn.name} and could find RepositorySynchronizationData.${inMessageEntityArrayName}[${value[valueColumnName]}]`);
            }
            value[valueColumnName] = sourceEntity._localId;
        }
    }
}

class SyncInRepositoryChecker {
    async checkRepositoriesAndMembers(message) {
        let missingRepositories = [];
        let newMembers = [];
        let newRepositoryMemberAcceptances = [];
        let signatureChecks = [];
        try {
            const data = message.data;
            let repositoryGUIDs = [];
            let messageRepositoryIndexMap = new Map();
            for (let i = 0; i < data.referencedRepositories.length; i++) {
                this.checkRepository(data.referencedRepositories[i], i, repositoryGUIDs, messageRepositoryIndexMap, data);
            }
            const history = data.history;
            if (typeof history !== 'object') {
                throw new Error(`message.data.history is not an object`);
            }
            let historyRepository = history.repository;
            const repositoryErrorPrefix = `Serialized RepositorySynchronizationData.history.repository should be`;
            const isRepositoryCreationEqualityErrorPrefix = `if RepositorySynchronizationData.history.isRepositoryCreation ===`;
            if (history.isRepositoryCreation) {
                if (typeof historyRepository !== 'object') {
                    throw new Error(`${repositoryErrorPrefix} an object
	${isRepositoryCreationEqualityErrorPrefix} === true`);
                }
                this.checkRepository(historyRepository, null, repositoryGUIDs, messageRepositoryIndexMap, data);
            }
            else {
                if (typeof historyRepository !== 'string') {
                    throw new Error(`${repositoryErrorPrefix} a string
	i${isRepositoryCreationEqualityErrorPrefix} === false`);
                }
                repositoryGUIDs.push(historyRepository);
            }
            const foundRepositories = await this.repositoryDao.findByGUIDs(repositoryGUIDs);
            for (const foundRepository of foundRepositories) {
                const messageRepositoryIndex = messageRepositoryIndexMap.get(foundRepository.GUID);
                if (messageRepositoryIndex || messageRepositoryIndex === 0) {
                    data.referencedRepositories[messageRepositoryIndex] = foundRepository;
                }
                else {
                    if (history.isRepositoryCreation) {
                        if (foundRepository.GUID === historyRepository.GUID) {
                            throw new Error(`Repository ${foundRepository.GUID} is already created.`);
                        }
                        throw new Error(`Unexpected Repository ${foundRepository.GUID}`);
                    }
                    else {
                        if (foundRepository.GUID !== historyRepository) {
                            throw new Error(`Unexpected Repository ${foundRepository.GUID}`);
                        }
                        // Populating ahead of potential insert is OK, object
                        // gets modified with required state on an insert
                        history.repository = historyRepository = foundRepository;
                    }
                }
            }
            missingRepositories = data.referencedRepositories
                .filter(referencedRepository => {
                if (referencedRepository._localId) {
                    return false;
                }
                else {
                    // Only the repository reference is loaded
                    referencedRepository.isLoaded = false;
                    return true;
                }
            });
            if (typeof historyRepository !== 'object') {
                throw new Error(`Repository with GUID ${historyRepository} is not
	present and cannot be synced
	This RepositorySynchronizationData is for an existing repository and that
	repository must already be loaded in this database for this message to be
	processed.`);
            }
            else {
                if (!historyRepository._localId) {
                    missingRepositories.push(historyRepository);
                }
            }
            const memberCheckResult = await this.checkRepositoryMembers(message);
            signatureChecks = memberCheckResult.signatureChecks;
            newMembers = memberCheckResult.newMembers;
            newRepositoryMemberAcceptances = [memberCheckResult.newRepositoryMemberAcceptance];
        }
        catch (e) {
            console.error(e);
            return {
                isValid: false
            };
        }
        return {
            isValid: true,
            missingRepositories,
            newMembers,
            newRepositoryMemberAcceptances,
            signatureChecks
        };
    }
    async checkRepositoryMembers(message) {
        const data = message.data;
        const inMessageRepositoryMemberMapByPublicSigningKey = this
            .getInMessageRepositoryMemberMap(data);
        const newMembers = [];
        const existingRepositoryMember = await this.getExistingRepositoryMember(data, inMessageRepositoryMemberMapByPublicSigningKey, newMembers);
        const newRepositoryMemberAcceptance = this
            .isNewRepositoryMemberAcceptanceMessage(data, existingRepositoryMember);
        const isNewRepositoryMemberAcceptanceMessage = !!newRepositoryMemberAcceptance;
        const isNewRepositoryMemberInvitationMessage = this
            .isNewRepositoryMemberInvitationMessage(data, existingRepositoryMember, newMembers);
        await this.checkRepositoryMemberUserAccounts(data, isNewRepositoryMemberAcceptanceMessage, isNewRepositoryMemberInvitationMessage);
        const signatureChecks = this.getPublicSigningKeysAndSignatureToCheck(message, isNewRepositoryMemberAcceptanceMessage);
        delete data.history.newRepositoryMembers;
        // TODO: Add a newPublicRepositoryMember property to history and check it
        return {
            newMembers,
            newRepositoryMemberAcceptance,
            signatureChecks
        };
    }
    async checkRepositoryMemberUserAccounts(data, isNewRepositoryMemberAcceptanceMessage, isNewRepositoryMemberInvitationMessage) {
        const history = data.history;
        for (let i = 0; i < data.repositoryMembers.length; i++) {
            const repositoryMember = data.repositoryMembers[i];
            if (repositoryMember.userAccount
                || repositoryMember.userAccount === 0) {
                const userAccount = data.userAccounts[history.member.userAccount];
                if (!userAccount) {
                    throw new Error(`UserAccount with index ${repositoryMember.userAccount} referenced in
message.data.repositoryMembers[${i}].userAccount does not exist in the message`);
                }
                repositoryMember.userAccount = userAccount;
            }
        }
        if (!data.userAccounts[history.member.userAccount]) {
            throw new Error(`UserAccount with index ${history.member.userAccount} referenced in
message.data.history.member.userAccount does not exist in the message`);
        }
        if (isNewRepositoryMemberInvitationMessage) {
            for (let i = 0; i < history.newRepositoryMemberInvitations.length; i++) {
                const newRepositoryMemberInvitation = history.newRepositoryMemberInvitations[i];
                if (newRepositoryMemberInvitation.invitedRepositoryMember.userAccount) {
                    throw new Error(`message.data.history.newRepositoryMemberInvitations[${i}] has a specified
specifies .invitedRepositoryMember.userAccount
Invited repository members cannot have a UserAccount specified`);
                }
            }
        }
        if (isNewRepositoryMemberAcceptanceMessage) {
            if (!history.newRepositoryMemberAcceptances[0].acceptingRepositoryMember.userAccount) {
                throw new Error(`message.data.history.newRepositoryMemberAcceptances[0] must have
a acceptingRepositoryMember.userAccount specified.`);
            }
        }
    }
    isNewRepositoryMemberAcceptanceMessage(data, existingRepositoryMember) {
        const history = data.history;
        const newRepositoryMemberAcceptancesErrorPrefix = `history.newRepositoryMemberAcceptances`;
        const newRepositoryMemberAcceptances = history.newRepositoryMemberAcceptances;
        if (!(newRepositoryMemberAcceptances instanceof Array)) {
            throw new Error(`${newRepositoryMemberAcceptancesErrorPrefix} is not an Array`);
        }
        if (!newRepositoryMemberAcceptances.length) {
            return null;
        }
        if (history.repository.isPublic) {
            throw new Error(`${newRepositoryMemberAcceptancesErrorPrefix} are NOT allowed on a public Repository`);
        }
        if (history.isRepositoryCreation) {
            throw new Error(`${newRepositoryMemberAcceptancesErrorPrefix} are NOT allowed on a newly created Repository`);
        }
        if (newRepositoryMemberAcceptances.length > 1) {
            throw new Error(`Cannot have more than one  ${newRepositoryMemberAcceptancesErrorPrefix} at a time.`);
        }
        const newRepositoryMemberAcceptance = newRepositoryMemberAcceptances[0];
        if (typeof newRepositoryMemberAcceptance !== 'object') {
            throw new Error(`${newRepositoryMemberAcceptancesErrorPrefix}[0] is not an object`);
        }
        if (typeof newRepositoryMemberAcceptance.createdAt !== 'number') {
            throw new Error(`${newRepositoryMemberAcceptancesErrorPrefix}[0].createdAt is not a number`);
        }
        newRepositoryMemberAcceptance.createdAt = new Date(newRepositoryMemberAcceptance.createdAt);
        if (typeof newRepositoryMemberAcceptance.acceptingRepositoryMember !== 'number') {
            throw new Error(`${newRepositoryMemberAcceptancesErrorPrefix}[0].acceptingRepositoryMember is not a number`);
        }
        this.checkPublicSigningKey(newRepositoryMemberAcceptance.invitationPublicSigningKey, `${newRepositoryMemberAcceptancesErrorPrefix}[0].invitationPublicSigningKey`);
        const acceptingRepositoryMember = data.repositoryMembers[newRepositoryMemberAcceptance.acceptingRepositoryMember];
        if (acceptingRepositoryMember !== existingRepositoryMember) {
            throw new Error(`${newRepositoryMemberAcceptancesErrorPrefix}[0] must be an existing RepositoryMember`);
        }
        if (acceptingRepositoryMember.status !== RepositoryMember_Status.JOINED) {
            throw new Error(`Wrong accepting RepositoryMember.status.  Status must be INVITED.`);
        }
        newRepositoryMemberAcceptance.acceptingRepositoryMember = acceptingRepositoryMember;
        delete newRepositoryMemberAcceptance.addedInRepositoryTransactionHistory;
        delete newRepositoryMemberAcceptance._localId;
        return newRepositoryMemberAcceptance;
    }
    isNewRepositoryMemberInvitationMessage(data, existingRepositoryMember, newMembers) {
        const history = data.history;
        const newRepositoryMemberInvitationsErrorPrefix = `history.newRepositoryMemberInvitations`;
        const newRepositoryMemberInvitations = history.newRepositoryMemberInvitations;
        if (!(newRepositoryMemberInvitations instanceof Array)) {
            throw new Error(`${newRepositoryMemberInvitationsErrorPrefix} is not an Array`);
        }
        if (!newRepositoryMemberInvitations.length) {
            return false;
        }
        if (history.repository.isPublic) {
            throw new Error(`${newRepositoryMemberInvitationsErrorPrefix} are NOT allowed on a public Repository`);
        }
        if (!existingRepositoryMember.isAdministrator) {
            throw new Error(`Non-Administrator user cannot send ${newRepositoryMemberInvitationsErrorPrefix}.`);
        }
        for (let i = 0; i < newRepositoryMemberInvitations.length; i++) {
            const newRepositoryMemberInvitation = newRepositoryMemberInvitations[i];
            if (typeof newRepositoryMemberInvitation !== 'object') {
                throw new Error(`${newRepositoryMemberInvitationsErrorPrefix}[${i}] is not an object`);
            }
            if (typeof newRepositoryMemberInvitation.createdAt !== 'number') {
                throw new Error(`${newRepositoryMemberInvitationsErrorPrefix}[${i}].createdAt is not a number`);
            }
            newRepositoryMemberInvitation.createdAt = new Date(newRepositoryMemberInvitation.createdAt);
            if (typeof newRepositoryMemberInvitation.invitedRepositoryMember !== 'number') {
                throw new Error(`${newRepositoryMemberInvitationsErrorPrefix}[${i}].invitedRepositoryMember is not a number`);
            }
            const invitedRepositoryMember = data.repositoryMembers[newRepositoryMemberInvitation.invitedRepositoryMember];
            if (!invitedRepositoryMember) {
                throw new Error(`Invited repository member with in-message index ${newRepositoryMemberInvitation.invitedRepositoryMember}
is not present in the message.`);
            }
            if (invitedRepositoryMember === existingRepositoryMember) {
                throw new Error(`${newRepositoryMemberInvitationsErrorPrefix}[${i}] cannot be an existing RepositoryMember`);
            }
            this.checkPublicSigningKey(newRepositoryMemberInvitation.invitationPublicSigningKey, `${newRepositoryMemberInvitationsErrorPrefix}[${i}].invitationPublicSigningKey`);
            if (invitedRepositoryMember.status !== RepositoryMember_Status.INVITED) {
                throw new Error(`Wrong ${newRepositoryMemberInvitationsErrorPrefix}[${i}].invitedRepositoryMember.status.  Status must be INVITED.`);
            }
            this.checkRepositoryMembershipFlags(invitedRepositoryMember, `${newRepositoryMemberInvitationsErrorPrefix}[${i}]`, false, data.history.repository);
            newRepositoryMemberInvitation.invitedRepositoryMember = invitedRepositoryMember;
            delete newRepositoryMemberInvitation.addedInRepositoryTransactionHistory;
            delete newRepositoryMemberInvitation._localId;
            newMembers.push(invitedRepositoryMember);
        }
        return true;
    }
    checkRepositoryMembershipFlags(repositoryMember, errorPrefix, isOwnerValue, repository) {
        if (typeof repositoryMember.isAdministrator !== 'boolean') {
            throw new Error(`${errorPrefix}.isAdministrator is not a boolean`);
        }
        if (typeof repositoryMember.canWrite !== 'boolean') {
            throw new Error(`${errorPrefix}.canWrite is not a boolean`);
        }
        repositoryMember.isOwner = isOwnerValue;
        repositoryMember.repository = repository;
        delete repositoryMember.addedInRepositoryTransactionHistory;
        delete repositoryMember.invitations;
        delete repositoryMember.updates;
    }
    getInMessageRepositoryMemberMap(data) {
        const repositoryMemberInMessageIndexesMapByPublicSigningKey = new Map();
        const repositoryMemberPublicSigningKeySet = new Set();
        for (let i = 0; i < data.repositoryMembers.length; i++) {
            const repositoryMember = data.repositoryMembers[i];
            if (typeof repositoryMember !== 'object') {
                throw new Error(`data.repositoryMembers[${i}] is not an object`);
            }
            const errorPrefix = `data.repositoryMembers[${i}].publicSigningKey`;
            const memberPublicSigningKey = repositoryMember.memberPublicSigningKey;
            this.checkPublicSigningKey(memberPublicSigningKey, errorPrefix);
            if (repositoryMemberPublicSigningKeySet.has(memberPublicSigningKey)) {
                throw new Error(`${errorPrefix} appears in more than one data.repositoryMembers`);
            }
            repositoryMemberPublicSigningKeySet.add(memberPublicSigningKey);
            repositoryMemberInMessageIndexesMapByPublicSigningKey.set(memberPublicSigningKey, i);
            delete repositoryMember._localId;
        }
        return repositoryMemberInMessageIndexesMapByPublicSigningKey;
    }
    checkPublicSigningKey(publicSigningKey, errorPrefix) {
        if (typeof publicSigningKey !== 'string') {
            throw new Error(`${errorPrefix} is not a string`);
        }
        // FIXME: get the right length of a publicSigningKey
        if (publicSigningKey.length !== 36) {
            throw new Error(`${errorPrefix} does not have .length === 36`);
        }
    }
    async getExistingRepositoryMember(data, repositoryMemberInMessageIndexesMapByPublicSigningKey, newMembers) {
        const memberPublicSigningKeys = data.repositoryMembers
            .map(repositoryMember => repositoryMember.memberPublicSigningKey);
        const existingMessageRepositoryMembers = await this.repositoryMemberDao
            .findByMemberPublicSigningKeys(Array.from(memberPublicSigningKeys));
        let existingRepositoryMember;
        const history = data.history;
        if (history.isRepositoryCreation) {
            if (existingMessageRepositoryMembers.length) {
                throw new Error(`Found existing repositoryMembers for a newly created repository`);
            }
            this.checkRepositoryMembershipFlags(history.member, `history.member`, false, data.history.repository);
            newMembers.push(history.member);
            return null;
        }
        if (existingMessageRepositoryMembers.length !== 1) {
            throw new Error(`Expecting exactly 1 existing RepositoryMember in non isRepositoryCreation message`);
        }
        existingRepositoryMember = existingMessageRepositoryMembers[0];
        const repositoryMemberInMessageIndex = repositoryMemberInMessageIndexesMapByPublicSigningKey[existingRepositoryMember.memberPublicSigningKey];
        if (history.member !== repositoryMemberInMessageIndex) {
            throw new Error(`history.member does not already exist in the Repository`);
        }
        history.member = existingRepositoryMember;
        data.repositoryMembers[repositoryMemberInMessageIndex] = existingRepositoryMember;
        return existingRepositoryMember;
    }
    getPublicSigningKeysAndSignatureToCheck(message, isNewRepositoryMemberAcceptanceMessage) {
        const signatureChecks = [];
        const history = message.data.history;
        signatureChecks.push({
            publicSigningKey: history.member.memberPublicSigningKey,
            signatureName: 'memberSignature',
            signatureToCheck: message.memberSignature
        });
        if (isNewRepositoryMemberAcceptanceMessage) {
            signatureChecks.push({
                publicSigningKey: message.data.history
                    .newRepositoryMemberAcceptances[0].invitationPublicSigningKey,
                signatureName: 'acceptanceSignature',
                signatureToCheck: message.acceptanceSignature
            });
        }
        if (isNewRepositoryMemberAcceptanceMessage || history.isRepositoryCreation) {
            signatureChecks.push({
                publicSigningKey: history.member.userAccount.accountPublicSigningKey,
                signatureName: 'userAccountSignature',
                signatureToCheck: message.userAccountSignature
            });
        }
        return signatureChecks;
    }
    checkRepository(repository, repositoryIndex, repositoryGUIDs, messageRepositoryIndexMap, message) {
        if (typeof repository.ageSuitability !== 'number') {
            throw new Error(`Invalid 'repository.ageSuitability'`);
        }
        if (!repository.createdAt || typeof repository.createdAt !== 'string') {
            throw new Error(`Invalid 'repository.createdAt'`);
        }
        repository.createdAt = new Date(repository.createdAt);
        if (typeof repository.immutable !== 'boolean') {
            throw new Error(`Invalid 'repository.immutable'`);
        }
        if (!repository.source || typeof repository.source !== 'string') {
            throw new Error(`Invalid 'repository.source'`);
        }
        if (typeof repository.GUID !== 'string' || repository.GUID.length !== 36) {
            throw new Error(`Invalid 'repository.GUID'`);
        }
        if (typeof repository.owner !== 'number') {
            throw new Error(`Expecting "in-message index" (number)
				in 'repository.owner'`);
        }
        if (typeof repository.isPublic !== 'boolean') {
            throw new Error(`Invalid 'repository.isPublic'`);
        }
        if (typeof repository.isLoaded !== 'undefined') {
            throw new Error(`'repository.isLoaded' cannot be specified`);
        }
        const userAccount = message.userAccounts[repository.owner];
        if (!userAccount) {
            throw new Error(`Did not find repository.owner (UserAccount) with "in-message index" ${repository.owner}`);
        }
        repository.owner = userAccount;
        repositoryGUIDs.push(repository.GUID);
        if (typeof repositoryIndex === 'number') {
            messageRepositoryIndexMap.set(repository.GUID, repositoryIndex);
        }
        // Make sure id field is not in the input
        delete repository._localId;
    }
}

class SyncInTerminalChecker {
    async ensureTerminals(data, context) {
        try {
            let terminalGUIDs = [];
            let messageTerminalIndexMap = new Map();
            for (let i = 0; i < data.terminals.length; i++) {
                const terminal = data.terminals[i];
                if (typeof terminal._localId !== 'undefined') {
                    throw new Error(`'terminal._localId' cannot be specified`);
                }
                if (typeof terminal.owner !== 'number') {
                    throw new Error(`Expecting "in-message index" (number)
					in 'terminal.owner' of RepositorySynchronizationData.terminals`);
                }
                if (typeof terminal.GUID !== 'string' || terminal.GUID.length !== 36) {
                    throw new Error(`Invalid 'terminal.GUID' in RepositorySynchronizationData.terminals`);
                }
                if (terminal.isLocal !== undefined) {
                    throw new Error(`'terminal.isLocal' cannot defined in RepositorySynchronizationData.terminals`);
                }
                terminal.isLocal = false;
                const owner = data.userAccounts[terminal.owner];
                if (!owner) {
                    throw new Error(`Did not find userAccount for terminal.owner with "in-message index" ${terminal.owner}
						for RepositorySynchronizationData.terminals`);
                }
                terminal.owner = owner;
                terminalGUIDs.push(terminal.GUID);
                messageTerminalIndexMap.set(terminal.GUID, i);
            }
            const terminals = await this.terminalDao.findByGUIDs(terminalGUIDs);
            const foundTerminalsByGUID = new Map();
            for (const terminal of terminals) {
                foundTerminalsByGUID.set(terminal.GUID, terminal);
                const messageTerminalIndex = messageTerminalIndexMap.get(terminal.GUID);
                data.terminals[messageTerminalIndex] = terminal;
            }
            const missingTerminals = data.terminals
                .filter(messageTerminal => !foundTerminalsByGUID.has(messageTerminal.GUID));
            if (missingTerminals.length) {
                await this.addMissingTerminals(missingTerminals, context);
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    async addMissingTerminals(missingTerminals, context) {
        for (const terminal of missingTerminals) {
            terminal.isLocal = false;
        }
        await this.terminalDao.insert(missingTerminals, context);
    }
}

class SyncInUserAccountChecker {
    async ensureUserAccounts(data, context) {
        try {
            // let userAccountPublicSigningKeys: UserAccount_PublicSigningKey[] = []
            const userAccountPublicSigningKeySet = new Set();
            let messageUserAccountIndexMap = new Map();
            for (let i = 0; i < data.userAccounts.length; i++) {
                const userAccount = data.userAccounts[i];
                if (typeof userAccount._localId !== 'undefined') {
                    throw new Error(`'userAccount._localId' cannot be specified`);
                }
                const accountPublicSigningKey = userAccount.accountPublicSigningKey;
                // FIXME: put in the proper UserAccount_PublicSigningKey (521) length
                if (typeof accountPublicSigningKey !== 'string' || accountPublicSigningKey.length !== 36) {
                    throw new Error(`Invalid 'userAccount.accountPublicSigningKey'`);
                }
                if (userAccountPublicSigningKeySet.has(accountPublicSigningKey)) {
                    throw new Error(`UserAccount with accountPublicSigningKey:
'${accountPublicSigningKey}'
appears more than once in message.data.userAccounts
`);
                }
                if (typeof userAccount.username !== 'string' || userAccount.username.length < 3) {
                    throw new Error(`Invalid 'userAccount.username'`);
                }
                userAccountPublicSigningKeySet.add(userAccount.accountPublicSigningKey);
                messageUserAccountIndexMap.set(userAccount.accountPublicSigningKey, i);
            }
            const userAccounts = await this.userAccountDao
                .findByAccountPublicSingingKeys(Array.from(userAccountPublicSigningKeySet));
            const foundUserAccountsByPublicSigningKey = new Map();
            for (const userAccount of userAccounts) {
                foundUserAccountsByPublicSigningKey.set(userAccount.accountPublicSigningKey, userAccount);
                const messageUserAccountIndex = messageUserAccountIndexMap.get(userAccount.accountPublicSigningKey);
                data.userAccounts[messageUserAccountIndex] = userAccount;
            }
            const missingUserAccounts = data.userAccounts
                .filter(messageUserAccount => !foundUserAccountsByPublicSigningKey
                .has(messageUserAccount.accountPublicSigningKey));
            if (missingUserAccounts.length) {
                await this.addMissingUserAccounts(missingUserAccounts, context);
            }
        }
        catch (e) {
            console.error(e);
            return false;
        }
        return true;
    }
    async addMissingUserAccounts(missingUserAccounts, context) {
        for (const userAccount of missingUserAccounts) {
            if (!userAccount.username || typeof userAccount.username !== 'string') {
                throw new Error(`Invalid UserAccount.username ${userAccount.username}`);
            }
        }
        await this.userAccountDao.insert(missingUserAccounts, context);
    }
}

class Stage1SyncedInDataProcessor {
    /**
     * In stage one:
     *
     *  1)  Unique create/update/delete statement datastructures are generated
     *  2)  Synchronization conflict datastructure is generated
     *
     * @param {Map<repositoryLocalId, ISyncRepoTransHistory[]>} repositoryTransactionHistoryMapByRepositoryLocalId
     * @param {Map<Actor_LocalId, IActor>} actorMayById
     * @returns {Promise<void>}
     */
    async performStage1DataProcessing(repositoryTransactionHistoryMapByRepositoryLocalId, actorMayById) {
        await this.populateSystemWideOperationIds(repositoryTransactionHistoryMapByRepositoryLocalId);
        const changedRecordIds = new Map();
        // query for all local operations on records in a repository (since the earliest
        // received change time).  Get the
        // changes by repository _localIds or by the actual tables and records in those tables
        // that will be updated or deleted.
        for (const [repositoryLocalId, repoTransHistoriesForRepo] of repositoryTransactionHistoryMapByRepositoryLocalId) {
            const changedRecordsForRepo = {
                actorRecordIdsByLocalIds: new Map(),
                firstChangeTime: new Date().getTime() + 10000000000
            };
            changedRecordIds.set(repositoryLocalId, changedRecordsForRepo);
            for (const repoTransHistory of repoTransHistoriesForRepo) {
                // determine the earliest change time of incoming history records
                const saveMillis = repoTransHistory.saveTimestamp;
                if (saveMillis
                    < changedRecordsForRepo.firstChangeTime) {
                    changedRecordsForRepo.firstChangeTime = repoTransHistory.saveTimestamp;
                }
                for (const operationHistory of repoTransHistory.operationHistory) {
                    // Collect the Actor related localIds
                    const idsForEntity = this.datastructureUtils.ensureChildJsMap(changedRecordsForRepo.actorRecordIdsByLocalIds, operationHistory.entity._localId);
                    for (const recordHistory of operationHistory.recordHistory) {
                        // Collect the Actor related localIds
                        this.datastructureUtils.ensureChildJsSet(idsForEntity, recordHistory.actor._localId)
                            .add(recordHistory._actorRecordId);
                        // add a map of new values
                        const newValueMap = new Map();
                        recordHistory.newValueMap = newValueMap;
                        for (const newValue of recordHistory.newValues) {
                            newValueMap.set(newValue.columnIndex, newValue);
                        }
                    }
                }
            }
        }
        const allRepoTransHistoryMapByRepoId = new Map();
        const allRemoteRecordDeletions = this.getDeletedRecordIdsAndPopulateAllHistoryMap(allRepoTransHistoryMapByRepoId, repositoryTransactionHistoryMapByRepositoryLocalId);
        // find local history for the matching repositories and corresponding time period
        const localRepoTransHistoryMapByrepositoryLocalId = await this.repositoryTransactionHistoryDao
            .findAllLocalChangesForRecordIds(changedRecordIds);
        const allLocalRecordDeletions = this.getDeletedRecordIdsAndPopulateAllHistoryMap(allRepoTransHistoryMapByRepoId, localRepoTransHistoryMapByrepositoryLocalId, true);
        // Find all actors that modified the locally recorded history, which are not already
        // in the actorMapById collect actors not already in cache
        const newlyFoundActorSet = new Set();
        for (const [_repositoryLocalId, repositoryTransactionHistoriesForRepository] of localRepoTransHistoryMapByrepositoryLocalId) {
            for (const repositoryTransactionHistory of repositoryTransactionHistoriesForRepository) {
                const actorId = repositoryTransactionHistory.actor._localId;
                if (actorMayById.get(actorId) === undefined) {
                    newlyFoundActorSet.add(actorId);
                }
            }
        }
        if (newlyFoundActorSet.size) {
            // cache remaining actors
            const newActors = await this.actorDao.findWithDetailsAndGlobalIdsByIds(Array.from(newlyFoundActorSet));
            for (const newActor of newActors) {
                actorMayById.set(newActor._localId, newActor);
            }
        }
        // sort all repository histories in processing order
        for (const [_repositoryLocalId, repoTransHistoriesForRepository] of allRepoTransHistoryMapByRepoId) {
            this.repositoryTransactionHistoryDuo
                .sortRepoTransHistories(repoTransHistoriesForRepository, actorMayById);
        }
        const recordCreations = new Map();
        const recordUpdates = new Map();
        const recordDeletions = new Map();
        const syncConflictMapByRepoId = new Map();
        // FIXME: add code to ensure that remote records coming in are performed only
        // by the actors that claim the operation AND that the records created are
        // created only by the actors that perform the operation (actorIds match)
        for (const [repositoryLocalId, repoTransHistoriesForRepo] of allRepoTransHistoryMapByRepoId) {
            for (const repoTransHistory of repoTransHistoriesForRepo) {
                for (const operationHistory of repoTransHistory.operationHistory) {
                    switch (operationHistory.changeType) {
                        case ChangeType.INSERT_VALUES:
                            this.processCreation(repositoryLocalId, operationHistory, repoTransHistory.isLocal, recordCreations, recordUpdates, recordDeletions, allRemoteRecordDeletions, allLocalRecordDeletions, syncConflictMapByRepoId);
                            break;
                        case ChangeType.UPDATE_ROWS:
                            this.processUpdate(repositoryLocalId, operationHistory, repoTransHistory.isLocal, recordCreations, recordUpdates, allRemoteRecordDeletions, allLocalRecordDeletions, syncConflictMapByRepoId);
                            break;
                        case ChangeType.DELETE_ROWS:
                            this.processDeletion(repositoryLocalId, operationHistory, recordCreations, recordUpdates, recordDeletions, allLocalRecordDeletions);
                            break;
                    }
                }
            }
        }
        return {
            recordCreations,
            recordDeletions,
            recordUpdates,
            syncConflictMapByRepoId
        };
    }
    async populateSystemWideOperationIds(repositoryTransactionHistoryMapByrepositoryLocalId) {
        let numSystemWideOperationIds = 0;
        for (const [_, repoTransHistoriesForRepo] of repositoryTransactionHistoryMapByrepositoryLocalId) {
            for (const repositoryTransactionHistory of repoTransHistoriesForRepo) {
                numSystemWideOperationIds += repositoryTransactionHistory
                    .operationHistory.length;
            }
        }
        const systemWideOperationIds = await this.systemWideOperationIdUtils
            .getSysWideOpIds(numSystemWideOperationIds);
        let i = 0;
        for (const [_, repoTransHistoriesForRepo] of repositoryTransactionHistoryMapByrepositoryLocalId) {
            for (const repositoryTransactionHistory of repoTransHistoriesForRepo) {
                for (const operationHistory of repositoryTransactionHistory.operationHistory) {
                    operationHistory.systemWideOperationId = systemWideOperationIds[i];
                    i++;
                }
            }
        }
    }
    ensureRecordHistoryLocalId(recordHistory, actorRecordLocalIdSetByActor, _actorRecordId = recordHistory._actorRecordId) {
        this.datastructureUtils.ensureChildJsMap(actorRecordLocalIdSetByActor, recordHistory.actor._localId)
            .set(_actorRecordId, recordHistory._localId);
    }
    getDeletedRecordIdsAndPopulateAllHistoryMap(allRepoTransHistoryMapByRepoId, repositoryTransactionHistoryMapByRepoId, isLocal = false) {
        const recordDeletions = new Map();
        for (const [repositoryLocalId, repoTransHistories] of repositoryTransactionHistoryMapByRepoId) {
            this.mergeArraysInMap(allRepoTransHistoryMapByRepoId, repositoryLocalId, repoTransHistories);
            for (const repoTransHistory of repoTransHistories) {
                repoTransHistory.isLocal = isLocal;
                for (const operationHistory of repoTransHistory.operationHistory) {
                    switch (operationHistory.changeType) {
                        case ChangeType.DELETE_ROWS:
                            for (const recordHistory of operationHistory.recordHistory) {
                                this.ensureRecordHistoryLocalId(recordHistory, this.syncInUtils
                                    .ensureRecordMapForRepoInTable(repositoryLocalId, operationHistory, recordDeletions));
                            }
                            break;
                    }
                }
            }
        }
        return recordDeletions;
    }
    mergeArraysInMap(map, key, array) {
        let targetArray = map.get(key);
        if (!targetArray) {
            targetArray = array;
        }
        else {
            targetArray = targetArray.concat(array);
        }
        map.set(key, targetArray);
    }
    /*
    NOTE: local creates are not inputted into this processing.
     */
    processCreation(repositoryLocalId, operationHistory, isLocal, recordCreations, recordUpdates, recordDeletions, allRemoteRecordDeletions, allLocalRecordDeletions, syncConflictMapByRepoId) {
        const recordUpdatesForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, recordUpdates);
        const recordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, recordDeletions);
        const allRemoteRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, allRemoteRecordDeletions);
        const allLocalRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, allLocalRecordDeletions);
        const insertsForEntityInRepo = this.syncInUtils.ensureRecordMapForRepoInTable(repositoryLocalId, operationHistory, recordCreations);
        for (const recordHistory of operationHistory.recordHistory) {
            if (this.getRecord(recordHistory, insertsForEntityInRepo)) {
                throw new Error(`A record is being created more than once.
					${this.getRecordInfo(repositoryLocalId, operationHistory, recordHistory)}
					This is not possible if every remote change is only processed once.
					`);
            }
            if (isLocal) {
                throw new Error(`Remotely mutated record is being created locally.
					${this.getRecordInfo(repositoryLocalId, operationHistory, recordHistory)}
					This is not possible if changes are never sent to originating TMs.
					`);
            }
            if (this.hasRecordId(recordHistory, recordDeletesForRepoInTable)) {
                throw new Error(`
				Remotely created record is being deleted remotely before it's been created.
					${this.getRecordInfo(repositoryLocalId, operationHistory, recordHistory)}
					This is not possible if all server clocks are synced.
					`);
            }
            if (this.getRecordHistoryLocalId(recordHistory, allLocalRecordDeletesForRepoInTable)) {
                throw new Error(`Remotely created record is being deleted locally.
					${this.getRecordInfo(repositoryLocalId, operationHistory, recordHistory)}
					This is not possible if every remote change is only processed once.
					`);
            }
            const remoteDeleteRecordHistoryLocalId = this.getRecordHistoryLocalId(recordHistory, allRemoteRecordDeletesForRepoInTable);
            if (remoteDeleteRecordHistoryLocalId) {
                // remotely created record has been remotely deleted
                this.addSyncConflict(SynchronizationConflict_Type.REMOTE_CREATE_REMOTELY_DELETED, repositoryLocalId, recordHistory, {
                    _localId: remoteDeleteRecordHistoryLocalId
                }, syncConflictMapByRepoId);
                // If the record has been deleted, do not process the create
                continue;
            }
            const createdRecord = this.ensureColumnValueMap(recordHistory, insertsForEntityInRepo);
            if (this.getRecord(recordHistory, recordUpdatesForRepoInTable)) {
                throw new Error(`Remotely created record is being updated BEFORE it is created.
					${this.getRecordInfo(repositoryLocalId, operationHistory, recordHistory)}
					This is not possible if all server clocks are synced.
					`);
            }
            // Record the creation of the record
            for (const newValue of recordHistory.newValues) {
                createdRecord.set(newValue.columnIndex, newValue.newValue);
            }
        }
    }
    /*
    NOTE: local updates to records NOT in incoming changes do not get inputted into
    this processing.
     */
    processUpdate(repositoryLocalId, operationHistory, isLocal, recordCreations, recordUpdates, allRemoteRecordDeletions, allLocalRecordDeletions, syncConflictMapByRepoId) {
        const recordCreationsForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, recordCreations);
        const allRemoteRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, allRemoteRecordDeletions);
        const allLocalRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, allLocalRecordDeletions);
        const updatesForEntityInRepo = this.syncInUtils.ensureRecordMapForRepoInTable(repositoryLocalId, operationHistory, recordUpdates);
        for (const recordHistory of operationHistory.recordHistory) {
            const localDeleteRecordHistoryLocalId = this.getRecordHistoryLocalId(recordHistory, allLocalRecordDeletesForRepoInTable);
            if (localDeleteRecordHistoryLocalId) {
                if (!isLocal) {
                    // A remote update to a record has been locally deleted
                    this.addSyncConflict(SynchronizationConflict_Type.REMOTE_UPDATE_LOCALLY_DELETED, repositoryLocalId, recordHistory, {
                        _localId: localDeleteRecordHistoryLocalId
                    }, syncConflictMapByRepoId);
                }
                // else {a local update to a record has been locally deleted - nothing to do}
                // If the record has been deleted, do not process the update
                continue;
            }
            const remoteDeleteRecordHistoryLocalId = this.getRecordHistoryLocalId(recordHistory, allRemoteRecordDeletesForRepoInTable);
            if (remoteDeleteRecordHistoryLocalId) {
                if (isLocal) {
                    // A local update for a record that has been deleted remotely
                    this.addSyncConflict(SynchronizationConflict_Type.LOCAL_UPDATE_REMOTELY_DELETED, repositoryLocalId, recordHistory, {
                        _localId: remoteDeleteRecordHistoryLocalId
                    }, syncConflictMapByRepoId);
                }
                // else {remote deletions do not cause conflicts for remotely updated records}
                // If the record has been deleted, do not process the update
                continue;
            }
            // If the record has been created, update the creation record instead
            let createdRecord = this.getRecord(recordHistory, recordCreationsForRepoInTable);
            if (createdRecord) {
                if (isLocal) {
                    throw new Error(`Remotely created records are being updated locally.
					${this.getRecordInfo(repositoryLocalId, operationHistory, recordHistory)}
					This is not possible if every remote change is only processed once.
					`);
                }
                else {
                    // remotely created record is being updated remotely - normal flow
                    for (const newValue of recordHistory.newValues) {
                        createdRecord.set(newValue.columnIndex, newValue.newValue);
                    }
                }
                // No need to record updates, already taken into account in the create
                continue;
            }
            // record update
            let updatedRecord = this.ensureRecord(recordHistory, updatesForEntityInRepo);
            let synchronizationConflict;
            for (const newValue of recordHistory.newValues) {
                if (isLocal) {
                    const columnIndex = newValue.columnIndex;
                    const recordUpdate = updatedRecord.get(columnIndex);
                    if (recordUpdate) {
                        // remotely updated record value is being updated locally
                        if (!synchronizationConflict) {
                            synchronizationConflict = this.addSyncConflict(SynchronizationConflict_Type.REMOTE_UPDATE_LOCALLY_UPDATED, repositoryLocalId, {
                                _localId: recordUpdate.recordHistoryLocalId,
                            }, {
                                _localId: remoteDeleteRecordHistoryLocalId
                            }, syncConflictMapByRepoId);
                            synchronizationConflict.values = [];
                        }
                        synchronizationConflict.values.push({
                            columnIndex,
                            synchronizationConflict
                        });
                        // no need to update since the value is already there
                        // Remove the update
                        updatedRecord.delete(newValue.columnIndex);
                    }
                }
                else {
                    // remotely updated record value is being updated remotely - normal flow
                    // replace the older update with the newer one
                    updatedRecord.set(newValue.columnIndex, {
                        newValue: newValue.newValue,
                        recordHistoryLocalId: recordHistory._localId
                    });
                }
            }
        }
    }
    /*
    NOTE: local deletes of records NOT in incoming changes do not get inputted into
    this processing.
     */
    processDeletion(repositoryLocalId, operationHistory, recordCreations, recordUpdates, recordDeletions, allLocalRecordDeletions) {
        const recordCreationsForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, recordCreations);
        const recordUpdatesForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, recordUpdates);
        const allLocalRecordDeletesForRepoInTable = this.getRecordsForRepoInTable(repositoryLocalId, operationHistory, allLocalRecordDeletions);
        const deletesForEntityInRepo = this.syncInUtils.ensureRecordMapForRepoInTable(repositoryLocalId, operationHistory, recordDeletions);
        for (const recordHistory of operationHistory.recordHistory) {
            let recordCreationsForActorInRepoInTable = this.getRecordsForActor(recordHistory, recordCreationsForRepoInTable);
            // If a remotely deleted record was also created remotely
            if (recordCreationsForActorInRepoInTable
                && recordCreationsForActorInRepoInTable.get(recordHistory._actorRecordId)) {
                // remote deletions do not cause conflicts for remotely created records
                // Remove the creation of the record
                recordCreationsForActorInRepoInTable.delete(recordHistory._actorRecordId);
                // No need to record a deletion for a record that was also created (remotely)
                continue;
            }
            let recordUpdatesForActorInRepoInTable = this.getRecordsForActor(recordHistory, recordUpdatesForRepoInTable);
            // If a remotely deleted record has been updated (remotely)
            if (recordUpdatesForActorInRepoInTable
                && recordUpdatesForActorInRepoInTable.get(recordHistory._actorRecordId)) {
                // remote deletions do not cause conflicts for remotely updated records
                // Remove record updates for deleted records
                recordUpdatesForActorInRepoInTable.delete(recordHistory._actorRecordId);
            }
            if (this.getRecordHistoryLocalId(recordHistory, allLocalRecordDeletesForRepoInTable)) {
                // If the record has been deleted locally, no need to add another delete operation
                continue;
            }
            // record deletion
            this.datastructureUtils.ensureChildJsSet(deletesForEntityInRepo, recordHistory.actor._localId)
                .add(recordHistory._actorRecordId);
        }
    }
    getRecordsForRepoInTable(repositoryLocalId, operationHistory, recordMapByApplicationTableAndRepository) {
        const recordMapForApplication = recordMapByApplicationTableAndRepository
            .get(operationHistory.entity.applicationVersion._localId);
        let recordMapForTable;
        if (recordMapForApplication) {
            recordMapForTable = recordMapForApplication.get(operationHistory.entity._localId);
        }
        let recordMapForRepoInTable;
        if (recordMapForTable) {
            recordMapForRepoInTable = recordMapForTable.get(repositoryLocalId);
        }
        return recordMapForRepoInTable;
    }
    getRecord(recordHistory, recordMapByActor) {
        let recordsForActor = this.getRecordsForActor(recordHistory, recordMapByActor);
        if (!recordsForActor) {
            return null;
        }
        return recordsForActor.get(recordHistory._actorRecordId);
    }
    hasRecordId(recordHistory, actorRecordLocalIdSetByActor) {
        let actorRecordIdsForActor = this.getRecordsForActor(recordHistory, actorRecordLocalIdSetByActor);
        if (!actorRecordIdsForActor) {
            return false;
        }
        return actorRecordIdsForActor.has(recordHistory._actorRecordId);
    }
    getRecordHistoryLocalId(recordHistory, actorRecordLocalIdSetByActor) {
        let actorRecordIdsForActor = this.getRecordsForActor(recordHistory, actorRecordLocalIdSetByActor);
        if (!actorRecordIdsForActor) {
            return null;
        }
        return actorRecordIdsForActor.get(recordHistory._actorRecordId);
    }
    getRecordsForActor(recordHistory, recordMapByActor) {
        let recordsForActor;
        if (recordMapByActor) {
            recordsForActor = recordMapByActor.get(recordHistory.actor._localId);
        }
        return recordsForActor;
    }
    getRecordInfo(repositoryLocalId, operationHistory, recordHistory) {
        return `
		Application Version ID: ${operationHistory.entity.applicationVersion._localId}
		Entity ID:         ${operationHistory.entity._localId}
		Repository ID:     ${repositoryLocalId}
		Actor ID:          ${recordHistory.actor._localId}
		Actor Record ID:   ${recordHistory._actorRecordId}
		`;
    }
    addSyncConflict(synchronizationConflictType, repositoryLocalId, overwrittenRecordHistory, overwritingRecordHistory, syncConflictMapByRepoId) {
        const syncConflict = this.createSynchronizationConflict(synchronizationConflictType, repositoryLocalId, overwrittenRecordHistory, overwritingRecordHistory);
        this.datastructureUtils.ensureChildArray(syncConflictMapByRepoId, repositoryLocalId).push(syncConflict);
        return syncConflict;
    }
    createSynchronizationConflict(synchronizationConflictType, repositoryLocalId, overwrittenRecordHistory, overwritingRecordHistory) {
        return {
            _localId: null,
            overwrittenRecordHistory,
            overwritingRecordHistory,
            repository: {
                _localId: repositoryLocalId
            },
            type: synchronizationConflictType
        };
    }
    ensureColumnValueMap(recordHistory, dataMap) {
        return this.datastructureUtils.ensureChildJsMap(this.datastructureUtils.ensureChildJsMap(dataMap, recordHistory.actor._localId), recordHistory._actorRecordId);
    }
    ensureRecord(recordHistory, recordMapByActor) {
        return this.datastructureUtils.ensureChildJsMap(this.datastructureUtils.ensureChildJsMap(recordMapByActor, recordHistory.actor._localId), recordHistory._actorRecordId);
    }
}

class Stage2SyncedInDataProcessor {
    async applyChangesToDb(stage1Result, applicationsByApplicationVersion_LocalIdMap) {
        const context = {};
        await this.performCreates(stage1Result.recordCreations, applicationsByApplicationVersion_LocalIdMap, context);
        await this.performUpdates(stage1Result.recordUpdates, applicationsByApplicationVersion_LocalIdMap, context);
        await this.performDeletes(stage1Result.recordDeletions, applicationsByApplicationVersion_LocalIdMap, context);
    }
    /**
     * Remote changes come in with ApplicationVersion_LocalIds not Application_Indexes, so it makes
     * sense to keep this structure.  NOTE: only one version of a given application is
     * processed at one time:
     *
     *  Changes for a application version below the one in this Terminal must first be upgraded.
     *  Terminal itself must first be upgraded to newer application versions, before changes
     *  for that application version are processed.
     *
     *  To tie in a given ApplicationVersion_LocalId to its Application_Index an additional mapping data
     *  structure is passed in.
     */
    async performCreates(recordCreations, applicationsByApplicationVersion_LocalIdMap, context) {
        for (const [applicationVersionId, creationInApplicationMap] of recordCreations) {
            const applicationIndex = applicationsByApplicationVersion_LocalIdMap
                .get(applicationVersionId).index;
            for (const [tableIndex, creationInTableMap] of creationInApplicationMap) {
                const dbEntity = this.airportDatabase.applications[applicationIndex].currentVersion[0]
                    .applicationVersion.entities[tableIndex];
                const qEntity = this.airportDatabase.qApplications[applicationIndex][dbEntity.name];
                const columns = [
                    qEntity.repository._localId,
                    qEntity.actor._localId,
                    qEntity._actorRecordId
                ];
                const nonIdColumns = this.getNonIdColumnsInIndexOrder(dbEntity);
                let creatingColumns = true;
                let numInserts = 0;
                const VALUES = [];
                for (const [repositoryId, creationForRepositoryMap] of creationInTableMap) {
                    for (const [actorId, creationForActorMap] of creationForRepositoryMap) {
                        for (const [_actorRecordId, creationOfRowMap] of creationForActorMap) {
                            const rowValues = [
                                repositoryId,
                                actorId,
                                _actorRecordId
                            ];
                            const columnIndexedValues = [];
                            for (const [columnIndex, columnValue] of creationOfRowMap) {
                                columnIndexedValues.push([columnIndex, columnValue]);
                            }
                            if (columnIndexedValues.length) {
                                numInserts++;
                            }
                            columnIndexedValues.sort((col1IndexAndValue, col2IndexAndValue) => {
                                return this.utils.compareNumbers(col1IndexAndValue[0], col2IndexAndValue[0]);
                            });
                            let currentNonIdColumnArrayIndex = 0;
                            for (const [columnIndex, columnValue] of columnIndexedValues) {
                                let nonIdColumn = nonIdColumns[currentNonIdColumnArrayIndex];
                                while (nonIdColumn.index < columnIndex) {
                                    if (creatingColumns) {
                                        columns.push(qEntity.__driver__.allColumns[nonIdColumn.index]);
                                    }
                                    rowValues.push(null);
                                    currentNonIdColumnArrayIndex++;
                                    nonIdColumn = nonIdColumns[currentNonIdColumnArrayIndex];
                                }
                                const qColumn = qEntity.__driver__.allColumns[columnIndex];
                                if (creatingColumns) {
                                    columns.push(qColumn);
                                }
                                rowValues.push(columnValue);
                                currentNonIdColumnArrayIndex++;
                            }
                            if (columnIndexedValues.length) {
                                VALUES.push(rowValues);
                            }
                            creatingColumns = false;
                        }
                    }
                }
                if (numInserts) {
                    const previousDbEntity = context.dbEntity;
                    context.dbEntity = qEntity
                        .__driver__.dbEntity;
                    try {
                        await this.databaseFacade.insertValues({
                            INSERT_INTO: qEntity,
                            columns,
                            VALUES
                        }, context);
                    }
                    finally {
                        context.dbEntity = previousDbEntity;
                    }
                }
            }
        }
    }
    getNonIdColumnsInIndexOrder(dbEntity) {
        const nonIdColumns = [];
        const airEntityColumns = this.dictionary.AirEntity.columns;
        for (const column of dbEntity.columns) {
            switch (column.name) {
                case airEntityColumns.ACTOR_LID:
                case airEntityColumns.ACTOR_RECORD_ID:
                case airEntityColumns.REPOSITORY_LID:
                    continue;
            }
            nonIdColumns.push(column);
        }
        nonIdColumns.sort((column1, column2) => {
            return this.utils.compareNumbers(column1.index, column2.index);
        });
        return nonIdColumns;
    }
    async performUpdates(recordUpdates, applicationsByApplicationVersion_LocalIdMap, context) {
        const finalUpdateMap = new Map();
        const recordUpdateStage = [];
        // Build the final update data structure
        for (const [applicationVersionId, applicationUpdateMap] of recordUpdates) {
            const finalApplicationUpdateMap = this.datastructureUtils.ensureChildJsMap(finalUpdateMap, applicationVersionId);
            const applicationIndex = applicationsByApplicationVersion_LocalIdMap
                .get(applicationVersionId).index;
            for (const [tableIndex, tableUpdateMap] of applicationUpdateMap) {
                const finalTableUpdateMap = this.datastructureUtils.ensureChildJsMap(finalApplicationUpdateMap, tableIndex);
                const dbEntity = this.airportDatabase.applications[applicationIndex].currentVersion[0]
                    .applicationVersion.entities[tableIndex];
                for (const [repositoryId, repositoryUpdateMap] of tableUpdateMap) {
                    for (const [actorId, actorUpdates] of repositoryUpdateMap) {
                        for (const [_actorRecordId, recordUpdateMap] of actorUpdates) {
                            const recordKeyMap = this.getRecordKeyMap(recordUpdateMap, finalTableUpdateMap);
                            this.datastructureUtils.ensureChildJsSet(this.datastructureUtils.ensureChildJsMap(recordKeyMap, repositoryId), actorId)
                                .add(_actorRecordId);
                            for (const [columnIndex, columnUpdate] of recordUpdateMap) {
                                dbEntity.columns[columnIndex];
                                recordUpdateStage.push([
                                    applicationVersionId,
                                    tableIndex,
                                    repositoryId,
                                    actorId,
                                    _actorRecordId,
                                    columnIndex,
                                    columnUpdate.newValue
                                ]);
                            }
                        }
                    }
                }
            }
        }
        if (!recordUpdateStage.length) {
            return;
        }
        await this.recordUpdateStageDao.insertValues(recordUpdateStage, context);
        // Perform the updates
        for (const [applicationVersionId, updateMapForApplication] of finalUpdateMap) {
            const application = applicationsByApplicationVersion_LocalIdMap.get(applicationVersionId);
            for (const [tableIndex, updateMapForTable] of updateMapForApplication) {
                await this.runUpdatesForTable(application.index, applicationVersionId, tableIndex, updateMapForTable, context);
            }
        }
        await this.recordUpdateStageDao.delete(context);
    }
    async performDeletes(recordDeletions, applicationsByApplicationVersion_LocalIdMap, context) {
        const trackedRepoGUIDSet = new Set();
        for (const [applicationVersionId, deletionInApplicationMap] of recordDeletions) {
            const application = applicationsByApplicationVersion_LocalIdMap.get(applicationVersionId);
            for (const [tableIndex, deletionInTableMap] of deletionInApplicationMap) {
                const dbEntity = this.airportDatabase.applications[application.index].currentVersion[0]
                    .applicationVersion.entities[tableIndex];
                const qEntity = this.airportDatabase.qApplications[application.index][dbEntity.name];
                let numClauses = 0;
                let repositoryWhereFragments = [];
                for (const [repositoryId, deletionForRepositoryMap] of deletionInTableMap) {
                    let actorWhereFragments = [];
                    for (const [actorId, actorRecordIdSet] of deletionForRepositoryMap) {
                        numClauses++;
                        actorWhereFragments.push(AND(qEntity._actorRecordId.IN(Array.from(actorRecordIdSet)), qEntity.actor._localId.equals(actorId)));
                    }
                    repositoryWhereFragments.push(AND(qEntity.repository._localId.equals(repositoryId), OR(...actorWhereFragments)));
                }
                if (numClauses) {
                    const previousDbEntity = context.dbEntity;
                    context.dbEntity = qEntity
                        .__driver__.dbEntity;
                    try {
                        await this.databaseFacade.deleteWhere({
                            DELETE_FROM: qEntity,
                            WHERE: OR(...repositoryWhereFragments)
                        }, context, trackedRepoGUIDSet);
                    }
                    finally {
                        context.dbEntity = previousDbEntity;
                    }
                }
            }
        }
    }
    /**
     * Get the record key map (RecordKeyMap = RepositoryId -> Actor_LocalId
     * -> ActorRecordId) for the recordUpdateMap (the specified combination
     * of columns/values being updated)
     * @param {Map<ApplicationColumn_Index, RecordUpdate>} recordUpdateMap
     * @param {ColumnUpdateKeyMap} finalTableUpdarecordKeyMapteMap
     * @returns {RecordKeyMap}
     */
    getRecordKeyMap(recordUpdateMap, // combination of columns/values
    // being updated
    finalTableUpdateMap) {
        const updatedColumns = [];
        for (const columnIndex of recordUpdateMap.keys()) {
            updatedColumns.push(columnIndex);
        }
        // Sort the updated columns by column index, to ensure that all records with the
        // same combination of updated columns are grouped
        updatedColumns.sort(this.utils.compareNumbers);
        // Navigate down the table UpdateKeyMap to find the matching combination of
        // columns being updated
        let columnValueUpdate;
        let updateKeyMap = finalTableUpdateMap;
        for (const columnIndex of updatedColumns) {
            columnValueUpdate = updateKeyMap.get(columnIndex);
            // If no update statements with the specified combination of columns exist yet
            if (!columnValueUpdate) {
                columnValueUpdate = {
                    childColumnUpdateKeyMap: new Map(),
                    recordKeyMap: new Map(),
                    updatedColumns: null,
                };
                updateKeyMap.set(columnIndex, columnValueUpdate);
            }
            // Navigate down
            updateKeyMap = columnValueUpdate.childColumnUpdateKeyMap;
        }
        columnValueUpdate.updatedColumns = updatedColumns;
        // Return the map of the records for the update statement of the specified combination
        // of columns/values
        return columnValueUpdate.recordKeyMap;
    }
    /**
     * Run all updates for a particular table.  One update per updated column combination
     * is run.
     *
     * @param {Application_Index} applicationIndex
     * @param {ApplicationEntity_TableIndex} tableIndex
     * @param {ColumnUpdateKeyMap} updateKeyMap
     * @returns {Promise<void>}
     */
    async runUpdatesForTable(applicationIndex, applicationVersionId, tableIndex, updateKeyMap, context) {
        for (const columnValueUpdate of updateKeyMap.values()) {
            const updatedColumns = columnValueUpdate.updatedColumns;
            if (updatedColumns) {
                await this.recordUpdateStageDao.updateEntityWhereIds(applicationIndex, applicationVersionId, tableIndex, columnValueUpdate.recordKeyMap, updatedColumns, context);
            }
            // Traverse down into nested column update combinations
            await this.runUpdatesForTable(applicationIndex, applicationVersionId, tableIndex, columnValueUpdate.childColumnUpdateKeyMap, context);
        }
    }
}

/**
 * Synchronization in Manager implementation.
 */
class SynchronizationInManager {
    async receiveMessages(messageMapByGUID, context) {
        const syncTimestamp = new Date().getTime();
        const existingRepositoryTransactionHistories = await this.repositoryTransactionHistoryDao
            .findWhereGUIDsIn([...messageMapByGUID.keys()]);
        for (const existingRepositoryTransactionHistory of existingRepositoryTransactionHistories) {
            messageMapByGUID.delete(existingRepositoryTransactionHistory.GUID);
        }
        if (!messageMapByGUID.size) {
            return;
        }
        const orderedMessages = this.timeOrderMessages(messageMapByGUID);
        const immediateProcessingMessages = [];
        const delayedProcessingMessages = [];
        const newAndUpdatedRepositoriesAndRecords = {
            missingRepositories: [],
            newMembers: [],
            newRepositoryMemberInvitations: [],
            newRepositoryMemberAcceptances: []
        };
        // Split up messages by type
        for (const message of orderedMessages) {
            if (!this.isValidLastChangeTime(syncTimestamp, message.syncTimestamp, 'Sync Timestamp')) {
                continue;
            }
            if (!this.isValidLastChangeTime(message.syncTimestamp, message.data.history.saveTimestamp, 'Sync Timestamp', 'Save Timestamp')) {
                continue;
            }
            let processMessage = true;
            let dataCheckResult;
            await this.transactionManager.transactInternal(async (transaction) => {
                dataCheckResult = await this.syncInChecker.checkData(message, context);
                if (!dataCheckResult.isValid) {
                    transaction.rollback(null, context);
                    processMessage = false;
                    return;
                }
                newAndUpdatedRepositoriesAndRecords.missingRepositories = [
                    ...newAndUpdatedRepositoriesAndRecords.missingRepositories,
                    ...dataCheckResult.missingRepositories
                ];
                newAndUpdatedRepositoriesAndRecords.newMembers = [
                    ...newAndUpdatedRepositoriesAndRecords.newMembers,
                    ...dataCheckResult.newMembers
                ];
                newAndUpdatedRepositoriesAndRecords.newRepositoryMemberAcceptances = [
                    ...newAndUpdatedRepositoriesAndRecords.newRepositoryMemberAcceptances,
                    ...dataCheckResult.newRepositoryMemberAcceptances
                ];
                newAndUpdatedRepositoriesAndRecords.newRepositoryMemberInvitations = [
                    ...newAndUpdatedRepositoriesAndRecords.newRepositoryMemberInvitations,
                    ...dataCheckResult.newRepositoryMemberInvitations
                ];
            }, null, context);
            if (processMessage) {
                immediateProcessingMessages.push({
                    ...message,
                    data: {
                        ...message.data,
                        history: {
                            ...message.data.history,
                            operationHistory: dataCheckResult.forImmediateProcessing
                        }
                    }
                });
                if (dataCheckResult.forDelayedProcessing.length) {
                    delayedProcessingMessages.push({
                        ...message,
                        data: {
                            ...message.data,
                            history: {
                                ...message.data.history,
                                operationHistory: dataCheckResult.forDelayedProcessing
                            }
                        }
                    });
                }
            }
        }
        await this.transactionManager.transactInternal(async (transaction, context) => {
            transaction.isSync = true;
            await this.twoStageSyncedInDataProcessor.syncMessages(immediateProcessingMessages, newAndUpdatedRepositoriesAndRecords, transaction, context);
        }, null, context);
        await this.wait(2000);
        await this.processDelayedMessages(delayedProcessingMessages, context);
        if (!context.doNotLoadReferences) {
            await this.loadReferencedRepositories([
                ...immediateProcessingMessages,
                ...delayedProcessingMessages
            ], context);
        }
    }
    timeOrderMessages(messageMapByGUID) {
        const messages = [...messageMapByGUID.values()];
        messages.sort((message1, message2) => {
            if (message1.syncTimestamp < message2.syncTimestamp) {
                return -1;
            }
            if (message1.syncTimestamp > message2.syncTimestamp) {
                return 1;
            }
            let history1 = message1.data.history;
            let history2 = message2.data.history;
            if (history1.saveTimestamp < history2.saveTimestamp) {
                return -1;
            }
            if (history1.saveTimestamp > history2.saveTimestamp) {
                return 1;
            }
            return 0;
        });
        return messages;
    }
    isValidLastChangeTime(syncTimestamp, remoteTimestamp, remoteFieldName, syncFieldName = 'Reception Time:') {
        if (syncTimestamp < remoteTimestamp) {
            console.error(`Message ${syncFieldName} is less than
			the ${remoteFieldName} in received message:
				${syncFieldName}:               ${syncTimestamp}
				${remoteFieldName}:           ${remoteTimestamp}
			`);
            return false;
        }
        return true;
    }
    wait(milliseconds) {
        return new Promise(resolve => {
            setTimeout(_ => {
                resolve();
            }, milliseconds);
        });
    }
    async processDelayedMessages(delayedProcessingMessages, context) {
        const delayedProcessingMessagesWithValidApps = [];
        for (const message of delayedProcessingMessages) {
            const data = message.data;
            // Possibly load (remotely) and install new apps - delayed processing
            // messages deal with other repositories that might include data from
            // other apps - other repositories might be referencing records in
            // the synched repositories (which may not be aware of the apps the
            // other repositories where created with)
            const applicationCheckMap = await this.syncInApplicationVersionChecker.ensureApplicationVersions(data.referencedApplicationVersions, data.applications, context);
            if (applicationCheckMap) {
                await this.syncInChecker.checkReferencedApplicationRelations(data, applicationCheckMap, context);
                delayedProcessingMessagesWithValidApps.push(message);
            }
        }
        if (delayedProcessingMessagesWithValidApps.length) {
            await this.transactionManager.transactInternal(async (transaction, context) => {
                transaction.isSync = true;
                await this.twoStageSyncedInDataProcessor.syncMessages(delayedProcessingMessagesWithValidApps, null, transaction, context);
            }, null, context);
        }
    }
    async loadReferencedRepositories(messages, context) {
        const repositoryMapByGUID = new Map();
        for (const message of messages) {
            for (const repository of message.data.referencedRepositories) {
                if (!repositoryMapByGUID.has(repository.GUID)) {
                    repositoryMapByGUID.set(repository.GUID, repository);
                }
            }
        }
        for (const repository of repositoryMapByGUID.values()) {
            await this.repositoryLoader.loadRepository(repository.GUID, {
                ...context,
                doNotLoadReferences: true
            });
        }
    }
}

/**
 * Result of comparing to versions of a given application.
 */
var ApplicationComparisonResult;
(function (ApplicationComparisonResult) {
    // Version specified in the message is lower than it's version in the receiving
    // Terminal (TM)
    ApplicationComparisonResult[ApplicationComparisonResult["MESSAGE_APPLICATION_VERSION_IS_LOWER"] = -1] = "MESSAGE_APPLICATION_VERSION_IS_LOWER";
    // Version of the application used i the message is the same as that in the receiving
    // Terminal (TM)
    ApplicationComparisonResult[ApplicationComparisonResult["MESSAGE_APPLICATION_VERSION_IS_EQUAL"] = 0] = "MESSAGE_APPLICATION_VERSION_IS_EQUAL";
    // Version specified in the message in higher than it's version in the receiving
    // Terminal (TM)
    ApplicationComparisonResult[ApplicationComparisonResult["MESSAGE_APPLICATION_VERSION_IS_HIGHER"] = 1] = "MESSAGE_APPLICATION_VERSION_IS_HIGHER";
})(ApplicationComparisonResult || (ApplicationComparisonResult = {}));
class SyncInUtils {
    ensureRecordMapForRepoInTable(repositoryLocalId, operationHistory, recordMapByApplicationTableAndRepository) {
        return this.datastructureUtils.ensureChildJsMap(this.datastructureUtils.ensureChildJsMap(this.datastructureUtils.ensureChildJsMap(recordMapByApplicationTableAndRepository, operationHistory.entity.applicationVersion._localId), operationHistory.entity.index), repositoryLocalId);
    }
}

class TwoStageSyncedInDataProcessor {
    /**
     * Synchronize the data messages coming to Terminal (new data for this TM)
     */
    async syncMessages(messages, newAndUpdatedRepositoriesAndRecords, transaction, context) {
        this.aggregateHistoryRecords(messages, transaction);
        await this.repositoryDao.insert(newAndUpdatedRepositoriesAndRecords.missingRepositories, context);
        const { actorMapById, repositoryTransactionHistoryMapByRepositoryId, applicationsByApplicationVersion_LocalIdMap } = await this.getDataStructures(messages);
        await this.repositoryMemberDao.insert(newAndUpdatedRepositoriesAndRecords.newMembers, context);
        await this.repositoryMemberInvitationDao.insert(newAndUpdatedRepositoriesAndRecords.newRepositoryMemberInvitations, context);
        await this.repositoryMemberAcceptanceDao.insert(newAndUpdatedRepositoriesAndRecords.newRepositoryMemberAcceptances, context);
        for (const newRepositoryMemberAcceptance of newAndUpdatedRepositoriesAndRecords.newRepositoryMemberAcceptances) {
            await this.repositoryMemberDao.updatePublicSigningKey(newRepositoryMemberAcceptance.invitationPublicSigningKey, newRepositoryMemberAcceptance.acceptingRepositoryMember.memberPublicSigningKey, context);
        }
        await this.updateLocalData(repositoryTransactionHistoryMapByRepositoryId, actorMapById, applicationsByApplicationVersion_LocalIdMap, context);
    }
    aggregateHistoryRecords(messages, transaction) {
        const transactionHistory = transaction.transactionHistory;
        transactionHistory.transactionType = TransactionType.REMOTE_SYNC;
        // split messages by repository and record actor information
        for (const message of messages) {
            const repositoryTransactionHistory = message.data.history;
            this.repositoryTransactionHistoryDuo
                .setModifiedRepository_LocalIdSet(repositoryTransactionHistory);
            transactionHistory.repositoryTransactionHistories.push(repositoryTransactionHistory);
            const columnMapByEntityLocalIdAndColumnIndex = new Map();
            repositoryTransactionHistory.repositoryTransactionType = RepositoryTransactionType.REMOTE;
            transactionHistory.allOperationHistory = transactionHistory
                .allOperationHistory.concat(repositoryTransactionHistory.operationHistory);
            repositoryTransactionHistory.operationHistory.forEach((operationHistory) => {
                const entityColumnMapByIndex = this.datastructureUtils.ensureChildJsMap(columnMapByEntityLocalIdAndColumnIndex, operationHistory.entity._localId);
                for (const dbColumn of operationHistory.entity.columns) {
                    entityColumnMapByIndex.set(dbColumn.index, dbColumn);
                }
                transactionHistory.allRecordHistory = transactionHistory
                    .allRecordHistory.concat(operationHistory.recordHistory);
                operationHistory.recordHistory.forEach((recordHistory) => {
                    if (recordHistory.newValues && recordHistory.newValues.length) {
                        transactionHistory.allRecordHistoryNewValues = transactionHistory
                            .allRecordHistoryNewValues.concat(recordHistory.newValues);
                        for (const newValue of recordHistory.newValues) {
                            const dbColumn = entityColumnMapByIndex.get(newValue.columnIndex);
                            this.recordHistoryDuo.ensureModifiedRepositoryLocalIdSet(recordHistory, dbColumn, newValue.columnIndex);
                        }
                    }
                    if (recordHistory.oldValues && recordHistory.oldValues.length) {
                        transactionHistory.allRecordHistoryOldValues = transactionHistory
                            .allRecordHistoryOldValues.concat(recordHistory.oldValues);
                        for (const oldValue of recordHistory.oldValues) {
                            const dbColumn = entityColumnMapByIndex.get(oldValue.columnIndex);
                            this.recordHistoryDuo.ensureModifiedRepositoryLocalIdSet(recordHistory, dbColumn, oldValue.columnIndex);
                        }
                    }
                });
            });
            transactionHistory.allRepositoryMembers = transactionHistory
                .allRepositoryMembers.concat(repositoryTransactionHistory.newRepositoryMembers);
            transactionHistory.allRepositoryMemberAcceptances = transactionHistory
                .allRepositoryMemberAcceptances.concat(repositoryTransactionHistory.newRepositoryMemberAcceptances);
            transactionHistory.allRepositoryMemberInvitations = transactionHistory
                .allRepositoryMemberInvitations.concat(repositoryTransactionHistory.newRepositoryMemberInvitations);
        }
    }
    async getDataStructures(messages) {
        const repositoryTransactionHistoryMapByRepositoryId = new Map();
        const applicationsByApplicationVersion_LocalIdMap = new Map();
        const actorMapById = new Map();
        const repoTransHistories = [];
        for (const message of messages) {
            const data = message.data;
            repoTransHistories.push(data.history);
            repositoryTransactionHistoryMapByRepositoryId.set(data.history.repository._localId, repoTransHistories);
            for (const actor of data.actors) {
                actorMapById.set(actor._localId, actor);
            }
            for (const applicationVersion of data.applicationVersions) {
                applicationsByApplicationVersion_LocalIdMap.set(applicationVersion._localId, applicationVersion.application);
            }
        }
        for (const [_, repoTransHistories] of repositoryTransactionHistoryMapByRepositoryId) {
            this.repositoryTransactionHistoryDuo
                .sortRepoTransHistories(repoTransHistories, actorMapById);
        }
        return {
            actorMapById,
            repositoryTransactionHistoryMapByRepositoryId,
            applicationsByApplicationVersion_LocalIdMap
        };
    }
    async updateLocalData(repositoryTransactionHistoryMapByRepositoryId, actorMayById, applicationsByApplicationVersion_LocalIdMap, context) {
        const stage1Result = await this.stage1SyncedInDataProcessor.performStage1DataProcessing(repositoryTransactionHistoryMapByRepositoryId, actorMayById);
        let allSyncConflicts = [];
        let allSyncConflictValues = [];
        for (const [_, synchronizationConflicts] of stage1Result.syncConflictMapByRepoId) {
            allSyncConflicts = allSyncConflicts.concat(synchronizationConflicts);
            for (const synchronizationConflict of synchronizationConflicts) {
                if (synchronizationConflict.values.length) {
                    allSyncConflictValues = allSyncConflictValues.concat(synchronizationConflict.values);
                }
            }
        }
        await this.stage2SyncedInDataProcessor.applyChangesToDb(stage1Result, applicationsByApplicationVersion_LocalIdMap);
        if (allSyncConflicts.length) {
            await this.synchronizationConflictDao.insert(allSyncConflicts, context);
        }
        if (allSyncConflictValues.length) {
            await this.synchronizationConflictValuesDao.insert(allSyncConflictValues, context);
        }
    }
}

var IndexedEntityType;
(function (IndexedEntityType) {
    IndexedEntityType[IndexedEntityType["APPLICATION"] = 0] = "APPLICATION";
    IndexedEntityType[IndexedEntityType["REPOSITORY_MEMBER"] = 1] = "REPOSITORY_MEMBER";
    IndexedEntityType[IndexedEntityType["TERMINAL"] = 2] = "TERMINAL";
    IndexedEntityType[IndexedEntityType["USER_ACCOUNT"] = 3] = "USER_ACCOUNT";
})(IndexedEntityType || (IndexedEntityType = {}));
class SyncOutDataSerializer {
    constructor() {
        this.WITH_ID = {};
        this.WITH_RECORD_HISTORY = {};
        this.WITH_INDEX = {};
    }
    async serialize(repositoryTransactionHistories) {
        let historiesToSend = [];
        const messages = [];
        for (let i = 0; i < repositoryTransactionHistories.length; i++) {
            const repositoryTransactionHistory = repositoryTransactionHistories[i];
            if (repositoryTransactionHistory.repositoryTransactionType !== RepositoryTransactionType.LOCAL) {
                continue;
            }
            const message = await this.serializeMessage(repositoryTransactionHistory);
            historiesToSend.push(repositoryTransactionHistory);
            messages.push(message);
        }
        return {
            historiesToSend,
            messages,
        };
    }
    getInMessageEntityLookup() {
        return {
            inMessageIndexesById: new Map(),
            lastInMessageIndex: -1
        };
    }
    async serializeMessage(repositoryTransactionHistory) {
        const lookups = {
            actorInMessageIndexesById: new Map(),
            applicationLookup: this.getInMessageEntityLookup(),
            referencedApplicationRelationIndexesById: new Map(),
            applicationVersionInMessageIndexesById: new Map(),
            applicationVersions: [],
            lastInMessageActorIndex: -1,
            lastInMessageReferencedApplicationRelationIndex: -1,
            lastInMessageApplicationVersionIndex: -1,
            lastInMessageReferencedApplicationRelation: -1,
            lastInMessageReferencedApplicationVersionIndex: -1,
            lastInMessageRepositoryIndex: -1,
            messageRepository: repositoryTransactionHistory.repository,
            referencedApplicationVersionInMessageIndexesById: new Map(),
            referencedApplicationVersions: [],
            repositoryInMessageIndexesById: new Map(),
            repositoryMemberLookup: this.getInMessageEntityLookup(),
            terminalLookup: this.getInMessageEntityLookup(),
            userAccountLookup: this.getInMessageEntityLookup()
        };
        const data = {
            actors: [],
            applicationVersions: [],
            applications: [],
            history: null,
            // Repositories may reference records in other repositories
            referencedApplicationVersions: [],
            referencedApplicationRelations: [],
            referencedRepositories: [],
            repositoryMembers: [],
            userAccounts: [],
            terminals: []
        };
        const message = {
            data
        };
        data.history = this.serializeRepositoryTransactionHistory(repositoryTransactionHistory, message.data, lookups);
        // TODO: replace db lookups with TerminalState lookups where possible
        await this.serializeRepositories(repositoryTransactionHistory, data, lookups);
        await this.serializeActorsUserAccountsAndTerminals(data, lookups);
        await this.serializeApplicationsAndVersions(data, lookups.applicationLookup, lookups.applicationVersions, data.applicationVersions);
        await this.serializeReferencedApplicationProperties(data, lookups);
        await this.serializeApplicationsAndVersions(data, lookups.applicationLookup, lookups.referencedApplicationVersions, data.referencedApplicationVersions);
        return message;
    }
    async serializeActorsUserAccountsAndTerminals(data, lookups) {
        let actorIdsToFindBy = [];
        for (let actorId of lookups.actorInMessageIndexesById.keys()) {
            actorIdsToFindBy.push(actorId);
        }
        const actors = await this.actorDao.findWithDetailsAndGlobalIdsByIds(actorIdsToFindBy);
        this.serializeUserAccounts(actors, data, lookups.userAccountLookup);
        this.serializeActorTerminals(actors, data, lookups.terminalLookup, lookups.userAccountLookup);
        for (const actor of actors) {
            const applicationInMessageIndex = this.serializeApplication(actor.application, lookups.applicationLookup, data);
            const actorInMessageIndex = lookups.actorInMessageIndexesById.get(actor._localId);
            data.actors[actorInMessageIndex] = {
                ...this.WITH_ID,
                application: applicationInMessageIndex,
                terminal: lookups.terminalLookup.inMessageIndexesById.get(actor.terminal.GUID),
                userAccount: lookups.userAccountLookup.inMessageIndexesById.get(actor.userAccount.accountPublicSigningKey),
                GUID: actor.GUID
            };
        }
    }
    serializeActorTerminals(actors, data, inMessageTerminalLookup, inMessageUserAccountLookup) {
        for (const actor of actors) {
            this.addTerminalToMessage(actor.terminal, data, inMessageTerminalLookup, inMessageUserAccountLookup);
        }
    }
    serializeUserAccounts(actors, data, inMessageUserAccountLookup) {
        for (const actor of actors) {
            this.addUserAccountToMessage(actor.userAccount, data, inMessageUserAccountLookup);
            this.addUserAccountToMessage(actor.terminal.owner, data, inMessageUserAccountLookup);
        }
    }
    addRepositoryMemberToMessage(repositoryMember, data, lookups, addFullRecord) {
        const { entityAlreadyAdded, inMessageIndex } = this.getEntityInMessageIndex(repositoryMember, IndexedEntityType.REPOSITORY_MEMBER, lookups.repositoryMemberLookup);
        if (!entityAlreadyAdded) {
            let newRepositoryMember = {
                ...this.WITH_ID,
                memberPublicSigningKey: repositoryMember.memberPublicSigningKey
            };
            if (addFullRecord) {
                newRepositoryMember = {
                    ...newRepositoryMember,
                    isOwner: repositoryMember.isOwner,
                    isAdministrator: repositoryMember.isAdministrator,
                    canWrite: repositoryMember.canWrite,
                    status: repositoryMember.status,
                    userAccount: this.addUserAccountToMessage(repositoryMember.userAccount, data, lookups.userAccountLookup)
                };
            }
            data.repositoryMembers[inMessageIndex] = newRepositoryMember;
        }
        return inMessageIndex;
    }
    getEntityInMessageIndex(entity, indexedEntityType, inMessageEntityLookup) {
        let id;
        switch (indexedEntityType) {
            case IndexedEntityType.APPLICATION:
                id = entity.index;
                break;
            case IndexedEntityType.REPOSITORY_MEMBER:
                id = entity.memberPublicSigningKey;
                break;
            case IndexedEntityType.TERMINAL:
                id = entity.GUID;
                break;
            case IndexedEntityType.USER_ACCOUNT:
                id = entity.accountPublicSigningKey;
                break;
        }
        let inMessageIndex = inMessageEntityLookup
            .inMessageIndexesById.get(id);
        const entityAlreadyAdded = inMessageIndex !== undefined;
        if (inMessageIndex === undefined) {
            inMessageIndex = ++inMessageEntityLookup.lastInMessageIndex;
            inMessageEntityLookup.inMessageIndexesById
                .set(id, inMessageIndex);
        }
        return {
            entityAlreadyAdded,
            inMessageIndex
        };
    }
    addUserAccountToMessage(userAccount, data, inMessageUserAccountLookup) {
        if (!userAccount) {
            return -1;
        }
        const { entityAlreadyAdded, inMessageIndex } = this.getEntityInMessageIndex(userAccount, IndexedEntityType.USER_ACCOUNT, inMessageUserAccountLookup);
        if (!entityAlreadyAdded) {
            let serializedUserAccount = {
                ...this.WITH_ID,
                accountPublicSigningKey: userAccount.accountPublicSigningKey,
                username: userAccount.username
            };
            data.userAccounts[inMessageIndex] = serializedUserAccount;
        }
        return inMessageIndex;
    }
    addTerminalToMessage(terminal, data, inMessageTerminalLookup, inMessageUserAccountLookup) {
        const { entityAlreadyAdded, inMessageIndex } = this.getEntityInMessageIndex(terminal, IndexedEntityType.TERMINAL, inMessageTerminalLookup);
        if (!entityAlreadyAdded) {
            data.terminals[inMessageIndex] = {
                ...this.WITH_ID,
                GUID: terminal.GUID,
                owner: inMessageUserAccountLookup.inMessageIndexesById.get(terminal.owner.accountPublicSigningKey)
            };
        }
        return inMessageIndex;
    }
    async serializeRepositories(repositoryTransactionHistory, data, lookups) {
        let repositoryIdsToFindBy = [];
        for (let repositoryId of lookups.repositoryInMessageIndexesById.keys()) {
            repositoryIdsToFindBy.push(repositoryId);
        }
        repositoryIdsToFindBy.push(repositoryTransactionHistory._localId);
        const repositories = await this.repositoryDao.findWithOwnerBy_LocalIds(repositoryIdsToFindBy);
        for (const repository of repositories) {
            let userAccountInMessageIndex = this.getEntityInMessageIndex(repository.owner, IndexedEntityType.USER_ACCOUNT, lookups.userAccountLookup);
            if (lookups.repositoryInMessageIndexesById.has(repository._localId)) {
                const repositoryInMessageIndex = lookups.repositoryInMessageIndexesById.get(repository._localId);
                data.referencedRepositories[repositoryInMessageIndex] =
                    this.serializeRepository(repository, userAccountInMessageIndex);
            }
            else {
                if (typeof data.history.repository !== 'string') {
                    data.history.repository.owner = userAccountInMessageIndex;
                    data.history.repository._localId = repository._localId;
                }
            }
        }
    }
    async serializeReferencedApplicationProperties(data, lookups) {
        let applicationRelationIdsToFindBy = [];
        for (let applicationRelationLocalId of lookups.referencedApplicationRelationIndexesById.keys()) {
            applicationRelationIdsToFindBy.push(applicationRelationLocalId);
        }
        const applicationRelations = await this.applicationRelationDao
            .findAllByLocalIdsWithApplications(applicationRelationIdsToFindBy);
        for (const applicationRelation of applicationRelations) {
            const referencedApplicationVersion = applicationRelation.entity.applicationVersion;
            let referencedApplicationVersionInMessageIndex;
            if (lookups.referencedApplicationVersionInMessageIndexesById.has(referencedApplicationVersion._localId)) {
                referencedApplicationVersionInMessageIndex = lookups.referencedApplicationVersionInMessageIndexesById.get(referencedApplicationVersion._localId);
            }
            else {
                referencedApplicationVersionInMessageIndex = ++lookups.lastInMessageReferencedApplicationVersionIndex;
                lookups.referencedApplicationVersionInMessageIndexesById.set(referencedApplicationVersion._localId, referencedApplicationVersionInMessageIndex);
            }
            lookups.referencedApplicationVersions[referencedApplicationVersionInMessageIndex] = referencedApplicationVersion;
            data.referencedApplicationRelations.push({
                ...this.WITH_ID,
                index: applicationRelation.index,
                entity: {
                    ...this.WITH_ID,
                    index: applicationRelation.entity.index,
                    applicationVersion: referencedApplicationVersionInMessageIndex
                }
            });
        }
    }
    serializeApplicationsAndVersions(data, applicationLookup, lookupVersions, finalApplicationVersions) {
        for (let i = 0; i < lookupVersions.length; i++) {
            const applicationVersion = lookupVersions[i];
            const applicationInMessageIndex = this.serializeApplication(applicationVersion.application, applicationLookup, data);
            finalApplicationVersions[i] = {
                ...this.WITH_ID,
                application: applicationInMessageIndex,
                integerVersion: applicationVersion.integerVersion
            };
        }
    }
    serializeApplication(application, applicationLookup, data) {
        const { entityAlreadyAdded, inMessageIndex } = this.getEntityInMessageIndex(application, IndexedEntityType.APPLICATION, applicationLookup);
        if (!entityAlreadyAdded) {
            data.applications[inMessageIndex] = {
                ...this.WITH_INDEX,
                domain: {
                    ...this.WITH_ID,
                    name: application.domain.name
                },
                name: application.name
            };
        }
        return inMessageIndex;
    }
    serializeRepositoryTransactionHistory(repositoryTransactionHistory, data, lookups) {
        repositoryTransactionHistory.operationHistory.sort((operationHistory1, operationHistory2) => {
            if (operationHistory1.orderNumber < operationHistory2.orderNumber) {
                return -1;
            }
            if (operationHistory1.orderNumber > operationHistory2.orderNumber) {
                return 1;
            }
            return 0;
        });
        const serializedOperationHistory = [];
        for (const operationHistory of repositoryTransactionHistory.operationHistory) {
            serializedOperationHistory.push(this.serializeOperationHistory(repositoryTransactionHistory, operationHistory, data, lookups));
        }
        const member = this.addRepositoryMemberToMessage(repositoryTransactionHistory, data, lookups, repositoryTransactionHistory.isRepositoryCreation);
        this.serializeNewRepositoryMembers(repositoryTransactionHistory, data, lookups);
        return {
            ...this.WITH_ID,
            actor: this.getActorInMessageIndex(repositoryTransactionHistory.actor, lookups),
            GUID: repositoryTransactionHistory.GUID,
            isRepositoryCreation: repositoryTransactionHistory.isRepositoryCreation,
            isPublic: repositoryTransactionHistory.isPublic,
            member,
            repository: this.serializeHistoryRepository(repositoryTransactionHistory, data, lookups.userAccountLookup),
            operationHistory: serializedOperationHistory,
            saveTimestamp: repositoryTransactionHistory.saveTimestamp,
            newRepositoryMemberAcceptances: this.serializeRepositoryMemberAcceptances(repositoryTransactionHistory, data, lookups),
            newRepositoryMemberInvitations: this.serializeRepositoryMemberInvitations(repositoryTransactionHistory, data, lookups)
        };
    }
    serializeHistoryRepository(repositoryTransactionHistory, data, inMessageUserAccountLookup) {
        if (repositoryTransactionHistory.isRepositoryCreation) {
            const repository = repositoryTransactionHistory.repository;
            let userAccountInMessageIndex = this.addUserAccountToMessage(repository.owner, data, inMessageUserAccountLookup);
            return this.serializeRepository(repository, userAccountInMessageIndex);
        }
        else {
            // When this repositoryTransactionHistory processed at sync-in 
            // the repository should already be loaded in the target database
            // if it's not then it's missing the repositoryTransactionHistory
            // with isRepositoryCreation === true
            return repositoryTransactionHistory.repository.GUID;
        }
    }
    serializeNewRepositoryMembers(repositoryTransactionHistory, data, lookups) {
        for (const newRepositoryMember of repositoryTransactionHistory
            .newRepositoryMembers) {
            this.addRepositoryMemberToMessage(newRepositoryMember, data, lookups, true);
        }
    }
    serializeRepositoryMemberAcceptances(repositoryTransactionHistory, data, lookups) {
        const serializedRepositoryMemberAcceptances = [];
        for (const newRepositoryMemberAcceptance of repositoryTransactionHistory
            .newRepositoryMemberAcceptances) {
            serializedRepositoryMemberAcceptances.push({
                ...this.WITH_ID,
                createdAt: newRepositoryMemberAcceptance.createdAt,
                acceptingRepositoryMember: this.addRepositoryMemberToMessage(newRepositoryMemberAcceptance.acceptingRepositoryMember, data, lookups, false),
                invitationPublicSigningKey: newRepositoryMemberAcceptance.invitationPublicSigningKey
            });
        }
        return serializedRepositoryMemberAcceptances;
    }
    serializeRepositoryMemberInvitations(repositoryTransactionHistory, data, lookups) {
        const serializedRepositoryMemberInvitations = [];
        for (const newRepositoryMemberInvitation of repositoryTransactionHistory
            .newRepositoryMemberInvitations) {
            serializedRepositoryMemberInvitations.push({
                ...this.WITH_ID,
                createdAt: newRepositoryMemberInvitation.createdAt,
                invitationPublicSigningKey: newRepositoryMemberInvitation.invitationPublicSigningKey,
                invitedRepositoryMember: this.addRepositoryMemberToMessage(newRepositoryMemberInvitation.invitedRepositoryMember, data, lookups, true)
            });
        }
        return serializedRepositoryMemberInvitations;
    }
    serializeOperationHistory(repositoryTransactionHistory, operationHistory, data, lookups) {
        const dbEntity = operationHistory.entity;
        const serializedRecordHistory = [];
        for (const recordHistory of operationHistory.recordHistory) {
            serializedRecordHistory.push(this.serializeRecordHistory(repositoryTransactionHistory, recordHistory, dbEntity, data, lookups));
        }
        const entity = operationHistory.entity;
        // Should be populated - coming from TerminalStore
        // if (typeof entity !== 'object') {
        // 	throw new Error(`OperationHistory.entity must be populated`)
        // }
        // if (typeof entity.index !== 'number') {
        // 	throw new Error(`OperationHistory.entity.index must be present`)
        // }
        const applicationVersion = entity.applicationVersion;
        // Should be populated - coming from TerminalStore
        // if (typeof applicationVersion !== 'object') {
        // 	throw new Error(`OperationHistory.entity.applicationVersion must be populated`)
        // }
        // if (typeof applicationVersion._localId !== 'number') {
        // 	throw new Error(`OperationHistory.entity.applicationVersion._localId must be present`)
        // }
        let applicationVersionInMessageIndex;
        if (lookups.applicationVersionInMessageIndexesById.has(applicationVersion._localId)) {
            applicationVersionInMessageIndex = lookups.applicationVersionInMessageIndexesById.get(applicationVersion._localId);
        }
        else {
            applicationVersionInMessageIndex = ++lookups.lastInMessageApplicationVersionIndex;
            lookups.applicationVersionInMessageIndexesById.set(applicationVersion._localId, applicationVersionInMessageIndex);
        }
        lookups.applicationVersions[applicationVersionInMessageIndex] = applicationVersion;
        return {
            ...this.WITH_ID,
            changeType: operationHistory.changeType,
            entity: {
                ...this.WITH_ID,
                applicationVersion: applicationVersionInMessageIndex,
                index: operationHistory.entity.index
            },
            recordHistory: serializedRecordHistory
        };
    }
    serializeRecordHistory(repositoryTransactionHistory, recordHistory, dbEntity, data, lookups) {
        const dbColumMapByIndex = new Map();
        for (const dbColumn of dbEntity.columns) {
            dbColumMapByIndex.set(dbColumn.index, dbColumn);
        }
        const newValues = [];
        for (const newValue of recordHistory.newValues) {
            const dbColumn = dbColumMapByIndex.get(newValue.columnIndex);
            newValues.push(this.serializeNewValue(newValue, dbColumn, data, lookups));
        }
        const oldValues = [];
        for (const oldValue of recordHistory.oldValues) {
            const dbColumn = dbColumMapByIndex.get(oldValue.columnIndex);
            oldValues.push(this.serializeOldValue(oldValue, dbColumn, data, lookups));
        }
        const actor = recordHistory.actor;
        // Actor may be null if it's the same actor as for RepositoryTransactionHistory
        // if (typeof actor !== 'object') {
        // 	throw new Error(`RecordHistory.actor must be populated`)
        // }
        const baseObject = {
            ...this.WITH_ID,
        };
        if (actor._localId !== repositoryTransactionHistory.actor._localId) {
            baseObject.actor = this.getActorInMessageIndex(actor, lookups);
        }
        if (newValues.length) {
            baseObject.newValues = newValues;
        }
        if (oldValues.length) {
            baseObject.oldValues = oldValues;
        }
        return {
            ...baseObject,
            _actorRecordId: recordHistory._actorRecordId,
        };
    }
    getActorInMessageIndex(actor, lookups) {
        if (!actor) {
            return null;
        }
        return this.getActorInMessageIndexById(actor._localId, lookups);
    }
    getActorInMessageIndexById(actorId, lookups) {
        let actorInMessageIndex;
        if (lookups.actorInMessageIndexesById.has(actorId)) {
            actorInMessageIndex = lookups.actorInMessageIndexesById.get(actorId);
        }
        else {
            actorInMessageIndex = ++lookups.lastInMessageActorIndex;
            lookups.actorInMessageIndexesById.set(actorId, actorInMessageIndex);
        }
        return actorInMessageIndex;
    }
    serializeNewValue(newValue, dbColumn, data, lookups) {
        return this.serializeValue(newValue, dbColumn, data, lookups, 'newValue');
    }
    serializeOldValue(oldValue, dbColumn, data, lookups) {
        return this.serializeValue(oldValue, dbColumn, data, lookups, 'oldValue');
    }
    serializeValue(valueRecord, dbColumn, data, lookups, valueFieldName) {
        let value = valueRecord[valueFieldName];
        let serailizedValue = value;
        if (this.applicationUtils.isManyRelationColumn(dbColumn)) {
            const oneSideDbEntity = this.applicationUtils
                .getOneSideEntityOfManyRelationColumn(dbColumn);
            if (this.dictionary.isActor(oneSideDbEntity)) {
                serailizedValue = this.getActorInMessageIndexById(value, lookups);
            }
            else if (this.dictionary.isRepository(oneSideDbEntity)) {
                serailizedValue = this.getSerializedRepositoryId(value, lookups);
            }
            else if (this.dictionary.isTerminal(oneSideDbEntity)) {
                const terminalInMessageIndex = this.addTerminalToMessage(value, data, lookups.terminalLookup, lookups.userAccountLookup);
                serailizedValue = terminalInMessageIndex;
            }
            else if (this.dictionary.isUserAccount(oneSideDbEntity)) {
                const userAccountInMessageIndex = this.addUserAccountToMessage(value, data, lookups.userAccountLookup);
                serailizedValue = userAccountInMessageIndex;
            }
            else if (this.dictionary.isApplicationRelation(oneSideDbEntity)) {
                serailizedValue = this.getSerializedReferencedApplicationRelationId(value, lookups);
            }
        }
        if (this.dictionary.isActorRelationColumn(dbColumn)) {
            serailizedValue = this.getActorInMessageIndexById(value, lookups);
        }
        if (this.dictionary.isRepositoryRelationColumn(dbColumn)) {
            serailizedValue = this.getSerializedRepositoryId(value, lookups);
        }
        return {
            ...this.WITH_RECORD_HISTORY,
            columnIndex: valueRecord.columnIndex,
            [valueFieldName]: serailizedValue
        };
    }
    getSerializedRepositoryId(repositoryLocalId, lookups) {
        if (repositoryLocalId === lookups.messageRepository._localId) {
            return -1;
        }
        let serailizedValue = lookups.repositoryInMessageIndexesById.get(repositoryLocalId);
        if (serailizedValue === undefined) {
            lookups.lastInMessageRepositoryIndex++;
            serailizedValue = lookups.lastInMessageRepositoryIndex;
            lookups.repositoryInMessageIndexesById.set(repositoryLocalId, serailizedValue);
        }
        return serailizedValue;
    }
    getSerializedReferencedApplicationRelationId(applicationRelationLocalId, lookups) {
        let serailizedValue = lookups.referencedApplicationRelationIndexesById
            .get(applicationRelationLocalId);
        if (serailizedValue === undefined) {
            lookups.lastInMessageReferencedApplicationRelationIndex++;
            serailizedValue = lookups.lastInMessageReferencedApplicationRelationIndex;
            lookups.referencedApplicationRelationIndexesById
                .set(applicationRelationLocalId, serailizedValue);
        }
        return serailizedValue;
    }
    serializeRepository(repository, owner) {
        return {
            ...this.WITH_ID,
            ageSuitability: repository.ageSuitability,
            createdAt: repository.createdAt,
            immutable: repository.immutable,
            owner,
            source: repository.source,
            GUID: repository.GUID
        };
    }
}

class SynchronizationOutManager {
    async synchronizeOut(repositoryTransactionHistories) {
        await this.loadHistoryRepositories(repositoryTransactionHistories);
        const { historiesToSend, messages } = await this.syncOutDataSerializer.serialize(repositoryTransactionHistories);
        // await this.ensureGlobalRepositoryIdentifiers(repositoryTransactionHistories, messages)
        this.messageSigningManager.signMessages(messages);
        const groupMessageMap = this.groupMessagesByRepository(messages, historiesToSend);
        for (const [repositoryGUID, messagesForRepository] of groupMessageMap) {
            const synchronizationAdapter = await this.synchronizationAdapterLoader.load(repositoryGUID);
            await synchronizationAdapter.sendTransactions(repositoryGUID, messagesForRepository);
        }
        await this.updateRepositoryTransactionHistories(messages, historiesToSend);
    }
    async loadHistoryRepositories(repositoryTransactionHistories) {
        const repositoryIdsToLookup = new Set();
        const repositoryMapById = new Map();
        for (const repositoryTransactionHistory of repositoryTransactionHistories) {
            repositoryIdsToLookup.add(repositoryTransactionHistory.repository._localId);
        }
        if (!repositoryIdsToLookup.size) {
            return;
        }
        const repositories = await this.repositoryDao.findWithOwnerBy_LocalIds([
            ...repositoryIdsToLookup.values()
        ]);
        for (const repository of repositories) {
            repositoryMapById.set(repository._localId, repository);
        }
        for (const repositoryTransactionHistory of repositoryTransactionHistories) {
            repositoryTransactionHistory.repository =
                repositoryMapById.get(repositoryTransactionHistory.repository._localId);
        }
    }
    async ensureGlobalRepositoryIdentifiers(repositoryTransactionHistories, messages) {
        const repositoryIdsToLookup = new Set();
        const repositoryMapById = new Map();
        for (const repositoryTransactionHistory of repositoryTransactionHistories) {
            const repository = repositoryTransactionHistory.repository;
            if (!repository.source || !repository.GUID) {
                repositoryIdsToLookup.add(repository._localId);
            }
            else {
                repositoryMapById.set(repository._localId, repository);
            }
        }
        if (!repositoryIdsToLookup.size) {
            return;
        }
        const repositories = await this.repositoryDao.findWithOwnerBy_LocalIds([
            ...repositoryIdsToLookup.values()
        ]);
        for (const repository of repositories) {
            repositoryMapById.set(repository._localId, repository);
        }
        for (const message of messages) {
            const repository = message.history.repository;
            if (!repository.source || !repository.GUID) {
                const foundRepository = repositoryMapById.get(repository._localId);
                repository.source = foundRepository.source;
                repository.GUID = foundRepository.GUID;
                delete repository._localId;
            }
        }
    }
    groupMessagesByRepository(messages, historiesToSend) {
        const groupMessageMap = new Map();
        for (let i = 0; i < messages.length; i++) {
            const repository = historiesToSend[i].repository;
            this.datastructureUtils.ensureChildArray(groupMessageMap, repository.GUID).push(messages[i]);
        }
        return groupMessageMap;
    }
    async updateRepositoryTransactionHistories(messages, repositoryTransactionHistories) {
        for (let i = 0; i < messages.length; i++) {
            const message = messages[i];
            const repositoryTransactionHistory = repositoryTransactionHistories[i];
            if (message.syncTimestamp) {
                repositoryTransactionHistory.syncTimestamp = message.syncTimestamp;
                await this.repositoryTransactionHistoryDao.updateSyncTimestamp(repositoryTransactionHistory);
            }
        }
    }
}

const groundTransport = lib('ground-transport');
groundTransport.register(Stage1SyncedInDataProcessor, Stage2SyncedInDataProcessor, SyncInActorChecker, SyncInChecker, SyncInDataChecker, SyncInTerminalChecker, SyncInRepositoryChecker, SyncInApplicationChecker, SyncInApplicationVersionChecker, SyncInUserAccountChecker, SyncInUtils, SynchronizationInManager, SynchronizationOutManager, SyncOutDataSerializer, TwoStageSyncedInDataProcessor, DebugSynchronizationAdapter, SynchronizationAdapterLoader);
groundTransport.setDependencies(DebugSynchronizationAdapter, {
    client: Client
});
groundTransport.setDependencies(Stage1SyncedInDataProcessor, {
    actorDao: ActorDao,
    airportDatabase: AIRPORT_DATABASE,
    datastructureUtils: DatastructureUtils,
    repositoryTransactionHistoryDao: RepositoryTransactionHistoryDao,
    repositoryTransactionHistoryDuo: RepositoryTransactionHistoryDuo,
    sequenceGenerator: SEQUENCE_GENERATOR,
    syncInUtils: SyncInUtils,
    systemWideOperationIdUtils: SystemWideOperationIdUtils,
});
groundTransport.setDependencies(Stage2SyncedInDataProcessor, {
    airportDatabase: AIRPORT_DATABASE,
    databaseFacade: DATABASE_FACADE,
    datastructureUtils: DatastructureUtils,
    dictionary: Dictionary,
    recordUpdateStageDao: RecordUpdateStageDao,
    utils: Utils
});
groundTransport.setDependencies(SyncInActorChecker, {
    actorDao: ActorDao,
});
groundTransport.setDependencies(SyncInApplicationChecker, {
    applicationDao: ApplicationDao,
    domainDao: DomainDao
});
groundTransport.setDependencies(SyncInApplicationVersionChecker, {
    applicationVersionDao: ApplicationVersionDao,
    applicationInitializer: APPLICATION_INITIALIZER
});
groundTransport.setDependencies(SyncInChecker, {
    datastructureUtils: DatastructureUtils,
    keyUtils: KeyUtils,
    syncInActorChecker: SyncInActorChecker,
    syncInApplicationChecker: SyncInApplicationChecker,
    syncInApplicationVersionChecker: SyncInApplicationVersionChecker,
    syncInDataChecker: SyncInDataChecker,
    syncInRepositoryChecker: SyncInRepositoryChecker,
    syncInTerminalChecker: SyncInTerminalChecker,
    syncInUserAccountChecker: SyncInUserAccountChecker,
    terminalStore: TerminalStore
});
groundTransport.setDependencies(SyncInDataChecker, {
    airportDatabase: AIRPORT_DATABASE,
    appTrackerUtils: AppTrackerUtils,
    datastructureUtils: DatastructureUtils,
    dictionary: Dictionary,
    systemWideOperationIdUtils: SystemWideOperationIdUtils,
    terminalStore: TerminalStore
});
groundTransport.setDependencies(SyncInRepositoryChecker, {
    repositoryDao: RepositoryDao,
});
groundTransport.setDependencies(SyncInTerminalChecker, {
    terminalDao: TerminalDao
});
groundTransport.setDependencies(SyncInUserAccountChecker, {
    userAccountDao: UserAccountDao
});
groundTransport.setDependencies(SyncInUtils, {
    datastructureUtils: DatastructureUtils
});
groundTransport.setDependencies(SyncOutDataSerializer, {
    actorDao: ActorDao,
    applicationRelationDao: ApplicationRelationDao,
    applicationUtils: ApplicationUtils,
    dbApplicationUtils: DbApplicationUtils,
    dictionary: Dictionary,
    repositoryDao: RepositoryDao,
});
groundTransport.setDependencies(SynchronizationAdapterLoader, {
    debugSynchronizationAdapter: DebugSynchronizationAdapter
});
groundTransport.setDependencies(SynchronizationInManager, {
    repositoryLoader: REPOSITORY_LOADER,
    repositoryTransactionHistoryDao: RepositoryTransactionHistoryDao,
    syncInApplicationVersionChecker: SyncInApplicationVersionChecker,
    syncInChecker: SyncInChecker,
    transactionManager: TRANSACTION_MANAGER,
    twoStageSyncedInDataProcessor: TwoStageSyncedInDataProcessor
});
groundTransport.setDependencies(SynchronizationOutManager, {
    datastructureUtils: DatastructureUtils,
    messageSigningManager: MessageSigningManager,
    repositoryDao: RepositoryDao,
    repositoryTransactionHistoryDao: RepositoryTransactionHistoryDao,
    synchronizationAdapterLoader: SynchronizationAdapterLoader,
    syncOutDataSerializer: SyncOutDataSerializer
});
groundTransport.setDependencies(TwoStageSyncedInDataProcessor, {
    datastructureUtils: DatastructureUtils,
    recordHistoryDuo: RecordHistoryDuo,
    repositoryDao: RepositoryDao,
    repositoryMemberAcceptanceDao: RepositoryMemberAcceptanceDao,
    repositoryMemberDao: RepositoryMemberDao,
    repositoryMemberInvitationDao: RepositoryMemberInvitationDao,
    repositoryTransactionHistoryDuo: RepositoryTransactionHistoryDuo,
    stage1SyncedInDataProcessor: Stage1SyncedInDataProcessor,
    stage2SyncedInDataProcessor: Stage2SyncedInDataProcessor,
    synchronizationConflictDao: SynchronizationConflictDao,
    synchronizationConflictValuesDao: SynchronizationConflictValuesDao
});

class ActiveQueries {
    constructor() {
        this.queries = new Map();
    }
    add(portableQuery, cachedSqlQuery) {
        const serializedJSONQuery = JSON.stringify(portableQuery.jsonQuery);
        this.queries.set(serializedJSONQuery, cachedSqlQuery);
    }
    remove(portableQuery) {
        const serializedJSONQuery = JSON.stringify(portableQuery.jsonQuery);
        this.queries.delete(serializedJSONQuery);
    }
    markQueriesToRerun(applicationMap, trackedRepoGUIDSet) {
        this.queries.forEach((cachedSqlQuery) => {
            cachedSqlQuery.rerun = this.shouldQueryBeRerun(cachedSqlQuery, applicationMap, trackedRepoGUIDSet);
        });
    }
    shouldQueryBeRerun(cachedSqlQuery, applicationMap, trackedRepoGUIDSet) {
        if (cachedSqlQuery.rerun) {
            // already marked to be re-run
            return true;
        }
        if (!applicationMap.intersects(cachedSqlQuery.sqlQuery.getFieldMap())) {
            return false;
        }
        if (!cachedSqlQuery.trackedRepoGUIDSet.size || !trackedRepoGUIDSet.size) {
            return true;
        }
        for (const repositoryGUID of trackedRepoGUIDSet.values()) {
            if (cachedSqlQuery.trackedRepoGUIDSet.has(repositoryGUID)) {
                return true;
            }
        }
        return false;
    }
    rerunQueries(fieldMap) {
        // Add a bit of a wait to let any query-subscribed screens that are closing after
        // a mutation operation to un-subscribe from those queries.
        setTimeout(() => {
            this.queries.forEach((cachedSqlQuery) => {
                if (cachedSqlQuery.rerun) {
                    cachedSqlQuery.rerun = false;
                    cachedSqlQuery.runQuery();
                }
            });
        }, 100);
    }
    clearQueriesToRerun() {
        this.queries.forEach((cachedSqlQuery) => {
            cachedSqlQuery.rerun = false;
        });
    }
}

class ObservableQueryAdapter {
    constructor() {
        this.queriedRepositoryIds = {
            GUIDSet: new Set(),
            localIdSet: new Set()
        };
        this.repositoryExistenceCheckInProgress = false;
    }
    collectAffectedFieldsAndRepositoriesToRerunQueriesBy(portableQuery, fieldMap, transaction) {
        transaction.fieldMap.merge(fieldMap);
        const trackedRepoGUIDs = portableQuery.trackedRepoGUIDs;
        if (trackedRepoGUIDs instanceof Array) {
            for (const trackedRepoGUID of trackedRepoGUIDs) {
                if (typeof trackedRepoGUID !== 'string') {
                    throw new Error(`Invalid Repository GUID`);
                }
                transaction.affectedRepository_GUIDSet.add(trackedRepoGUID);
            }
        }
        const trackedRepoLocalIds = portableQuery.trackedRepoLocalIds;
        if (trackedRepoLocalIds instanceof Array) {
            for (const trackedRepoLocalId of trackedRepoLocalIds) {
                if (typeof trackedRepoLocalId !== 'number') {
                    throw new Error(`Invalid Repository LocalId`);
                }
                transaction.affectedRepository_LocalIdSet.add(trackedRepoLocalId);
            }
        }
    }
    async checkExistenceOfQueriedRepositories() {
        try {
            if (this.repositoryExistenceCheckInProgress) {
                return;
            }
            this.repositoryExistenceCheckInProgress = true;
            const locallyPresentRepositories = await this.repositoryDao
                .findByGUIDsAndLocalIds(Array.from(this.queriedRepositoryIds.GUIDSet), Array.from(this.queriedRepositoryIds.localIdSet));
            const locallyPresentRepositoryMapByGUID = new Map();
            const locallyPresentRepositoryMapByLocalId = new Map();
            for (const localyPresentRepository of locallyPresentRepositories) {
                locallyPresentRepositoryMapByGUID.set(localyPresentRepository.GUID, localyPresentRepository);
                locallyPresentRepositoryMapByLocalId.set(localyPresentRepository._localId, localyPresentRepository);
            }
            const locallyMissingRepositoryGUIDSet = new Set();
            for (const repositoryGUIDToCheck of this.queriedRepositoryIds.GUIDSet.values()) {
                const locallyPresentRepository = locallyPresentRepositoryMapByGUID
                    .get(repositoryGUIDToCheck);
                if (!locallyPresentRepository || !locallyPresentRepository.isLoaded) {
                    locallyMissingRepositoryGUIDSet.add(repositoryGUIDToCheck);
                }
            }
            for (const repositoryLocalId of this.queriedRepositoryIds.localIdSet.values()) {
                const locallyPresentRepository = locallyPresentRepositoryMapByLocalId
                    .get(repositoryLocalId);
                if (!locallyPresentRepository) {
                    throw new Error(`Did not find a repository with _localId '${repositoryLocalId}'.`);
                }
                if (!locallyPresentRepository.isLoaded) {
                    locallyMissingRepositoryGUIDSet.add(locallyPresentRepository.GUID);
                }
            }
            for (const locallyMissingRepositoryGUID of locallyMissingRepositoryGUIDSet.values()) {
                await this.repositoryLoader.loadRepository(locallyMissingRepositoryGUID, {
                    doNotLoadReferences: true
                });
            }
            this.queriedRepositoryIds.GUIDSet.clear();
            this.queriedRepositoryIds.localIdSet.clear();
        }
        catch (e) {
            console.error('Error checking Repositor existence');
            console.error(e);
        }
        finally {
            this.repositoryExistenceCheckInProgress = false;
        }
    }
    wrapInObservable(portableQuery, queryCallback) {
        // TODO: checking for presence of a Repository in an Observable
        // await this.ensureRepositoryPresenceAndCurrentState(context)
        let resultsSubject = new Subject();
        // FIXME: Remove the query for the list of cached queries, that are checked every
        //       time a mutation operation is run
        // let resultsSubject                 = new Subject<E>(() => {
        // 	if (resultsSubject.subscriptions.length < 1) {
        // 					// Remove the query for the list of cached queries, that are checked every
        // 					// time a mutation operation is run
        // 					this.activeQueries.remove(portableQuery)
        // 	}
        // });
        let trackedRepoGUIDSet = this
            .trackedRepoGUIDArrayToSet(portableQuery.trackedRepoGUIDs);
        let trackedRepoLocalIdSet = this
            .trackedRepoLocalIdArrayToSet(portableQuery.trackedRepoLocalIds);
        let cachedSqlQuery = {
            portableQuery,
            resultsSubject,
            runQuery: () => {
                queryCallback().then(augmentedResult => {
                    resultsSubject.next(augmentedResult);
                });
            },
            trackedRepoGUIDSet,
            trackedRepoLocalIdSet
        };
        this.activeQueries.add(portableQuery, cachedSqlQuery);
        cachedSqlQuery.runQuery();
        return resultsSubject;
    }
    trackedRepoGUIDArrayToSet(trackedRepoGUIDs) {
        let trackedRepoGUIDSet = new Set();
        if (!(trackedRepoGUIDs instanceof Array) || !trackedRepoGUIDs.length) {
            return;
        }
        for (const trackedRepoGUID of trackedRepoGUIDs) {
            if (typeof trackedRepoGUID !== 'string') {
                throw new Error(`Invalid Repository GUID`);
            }
            trackedRepoGUIDSet.add(trackedRepoGUID);
        }
        return trackedRepoGUIDSet;
    }
    trackedRepoLocalIdArrayToSet(trackedRepoLocalIds) {
        let trackedRepoLocalIdSet = new Set();
        if (!(trackedRepoLocalIds instanceof Array) || !trackedRepoLocalIds.length) {
            return;
        }
        for (const trackedRepoLocalId of trackedRepoLocalIds) {
            if (typeof trackedRepoLocalId !== 'number') {
                throw new Error(`Invalid Repository Local Id`);
            }
            trackedRepoLocalIdSet.add(trackedRepoLocalId);
        }
        return trackedRepoLocalIdSet;
    }
}

const flightNumber = lib('flight-number');
flightNumber.register(ActiveQueries);
const OBSERVABLE_QUERY_ADAPTER = flightNumber.token('ObservableQueryAdapter');
OBSERVABLE_QUERY_ADAPTER.setClass(ObservableQueryAdapter);
OBSERVABLE_QUERY_ADAPTER.setDependencies({
    activeQueries: ActiveQueries,
    repositoryDao: RepositoryDao
});
globalThis.OBSERVABLE_QUERY_ADAPTER = OBSERVABLE_QUERY_ADAPTER;

setTimeout(() => {
    if (globalThis.repositoryAutoload !== false) {
        setInterval(() => {
            globalThis.IOC.get(globalThis.OBSERVABLE_QUERY_ADAPTER).then(observableQueryAdapter => observableQueryAdapter
                .checkExistenceOfQueriedRepositories().then());
        }, 300);
    }
}, 2000);

class AbstractEntityOrderByParser {
    constructor(rootSelectClauseFragment, airportDatabase, qValidator, relationManager, orderBy) {
        this.rootSelectClauseFragment = rootSelectClauseFragment;
        this.airportDatabase = airportDatabase;
        this.qValidator = qValidator;
        this.relationManager = relationManager;
        this.orderBy = orderBy;
    }
    getCommonOrderByFragment(orderByFields) {
        return orderByFields.map((orderByField) => {
            switch (orderByField.so) {
                case SortOrder.ASCENDING:
                    return `${orderByField.fa} ASC`;
                case SortOrder.DESCENDING:
                    return `${orderByField.fa} DESC`;
            }
        })
            .join(', ');
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * Will hierarchically order the results of the query using breadth-first processing.
 * Within a given entity will take into account the sort order specified in the Order By
 * clause.
 */
class EntityOrderByParser extends AbstractEntityOrderByParser {
    /**
     * Using the following algorithm
     * http://stackoverflow.com/questions/2549541/performing-breadth-first-search-recursively
     * :
     BinarySearchTree.prototype.breadthFirst = function() {
      var result = '',
      queue = [],
      current = this.root;
      if (!current) return null;
      queue.push(current);
      while (current = queue.shift()) {
            result += current.value + ' ';
            current.left && queue.push(current.left);
            current.right && queue.push(current.right);
        }
      return result;
     }
     *
     * @param joinTree
     * @param qEntityMapByAlias
     * @returns {string}
     */
    getOrderByFragment(joinTree, qEntityMapByAlias, context) {
        let orderByFragments = [];
        let orderBy = [];
        if (this.orderBy) {
            orderBy = this.orderBy.slice();
        }
        const selectFragmentQueue = [];
        let currentSelectFragment = this.rootSelectClauseFragment;
        selectFragmentQueue.push(currentSelectFragment);
        const joinNodeQueue = [];
        let currentJoinNode = joinTree;
        joinNodeQueue.push(currentJoinNode);
        // Perform breadth-first SELECT clause traversal
        while ((currentSelectFragment = selectFragmentQueue.shift())
            && (currentJoinNode = joinNodeQueue.shift())) {
            const tableAlias = this.relationManager.getAlias(currentJoinNode.jsonRelation);
            const dbEntity = qEntityMapByAlias[tableAlias].__driver__.dbEntity;
            const currentEntityOrderBy = [];
            orderBy = orderBy.filter((orderByField) => {
                const orderByDbEntity = this.airportDatabase.applications[orderByField.si]
                    .currentVersion[0].applicationVersion.entities[orderByField.ti];
                const dbColumn = orderByDbEntity.columns[orderByField.ci];
                if (this.isForParentNode(currentJoinNode, orderByField)) {
                    throw new Error(`Found out of order entry in Order By 
					[${orderByDbEntity.applicationVersion.application.name} - ${orderByDbEntity.name}.${dbColumn.name}].
					Entries must be ordered hierarchically, in breadth-first order.`);
                }
                if (orderByField.si !== dbEntity.applicationVersion.application.index || orderByField.ti !== dbEntity.index) {
                    return true;
                }
                this.qValidator.validateReadProperty(dbColumn);
                orderByField.fa = `${tableAlias}.${dbColumn.name}`;
                currentEntityOrderBy.push(orderByField);
                return false;
            });
            // NOTE: Order by Ids is necessary to correctly reconstruct 
            // the entity graph
            const allColumnsToSortBy = [];
            const idColumnsToSortBy = [];
            // By now the SELECT clause is guaranteed to have:
            // Either all ID columns defined on the entity (if @Id columns are defined)
            // Or ALL of the columns on the entity (if no @Id columns are defined)
            for (const propertyName in currentSelectFragment) {
                const dbProperty = dbEntity.propertyMap[propertyName];
                if (dbProperty.relation && dbProperty.relation.length) {
                    for (const dbPropertyColumn of dbProperty.propertyColumns) {
                        const dbColumn = dbPropertyColumn.column;
                        allColumnsToSortBy.push(dbColumn.name);
                        if (dbProperty.isId) {
                            idColumnsToSortBy.push(dbColumn.name);
                        }
                    }
                    if (!currentJoinNode.childNodes.length) {
                        continue;
                    }
                    const dbRelation = dbProperty.relation[0];
                    const dbEntity = dbRelation.relationEntity;
                    const matchingNodes = currentJoinNode.childNodes.filter(childNode => {
                        const jsonRelation = childNode.jsonRelation;
                        return jsonRelation.si === dbEntity.applicationVersion.application.index
                            && jsonRelation.ti === dbEntity.index;
                    });
                    if (!matchingNodes.length) {
                        return;
                    }
                    selectFragmentQueue.push(this.rootSelectClauseFragment[propertyName]);
                    const childJoinNode = currentJoinNode.getEntityRelationChildNode(dbRelation);
                    joinNodeQueue.push(childJoinNode);
                }
                else {
                    const dbColumn = dbProperty.propertyColumns[0].column;
                    allColumnsToSortBy.push(dbColumn.name);
                    // Tentatively add column to the list of columnIndexes to sort by
                    if (dbProperty.isId) {
                        idColumnsToSortBy.push(dbColumn.name);
                    }
                }
            }
            let entityOrderByFragments = this.buildOrderByFragmentForEntity(tableAlias, allColumnsToSortBy, idColumnsToSortBy, currentEntityOrderBy, qEntityMapByAlias);
            orderByFragments = orderByFragments.concat(entityOrderByFragments);
        }
        if (orderBy.length) {
            throw new Error(`
			Found entries in ORDER_BY for tables not found in SELECT clause.  
			Entries must be ordered hierarchically, in breadth-first order.`);
        }
        return orderByFragments.join(', ');
    }
    buildOrderByFragmentForEntity(tableAlias, allColumnsToSortBy, idColumnsToSortBy, currentEntityOrderBy, qEntityMapByAlias) {
        const finalOrderByColumnsFragments = [];
        const inputOrderByPropertyNameSet = {};
        const dbEntity = qEntityMapByAlias[tableAlias].__driver__.dbEntity;
        // First add the fields specified in the Order By clause for this entity
        currentEntityOrderBy.forEach((orderByField) => {
            finalOrderByColumnsFragments.push(orderByField);
            const columnName = dbEntity.columns[orderByField.ci].name;
            inputOrderByPropertyNameSet[columnName] = true;
        });
        if (idColumnsToSortBy.length) {
            // Then if the ID column is present in the result set, just order by id
            for (const idColumnName of idColumnsToSortBy) {
                if (!inputOrderByPropertyNameSet[idColumnName]) {
                    finalOrderByColumnsFragments.push({
                        fa: `${tableAlias}.${idColumnName}`,
                        so: SortOrder.ASCENDING
                    });
                }
            }
        }
        else {
            allColumnsToSortBy.forEach((columnName) => {
                if (!inputOrderByPropertyNameSet[columnName]) {
                    finalOrderByColumnsFragments.push({
                        fa: `${tableAlias}.${columnName}`,
                        so: SortOrder.ASCENDING
                    });
                }
            });
        }
        return this.getCommonOrderByFragment(finalOrderByColumnsFragments);
    }
    isForParentNode(joinTreeNode, orderByField) {
        do {
            joinTreeNode = joinTreeNode.parentNode;
            if (!joinTreeNode) {
                return false;
            }
            if (orderByField.si === joinTreeNode.jsonRelation.si
                && orderByField.ti === joinTreeNode.jsonRelation.ti) {
                return true;
            }
        } while (joinTreeNode.parentNode);
        return false;
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * Will order the results exactly as specified in the Order By clause
 */
class ExactOrderByParser {
    constructor(validator) {
        this.validator = validator;
    }
    getOrderByFragment(rootSelectClauseFragment, orderBy) {
        return orderBy.map((orderByField) => {
            this.validator.validateAliasedFieldAccess(orderByField.fa);
            switch (orderByField.so) {
                case SortOrder.ASCENDING:
                    return `${orderByField.fa} ASC`;
                case SortOrder.DESCENDING:
                    return `${orderByField.fa} DESC`;
            }
        })
            .join(', ');
    }
}

/**
 * Created by Papa on 11/8/2016.
 */
/**
 * Will hierarchically order the results of the query using breadth-first processing.
 * Within a given sub-SELECT facade will take into account the sort order specified in the Order
 * By clause.
 */
class MappedOrderByParser {
    constructor(validator) {
        this.validator = validator;
    }
    /**
     * Using the following algorithm
     * http://stackoverflow.com/questions/2549541/performing-breadth-first-search-recursively
     * :
     BinarySearchTree.prototype.breadthFirst = function() {
      var result = '',
      queue = [],
      current = this.root;

      if (!current) return null;
      queue.push(current);

      while (current = queue.shift()) {
            result += current.value + ' ';
            current.left && queue.push(current.left);
            current.right && queue.push(current.right);
        }
      return result;
     }
     *
     * @param joinTree
     * @param qEntityMapByAlias
     * @returns {string}
     */
    getOrderByFragment(rootSelectClauseFragment, originalOrderBy) {
        let orderByFragments = [];
        let orderBy = [];
        if (originalOrderBy) {
            orderBy = originalOrderBy.slice();
        }
        let selectFragmentQueue = [];
        let currentSelectFragment = rootSelectClauseFragment;
        selectFragmentQueue.push(currentSelectFragment);
        // Breadth first traversal using a queue
        while (currentSelectFragment = selectFragmentQueue.shift()) {
            let currentSelectFragmentFieldSet = {};
            for (let propertyName in currentSelectFragment) {
                let field = currentSelectFragment[propertyName];
                if (!field.appliedFunctions) {
                    selectFragmentQueue.push(field);
                    continue;
                }
                currentSelectFragmentFieldSet[field.fa] = true;
            }
            let currentEntityOrderBy = [];
            // First add the fields specified in the query Order By clause for this entity, in the
            // order they are specified
            orderBy = orderBy.filter((orderByField) => {
                if (!currentSelectFragmentFieldSet[orderByField.fa]) {
                    return true;
                }
                delete currentSelectFragmentFieldSet[orderByField.fa];
                currentEntityOrderBy.push(orderByField);
                return false;
            });
            // Then add all the rest of the fields for this entity, we are maintaining the tree
            // structure of the result
            for (let alias in currentSelectFragmentFieldSet) {
                currentEntityOrderBy.push({
                    fa: alias,
                    so: SortOrder.ASCENDING
                });
            }
            let entityOrderByFragments = this.buildOrderByFragmentForEntity(currentEntityOrderBy);
            orderByFragments = orderByFragments.concat(entityOrderByFragments);
        }
        if (orderBy.length) {
            throw new Error(`Found entries in ORDER_BY for tables not found in SELECT clause.  Entries must be ordered hierarchically, in breadth-first order.`);
        }
        return orderByFragments.join(', ');
    }
    buildOrderByFragmentForEntity(orderByFields) {
        return orderByFields.map((orderByField) => {
            this.validator.validateAliasedFieldAccess(orderByField.fa);
            switch (orderByField.so) {
                case SortOrder.ASCENDING:
                    return `${orderByField.fa} ASC`;
                case SortOrder.DESCENDING:
                    return `${orderByField.fa} DESC`;
            }
        });
    }
}
class AbstractObjectResultParser {
    constructor(applicationUtils, entityStateManager, utils) {
        this.applicationUtils = applicationUtils;
        this.entityStateManager = entityStateManager;
        this.utils = utils;
    }
    addManyToOneStub(resultObject, propertyName, relationInfos, context) {
        let manyToOneStub = {};
        this.entityStateManager.isStub(manyToOneStub);
        resultObject[propertyName] = manyToOneStub;
        let haveAllIds = true;
        relationInfos.forEach((relationInfo) => {
            if (this.applicationUtils.isIdEmpty(relationInfo.value)) {
                haveAllIds = false;
                return;
            }
            let lastObject;
            let currentObject = manyToOneStub;
            let currentIndex = 1;
            const propertyNameChain = relationInfo.propertyNameChains[0];
            while (currentIndex < propertyNameChain.length) {
                // If there is no object in context, create one
                if (!currentObject) {
                    currentObject = {};
                    this.entityStateManager.markAsStub(currentObject);
                    lastObject[propertyNameChain[currentIndex - 1]] = currentObject;
                }
                // If it's not a leaf (more objects in the chain exist)
                if (currentIndex < propertyNameChain.length - 1) {
                    lastObject = currentObject;
                    currentObject = lastObject[propertyNameChain[currentIndex]];
                }
                else {
                    // Otherwise, just assign the value
                    currentObject[propertyNameChain[currentIndex]] = relationInfo.value;
                }
                currentIndex++;
            }
        });
        return haveAllIds;
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * The goal of this parser to to bridge all entity references and arrive at an
 * inter-connected graph (where possible).
 */
class EntityGraphResultParser extends AbstractObjectResultParser {
    constructor(config, datastructureUtils, rootDbEntity, applicationUtils, queryUtils, entityStateManager, utils) {
        super(applicationUtils, entityStateManager, utils);
        this.config = config;
        this.datastructureUtils = datastructureUtils;
        this.rootDbEntity = rootDbEntity;
        this.queryUtils = queryUtils;
        // Keys can only be strings or numbers | TODO: change to JS Maps, if needed
        this.entityMapByApplicationAndTableIndexes = [];
        // One-To-Many & MtO temp stubs (before entityId is available)
        this.otmStubBuffer = [];
        this.mtoStubBuffer = [];
        // Used in ENTITY_FLATTENED queries
        this.currentResultRow = [];
        this.otmMapper = new globalThis.GraphOtmMapper(datastructureUtils);
        this.mtoMapper = new globalThis.GraphMtoMapper(datastructureUtils);
    }
    addEntity(entityAlias, dbEntity, context) {
        return this.applicationUtils.getNewEntity(dbEntity);
    }
    addProperty(entityAlias, resultObject, dataType, propertyName, propertyValue) {
        resultObject[propertyName] = propertyValue;
        return this.utils.objectExists(propertyValue);
    }
    bufferManyToOneStub(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, relationInfos, context) {
        const oneToManyStubAdded = this.addManyToOneStub(resultObject, propertyName, relationInfos, context);
        if (oneToManyStubAdded) {
            const relatedEntityId = this.queryUtils.getIdKey(resultObject[propertyName], relationDbEntity);
            this.bufferManyToOne(dbEntity, propertyName, relationDbEntity, relatedEntityId);
        }
    }
    bufferBlankManyToOneStub(entityAlias, resultObject, propertyName) {
        resultObject[propertyName] = null;
        // Nothing to do for bridged parser - bridging will map blanks, where possible
    }
    bufferManyToOneObject(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, childResultObject, context) {
        resultObject[propertyName] = childResultObject;
        const relatedEntityId = this.queryUtils.getIdKey(resultObject[propertyName], relationDbEntity);
        this.bufferManyToOne(dbEntity, propertyName, relationDbEntity, relatedEntityId);
    }
    bufferBlankManyToOneObject(entityAlias, resultObject, propertyName) {
        resultObject[propertyName] = null;
        // Nothing to do for bridged parser - bridging will map blanks, where possible
    }
    bufferOneToManyStub(otmDbEntity, otmPropertyName) {
        this.bufferOneToMany(otmDbEntity, otmPropertyName);
    }
    bufferOneToManyCollection(entityAlias, resultObject, otmDbEntity, propertyName, relationDbEntity, childResultObject, context) {
        this.bufferOneToMany(otmDbEntity, propertyName);
        resultObject[propertyName] = [childResultObject];
    }
    bufferBlankOneToMany(entityAlias, resultObject, otmEntityName, propertyName, relationDbEntity, context) {
        resultObject[propertyName] = [];
    }
    flushEntity(entityAlias, dbEntity, selectClauseFragment, entityIdValue, resultObject, context) {
        if (!entityIdValue) {
            throw new Error(`No Id provided for entity 
			'${dbEntity.applicationVersion.application.name}.${dbEntity.name}'`);
        }
        let currentEntity = this.getEntityToFlush(dbEntity, selectClauseFragment, entityIdValue, resultObject, context);
        this.flushRelationStubBuffers(entityIdValue, currentEntity, dbEntity, context);
        return currentEntity;
    }
    flushRow() {
        // Nothing to do, bridged queries don't rely on rows changing
    }
    bridge(parsedResults, selectClauseFragment, context) {
        this.mtoMapper.populateMtos(this.entityMapByApplicationAndTableIndexes);
        this.otmMapper.populateOtms(this.entityMapByApplicationAndTableIndexes);
        // merge any out of order entity references (there shouldn't be any)
        return parsedResults;
    }
    bufferManyToOne(dbEntity, propertyName, relationDbEntity, relatedEntityId) {
        let otmEntityField;
        for (const dbRelation of relationDbEntity.relations) {
            switch (dbRelation.relationType) {
                case EntityRelationType.ONE_TO_MANY:
                    break;
                case EntityRelationType.MANY_TO_ONE:
                    continue;
                default:
                    throw new Error(`Unknown EntityRelationType: ${dbRelation.relationType}`);
            }
            if (dbRelation.oneToManyElems && dbRelation.oneToManyElems.mappedBy) {
                if (dbEntity._localId === dbRelation.relationEntity._localId
                    || dbRelation.oneToManyElems.mappedBy === propertyName) {
                    otmEntityField = dbRelation.property.name;
                }
            }
        }
        this.mtoStubBuffer.push({
            otmEntityId: relatedEntityId,
            otmDbEntity: relationDbEntity,
            otmEntityField: otmEntityField,
            mtoDbEntity: dbEntity,
            mtoRelationField: propertyName,
            mtoParentObject: null
        });
    }
    bufferOneToMany(otmDbEntity, otmPropertyName) {
        this.otmStubBuffer.push({
            otmDbEntity: otmDbEntity,
            otmPropertyName: otmPropertyName,
            otmObject: null
        });
    }
    getEntityToFlush(dbEntity, selectClauseFragment, idValue, resultObject, context) {
        if (!idValue) {
            throw new Error(`Entity ID not specified for entity 
			'${dbEntity.applicationVersion.application.name}.${dbEntity.name}'.`);
        }
        let entityMapForName = this.datastructureUtils.ensureChildMap(this.datastructureUtils.ensureChildArray(this.entityMapByApplicationAndTableIndexes, dbEntity.applicationVersion.application.index), dbEntity.index);
        let existingEntity = entityMapForName[idValue];
        let currentEntity = this.mergeEntities(existingEntity, resultObject, dbEntity, selectClauseFragment, context);
        entityMapForName[idValue] = currentEntity;
        return currentEntity;
    }
    // Must merge the one-to-many relationships returned as part of the result tree
    /**
     * Merge entities with of the same class and with the same Id
     *
     * @param source
     * @param target
     * @param qEntity
     * @param selectClauseFragment
     * @param entityPropertyTypeMap
     * @param entityRelationMap
     * @returns {any}
     */
    mergeEntities(source, target, dbEntity, selectClauseFragment, context) {
        if (!source || target === source) {
            return target;
        }
        const id = this.queryUtils.getIdKey(target, dbEntity);
        for (let propertyName in selectClauseFragment) {
            if (selectClauseFragment[propertyName] === undefined) {
                continue;
            }
            const dbProperty = dbEntity.propertyMap[propertyName];
            // Merge properties (conflicts detected at query parsing time):
            if (!dbProperty.relation || !dbProperty.relation.length) {
                // If source property doesn't exist
                if (this.applicationUtils.isEmpty(source[propertyName])) {
                    // set the source property to value of target
                    source[propertyName] = target[propertyName];
                }
                // Else if target property doesn't exist, keep the source value
                // Else, assume that properties must be the same
            }
            // Merge relations
            else {
                const childSelectClauseFragment = selectClauseFragment[propertyName];
                // For stubs (conflicts detected at query parsing time)
                if (childSelectClauseFragment == null) {
                    // For Many-to-One stubs, assume they are are the same and don't detect
                    // conflicts, just merge
                    source[propertyName] = target[propertyName];
                    // Don't process One-to-Many stubs yet (not all related MTOs may have been
                    // collected).
                }
                // For actual objects
                else {
                    const dbRelation = dbProperty.relation[0];
                    const childDbEntity = dbRelation.relationEntity;
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            // Many-to-One (conflicts detected at query parsing time)
                            // If source is missing this mapping and target has it
                            if (source[propertyName] === undefined && target[propertyName] !== undefined) {
                                // set the source property to value of target
                                source[propertyName] = target[propertyName];
                            }
                            // Else if target property doesn't exist, keep the source value
                            // Assume that the child objects have already been merged themselves and
                            // don't process
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            let sourceArray = source[propertyName];
                            const targetArray = target[propertyName];
                            // Because parseQueryResult is depth-first, all child objects have already
                            // been processed
                            // TODO: this will probably fail, since the merged in array should always
                            // have only one entity in it because it is created for a single result set
                            // row.
                            if (this.config && this.config.strict) {
                                if ((!sourceArray && targetArray)
                                    || (!targetArray && sourceArray)
                                    || sourceArray.length != targetArray.length) {
                                    throw new Error(`One-to-Many child arrays don't match for 
									'${dbEntity.name}.${dbProperty.name}', Id: ${id}`);
                                }
                            }
                            const sourceSet = {};
                            if (sourceArray) {
                                sourceArray.forEach((sourceChild) => {
                                    const sourceChildIdValue = this.queryUtils.getIdKey(sourceChild, childDbEntity);
                                    sourceSet[sourceChildIdValue] = sourceChild;
                                });
                            }
                            else {
                                sourceArray = [];
                                source[propertyName] = sourceArray;
                            }
                            if (targetArray) {
                                targetArray.forEach((targetChild) => {
                                    const targetChildIdValue = this.queryUtils.getIdKey(targetChild, childDbEntity);
                                    if (this.config && this.config.strict && !sourceSet[targetChildIdValue]) {
                                        throw new Error(`One-to-Many child arrays don't match for 
										'${dbEntity.name}.${dbProperty.name}', Id: ${id}`);
                                    }
                                    // If target child array has a value that source doesn't
                                    if (!sourceSet[targetChildIdValue]) {
                                        // add it to source (preserve order)
                                        sourceArray.push(targetChild);
                                    }
                                });
                            }
                            // So instead just do
                            // for(let targetObject in targetArray) {
                            //		sourceArray.push(targetArray)
                            //}
                            break;
                        default:
                            throw new Error(`Unknown relation type '${dbRelation.relationType}' for 
							'${dbEntity.name}.${dbProperty.name}'`);
                    }
                }
            }
        }
        return source;
    }
    flushRelationStubBuffers(entityIdValue, currentEntity, dbEntity, context) {
        let otmStubBuffer = this.otmStubBuffer;
        this.otmStubBuffer = [];
        otmStubBuffer.forEach((otmStub) => {
            otmStub.otmObject = currentEntity;
            this.otmMapper.addOtmReference(otmStub, entityIdValue);
        });
        let mtoStubBuffer = this.mtoStubBuffer;
        this.mtoStubBuffer = [];
        mtoStubBuffer.forEach((mtoStub) => {
            mtoStub.mtoParentObject = currentEntity;
            this.otmMapper.addMtoReference(mtoStub, entityIdValue, dbEntity, context);
            this.mtoMapper.addMtoReference(mtoStub, entityIdValue);
        });
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * The goal of this Parser is to determine which objects in the current row are the same
 * as they were in the previous row.  If the objects are the same this parser will merge
 * them.
 */
class TreeResultParser extends AbstractObjectResultParser {
    constructor() {
        super(...arguments);
        this.currentRowObjectMap = {};
        this.objectEqualityMap = {};
        this.lastRowObjectMap = {};
        this.currentObjectOneToManys = {};
    }
    addProperty(entityAlias, resultObject, dataType, propertyName, propertyValue) {
        resultObject[propertyName] = propertyValue;
        if (this.isDifferentOrDoesntExist(entityAlias, resultObject, propertyName)) {
            return this.utils.objectExists(propertyValue);
        }
        // Both last and current objects must exist here
        let lastObject = this.lastRowObjectMap[entityAlias];
        // Both of the properties are truthy
        switch (dataType) {
            case SQLDataType.DATE:
                this.objectEqualityMap[entityAlias] = (lastObject[propertyName].getTime() === resultObject[propertyName].getTime());
                break;
            default:
                this.objectEqualityMap[entityAlias] = (lastObject[propertyName] === resultObject[propertyName]);
                break;
        }
        return true;
    }
    flushRow() {
        this.lastRowObjectMap = this.currentRowObjectMap;
        this.currentRowObjectMap = {};
    }
    isDifferentOrDoesntExist(entityAlias, resultObject, propertyName) {
        // If we already know that this is a new facade, no need to keep on checking
        if (!this.objectEqualityMap[entityAlias]) {
            return true;
        }
        let lastObject = this.lastRowObjectMap[entityAlias];
        // If there was no last facade
        if (!lastObject) {
            this.objectEqualityMap[entityAlias] = false;
            return true;
        }
        if (!resultObject) {
            return true;
        }
        // Types are guaranteed to be the same, so:
        // If the last property is not there or is falsy
        if (!lastObject[propertyName]) {
            this.objectEqualityMap[entityAlias] = !resultObject[propertyName];
            return true;
        } // If the current property is not there or is falsy
        else if (!resultObject[propertyName]) {
            this.objectEqualityMap[entityAlias] = !lastObject[propertyName];
            return true;
        }
        return false;
    }
    addOneToManyCollection(entityAlias, resultObject, propertyName) {
        let currentOtmCollection = resultObject[propertyName];
        this.currentObjectOneToManys[propertyName] = currentOtmCollection;
        if (this.isDifferentOrDoesntExist(entityAlias, resultObject, propertyName)) {
            return;
        }
        let lastObject = this.lastRowObjectMap[entityAlias];
        let lastOtmCollection = lastObject[propertyName];
        // Now both arrays are guaranteed to exist
        // TODO: verify assumption below:
        // For @OneToMany collections, if existence of last child facade changes it must be a
        // new facade
        if (!lastOtmCollection.length) {
            if (currentOtmCollection.length) {
                this.objectEqualityMap[entityAlias] = false;
            }
        }
        else if (!currentOtmCollection.length) {
            if (lastOtmCollection.length) {
                this.objectEqualityMap[entityAlias] = false;
            }
        }
        // Otherwise if it still exists
    }
    mergeEntity(entityAlias, resultObject) {
        let isSameObjectAsLastRow = this.objectEqualityMap[entityAlias];
        this.objectEqualityMap[entityAlias] = true;
        let oneToManys = this.currentObjectOneToManys;
        this.currentObjectOneToManys = {};
        // If it's a new facade
        if (!isSameObjectAsLastRow) {
            return resultObject;
        }
        // All equality checks have passed - this is the same exact facade as last time
        resultObject = this.lastRowObjectMap[entityAlias];
        this.currentRowObjectMap[entityAlias] = resultObject;
        // All @ManyToOnes have been merged automatically (because they are entities
        // themselves)
        // For @OneToManys:
        // If the current one it the same as the last one of the ones in the last entity then
        // it's the same otherwise its new and should be added to the collection
        for (let oneToManyProperty in oneToManys) {
            let currentOneToMany = oneToManys[oneToManyProperty];
            if (currentOneToMany && currentOneToMany.length) {
                // There will always be only one current record, since this is done per result
                // set row
                let currentMto = currentOneToMany[0];
                let existingOneToMany = resultObject[oneToManyProperty];
                if (!existingOneToMany || !existingOneToMany.length) {
                    resultObject[oneToManyProperty] = currentOneToMany;
                }
                // Otherwise if the last facade doesn't match then its a new one
                else if (existingOneToMany[existingOneToMany.length - 1] !== currentMto) {
                    existingOneToMany.push(currentMto);
                }
            }
        }
        return resultObject;
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * The goal of this Parser is to determine which objects in the current row are the same
 * as they were in the previous row.  If the objects are the same this parser will merge
 * them.
 */
class EntityTreeResultParser extends TreeResultParser {
    constructor() {
        super(...arguments);
        this.currentRowObjectMap = {};
        this.objectEqualityMap = {};
        this.lastRowObjectMap = {};
        this.currentObjectOneToManys = {};
    }
    addEntity(entityAlias, dbEntity, context) {
        let resultObject = this.applicationUtils.getNewEntity(dbEntity);
        this.currentRowObjectMap[entityAlias] = resultObject;
        if (this.objectEqualityMap[entityAlias] !== undefined) {
            this.objectEqualityMap[entityAlias] = true;
        }
        return resultObject;
    }
    bufferManyToOneStub(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, relationInfos, context) {
        this.addManyToOneStub(resultObject, propertyName, relationInfos, context);
        this.addManyToOneReference(entityAlias, resultObject, propertyName);
    }
    bufferBlankManyToOneStub(entityAlias, resultObject, propertyName) {
        resultObject[propertyName] = null;
        this.addManyToOneReference(entityAlias, resultObject, propertyName);
    }
    bufferManyToOneObject(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, childResultObject, context) {
        resultObject[propertyName] = childResultObject;
        if (this.isDifferentOrDoesntExist(entityAlias, resultObject, propertyName)) {
            return;
        }
        // Both last and current objects must exist here
        let lastObject = this.lastRowObjectMap[entityAlias];
        // @ManyToOne objects will have been merged by now, just check if its the same facade
        this.objectEqualityMap[entityAlias] = lastObject[propertyName] === resultObject[propertyName];
    }
    bufferBlankManyToOneObject(entityAlias, resultObject, propertyName) {
        resultObject[propertyName] = null;
        this.addManyToOneReference(entityAlias, null, propertyName);
    }
    bufferOneToManyStub(otmDbEntity, otmPropertyName) {
        throw new Error(`@OneToMany stubs not allowed in QueryResultType.HIERARCHICAL`);
    }
    bufferOneToManyCollection(entityAlias, resultObject, otmDbEntity, propertyName, relationDbEntity, childResultObject, context) {
        resultObject[propertyName] = [childResultObject];
        this.addOneToManyCollection(entityAlias, resultObject, propertyName);
    }
    bufferBlankOneToMany(entityAlias, resultObject, otmEntityName, propertyName, relationDbEntity, context) {
        resultObject[propertyName] = [];
        this.addOneToManyCollection(entityAlias, resultObject, propertyName);
    }
    flushEntity(entityAlias, dbEntity, selectClauseFragment, entityId, resultObject, context) {
        return this.mergeEntity(entityAlias, resultObject);
    }
    bridge(parsedResults, selectClauseFragment, context) {
        // Nothing to be done, hierarchical queries are not bridged
        return parsedResults;
    }
    addManyToOneReference(entityAlias, resultObject, propertyName) {
        if (this.isDifferentOrDoesntExist(entityAlias, resultObject, propertyName)) {
            return;
        }
        // Both last and current objects must exist here
        let lastMtoStub = this.lastRowObjectMap[entityAlias][propertyName];
        let currentMtoStub = resultObject[propertyName];
        this.objectEqualityMap[entityAlias] = this.utils.valuesEqual(lastMtoStub, currentMtoStub, true);
    }
}

// For MtO mapping in bridged queries
class GraphMtoMapper {
    constructor(datastructureUtils) {
        this.datastructureUtils = datastructureUtils;
        // Map of all objects that have a given MtO reference
        // [] MtO reference Application Entity Index
        // [] MtO reference Entity Index
        this.mtoStubReferenceMap = [];
    }
    addMtoReference(mtoStubReference, mtoEntityIdValue) {
        const mtoDbEntity = mtoStubReference.mtoDbEntity;
        let mtoEntitiesForTypeMap = this.datastructureUtils.ensureChildMap(this.datastructureUtils.ensureChildArray(this.mtoStubReferenceMap, mtoDbEntity.applicationVersion.application.index), mtoDbEntity.index);
        let mtosForEntity = this.datastructureUtils.ensureChildMap(mtoEntitiesForTypeMap, mtoEntityIdValue);
        mtosForEntity[mtoStubReference.mtoRelationField] = mtoStubReference;
    }
    populateMtos(entityMap) {
        for (const applicationIndex in this.mtoStubReferenceMap) {
            const mtoEntitiesForApplicationMap = this.mtoStubReferenceMap[applicationIndex];
            for (const entityIndex in mtoEntitiesForApplicationMap) {
                const mtoEntitiesForTypeMap = mtoEntitiesForApplicationMap[entityIndex];
                for (let mtoEntityId in mtoEntitiesForTypeMap) {
                    let mtosForEntity = mtoEntitiesForTypeMap[mtoEntityId];
                    for (let mtoPropertyName in mtosForEntity) {
                        let mtoStubReference = mtosForEntity[mtoPropertyName];
                        let otmDbEntity = mtoStubReference.otmDbEntity;
                        if (!entityMap[otmDbEntity.applicationVersion.application.index]) {
                            continue;
                        }
                        let otmEntitiesForTypeMap = entityMap[otmDbEntity.applicationVersion.application.index][otmDbEntity.index];
                        if (!otmEntitiesForTypeMap) {
                            continue;
                        }
                        let otmEntity = otmEntitiesForTypeMap[mtoStubReference.otmEntityId];
                        if (!otmEntity) {
                            continue;
                        }
                        mtoStubReference.mtoParentObject[mtoStubReference.mtoRelationField] = otmEntity;
                    }
                }
            }
        }
    }
}
globalThis.GraphMtoMapper = GraphMtoMapper;

// For OtM mapping in bridged queries
class GraphOtmMapper {
    constructor(datastructureUtils) {
        this.datastructureUtils = datastructureUtils;
        // Map of MtO referred objects by OtM references
        // [] OTM Reference Entity Application Index
        // [] OTM Reference Entity Index
        this.mtoEntityReferenceMap = [];
        // Map of objects with OtM references by
        // [] OtM reference Application Entity Index
        // [] OtM reference Entity Index
        this.otmEntityReferenceMap = [];
    }
    addMtoReference(mtoStubReference, mtoEntityId, dbEntity, context) {
        // If the @OneToMany({ mappedBy: ... }) is missing, there is nothing to map to
        if (!mtoStubReference.otmEntityField) {
            return;
        }
        // Add into mtoEntityReferenceMap
        const otmDbEntity = mtoStubReference.otmDbEntity;
        let mtoEntityReferenceMapForEntity = this.datastructureUtils.ensureChildMap(this.datastructureUtils.ensureChildArray(this.mtoEntityReferenceMap, otmDbEntity.applicationVersion.application.index), otmDbEntity.index);
        let mapForOtmEntity = mtoEntityReferenceMapForEntity[mtoStubReference.otmEntityId];
        if (!mapForOtmEntity) {
            mapForOtmEntity = {};
            mtoEntityReferenceMapForEntity[mtoStubReference.otmEntityId] = mapForOtmEntity;
        }
        let mtoCollection = mapForOtmEntity[mtoStubReference.otmEntityField];
        if (!mtoCollection) {
            mtoCollection = [];
            mapForOtmEntity[mtoStubReference.otmEntityField]
                = mtoCollection;
        }
        mtoCollection.push(mtoStubReference.mtoParentObject);
    }
    addOtmReference(otmStubReference, otmEntityIdValue) {
        // Add into otoEntityReferenceMap
        const otmDbEntity = otmStubReference.otmDbEntity;
        let mtoEntityReferenceMapForEntity = this.datastructureUtils.ensureChildMap(this.datastructureUtils.ensureChildArray(this.otmEntityReferenceMap, otmDbEntity.applicationVersion.application.index), otmDbEntity.index);
        let otmRecordByPropertyName = mtoEntityReferenceMapForEntity[otmEntityIdValue];
        if (!otmRecordByPropertyName) {
            otmRecordByPropertyName = {};
            mtoEntityReferenceMapForEntity[otmEntityIdValue] = otmRecordByPropertyName;
        }
        otmRecordByPropertyName[otmStubReference.otmPropertyName] = otmStubReference.otmObject;
    }
    populateOtms(entityMap) {
        for (const applicationIndex in this.mtoEntityReferenceMap) {
            const mtoEntityReferenceMapForApplication = this.mtoEntityReferenceMap[applicationIndex];
            for (const entityIndex in mtoEntityReferenceMapForApplication) {
                const mtoEntityReferenceMapForEntity = mtoEntityReferenceMapForApplication[entityIndex];
                // If there are no entities of this type in query results, just keep the stubs
                if (!entityMap[applicationIndex]) {
                    continue;
                }
                let entityOfTypeMap = entityMap[applicationIndex][entityIndex];
                // If there are no entities of this type in query results, just keep the stubs
                if (!entityOfTypeMap) {
                    continue;
                }
                // If there are no OTM for this type in query results, no mapping needs to happen
                if (!this.otmEntityReferenceMap[applicationIndex]) {
                    continue;
                }
                let entityWithOtmMap = this.otmEntityReferenceMap[applicationIndex][entityIndex];
                // If there are no OTM for this type in query results, no mapping needs to happen
                if (!entityWithOtmMap) {
                    continue;
                }
                for (let otmEntityId in mtoEntityReferenceMapForEntity) {
                    let referencedEntitiesByPropertyMap = mtoEntityReferenceMapForEntity[otmEntityId];
                    let otmRecordByPropertyName = entityWithOtmMap[otmEntityId];
                    // If there are no OtMs for this entity, no mapping needs to happen
                    if (!otmRecordByPropertyName) {
                        continue;
                    }
                    for (let otmProperty in referencedEntitiesByPropertyMap) {
                        let otmEntity = otmRecordByPropertyName[otmProperty];
                        // If OtM entity doesn't have this collection, no mapping needs to happen
                        if (!otmEntity) {
                            continue;
                        }
                        let referencedEntityArray = referencedEntitiesByPropertyMap[otmProperty];
                        let otmCollection = otmEntity[otmProperty];
                        // If @OneToMany isn't set yet
                        if (!otmCollection) {
                            otmEntity[otmProperty] = referencedEntityArray;
                        }
                        else {
                            for (let referencedEntity of referencedEntityArray) {
                                otmCollection.push(referencedEntity);
                            }
                        }
                        otmRecordByPropertyName[otmProperty] = otmEntity[otmProperty].slice();
                    }
                }
            }
        }
    }
}
globalThis.GraphOtmMapper = GraphOtmMapper;

class ObjectResultParserFactory {
    getObjectResultParser(queryResultType, config, rootDbEntity) {
        switch (queryResultType) {
            case QueryResultType.ENTITY_GRAPH:
                return new EntityGraphResultParser(config, this.datastructureUtils, rootDbEntity, this.applicationUtils, this.queryUtils, this.entityStateManager, this.utils);
            case QueryResultType.ENTITY_TREE:
                return new EntityTreeResultParser(this.applicationUtils, this.entityStateManager, this.utils);
            default:
                throw new Error(`ObjectQueryParser not supported for QueryResultType: ${queryResultType}`);
        }
    }
}

/**
 * Created by Papa on 11/8/2016.
 */
class TreeQueryResultParser extends TreeResultParser {
    addEntity(entityAlias) {
        let resultObject = {};
        this.currentRowObjectMap[entityAlias] = resultObject;
        return resultObject;
    }
    bufferOneToManyCollection(entityAlias, resultObject, propertyName, childResultObject) {
        resultObject[propertyName] = [childResultObject];
        this.addOneToManyCollection(entityAlias, resultObject, propertyName);
    }
    flushEntity(entityAlias, resultObject) {
        return this.mergeEntity(entityAlias, resultObject);
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
var ClauseType;
(function (ClauseType) {
    ClauseType["MAPPED_SELECT_CLAUSE"] = "MAPPED_SELECT_CLAUSE";
    ClauseType["NON_MAPPED_SELECT_CLAUSE"] = "NON_MAPPED_SELECT_CLAUSE";
    ClauseType["WHERE_CLAUSE"] = "WHERE_CLAUSE";
    ClauseType["FUNCTION_CALL"] = "FUNCTION_CALL";
})(ClauseType || (ClauseType = {}));
class SQLWhereBase {
    constructor(dbEntity, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        this.dbEntity = dbEntity;
        this.dialect = dialect;
        this.airportDatabase = airportDatabase;
        this.applicationUtils = applicationUtils;
        this.queryUtils = queryUtils;
        this.entityStateManager = entityStateManager;
        this.qMetadataUtils = qMetadataUtils;
        this.qValidator = qValidator;
        this.sqlQueryAdapter = sqlQueryAdapter;
        this.storeDriver = storeDriver;
        this.subStatementSqlGenerator = subStatementSqlGenerator;
        this.utils = utils;
        this.context = context;
        this.parameterReferences = [];
        this.fieldMap = new globalThis.ApplicationMap();
        this.qEntityMapByAlias = {};
        this.jsonRelationMapByAlias = {};
    }
    getParameters(parameterMap, //,
    context) {
        // let populatedParameterMap: {[parameterAlias: string]: boolean} = {};
        return this.parameterReferences
            /*
             .parameterReferences.filter(( parameterReference ) => {
             if (!populatedParameterMap[parameterReference]) {
             populatedParameterMap[parameterReference] = true;
             return true;
             }
             return false;
             })
             */
            .map((parameterReference) => {
            let parameter = parameterMap[parameterReference];
            if (!parameter) {
                const isReference = parameterReference === null || ['number', 'string'].indexOf(typeof parameterReference) > -1;
                if (isReference) {
                    // if (!valuesArray) {
                    return parameterReference;
                    // } else if (typeof parameterReference === 'number') {
                    // 	return sqlAdaptor.getValue(valuesArray[parameterReference])
                    // }
                }
                throw new Error(`No parameter found for alias '${parameterReference}'`);
            }
            return this.sqlQueryAdapter.getParameterValue(parameter);
        });
    }
    getFunctionCallValue(rawValue, context) {
        return this.getFieldValue(rawValue, ClauseType.FUNCTION_CALL, null, context);
    }
    getFieldFunctionValue(aField, defaultCallback, context) {
        let aValue = aField.v;
        if (this.isParameterReference(aValue)) {
            let stringValue = aValue;
            this.parameterReferences.push(stringValue);
            aValue = this.sqlQueryAdapter.getParameterReference(this.parameterReferences, stringValue);
        }
        else {
            aValue = this.getFieldValue(aValue, ClauseType.FUNCTION_CALL, defaultCallback, context);
        }
        aValue = this.sqlQueryAdapter.getFunctionAdaptor()
            .getFunctionCalls(aField, aValue, this.qEntityMapByAlias, this, context);
        this.qValidator.addFunctionAlias(aField.fa);
        return aValue;
    }
    getFieldValue(clauseField, clauseType, defaultCallback, context) {
        let columnName;
        if (!clauseField) {
            throw new Error(`Missing Clause Field definition`);
        }
        if (clauseField instanceof Array) {
            return clauseField
                .map((clauseFieldMember) => this.getFieldValue(clauseFieldMember, clauseType, defaultCallback, context))
                .join(', ');
        }
        if (clauseType !== ClauseType.MAPPED_SELECT_CLAUSE && !clauseField.ot) {
            throw new Error(`Object Type is not defined in JSONClauseField`);
        }
        const aField = clauseField;
        let qEntity;
        switch (clauseField.ot) {
            case JSONClauseObjectType.FIELD_FUNCTION:
                return this.getFieldFunctionValue(aField, defaultCallback, context);
            case JSONClauseObjectType.DISTINCT_FUNCTION:
                throw new Error(`Distinct function cannot be nested.`);
            case JSONClauseObjectType.EXISTS_FUNCTION: {
                if (clauseType !== ClauseType.WHERE_CLAUSE) {
                    throw new Error(`Exists can only be used as a top function in a WHERE clause.`);
                }
                const { parameterReferences, subQuerySql } = this.subStatementSqlGenerator.getTreeQuerySql(aField.v, this.dialect, context);
                if (parameterReferences.length) {
                    this.parameterReferences = this.parameterReferences.concat(parameterReferences);
                }
                return `EXISTS(${subQuerySql})`;
            }
            case JSONClauseObjectType.FIELD: {
                qEntity = this.qEntityMapByAlias[aField.ta];
                this.qValidator.validateReadQEntityProperty(aField.si, aField.ti, aField.ci);
                columnName = this.getEntityPropertyColumnName(qEntity, aField.ci, context);
                this.addField(aField.si, aField.ti, aField.ci);
                return this.getComplexColumnFragment(aField, columnName, context);
            }
            case JSONClauseObjectType.FIELD_QUERY: {
                let jsonFieldSqlSubQuery = aField.fieldSubQuery;
                if (aField.S) {
                    jsonFieldSqlSubQuery = aField;
                }
                const { parameterReferences, subQuerySql } = this.subStatementSqlGenerator.getFieldQuerySql(jsonFieldSqlSubQuery, this.dialect, this.qEntityMapByAlias, context);
                if (parameterReferences.length) {
                    this.parameterReferences = this.parameterReferences.concat(parameterReferences);
                }
                this.qValidator.addSubQueryAlias(aField.fa);
                return `(${subQuerySql})`;
            }
            case JSONClauseObjectType.MANY_TO_ONE_RELATION: {
                qEntity = this.qEntityMapByAlias[aField.ta];
                this.qValidator.validateReadQEntityManyToOneRelation(aField.si, aField.ti, aField.ci);
                columnName = this.getEntityManyToOneColumnName(qEntity, aField.ci, context);
                this.addField(aField.si, aField.ti, aField.ci);
                return this.getComplexColumnFragment(aField, columnName, context);
            }
            // must be a nested object
            default: {
                if (clauseType !== ClauseType.MAPPED_SELECT_CLAUSE) ;
                return defaultCallback();
            }
        }
    }
    applyOperator(operator, rValue) {
        switch (operator) {
            case SqlOperator.EQUALS:
                return ` = ${rValue}`;
            case SqlOperator.GREATER_THAN:
                return ` > ${rValue}`;
            case SqlOperator.GREATER_THAN_OR_EQUALS:
                return ` >= ${rValue}`;
            case SqlOperator.IS_NOT_NULL:
                return ` IS NOT NULL`;
            case SqlOperator.IS_NULL:
                return ` IS NULL`;
            case SqlOperator.IN:
                return ` IN (${rValue})`;
            case SqlOperator.LESS_THAN:
                return ` < ${rValue}`;
            case SqlOperator.LESS_THAN_OR_EQUALS:
                return ` <= ${rValue}`;
            case SqlOperator.NOT_EQUALS:
                return ` != ${rValue}`;
            case SqlOperator.NOT_IN:
                return ` NOT IN (${rValue})`;
            case SqlOperator.LIKE:
                return ` LIKE ${rValue}`;
            default:
                throw new Error(`Unsupported operator ${operator}`);
        }
    }
    getWHEREFragment(operation, nestingPrefix, context) {
        let whereFragment = '';
        if (!operation) {
            throw new Error(`An operation is missing in WHERE or HAVING clause`);
        }
        nestingPrefix = `${nestingPrefix}\t`;
        switch (operation.c) {
            case OperationCategory.LOGICAL:
                return this.getLogicalWhereFragment(operation, nestingPrefix, context);
            case OperationCategory.BOOLEAN:
            case OperationCategory.DATE:
            case OperationCategory.NUMBER:
            case OperationCategory.STRING:
            case OperationCategory.UNTYPED:
                let valueOperation = operation;
                let lValueSql = this.getFieldValue(valueOperation.l, ClauseType.WHERE_CLAUSE, null, context);
                if (valueOperation.o === SqlOperator.IS_NOT_NULL
                    || valueOperation.o === SqlOperator.IS_NULL) {
                    let operator = this.applyOperator(valueOperation.o, null);
                    whereFragment += `${lValueSql}${operator}`;
                }
                else {
                    let rValueSql = this.getFieldValue(valueOperation.r, ClauseType.WHERE_CLAUSE, null, context);
                    let rValueWithOperator = this.applyOperator(valueOperation.o, rValueSql);
                    whereFragment += `${lValueSql}${rValueWithOperator}`;
                }
                break;
            case OperationCategory.FUNCTION:
                let functionOperation = operation;
                whereFragment = this.getFieldValue(functionOperation.ob, ClauseType.WHERE_CLAUSE, null, context);
                // exists function and maybe others
                break;
        }
        return whereFragment;
    }
    getEntityPropertyColumnName(qEntity, columnIndex, context) {
        const dbEntity = this.qMetadataUtils.getDbEntity(qEntity);
        return dbEntity.columns[columnIndex].name;
    }
    addFieldFromColumn(dbColumn) {
        const dbEntity = dbColumn.propertyColumns[0].property.entity;
        this.addField(dbEntity.applicationVersion._localId, dbEntity.index, dbColumn.index);
    }
    addField(applicationIndex, tableIndex, columnIndex) {
        this.fieldMap.ensure(applicationIndex, tableIndex)
            .ensure(columnIndex);
    }
    warn(warning) {
        console.log(warning);
    }
    getSimpleColumnFragment(tableAlias, columnName) {
        return `${tableAlias}.${columnName}`;
    }
    getComplexColumnFragment(value, columnName, context) {
        let selectSqlFragment = `${value.ta}.${columnName}`;
        selectSqlFragment = this.sqlQueryAdapter.getFunctionAdaptor()
            .getFunctionCalls(value, selectSqlFragment, this.qEntityMapByAlias, this, context);
        return selectSqlFragment;
    }
    getEntityManyToOneColumnName(qEntity, columnIndex, context) {
        return this.getEntityPropertyColumnName(qEntity, columnIndex, context);
    }
    getLogicalWhereFragment(operation, nestingPrefix, context) {
        let operator;
        switch (operation.o) {
            case SqlOperator.AND:
                operator = 'AND';
                break;
            case SqlOperator.OR:
                operator = 'OR';
                break;
            case SqlOperator.NOT:
                const whereFragment = this.getWHEREFragment(operation.v, nestingPrefix, context);
                return ` NOT (${whereFragment})`;
            default:
                throw new Error(`Unknown logical operator: ${operation.o}`);
        }
        let childOperations = operation.v;
        if (!(childOperations instanceof Array)) {
            throw new Error(`Expecting an array of child operations as a value for operator ${operator}, 
				in the WHERE Clause.`);
        }
        let whereFragment = childOperations.map((childOperation) => {
            return this.getWHEREFragment(childOperation, nestingPrefix, context);
        })
            .join(`\n${nestingPrefix}${operator} `);
        return `( ${whereFragment} )`;
    }
    isParameterReference(value) {
        if (value === null) {
            return false;
        }
        if (value === undefined || value === '' || Number.isNaN(value)) {
            throw new Error(`Invalid query value: ${value}`);
        }
        switch (typeof value) {
            case 'boolean':
            case 'number':
                throw new Error(`Unexpected primitive instance, expecting parameter alias.`);
            case 'string':
                return true;
        }
        if (value instanceof Date) {
            throw new Error(`Unexpected date instance, expecting parameter alias.`);
        }
        return false;
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
class SQLNoJoinQuery extends SQLWhereBase {
    constructor(dbEntity, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        super(dbEntity, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.relationManager = relationManager;
    }
    getFromFragment(fromRelation, fieldMap, syncAllFields, context, addAs = true) {
        if (!fromRelation) {
            throw new Error(`Expecting exactly one table in UPDATE/DELETE clause`);
        }
        if (fromRelation.ri || fromRelation.jt) {
            throw new Error(`Table in UPDATE/DELETE clause cannot be joined`);
        }
        const firstDbEntity = this.airportDatabase.applications[fromRelation.si]
            .currentVersion[0].applicationVersion.entities[fromRelation.ti];
        const columnMap = fieldMap.ensureEntity(firstDbEntity, syncAllFields);
        let tableName = this.storeDriver.getEntityTableName(firstDbEntity, context);
        if (fromRelation.si !== this.dbEntity.applicationVersion.application.index
            || fromRelation.ti !== this.dbEntity.index) {
            throw new Error(`Unexpected table in UPDATE/DELETE clause: 
			'${tableName}',
			expecting: '${this.dbEntity.applicationVersion.application.name}.${this.dbEntity.name}'`);
        }
        const firstQEntity = new QEntity(firstDbEntity, this.queryUtils, this.relationManager);
        const tableAlias = this.relationManager.getAlias(fromRelation);
        this.qEntityMapByAlias[tableAlias] = firstQEntity;
        let fromFragment = `\t${tableName}`;
        if (addAs) {
            fromFragment += ` AS ${tableAlias}`;
        }
        return {
            columnMap,
            tableFragment: fromFragment
        };
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
class SQLDelete extends SQLNoJoinQuery {
    constructor(jsonDelete, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        super(airportDatabase.applications[jsonDelete.DF.si].currentVersion[0]
            .applicationVersion.entities[jsonDelete.DF.ti], dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.jsonDelete = jsonDelete;
    }
    toSQL(fieldMap, context) {
        let { tableFragment } = this.getFromFragment(this.jsonDelete.DF, fieldMap, true, context);
        let whereFragment = '';
        let jsonQuery = this.jsonDelete;
        if (jsonQuery.W) {
            whereFragment = this.getWHEREFragment(jsonQuery.W, '', context);
            whereFragment = `
WHERE
${whereFragment}`;
            // TODO: following might be needed for some RDBMS, does not work for SqLite
            // Replace the root entity alias reference with the table name
            // let tableAlias = this.relationManager.getAlias(this.jsonDelete.DF)
            // let tableName = this.storeDriver.getEntityTableName(this.qEntityMapByAlias[tableAlias].__driver__.dbEntity, context)
            // whereFragment = whereFragment.replace(new RegExp(`${tableAlias}`, 'g'), tableName)
        }
        return `DELETE
FROM
  ${tableFragment}${whereFragment}`;
    }
}

/**
 * Created by Papa on 11/17/2016.
 */
class SQLInsertValues extends SQLNoJoinQuery {
    constructor(jsonInsertValues, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context
    // repository?: IRepository
    ) {
        super(airportDatabase.applications[jsonInsertValues.II.si].currentVersion[0]
            .applicationVersion.entities[jsonInsertValues.II.ti], dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.jsonInsertValues = jsonInsertValues;
    }
    toSQL(fieldMap, context) {
        if (!this.jsonInsertValues.II) {
            throw new Error(`Expecting exactly one table in INSERT INTO clause`);
        }
        this.qValidator.validateInsertQEntity(this.dbEntity);
        let { columnMap, tableFragment } = this.getFromFragment(this.jsonInsertValues.II, fieldMap, false, context, false);
        let columnsFragment = this.getColumnsFragment(this.dbEntity, this.jsonInsertValues.C, columnMap);
        let valuesFragment = this.getValuesFragment(this.jsonInsertValues.V, context);
        return `INSERT INTO
${tableFragment} ${columnsFragment}
VALUES
${valuesFragment}
`;
    }
    getColumnsFragment(dbEntity, columns, columnMap) {
        if (!columns.length) {
            return '';
        }
        const columnNames = columns.map(columnIndex => {
            columnMap.ensure(columnIndex);
            return dbEntity.columns[columnIndex].name;
        });
        return `( ${columnNames.join(', \n')} )`;
    }
    getValuesFragment(valuesClauseFragment, context) {
        let allValuesFragment = valuesClauseFragment.map((valuesArray) => {
            let valuesFragment = valuesArray.map((value) => {
                if (value === null || ['number', 'string'].indexOf(typeof value) > -1) {
                    this.parameterReferences.push(value);
                    return this.sqlQueryAdapter.getParameterReference(this.parameterReferences, value);
                }
                else if (value === undefined) {
                    throw new Error(`An 'undefined' value was provided when inserting into: ${this.dbEntity.applicationVersion.application.name}.${this.dbEntity.name}`);
                }
                else {
                    const fieldValue = this.getFieldValue(value, ClauseType.WHERE_CLAUSE, null, context);
                    return `\n${fieldValue}\n`;
                }
            });
            return `(${valuesFragment.join(',')})`;
        });
        return allValuesFragment.join(',\n');
    }
}

/**
 * Created by Papa on 8/20/2016.
 */
var SQLDialect;
(function (SQLDialect) {
    SQLDialect["MYSQL"] = "MYSQL";
    SQLDialect["POSTGRESQL"] = "POSTGRESQL";
    SQLDialect["SQLITE"] = "SQLITE";
})(SQLDialect || (SQLDialect = {}));
class EntityDefaults {
    constructor() {
        this.map = {};
    }
    getForAlias(alias) {
        let defaultsForAlias = this.map[alias];
        if (!defaultsForAlias) {
            defaultsForAlias = {};
            this.map[alias] = defaultsForAlias;
        }
        return defaultsForAlias;
    }
}
/**
 * String based SQL query.
 */
class SQLQuery extends SQLWhereBase {
    constructor(jsonQuery, dbEntity, dialect, queryResultType, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        super(dbEntity, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.jsonQuery = jsonQuery;
        this.queryResultType = queryResultType;
        this.relationManager = relationManager;
        this.entityDefaults = new EntityDefaults();
        this.inputRepositoryIds = new Set();
        this.resultsRepositoryIds = new Set();
    }
    getFieldMap() {
        return this.fieldMap;
    }
    getInputRepositoryIds() {
        return this.inputRepositoryIds;
    }
    getResultsRepositoryIds() {
        return this.resultsRepositoryIds;
    }
    getEntityApplicationRelationFromJoin(leftQEntity, rightQEntity, entityRelation, parentRelation, currentAlias, parentAlias, joinTypeString, errorPrefix, context) {
        const allJoinOnColumns = [];
        const leftDbEntity = leftQEntity.__driver__.dbEntity;
        const rightDbEntity = rightQEntity.__driver__.dbEntity;
        const dbRelation = leftDbEntity.relations[entityRelation.ri];
        let relationColumns;
        switch (dbRelation.relationType) {
            case EntityRelationType.MANY_TO_ONE:
                relationColumns = dbRelation.manyRelationColumns;
                break;
            case EntityRelationType.ONE_TO_MANY:
                if (dbRelation.oneRelationColumns && dbRelation.oneRelationColumns.length) {
                    relationColumns = dbRelation.oneRelationColumns;
                }
                else {
                    const matchingRelations = dbRelation.relationEntity.relations.filter(manySideRelation => manySideRelation.relationEntity._localId == leftDbEntity._localId
                        && manySideRelation.manyToOneElems
                        && manySideRelation.manyToOneElems !== true
                        && manySideRelation.manyToOneElems.mappedBy === dbRelation.property.name);
                    if (matchingRelations.length) {
                        relationColumns = matchingRelations[0].manyRelationColumns;
                    }
                }
                break;
            default:
                throw new Error(`Unknown relation type ${dbRelation.relationType} 
on '${leftDbEntity.applicationVersion.application.name}.${leftDbEntity.name}.${dbRelation.property.name}'.`);
        }
        for (const relationColumn of relationColumns) {
            let ownColumnName;
            let referencedColumnName;
            switch (dbRelation.relationType) {
                case EntityRelationType.MANY_TO_ONE:
                    ownColumnName = relationColumn.manyColumn.name;
                    referencedColumnName = relationColumn.oneColumn.name;
                    break;
                case EntityRelationType.ONE_TO_MANY:
                    ownColumnName = relationColumn.oneColumn.name;
                    referencedColumnName = relationColumn.manyColumn.name;
                    break;
                default:
                    throw new Error(`Unknown relation type ${dbRelation.relationType} 
on '${leftDbEntity.applicationVersion.application.name}.${leftDbEntity.name}.${dbRelation.property.name}'.`);
            }
            allJoinOnColumns.push({
                leftColumn: ownColumnName,
                rightColumn: referencedColumnName
            });
        }
        let onClause = allJoinOnColumns.map(joinOnColumn => ` ${parentAlias}.${joinOnColumn.leftColumn} = ${currentAlias}.${joinOnColumn.rightColumn}`)
            .join('\n\t\t\tAND');
        if (entityRelation.joinWhereClause) {
            const whereClause = this.getWHEREFragment(entityRelation.joinWhereClause, '\t\t', context);
            const joinWhereOperator = entityRelation.joinWhereClauseOperator === SqlOperator.AND ? 'AND' : 'OR';
            onClause = `${onClause}
			${joinWhereOperator} ${whereClause}`;
        }
        const tableName = this.storeDriver.getEntityTableName(rightDbEntity, context);
        const fromFragment = `\n\t${joinTypeString} ${tableName} ${currentAlias}\n\t\tON ${onClause}`;
        return fromFragment;
    }
}

/**
 * Created by Papa on 10/2/2016.
 */
class SQLUpdate extends SQLNoJoinQuery {
    constructor(jsonUpdate, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context) {
        super(airportDatabase.applications[jsonUpdate.U.si].currentVersion[0]
            .applicationVersion.entities[jsonUpdate.U.ti], dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.jsonUpdate = jsonUpdate;
    }
    toSQL(internalFragments, fieldMap, context) {
        if (!this.jsonUpdate.U) {
            throw new Error(`Expecting exactly one table in UPDATE clause`);
        }
        let { columnMap, tableFragment } = this.getFromFragment(this.jsonUpdate.U, fieldMap, false, context);
        let setFragment = this.getSetFragment(this.jsonUpdate.S, columnMap, context);
        if (internalFragments.SET && internalFragments.SET.length) {
            setFragment += ',' + internalFragments.SET.map(internalSetFragment => {
                columnMap.ensure(internalSetFragment.column.index);
                return `
	${internalSetFragment.column.name} = ${internalSetFragment.value}`;
            })
                .join(',');
        }
        let whereFragment = '';
        let jsonQuery = this.jsonUpdate;
        if (jsonQuery.W) {
            whereFragment = this.getWHEREFragment(jsonQuery.W, '', context);
            whereFragment = `WHERE
${whereFragment}`;
            // TODO: following might be needed for some RDBMS, does not work for SqLite
            // Replace the root entity alias reference with the table name
            // let tableAlias = this.relationManager.getAlias(this.jsonUpdate.U)
            // let tableName  = this.storeDriver.getEntityTableName(this.qEntityMapByAlias[tableAlias].__driver__.dbEntity, context)
            // whereFragment  = whereFragment.replace(new RegExp(`${tableAlias}`, 'g'), tableName)
        }
        return `UPDATE
${tableFragment}
SET
${setFragment}
${whereFragment}`;
    }
    getSetFragment(setClauseFragment, columnMap, context) {
        let setFragments = [];
        for (let columnName in setClauseFragment) {
            let value = setClauseFragment[columnName];
            // Skip undefined values
            if (value === undefined) {
                continue;
            }
            const updatedDbColumn = this.dbEntity.columnMap[columnName];
            this.qValidator.validateUpdateColumn(updatedDbColumn);
            this.addSetFragment(columnName, value, setFragments, context);
            columnMap.ensure(updatedDbColumn.index);
        }
        return setFragments.join(', \n');
    }
    addSetFragment(columnName, value, setFragments, context) {
        let fieldValue;
        if (typeof value === 'number') {
            this.parameterReferences.push(value);
            fieldValue = this.sqlQueryAdapter.getParameterReference(this.parameterReferences, value);
        }
        else {
            fieldValue = this.getFieldValue(value, ClauseType.WHERE_CLAUSE, null, context);
        }
        setFragments.push(`\t${columnName} = ${fieldValue}`);
    }
    isManyToOneRelation(value) {
        return typeof value === 'object'
            && value.ot === JSONClauseObjectType.MANY_TO_ONE_RELATION;
    }
    addManyToOneMappings(parentMapping) {
        let mappings = [];
        const value = parentMapping.value;
        if (typeof value === 'object' &&
            (!value.ot
                || value.ot === JSONClauseObjectType.MANY_TO_ONE_RELATION)) {
            for (const key in value) {
                if (key === 'ot'
                    && value[key] === JSONClauseObjectType.MANY_TO_ONE_RELATION) {
                    continue;
                }
                const mapping = {
                    tableIndex: parentMapping.tableIndex,
                    propertyChain: parentMapping.propertyChain.concat([key]),
                    value: value[key]
                };
                const childMappings = this.addManyToOneMappings(mapping);
                mappings = mappings.concat(childMappings);
            }
        }
        else {
            mappings.push(parentMapping);
        }
        return mappings;
    }
}

class SqlFunctionField {
    constructor(jsonClauseField) {
        this.jsonClauseField = jsonClauseField;
        // Test
    }
    getValue(sqlValueProvider, context) {
        return sqlValueProvider.getFieldFunctionValue(this.jsonClauseField, null, context);
    }
}

/**
 * Created by Papa on 10/28/2016.
 */
class NonEntitySQLQuery extends SQLQuery {
    constructor(jsonQuery, dialect, queryResultType, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context) {
        super(jsonQuery, null, dialect, queryResultType, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context);
    }
    addQEntityMapByAlias(sourceMap) {
        for (let alias in sourceMap) {
            this.qEntityMapByAlias[alias] = sourceMap[alias];
        }
    }
    toSQL(internalFragments, context) {
        let jsonQuery = this.jsonQuery;
        let joinNodeMap = {};
        this.joinTrees = this.buildFromJoinTree(jsonQuery.F, joinNodeMap, context);
        let selectFragment = this.getSELECTFragment(false, jsonQuery.S, internalFragments, context);
        let fromFragment = this.getFROMFragments(this.joinTrees, context);
        let whereFragment = '';
        if (jsonQuery.W) {
            whereFragment = `
WHERE
	${this.getWHEREFragment(jsonQuery.W, '', context)}`;
        }
        let groupByFragment = '';
        if (jsonQuery.GB && jsonQuery.GB.length) {
            groupByFragment = `
GROUP BY
	${this.getGroupByFragment(jsonQuery.GB)}`;
        }
        let havingFragment = '';
        if (jsonQuery.H) {
            havingFragment = `
HAVING
	${this.getWHEREFragment(jsonQuery.H, '', context)}`;
        }
        let orderByFragment = '';
        if (jsonQuery.OB && jsonQuery.OB.length) {
            orderByFragment = `
ORDER BY
	${this.orderByParser.getOrderByFragment(jsonQuery.S, jsonQuery.OB)}`;
        }
        let offsetFragment = '';
        if (jsonQuery.O) {
            offsetFragment = this.sqlQueryAdapter.getOffsetFragment(jsonQuery.O);
        }
        let limitFragment = '';
        if (jsonQuery.L) {
            offsetFragment = this.sqlQueryAdapter.getLimitFragment(jsonQuery.L);
        }
        return `SELECT
	${selectFragment}
FROM
${fromFragment}${whereFragment}${groupByFragment}${havingFragment}${orderByFragment}${offsetFragment}${limitFragment}
${this.storeDriver.getSelectQuerySuffix(this.jsonQuery, context)}`;
    }
    buildFromJoinTree(joinRelations, joinNodeMap, context) {
        let jsonTrees = [];
        let jsonTree;
        // For entity queries it is possible to have a query with no from clause, in this case
        // make the query entity the root tree node
        if (joinRelations.length < 1) {
            throw new Error(`FROM clause must have entries for non-Entity queries`);
        }
        let firstRelation = joinRelations[0];
        switch (firstRelation.rt) {
            case JSONRelationType.SUB_QUERY_ROOT:
            case JSONRelationType.ENTITY_ROOT:
                break;
            default:
                throw new Error(`First table in FROM clause cannot be joined`);
        }
        let alias = this.relationManager.getAlias(firstRelation);
        this.qValidator.validateReadFromEntity(firstRelation);
        let firstEntity = this.relationManager.createRelatedQEntity(firstRelation, context);
        this.qEntityMapByAlias[alias] = firstEntity;
        jsonTree = new JoinTreeNode(firstRelation, [], null);
        jsonTrees.push(jsonTree);
        joinNodeMap[alias] = jsonTree;
        for (let i = 1; i < joinRelations.length; i++) {
            let rightEntity;
            let joinRelation = joinRelations[i];
            if (!joinRelation.jt) {
                throw new Error(`Table ${i + 1} in FROM clause is missing joinType`);
            }
            this.qValidator.validateReadFromEntity(joinRelation);
            alias = this.relationManager.getAlias(joinRelation);
            switch (joinRelation.rt) {
                case JSONRelationType.SUB_QUERY_ROOT:
                    let view = this.addFieldsToView(joinRelation, alias, context);
                    this.qEntityMapByAlias[alias] = view;
                    continue;
                case JSONRelationType.ENTITY_ROOT:
                    // Non-Joined table
                    let nonJoinedEntity = this.relationManager.createRelatedQEntity(joinRelation, context);
                    this.qEntityMapByAlias[alias] = nonJoinedEntity;
                    let anotherTree = new JoinTreeNode(joinRelation, [], null);
                    if (joinNodeMap[alias]) {
                        throw new Error(`Alias '${alias}' used more than once in the FROM clause.`);
                    }
                    jsonTrees.push(anotherTree);
                    joinNodeMap[alias] = anotherTree;
                    continue;
                case JSONRelationType.ENTITY_APPLICATION_RELATION:
                    if (!joinRelation.ri) {
                        throw new Error(`Table ${i + 1} in FROM clause is missing relationPropertyName`);
                    }
                    rightEntity = this.relationManager.createRelatedQEntity(joinRelation, context);
                    break;
                case JSONRelationType.SUB_QUERY_JOIN_ON:
                    if (!joinRelation.joinWhereClause) {
                        this.warn(`View ${i + 1} in FROM clause is missing joinWhereClause`);
                    }
                    rightEntity = this.addFieldsToView(joinRelation, alias, context);
                    break;
                case JSONRelationType.ENTITY_JOIN_ON:
                    if (!joinRelation.joinWhereClause) {
                        this.warn(`Table ${i + 1} in FROM clause is missing joinWhereClause`);
                    }
                    rightEntity = this.relationManager.createRelatedQEntity(joinRelation, context);
                    break;
                default:
                    throw new Error(`Unknown JSONRelationType ${joinRelation.rt}`);
            }
            let parentAlias = this.relationManager.getParentAlias(joinRelation);
            if (!joinNodeMap[parentAlias]) {
                throw new Error(`Missing parent entity for alias ${parentAlias}, on table ${i + 1} in FROM clause. 
					NOTE: sub-queries in FROM clause cannot reference parent FROM tables.`);
            }
            let leftNode = joinNodeMap[parentAlias];
            let rightNode = new JoinTreeNode(joinRelation, [], leftNode);
            leftNode.addChildNode(rightNode);
            this.qValidator.validateReadFromEntity(joinRelation);
            this.qEntityMapByAlias[alias] = rightEntity;
            if (!rightEntity) {
                throw new Error(`Could not find entity ${joinRelation.ti} for table ${i + 1} in FROM clause`);
            }
            if (joinNodeMap[alias]) {
                throw new Error(`Alias '${alias}' used more than once in the FROM clause.`);
            }
            joinNodeMap[alias] = rightNode;
        }
        return jsonTrees;
    }
    addFieldsToView(viewJoinRelation, viewAlias, context) {
        let view = new QTree(viewJoinRelation.fromClausePosition, null);
        this.addFieldsToViewForSelect(view, viewAlias, viewJoinRelation.subQuery.S, 'f', null, context);
        return view;
    }
    /**
     * Just build the shell fields for the external API of the view, don't do anything else.
     * @param view
     * @param select
     * @param fieldPrefix
     */
    addFieldsToViewForSelect(view, viewAlias, select, fieldPrefix, forFieldQueryAlias, context) {
        let fieldIndex = 0;
        let hasDistinctClause = false;
        for (let fieldName in select) {
            let alias = `${fieldPrefix}${++fieldIndex}`;
            let fieldJson = select[fieldName];
            // If its a nested SELECT
            if (!fieldJson.ot) {
                this.addFieldsToViewForSelect(view, viewAlias, fieldJson, `${alias}_`, null, context);
            }
            else {
                let aliasToSet = forFieldQueryAlias ? forFieldQueryAlias : alias;
                hasDistinctClause = hasDistinctClause && this.addFieldToViewForSelect(view, viewAlias, fieldPrefix, fieldJson, aliasToSet, forFieldQueryAlias, context);
            }
        }
        if (fieldIndex > 1) {
            if (hasDistinctClause) {
                throw new Error(`DISTINCT clause must be the only property at its level`);
            }
            if (forFieldQueryAlias) {
                throw new Error(`Field queries can have only one field in SELECT clause`);
            }
        }
    }
    addFieldToViewForSelect(view, viewAlias, fieldPrefix, fieldJson, alias, forFieldQueryAlias = null, context) {
        let hasDistinctClause = false;
        let dbEntity;
        let dbProperty;
        let dbColumn;
        switch (fieldJson.ot) {
            case JSONClauseObjectType.FIELD_FUNCTION:
                view[alias] = new SqlFunctionField(fieldJson);
                throw new Error('Not implemented');
            case JSONClauseObjectType.EXISTS_FUNCTION:
                throw new Error(`Exists function cannot be used in SELECT clause.`);
            case JSONClauseObjectType.FIELD:
                dbEntity = this.airportDatabase.applications[fieldJson.si].currentVersion[0]
                    .applicationVersion.entities[fieldJson.ti];
                dbProperty = dbEntity.properties[fieldJson.pi];
                dbColumn = dbEntity.columns[fieldJson.ci];
                switch (fieldJson.dt) {
                    case SQLDataType.BOOLEAN:
                        view[alias] = new QBooleanField(dbColumn, dbProperty, view);
                        break;
                    case SQLDataType.DATE:
                        view[alias] = new QDateField(dbColumn, dbProperty, view);
                        break;
                    case SQLDataType.NUMBER:
                        view[alias] = new QNumberField(dbColumn, dbProperty, view);
                        break;
                    case SQLDataType.STRING:
                        view[alias] = new QStringField(dbColumn, dbProperty, view);
                        break;
                    // case SQLDataType.ANY:
                    // 	view[alias] = new QUntypedField(dbColumn, dbProperty,
                    // 		view as IQEntityInternal<any>)
                    // 	break
                    default:
                        throw new Error(`Unknown SQLDataType: ${fieldJson.dt}.`);
                }
                break;
            case JSONClauseObjectType.FIELD_QUERY:
                let fieldQuery = fieldJson;
                this.addFieldToViewForSelect(view, viewAlias, fieldPrefix, fieldQuery.S, alias, alias, context);
                break;
            case JSONClauseObjectType.DISTINCT_FUNCTION:
                this.addFieldsToViewForSelect(view, viewAlias, fieldJson.v, fieldPrefix, forFieldQueryAlias, context);
                hasDistinctClause = true;
                break;
            case JSONClauseObjectType.MANY_TO_ONE_RELATION:
                throw new Error(`@ManyToOne fields cannot be directly in a SELECT clause.
					Please select a non-relational field within the relation.`);
            // let relation =
            // <QField<any>><any>QMetadataUtils.getRelationByColumnIndex(this.dbFacade.getQEntityByIndex(fieldJson.ti),
            // fieldJson.ci); view[alias] = relation.getInstance(view); break;
            default:
                throw new Error(`Unexpected type property on JSONClauseField: ${fieldJson.ot}.`);
        }
        return hasDistinctClause;
    }
    getFieldSelectFragment(value, clauseType, nestedObjectCallBack, fieldIndex, context) {
        let columnSelectSqlFragment = this.getFieldValue(value, clauseType, 
        // Nested object processing
        nestedObjectCallBack, context);
        if (value.fa !== undefined) {
            columnSelectSqlFragment += ` as ${value.fa}`;
        }
        if (fieldIndex === 0) {
            return `\n\t${columnSelectSqlFragment}`;
        }
        else {
            return `,\n\t${columnSelectSqlFragment}`;
        }
    }
    getFROMFragments(joinTrees, context) {
        return joinTrees.map(joinTree => this.getFROMFragment(null, joinTree, context))
            .join('\n');
    }
    getFROMFragment(parentTree, currentTree, context) {
        let fromFragment = '\t';
        let currentRelation = currentTree.jsonRelation;
        let currentAlias = this.relationManager.getAlias(currentRelation);
        let qEntity = this.qEntityMapByAlias[currentAlias];
        if (!parentTree) {
            switch (currentRelation.rt) {
                case JSONRelationType.ENTITY_ROOT:
                    fromFragment += `${this.storeDriver.getEntityTableName(qEntity.__driver__.dbEntity, context)} ${currentAlias}`;
                    break;
                case JSONRelationType.SUB_QUERY_ROOT:
                    let viewRelation = currentRelation;
                    const { parameterReferences, subQuerySql } = this.subStatementSqlGenerator.getTreeQuerySql(viewRelation.subQuery, this.dialect, context);
                    if (parameterReferences.length) {
                        this.parameterReferences = this.parameterReferences.concat(parameterReferences);
                    }
                    fromFragment += `(${subQuerySql}) ${currentAlias}`;
                    break;
                default:
                    throw new Error(`Top level FROM entries must be Entity or Sub-Query root`);
            }
        }
        else {
            let parentRelation = parentTree.jsonRelation;
            let parentAlias = this.relationManager.getAlias(parentRelation);
            let leftEntity = this.qEntityMapByAlias[parentAlias];
            let rightEntity = this.qEntityMapByAlias[currentAlias];
            let joinTypeString;
            switch (currentRelation.jt) {
                case JoinType.FULL_JOIN:
                    joinTypeString = 'FULL JOIN';
                    break;
                case JoinType.INNER_JOIN:
                    joinTypeString = 'INNER JOIN';
                    break;
                case JoinType.LEFT_JOIN:
                    joinTypeString = 'LEFT JOIN';
                    break;
                case JoinType.RIGHT_JOIN:
                    joinTypeString = 'RIGHT JOIN';
                default:
                    throw new Error(`Unsupported join type: ${currentRelation.jt}`);
            }
            let errorPrefix = 'Error building FROM: ';
            let joinOnClause;
            switch (currentRelation.rt) {
                case JSONRelationType.ENTITY_JOIN_ON:
                    let joinRelation = currentRelation;
                    joinOnClause = this.getWHEREFragment(joinRelation.joinWhereClause, '\t', context);
                    fromFragment += `\t${joinTypeString} ${this.storeDriver.getEntityTableName(qEntity.__driver__.dbEntity, context)} ${currentAlias} ON\n${joinOnClause}`;
                    break;
                case JSONRelationType.ENTITY_APPLICATION_RELATION:
                    fromFragment += this.getEntityApplicationRelationFromJoin(leftEntity, rightEntity, currentRelation, parentRelation, currentAlias, parentAlias, joinTypeString, errorPrefix, context);
                    break;
                case JSONRelationType.SUB_QUERY_JOIN_ON:
                    let viewJoinRelation = currentRelation;
                    const { parameterReferences, subQuerySql } = this.subStatementSqlGenerator.getTreeQuerySql(viewJoinRelation.subQuery, this.dialect, context);
                    if (parameterReferences.length) {
                        this.parameterReferences = this.parameterReferences.concat(parameterReferences);
                    }
                    joinOnClause = this.getWHEREFragment(viewJoinRelation.joinWhereClause, '\t', context);
                    fromFragment += `${joinTypeString} (${subQuerySql}) ${currentAlias} ON\n${joinOnClause}`;
                    break;
                default:
                    throw new Error(`Nested FROM entries must be Entity JOIN ON
					or Application Relation, or Sub-Query JOIN ON`);
            }
        }
        for (let i = 0; i < currentTree.childNodes.length; i++) {
            let childTreeNode = currentTree.childNodes[i];
            fromFragment += this.getFROMFragment(currentTree, childTreeNode, context);
        }
        return fromFragment;
    }
    getGroupByFragment(groupBy) {
        return groupBy.map((groupByField) => {
            this.qValidator.validateAliasedFieldAccess(groupByField.fa);
            return `${groupByField.fa}`;
        })
            .join(', ');
    }
    getOrderByFragment(orderBy) {
        return orderBy.map((orderByField) => {
            this.qValidator.validateAliasedFieldAccess(orderByField.fa);
            switch (orderByField.so) {
                case SortOrder.ASCENDING:
                    return `${orderByField.fa} ASC`;
                case SortOrder.DESCENDING:
                    return `${orderByField.fa} DESC`;
            }
        })
            .join(', ');
    }
}

/**
 * Created by Papa on 10/29/2016.
 */
class FieldSQLQuery extends NonEntitySQLQuery {
    constructor(jsonQuery, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context) {
        super(jsonQuery, dialect, QueryResultType.FIELD, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context);
        this.orderByParser = new ExactOrderByParser(qValidator);
    }
    async parseQueryResults(results, internalFragments, queryResultType, context, bridgedQueryConfiguration) {
        let parsedResults = [];
        if (!results || !results.length) {
            return parsedResults;
        }
        parsedResults = [];
        results.forEach((result) => {
            let parsedResult = this.parseQueryResult(this.jsonQuery.S, result, [0]);
            parsedResults.push(parsedResult);
        });
        return parsedResults;
    }
    getSELECTFragment(nested, selectClauseFragment, internalFragments, context) {
        if (!selectClauseFragment) {
            throw new Error(`SELECT clause is not defined for a Field Query`);
        }
        {
            let distinctClause = selectClauseFragment;
            if (distinctClause.ot == JSONClauseObjectType.DISTINCT_FUNCTION) {
                let distinctSelect = this.getSELECTFragment(nested, distinctClause.appliedFunctions[0].p[0], internalFragments, context);
                return `DISTINCT ${distinctSelect}`;
            }
        }
        let field = selectClauseFragment;
        let fieldIndex = 0;
        let selectSqlFragment = this.getFieldSelectFragment(field, ClauseType.NON_MAPPED_SELECT_CLAUSE, null, fieldIndex++, context);
        return selectSqlFragment;
    }
    parseQueryResult(selectClauseFragment, resultRow, nextFieldIndex) {
        let field = selectClauseFragment;
        let propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, field.fa, nextFieldIndex[0], field.dt, null);
        nextFieldIndex[0]++;
        return propertyValue;
    }
}

/**
 * Created by Papa on 10/28/2016.
 */
class TreeSQLQuery extends NonEntitySQLQuery {
    constructor(jsonQuery, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context) {
        super(jsonQuery, dialect, QueryResultType.TREE, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context);
        this.queryParser = new TreeQueryResultParser(applicationUtils, entityStateManager, utils);
        this.orderByParser = new MappedOrderByParser(qValidator);
    }
    /**
     * Entities get merged if they are right next to each other in the result set.  If they
     * are not, they are treated as separate entities - hence, your sort order matters.
     *
     * @param results
     * @returns {any[]}
     */
    async parseQueryResults(results, internalFragments, queryResultType, context, bridgedQueryConfiguration) {
        let parsedResults = [];
        if (!results || !results.length) {
            return parsedResults;
        }
        parsedResults = [];
        results.forEach((result) => {
            let aliasCache = new AliasCache();
            let parsedResult = this.parseQueryResult(this.jsonQuery.S, result, [0], aliasCache, aliasCache.getFollowingAlias());
            {
                parsedResults.push(parsedResult);
            }
            this.queryParser.flushRow();
        });
        return parsedResults;
    }
    getSELECTFragment(nested, selectClauseFragment, internalFragments, context) {
        const distinctClause = selectClauseFragment;
        if (distinctClause.ot == JSONClauseObjectType.DISTINCT_FUNCTION) {
            if (nested) {
                throw new Error(`Cannot have DISTINCT specified in a nested SELECT clause`);
            }
            const distinctSelect = this.getSELECTFragment(nested, distinctClause.appliedFunctions[0].p[0], internalFragments, context);
            return `DISTINCT ${distinctSelect}`;
        }
        let numProperties = 0;
        for (let propertyName in selectClauseFragment) {
            if (propertyName === '*') {
                throw new Error(`'*' operator isn't yet implemented in mapped queries`);
            }
            if (propertyName === 'id') {
                throw new Error(`'id' operator isn't yet implemented in mapped queries`);
            }
            numProperties++;
        }
        if (numProperties === 0) {
            if (nested) {
                throw new Error(`Mapped query must have fields in a nested-SELECT clause`);
            }
            else {
                return '*';
            }
        }
        let fieldIndex = 0;
        let selectSqlFragment = '';
        for (let propertyName in selectClauseFragment) {
            const value = selectClauseFragment[propertyName];
            // Skip undefined values
            if (value === undefined) {
                continue;
            }
            if (value instanceof SqlFunctionField) {
                selectSqlFragment += value.getValue(this, context);
                continue;
            }
            selectSqlFragment += this.getFieldSelectFragment(value, ClauseType.MAPPED_SELECT_CLAUSE, () => {
                return this.getSELECTFragment(true, value, internalFragments, context);
            }, fieldIndex++, context);
        }
        return selectSqlFragment;
    }
    parseQueryResult(selectClauseFragment, resultRow, nextFieldIndex, aliasCache, entityAlias) {
        // Return blanks, primitives and Dates directly
        if (!resultRow || !(resultRow instanceof Object) || resultRow instanceof Date) {
            return resultRow;
        }
        {
            let distinctClause = selectClauseFragment;
            if (distinctClause.ot == JSONClauseObjectType.DISTINCT_FUNCTION) {
                return this.parseQueryResult(distinctClause.appliedFunctions[0].p[0], resultRow, nextFieldIndex, aliasCache, entityAlias);
            }
        }
        let resultObject = this.queryParser.addEntity(entityAlias);
        for (let propertyName in selectClauseFragment) {
            if (selectClauseFragment[propertyName] === undefined) {
                continue;
            }
            let jsonClauseField = selectClauseFragment[propertyName];
            let dataType = jsonClauseField.dt;
            // Must be a sub-query
            if (!dataType) {
                let childResultObject = this.parseQueryResult(jsonClauseField, resultRow, nextFieldIndex, aliasCache, aliasCache.getFollowingAlias());
                this.queryParser.bufferOneToManyCollection(entityAlias, resultObject, propertyName, childResultObject);
            }
            else {
                let propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, jsonClauseField.fa, nextFieldIndex[0], dataType, null);
                this.queryParser.addProperty(entityAlias, resultObject, dataType, propertyName, propertyValue);
            }
            nextFieldIndex[0]++;
        }
        return this.queryParser.flushEntity(entityAlias, resultObject);
    }
}

class SubStatementSqlGenerator {
    getTreeQuerySql(jsonTreeQuery, dialect, context) {
        let mappedSqlQuery = new TreeSQLQuery(jsonTreeQuery, dialect, this.airportDatabase, this.applicationUtils, this.queryUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this.storeDriver, this, this.utils, context);
        const subQuerySql = mappedSqlQuery.toSQL({}, context);
        const parameterReferences = mappedSqlQuery.parameterReferences;
        return {
            parameterReferences,
            subQuerySql
        };
    }
    getFieldQuerySql(jsonFieldSqlSubQuery, dialect, qEntityMapByAlias, context) {
        let fieldSqlQuery = new FieldSQLQuery(jsonFieldSqlSubQuery, dialect, this.airportDatabase, this.applicationUtils, this.queryUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this.storeDriver, this, this.utils, context);
        fieldSqlQuery.addQEntityMapByAlias(qEntityMapByAlias);
        const subQuerySql = fieldSqlQuery.toSQL({}, context);
        const parameterReferences = fieldSqlQuery.parameterReferences;
        return {
            parameterReferences,
            subQuerySql
        };
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * Represents SQL String query with Entity tree Select clause.
 */
class EntitySQLQuery extends SQLQuery {
    constructor(jsonQuery, dbEntity, dialect, queryResultType, airportDatabase, applicationUtils, queryUtils, entityStateManager, objectResultParserFactory, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context, graphQueryConfiguration) {
        super(jsonQuery, dbEntity, dialect, queryResultType, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementSqlGenerator, utils, context);
        this.objectResultParserFactory = objectResultParserFactory;
        this.graphQueryConfiguration = graphQueryConfiguration;
        this.columnAliases = new AliasCache();
        if (graphQueryConfiguration && this.graphQueryConfiguration.strict !== undefined) {
            throw new Error(`"strict" configuration is not yet implemented for 
			QueryResultType.ENTITY_GRAPH`);
        }
        this.finalSelectTree = this.setupSelectFields(this.jsonQuery.S, dbEntity, context);
        this.orderByParser = new EntityOrderByParser(this.finalSelectTree, airportDatabase, qValidator, relationManager, jsonQuery.OB);
    }
    toSQL(internalFragments, context) {
        let joinNodeMap = {};
        this.joinTree = this.buildFromJoinTree(this.jsonQuery.F, joinNodeMap, context);
        let selectFragment = this.getSELECTFragment(this.dbEntity, this.finalSelectTree, this.joinTree, context);
        let fromFragment = this.getFROMFragment(null, this.joinTree, context);
        let whereFragment = '';
        let jsonQuery = this.jsonQuery;
        if (jsonQuery.W) {
            whereFragment = `
WHERE
${this.getWHEREFragment(jsonQuery.W, '', context)}`;
        }
        let orderByFragment = '';
        if (jsonQuery.OB && jsonQuery.OB.length) {
            orderByFragment = `
ORDER BY
${this.orderByParser.getOrderByFragment(this.joinTree, this.qEntityMapByAlias, context)}`;
        }
        return `SELECT
	${selectFragment}
FROM
${fromFragment}${whereFragment}${orderByFragment}
${this.storeDriver.getSelectQuerySuffix(this.jsonQuery, context)}`;
    }
    /**
     * If bridging is not applied:
     *
     * Entities get merged if they are right next to each other in the result set.  If they
     * are not, they are treated as separate entities - hence, your sort order matters.
     *
     * If bridging is applied - all entities get merged - your sort order does not matter.
     * Might as well disallow sort order for bridged queries (or re-sort in memory)?
     *
     * @param results
     * @returns {any[]}
     */
    async parseQueryResults(results, internalFragments, queryResultType, context, bridgedQueryConfiguration) {
        this.queryParser = this.objectResultParserFactory.getObjectResultParser(this.queryResultType, this.graphQueryConfiguration, this.dbEntity);
        let parsedResults = [];
        if (!results || !results.length) {
            return parsedResults;
        }
        parsedResults = [];
        let lastResult;
        for (let i = 0; i < results.length; i++) {
            let result = results[i];
            let entityAlias = this.relationManager.getAlias(this.joinTree.jsonRelation);
            this.columnAliases.reset();
            let parsedResult = this.parseQueryResult(this.finalSelectTree, entityAlias, this.joinTree, result, [0], context);
            if (!lastResult) {
                parsedResults.push(parsedResult);
            }
            else if (lastResult !== parsedResult) {
                parsedResults.push(parsedResult);
            }
            lastResult = parsedResult;
            this.queryParser.flushRow();
        }
        return this.queryParser.bridge(parsedResults, this.jsonQuery.S, context);
    }
    buildFromJoinTree(joinRelations, joinNodeMap, context) {
        let jsonTree;
        // For entity queries it is possible to have a query with no from clause, in this case
        // make the query entity the root tree node
        if (joinRelations.length < 1) {
            let onlyJsonRelation = {
                currentChildIndex: 0,
                ti: this.dbEntity.index,
                fromClausePosition: [],
                jt: null,
                ri: null,
                rt: JSONRelationType.ENTITY_ROOT,
                rep: 'r_',
                si: this.dbEntity.applicationVersion._localId
            };
            joinRelations.push(onlyJsonRelation);
        }
        let firstRelation = joinRelations[0];
        switch (firstRelation.rt) {
            case JSONRelationType.ENTITY_ROOT:
                break;
            case JSONRelationType.SUB_QUERY_ROOT:
            case JSONRelationType.SUB_QUERY_JOIN_ON:
                throw new Error(`Entity query's FROM clause cannot contain sub-queries`);
            case JSONRelationType.ENTITY_JOIN_ON:
                throw new Error(`Entity queries cannot use JOIN ON`);
            default:
                throw new Error(`First table in FROM clause cannot be result of a join`);
        }
        // if (firstRelation.rt !== JSONRelationType.ENTITY_ROOT) {
        // 	throw new Error(`First table in FROM clause cannot be joined`)
        // }
        let alias = this.relationManager.getAlias(firstRelation);
        let firstEntity = this.relationManager.createRelatedQEntity(firstRelation, context);
        this.qEntityMapByAlias[alias] = firstEntity;
        this.jsonRelationMapByAlias[alias] = firstRelation;
        // In entity queries the first entity must always be the same as the query entity
        const firstDbEntity = firstEntity.__driver__.dbEntity;
        // if (firstEntity.constructor != this.rootQEntity.constructor) {
        if (firstDbEntity.applicationVersion.application.index !== this.dbEntity.applicationVersion.application.index || firstDbEntity.index !== this.dbEntity.index) {
            throw new Error(`ERROR: Unexpected first table in FROM clause: 
			'${firstDbEntity.applicationVersion.application.name}.${firstDbEntity.name}',
			expecting:
			'${this.dbEntity.applicationVersion.application.name}.${this.dbEntity.name}'`);
        }
        jsonTree = new JoinTreeNode(firstRelation, [], null);
        joinNodeMap[alias] = jsonTree;
        for (let i = 1; i < joinRelations.length; i++) {
            let joinRelation = joinRelations[i];
            switch (joinRelation.rt) {
                case JSONRelationType.ENTITY_ROOT:
                    throw new Error(`All Entity query tables after the first must be joined`);
                case JSONRelationType.SUB_QUERY_JOIN_ON:
                    throw new Error(`Entity queries FROM clause cannot contain sub-queries`);
                case JSONRelationType.ENTITY_JOIN_ON:
                    throw new Error(`Entity queries cannot use JOIN ON`);
            }
            if (!joinRelation.ri && joinRelation.ri !== 0) {
                throw new Error(`Table ${i + 1} in FROM clause is missing 
				relationPropertyName`);
            }
            let parentAlias = this.relationManager.getParentAlias(joinRelation);
            if (!joinNodeMap[parentAlias]) {
                throw new Error(`Missing parent entity for alias ${parentAlias}, 
				on table ${i + 1} in FROM clause`);
            }
            let leftNode = joinNodeMap[parentAlias];
            let rightNode = new JoinTreeNode(joinRelation, [], leftNode);
            leftNode.addChildNode(rightNode);
            alias = this.relationManager.getAlias(joinRelation);
            let rightEntity = this.relationManager.createRelatedQEntity(joinRelation, context);
            this.qEntityMapByAlias[alias] = rightEntity;
            this.jsonRelationMapByAlias[alias] = firstRelation;
            if (!rightEntity) {
                throw new Error(`Could not find entity ${joinRelation.ti} for 
				table ${i + 1} in FROM clause`);
            }
            if (joinNodeMap[alias]) {
                throw new Error(`Alias '${alias}' used more than once in the FROM clause.`);
            }
            joinNodeMap[alias] = rightNode;
        }
        return jsonTree;
    }
    parseQueryResult(selectClauseFragment, entityAlias, currentJoinNode, resultRow, nextColumnIndex, context) {
        // Return blanks, primitives and Dates directly
        if (!resultRow || !(resultRow instanceof Object) || resultRow instanceof Date) {
            return resultRow;
        }
        let numNonNullColumns = 0;
        let qEntity = this.qEntityMapByAlias[entityAlias];
        const dbEntity = qEntity.__driver__.dbEntity;
        let resultObject = this.queryParser.addEntity(entityAlias, dbEntity, context);
        for (let propertyName in selectClauseFragment) {
            const dbProperty = dbEntity.propertyMap[propertyName];
            if (!dbProperty.relation || !dbProperty.relation.length) {
                const columnAlias = this.columnAliases.getFollowingAlias();
                const defaultValue = this.entityDefaults.getForAlias(entityAlias)[propertyName];
                const dbColumn = dbProperty.propertyColumns[0].column;
                const propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, columnAlias, nextColumnIndex[0], dbColumn.type, defaultValue);
                if (this.queryParser.addProperty(entityAlias, resultObject, dbColumn.type, propertyName, propertyValue)) {
                    numNonNullColumns++;
                }
                nextColumnIndex[0]++;
            }
            else {
                const childSelectClauseFragment = selectClauseFragment[propertyName];
                const dbRelation = dbProperty.relation[0];
                const childDbEntity = dbRelation.relationEntity;
                if (childSelectClauseFragment === null || childSelectClauseFragment.__state__ === EntityState.STUB) {
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            let haveRelationValues = false;
                            let relationInfos = [];
                            this.applicationUtils.forEachColumnTypeOfRelation(dbRelation, (dbColumn, propertyNameChains) => {
                                const columnAlias = this.columnAliases.getFollowingAlias();
                                let value = this.sqlQueryAdapter.getResultCellValue(resultRow, columnAlias, nextColumnIndex[0], dbColumn.type, null);
                                relationInfos.push({
                                    propertyNameChains: propertyNameChains,
                                    sqlDataType: dbColumn.type,
                                    value
                                });
                                if (this.utils.objectExists(value)) {
                                    haveRelationValues = true;
                                    numNonNullColumns++;
                                }
                                nextColumnIndex[0]++;
                            });
                            if (haveRelationValues) {
                                this.queryParser.bufferManyToOneStub(entityAlias, dbEntity, resultObject, propertyName, childDbEntity, relationInfos, context);
                            }
                            else {
                                this.queryParser.bufferBlankManyToOneStub(entityAlias, resultObject, propertyName, relationInfos);
                            }
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            this.queryParser.bufferOneToManyStub(dbEntity, propertyName);
                            break;
                        default:
                            throw new Error(`Unknown relation type '${dbRelation.relationType}' for 
								'${dbEntity.name}.${dbProperty.name}'`);
                    }
                }
                else {
                    const childJoinNode = currentJoinNode.getEntityRelationChildNode(dbRelation);
                    const childEntityAlias = this.relationManager.getAlias(childJoinNode.jsonRelation);
                    const relationQEntity = this.qEntityMapByAlias[childEntityAlias];
                    const relationDbEntity = relationQEntity.__driver__.dbEntity;
                    let childResultObject = this.parseQueryResult(childSelectClauseFragment, childEntityAlias, childJoinNode, resultRow, nextColumnIndex, context);
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            if (childResultObject) {
                                this.queryParser.bufferManyToOneObject(entityAlias, dbEntity, resultObject, propertyName, relationDbEntity, childResultObject, context);
                            }
                            else {
                                this.queryParser.bufferBlankManyToOneObject(entityAlias, resultObject, propertyName);
                            }
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            if (childResultObject) {
                                this.queryParser.bufferOneToManyCollection(entityAlias, resultObject, dbEntity, propertyName, relationDbEntity, childResultObject, context);
                            }
                            else {
                                this.queryParser.bufferBlankOneToMany(entityAlias, resultObject, dbEntity.name, propertyName, relationDbEntity, context);
                            }
                            break;
                        default:
                            throw new Error(`Unknown relation type '${dbRelation.relationType}' for 
								'${dbEntity.name}.${dbProperty.name}'`);
                    }
                }
            }
        }
        if (numNonNullColumns === 0) {
            return null;
        }
        let idValue = this.queryUtils.getIdKey(resultObject, dbEntity);
        return this.queryParser.flushEntity(entityAlias, dbEntity, selectClauseFragment, idValue, resultObject, context);
    }
    /**
     * Verify that the entity SELECT clause is valid (has _localIds) and fill in clauses
     * that are blank (defined as {}).
     *
     *
     * {
     *  id1: Y,
     *  id2: {
     *    subId1: Y
     *  },
     *  other1: Y
     * }
     *
     * If no properties are specified all properties are included.
     *
     * @param selectClauseFragment
     * @param {DbEntity} dbEntity
     * @returns {any}
     */
    setupSelectFields(selectClauseFragment, dbEntity, context, parentDbProperty) {
        let retrieveAllOwnFields = true;
        let selectFragment;
        if (!selectClauseFragment || selectClauseFragment instanceof Array) {
            let ofProperty = '';
            if (parentDbProperty) {
                ofProperty = `(of '${parentDbProperty.entity.name}.${parentDbProperty.name}') `;
            }
            throw new Error(`'${dbEntity.name}' Entity SELECT clause ${ofProperty}must be specified as an Object.`);
        }
        else if (isID(selectFragment)) {
            selectFragment = {};
            retrieveAllOwnFields = false;
        }
        else {
            selectFragment = { ...selectClauseFragment };
        }
        let allFieldsSpecified = false;
        if (selectFragment.__allFields__ === true || selectFragment['*'] === true
            || (selectFragment['*'] && selectFragment['*'].airportSelectField === true)) {
            allFieldsSpecified = true;
            delete selectFragment.__allFields__;
            delete selectFragment['*'];
        }
        const entityDefinitionHasIds = !!dbEntity.idColumns.length;
        for (const propertyName in selectFragment) {
            if (!allFieldsSpecified) {
                retrieveAllOwnFields = false;
            }
            const dbProperty = dbEntity.propertyMap[propertyName];
            if (!dbProperty) {
                throw new Error(`Entity property '${dbEntity.name}.${propertyName}' does not exist.`);
            }
            const value = selectFragment[propertyName];
            if (value === undefined || value === null || isN(value)) {
                if (dbProperty.isId) {
                    throw new Error(`@Id properties cannot be excluded from entity queries.`);
                }
                if (!entityDefinitionHasIds) {
                    throw new Error(`Cannot exclude property '${propertyName}' from SELECT clause 
					for '${dbEntity.name}' Entity - entity has no @Id so all properties must be included.`);
                }
                delete selectFragment[propertyName];
                continue;
            }
            // Need to differentiate between properties that contain only
            // foreign key _localIds and properties
            if (dbProperty.relation && dbProperty.relation.length) {
                selectFragment[propertyName] = this.setupSelectFields(value, dbProperty.relation[0].relationEntity, context, dbProperty);
                // } else {
                // 	//  At least one non-relational field is in the original SELECT clause
                // 	retrieveAllOwnFields = false
            }
            else if (!isY(value)) {
                selectFragment[propertyName] = Y;
            }
        }
        //  For {} SELECT causes, entities with no @Id, retrieve the entire object.
        // Otherwise make sure all @Id columns are specified.
        for (const dbProperty of dbEntity.properties) {
            if (entityDefinitionHasIds && !dbProperty.isId && !retrieveAllOwnFields) {
                continue;
            }
            const allowDefaults = entityDefinitionHasIds && !dbProperty.isId;
            if (dbProperty.relation && dbProperty.relation.length) {
                const dbRelation = dbProperty.relation[0];
                switch (dbRelation.relationType) {
                    case EntityRelationType.ONE_TO_MANY:
                        break;
                    case EntityRelationType.MANY_TO_ONE:
                        // If SELECT fragment for the child entity is already defined, do not overwrite it
                        if (selectFragment[dbProperty.name]) {
                            break;
                        }
                        const manyToOneRelation = {};
                        this.entityStateManager.markAsStub(manyToOneRelation);
                        selectFragment[dbProperty.name] = manyToOneRelation;
                        // applicationUtils.addRelationToEntitySelectClause(dbRelation, selectFragment,
                        // allowDefaults)
                        break;
                    default:
                        throw new Error(`Unknown relation type: '${dbRelation.relationType}' 
						on '${dbEntity.name}.${dbProperty.name}'.`);
                }
            }
            else {
                const value = selectFragment[dbProperty.name];
                if (value !== undefined && value !== null) {
                    if (!allowDefaults && !isY(value)) {
                        throw new Error(`${entityDefinitionHasIds ? '@Id properties' : 'Entities without @Id'} 
						cannot have default SELECT values.`);
                    }
                }
                else {
                    selectFragment[dbProperty.name] = Y;
                }
            }
        }
        return selectFragment;
    }
    getSELECTFragment(dbEntity, selectClauseFragment, joinTree, context, parentProperty) {
        const tableAlias = this.relationManager.getAlias(joinTree.jsonRelation);
        let selectSqlFragments = [];
        this.entityStateManager.isStub(selectClauseFragment);
        const defaults = this.entityDefaults.getForAlias(tableAlias);
        for (let propertyName in selectClauseFragment) {
            if (propertyName === '__state__') {
                continue;
            }
            const value = selectClauseFragment[propertyName];
            if (!isY(value)) {
                defaults[propertyName] = value;
            }
            const dbProperty = dbEntity.propertyMap[propertyName];
            if (dbProperty.relation && dbProperty.relation.length) {
                const dbRelation = dbProperty.relation[0];
                if (this.entityStateManager.isStub(selectClauseFragment[propertyName])) {
                    for (const relationColumn of dbRelation.manyRelationColumns) {
                        const dbColumn = relationColumn.manyColumn;
                        this.addFieldFromColumn(dbColumn);
                        const columnSelect = this.getSimpleColumnFragment(tableAlias, dbColumn.name);
                        selectSqlFragments.push(`${columnSelect} ${this.columnAliases.getFollowingAlias()}`);
                    }
                }
                else {
                    const subSelectFragments = this.getSELECTFragment(dbRelation.relationEntity, selectClauseFragment[propertyName], joinTree.getEntityRelationChildNode(dbRelation), context, dbProperty);
                    selectSqlFragments = selectSqlFragments.concat(subSelectFragments);
                }
            }
            else {
                const dbColumn = dbProperty.propertyColumns[0].column;
                this.addFieldFromColumn(dbColumn);
                const columnSelect = this.getSimpleColumnFragment(tableAlias, dbColumn.name);
                selectSqlFragments.push(`${columnSelect} ${this.columnAliases.getFollowingAlias()}`);
            }
        }
        return selectSqlFragments;
    }
    getFROMFragment(parentTree, currentTree, context) {
        let fromFragment = '\t';
        let currentRelation = currentTree.jsonRelation;
        let currentAlias = this.relationManager.getAlias(currentRelation);
        let qEntity = this.qEntityMapByAlias[currentAlias];
        if (!qEntity) {
            throw new Error(`Select clause doesn't match the from clause.
Please make sure that all entities present in the SELECT: {...} clause
are specified in the FROM: [...] clause, with the SAME nesting pattern as
in the SELECT: {...} clause.  The non-matching SELECT clause is:

${getErrorMessageSelectStatement(this.jsonQuery.S)}

`);
        }
        let tableName = this.storeDriver.getEntityTableName(qEntity.__driver__.dbEntity, context);
        if (!parentTree) {
            fromFragment += `${tableName} ${currentAlias}`;
        }
        else {
            let parentRelation = parentTree.jsonRelation;
            let parentAlias = this.relationManager.getAlias(parentRelation);
            let leftEntity = this.qEntityMapByAlias[parentAlias];
            let rightEntity = this.qEntityMapByAlias[currentAlias];
            let joinTypeString;
            switch (currentRelation.jt) {
                case JoinType.FULL_JOIN:
                    throw new Error(`Full Joins are not allowed in Entity queries.`);
                case JoinType.INNER_JOIN:
                    joinTypeString = 'INNER JOIN';
                    break;
                case JoinType.LEFT_JOIN:
                    joinTypeString = 'LEFT JOIN';
                    break;
                case JoinType.RIGHT_JOIN:
                    throw new Error(`Right Joins are not allowed in Entity queries.`);
                default:
                    throw new Error(`Unsupported join type: ${currentRelation.jt}`);
            }
            let errorPrefix = 'Error building FROM: ';
            switch (currentRelation.rt) {
                case JSONRelationType.ENTITY_APPLICATION_RELATION:
                    fromFragment += this.getEntityApplicationRelationFromJoin(leftEntity, rightEntity, currentRelation, parentRelation, currentAlias, parentAlias, joinTypeString, errorPrefix, context);
                    break;
                default:
                    throw new Error(`Only Entity application relations are allowed in Entity query FROM clause.`);
            }
        }
        for (let i = 0; i < currentTree.childNodes.length; i++) {
            let childTreeNode = currentTree.childNodes[i];
            fromFragment += this.getFROMFragment(currentTree, childTreeNode, context);
        }
        return fromFragment;
    }
}

/**
 * Created by Papa on 10/16/2016.
 */
/**
 * Represents SQL String query with flat (aka traditional) Select clause.
 */
class SheetSQLQuery extends NonEntitySQLQuery {
    constructor(jsonQuery, dialect, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context) {
        super(jsonQuery, dialect, QueryResultType.SHEET, airportDatabase, applicationUtils, queryUtils, entityStateManager, qMetadataUtils, qValidator, relationManager, sqlQueryAdapter, storeDriver, subStatementQueryGenerator, utils, context);
        this.orderByParser = new ExactOrderByParser(qValidator);
    }
    async parseQueryResults(results, internalFragments, queryResultType, context, bridgedQueryConfiguration) {
        let parsedResults = [];
        if (!results || !results.length) {
            return parsedResults;
        }
        parsedResults = [];
        results.forEach((result) => {
            let parsedResult = this.parseQueryResult(this.jsonQuery.S, result, [0], internalFragments);
            parsedResults.push(parsedResult);
        });
        return parsedResults;
    }
    getSELECTFragment(nested, selectClauseFragment, internalFragments, context) {
        if (!selectClauseFragment) {
            throw new Error(`SELECT clause is not defined for a Flat Query`);
        }
        {
            let distinctClause = selectClauseFragment;
            if (distinctClause.ot == JSONClauseObjectType.DISTINCT_FUNCTION) {
                let distinctSelect = this.getSELECTFragment(nested, distinctClause.appliedFunctions[0].p[0], internalFragments, context);
                return `DISTINCT ${distinctSelect}`;
            }
        }
        if (!(selectClauseFragment instanceof Array)) {
            throw new Error(`SELECT clause for a Flat Query must be an Array`);
        }
        let fieldIndex = 0;
        let selectSqlFragment = selectClauseFragment.map((field) => {
            return this.getFieldSelectFragment(field, ClauseType.NON_MAPPED_SELECT_CLAUSE, null, fieldIndex++, context);
        })
            .join('');
        const selectClause = internalFragments.SELECT;
        if (selectClause && selectClause.length) {
            if (fieldIndex) {
                selectSqlFragment += '\n\t,';
            }
            selectSqlFragment += selectClause
                .map(dbColumn => `${dbColumn.name}`)
                .join('\n\t,');
        }
        return selectSqlFragment;
    }
    parseQueryResult(selectClauseFragment, resultRow, nextFieldIndex, internalFragments) {
        const resultsFromSelect = selectClauseFragment.map((field) => {
            let propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, field.fa, nextFieldIndex[0], field.dt, null);
            nextFieldIndex[0]++;
            return propertyValue;
        });
        const selectClause = internalFragments.SELECT;
        if (selectClause && selectClause.length) {
            for (const dbColumn of selectClause) {
                let propertyValue = this.sqlQueryAdapter.getResultCellValue(resultRow, dbColumn.name, nextFieldIndex[0], dbColumn.type, null);
                resultsFromSelect.push(propertyValue);
                nextFieldIndex[0]++;
            }
        }
        return resultsFromSelect;
    }
}

/**
 * Created by Papa on 9/2/2016.
 */
class IdGenerator {
    constructor() {
        this.transactionHistory_LocalIdColumns = [];
    }
    async init() {
        this.populateTransactionHistory_LocalIdColumns().then();
    }
    populateTransactionHistory_LocalIdColumns() {
        return new Promise((resolve, _reject) => {
            this.doPopulateTransactionHistory_LocalIdColumns(resolve);
        });
    }
    doPopulateTransactionHistory_LocalIdColumns(resolve) {
        if (Q_airport____at_airport_slash_holding_dash_pattern$1.__dbApplication__ && Q_airport____at_airport_slash_holding_dash_pattern$1.__dbApplication__.currentVersion) {
            const transactionHistoryDbEntity = this.getHoldingPatternDbEntity('TransactionHistory');
            const repoTransHistoryDbEntity = this.getHoldingPatternDbEntity('RepositoryTransactionHistory');
            const operationHistoryDbEntity = this.getHoldingPatternDbEntity('OperationHistory');
            const recordHistoryDbEntity = this.getHoldingPatternDbEntity('RecordHistory');
            this.transactionHistory_LocalIdColumns.push(transactionHistoryDbEntity.idColumns[0]);
            this.transactionHistory_LocalIdColumns.push(repoTransHistoryDbEntity.idColumns[0]);
            this.transactionHistory_LocalIdColumns.push(operationHistoryDbEntity.idColumns[0]);
            this.transactionHistory_LocalIdColumns.push(recordHistoryDbEntity.idColumns[0]);
            resolve();
        }
        else {
            setTimeout(() => {
                this.doPopulateTransactionHistory_LocalIdColumns(resolve);
            }, 100);
        }
    }
    async generateTransactionHistory_LocalIds(numRepositoryTransHistories, numOperationTransHistories, numRecordHistories) {
        let generatedSequenceNumbers = await this.sequenceGenerator
            .generateSequenceNumbers(this.transactionHistory_LocalIdColumns, [
            1,
            numRepositoryTransHistories,
            numOperationTransHistories,
            numRecordHistories
        ]);
        return {
            operationHistory_LocalIds: generatedSequenceNumbers[2],
            recordHistory_LocalIds: generatedSequenceNumbers[3],
            repositoryHistory_LocalIds: generatedSequenceNumbers[1],
            transactionHistory_LocalId: generatedSequenceNumbers[0][0]
        };
    }
    async generateEntityIds() {
    }
    getHoldingPatternDbEntity(holdingPatternEntityName) {
        return Q_airport____at_airport_slash_holding_dash_pattern$1.__dbApplication__.currentVersion[0].applicationVersion
            .entityMapByName[holdingPatternEntityName];
    }
}
var CurrentState;
(function (CurrentState) {
    CurrentState["CREATED"] = "CREATED";
    CurrentState["DELETED"] = "DELETED";
    CurrentState["UPDATED"] = "UPDATED";
})(CurrentState || (CurrentState = {}));

/**
 * Created by Papa on 9/9/2016.
 */
class SqlDriver {
    supportsLocalTransactions(context) {
        return true;
    }
    getEntityTableName(dbEntity, context) {
        return this.getTableName(dbEntity.applicationVersion.application, dbEntity.applicationVersion.integerVersion, dbEntity, context);
    }
    getTableName(application, applicationIntegerVersion, table, context) {
        const domainName = typeof application.domain === 'string'
            ? application.domain
            : application.domain.name;
        const actorApplication = context.transaction.actor.application;
        if (!this.appTrackerUtils.isInternalDomain(actorApplication.domain.name)) {
            const entityHasExternalAccessPermissions = this.appTrackerUtils.entityHasExternalAccessPermissions(domainName, application.name, applicationIntegerVersion, table.name);
            if (!entityHasExternalAccessPermissions) {
                throw new Error(`
Domain:          ${actorApplication.domain.name}
Application:     ${actorApplication.name}

has no permissions to access:

Domain:          ${domainName}
Application:     ${application.name},
Integer Version: ${applicationIntegerVersion}
Entity:          ${table.name}
`);
            }
        }
        let theTableName = table.name;
        if (table.tableConfig && table.tableConfig.name) {
            theTableName = table.tableConfig.name;
        }
        let fullApplication_Name;
        if (application.fullName) {
            fullApplication_Name = application.fullName;
        }
        else {
            fullApplication_Name = this.dbApplicationUtils.getApplication_FullName(application);
        }
        return this.composeTableName(fullApplication_Name, theTableName, context);
    }
    async internalSetupTransaction(transaction, context) {
        await this.ensureContext(context);
    }
    async tearDownTransaction(transaction, context) {
        if (transaction.childTransaction) {
            this.tearDownTransaction(transaction.childTransaction, context);
        }
        if (transaction.parentTransaction) {
            transaction.parentTransaction.childTransaction = null;
            transaction.parentTransaction = null;
        }
    }
    async startTransaction(transaction, context) {
        await this.ensureContext(context);
        try {
            await this.internalStartTransaction(transaction);
        }
        catch (e) {
            await this.tearDownTransaction(transaction, context);
            console.error(e);
            throw e;
        }
    }
    async commit(transaction, context) {
        await this.ensureContext(context);
        let commitSucceeded = false;
        try {
            await this.internalCommit(transaction);
            commitSucceeded = true;
        }
        catch (e) {
            console.error(e);
            try {
                await this.internalRollback(transaction);
            }
            catch (rollbackError) {
                console.error(rollbackError);
            }
            throw e;
        }
        finally {
            await this.tearDownTransaction(transaction, context);
            if (commitSucceeded) {
                this.activeQueries.rerunQueries(transaction.fieldMap);
            }
            else {
                this.activeQueries.clearQueriesToRerun();
            }
        }
    }
    async rollback(transaction, context) {
        await this.ensureContext(context);
        try {
            await this.internalRollback(transaction);
        }
        catch (e) {
            console.error(e);
            // Do not re-throw the exception, rollback is final (at least for now)
        }
        finally {
            await this.tearDownTransaction(transaction, context);
            this.activeQueries.clearQueriesToRerun();
        }
    }
    async insertValues(portableQuery, context, cachedSqlQueryId) {
        let fieldMap = new globalThis.SyncApplicationMap();
        const splitValues = this.splitValues(portableQuery.jsonQuery.V, context);
        let numVals = 0;
        for (const V of splitValues) {
            let sqlInsertValues = new SQLInsertValues({
                ...portableQuery.jsonQuery,
                V
            }, this.getDialect(context), this.airportDatabase, this.applicationUtils, this.queryUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementSqlGenerator, this.utils, context);
            let sql = sqlInsertValues.toSQL(fieldMap, context);
            let parameters = sqlInsertValues.getParameters(portableQuery.parameterMap, context);
            numVals += await this.executeNative(sql, parameters, context);
        }
        this.observableQueryAdapter
            .collectAffectedFieldsAndRepositoriesToRerunQueriesBy(portableQuery, fieldMap, context.transaction);
        return numVals;
    }
    async deleteWhere(portableQuery, context) {
        let fieldMap = new globalThis.SyncApplicationMap();
        let sqlDelete = new SQLDelete(portableQuery.jsonQuery, this.getDialect(context), this.airportDatabase, this.applicationUtils, this.queryUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementSqlGenerator, this.utils, context);
        let sql = sqlDelete.toSQL(fieldMap, context);
        let parameters = sqlDelete.getParameters(portableQuery.parameterMap, context);
        let numberOfAffectedRecords = await this.executeNative(sql, parameters, context);
        this.observableQueryAdapter
            .collectAffectedFieldsAndRepositoriesToRerunQueriesBy(portableQuery, fieldMap, context.transaction);
        return numberOfAffectedRecords;
    }
    async updateWhere(portableQuery, internalFragments, context) {
        let fieldMap = new globalThis.SyncApplicationMap();
        let sqlUpdate = new SQLUpdate(portableQuery.jsonQuery, this.getDialect(context), this.airportDatabase, this.applicationUtils, this.queryUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementSqlGenerator, this.utils, context);
        let sql = sqlUpdate.toSQL(internalFragments, fieldMap, context);
        let parameters = sqlUpdate.getParameters(portableQuery.parameterMap, context);
        const numAffectedRows = await this.executeNative(sql, parameters, context);
        this.observableQueryAdapter
            .collectAffectedFieldsAndRepositoriesToRerunQueriesBy(portableQuery, fieldMap, context.transaction);
        return numAffectedRows;
    }
    async find(portableQuery, internalFragments, context, cachedSqlQueryId) {
        context = await this.ensureContext(context);
        const sqlQuery = this.getSQLQuery(portableQuery, context);
        const sql = sqlQuery.toSQL(internalFragments, context);
        const parameters = sqlQuery.getParameters(portableQuery.parameterMap, context);
        let results = await this.findNative(sql, parameters, context);
        results = await sqlQuery.parseQueryResults(results, internalFragments, portableQuery.queryResultType, context);
        return results;
    }
    getSQLQuery(portableQuery, context) {
        let jsonQuery = portableQuery.jsonQuery;
        let dialect = this.getDialect(context);
        let resultType = portableQuery.queryResultType;
        const QueryResType = QueryResultType;
        switch (resultType) {
            case QueryResType.ENTITY_GRAPH:
            case QueryResType.ENTITY_TREE:
                const dbEntity = this.airportDatabase.applications[portableQuery.applicationIndex]
                    .currentVersion[0].applicationVersion.entities[portableQuery.tableIndex];
                return new EntitySQLQuery(jsonQuery, dbEntity, dialect, resultType, this.airportDatabase, this.applicationUtils, this.queryUtils, this.entityStateManager, this.objectResultParserFactory, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementSqlGenerator, this.utils, context);
            case QueryResType.FIELD:
                return new FieldSQLQuery(jsonQuery, dialect, this.airportDatabase, this.applicationUtils, this.queryUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementSqlGenerator, this.utils, context);
            case QueryResType.SHEET:
                return new SheetSQLQuery(jsonQuery, dialect, this.airportDatabase, this.applicationUtils, this.queryUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementSqlGenerator, this.utils, context);
            case QueryResType.TREE:
                return new TreeSQLQuery(jsonQuery, dialect, this.airportDatabase, this.applicationUtils, this.queryUtils, this.entityStateManager, this.qMetadataUtils, this.qValidator, this.relationManager, this.sqlQueryAdapter, this, this.subStatementSqlGenerator, this.utils, context);
            case QueryResType.RAW:
            default:
                throw new Error(`Unknown QueryResultType: ${resultType}`);
        }
    }
    async findOne(portableQuery, internalFragments, context, cachedSqlQueryId) {
        let results = await this.find(portableQuery, internalFragments, context);
        if (results.length > 1) {
            throw new Error(`Expecting a single result, got ${results.length}`);
        }
        if (results.length == 1) {
            return results[0];
        }
        return null;
    }
    warn(message) {
        console.log(message);
    }
    splitValues(values, context) {
        const valuesInRow = values[0].length;
        const numValues = values.length * valuesInRow;
        if (numValues <= this.maxValues) {
            return [values];
        }
        let numRowsPerBatch = Math.floor(this.maxValues / valuesInRow);
        const splitValues = [];
        for (let i = 0; i < values.length; i += numRowsPerBatch) {
            const aSplitValues = values.slice(i, i + numRowsPerBatch);
            splitValues.push(aSplitValues);
        }
        return splitValues;
    }
    async ensureContext(context) {
        return doEnsureContext(context);
    }
}

class QValidator {
    validateInsertQEntity(dbEntity) {
    }
    validateReadFromEntity(relation) {
    }
    validateReadProperty(dbColumn) {
    }
    validateUpdateProperty(propertyName, dbEntity) {
    }
    validateUpdateColumn(dbColumn) {
    }
    validateReadQEntityProperty(applicationIndex, tableIndex, columnIndex) {
    }
    validateReadQEntityManyToOneRelation(applicationIndex, tableIndex, columnIndex) {
    }
    addFunctionAlias(functionAlias) {
    }
    addSubQueryAlias(subQueryAlias) {
    }
    validateAliasedFieldAccess(fieldAlias) {
    }
}

const fuelHydrantSystem = lib('fuel-hydrant-system');
fuelHydrantSystem.register(SubStatementSqlGenerator, IdGenerator, ObjectResultParserFactory, QValidator, SqlDriver);
const SQL_QUERY_ADAPTOR = fuelHydrantSystem.token('SQLQueryAdaptor');
fuelHydrantSystem.setDependencies(IdGenerator, {
    sequenceGenerator: SEQUENCE_GENERATOR
});
fuelHydrantSystem.setDependencies(ObjectResultParserFactory, {
    applicationUtils: ApplicationUtils,
    datastructureUtils: DatastructureUtils,
    entityStateManager: ENTITY_STATE_MANAGER,
    queryUtils: QUERY_UTILS,
    utils: Utils
});
fuelHydrantSystem.setDependencies(SqlDriver, {
    activeQueries: ActiveQueries,
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: ApplicationUtils,
    appTrackerUtils: AppTrackerUtils,
    dbApplicationUtils: DbApplicationUtils,
    entityStateManager: ENTITY_STATE_MANAGER,
    objectResultParserFactory: ObjectResultParserFactory,
    observableQueryAdapter: ObservableQueryAdapter,
    qMetadataUtils: QMetadataUtils,
    queryUtils: QUERY_UTILS,
    qValidator: QValidator,
    relationManager: RelationManager,
    sqlQueryAdapter: SQL_QUERY_ADAPTOR,
    subStatementSqlGenerator: SubStatementSqlGenerator,
    transactionManager: TRANSACTION_MANAGER,
    utils: Utils
});
fuelHydrantSystem.setDependencies(SubStatementSqlGenerator, {
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: ApplicationUtils,
    entityStateManager: ENTITY_STATE_MANAGER,
    qMetadataUtils: QMetadataUtils,
    queryUtils: QUERY_UTILS,
    qValidator: QValidator,
    relationManager: RelationManager,
    sqlQueryAdapter: SQL_QUERY_ADAPTOR,
    storeDriver: STORE_DRIVER,
    utils: Utils
});

class ApiProxy {
    constructor(application) {
        this.application = application;
    }
    get proxy() {
        // Proxy won't be set by default in UIs, where there is 
        // no dependency injection or the associated 'init()' call
        if (!this._proxy) {
            this.setProxy(globalThis.IOC.getAutopilotApiLoader());
        }
        return this._proxy;
    }
    init() {
        this.setProxy(this.__container__.getSync(globalThis.AUTOPILOT_API_LOADER));
    }
    setProxy(autopilotApiLoader) {
        this._proxy = autopilotApiLoader.loadApiAutopilot({
            application: this.application,
            descriptor: {
                interface: this.constructor.name
            }
        });
    }
}

const application$1 = {
    name: '@airport/holding-pattern',
    domain: {
        name: 'airport'
    }
};

// An API stub for other Applications and UIs to use
// @Injected() is implied but not specified to avoid @airport/direction-indicator
// dependency in UI API stub (eventually, once it's @airport/autopilot is cleaned
// up)
// @Injected()
class RepositoryApi extends ApiProxy {
    constructor() {
        super(application$1);
    }
    async findRootRepositories() {
        return await this.proxy.findRootRepositories();
    }
    async create(repositoryName, isPublic) {
        return await this.proxy.create(repositoryName, isPublic);
    }
    async setUiEntryUri(uiEntryUri, repository) {
        await this.proxy.setUiEntryUri(uiEntryUri, repository);
    }
}

/**
 * Created by Papa on 4/17/2017.
 */
/**
 * Marks a group of mutation history changes.
 */
class OperationHistory {
    constructor() {
        this.recordHistory = [];
    }
}

class RecordHistory {
    constructor() {
        this.newValues = [];
        this.oldValues = [];
    }
}

/**
 * Created by Papa on 9/15/2016.
 */
/**
 * Currently, syncing databases are always SqLite dbs.  This means
 * we don't need to store types for values.  If a need arises type
 * specific FieldChange classes can always be added.  Having
 * VARCHAR and NUMBER should suffice for other db implementations.
 * NUMBER covers (dates, booleans and numbers).  Maybe REALs will
 * also be required.
 */
class RecordHistoryNewValue {
}

/**
 * Created by Papa on 9/15/2016.
 */
/**
 * Currently, syncing databases are always SqLite dbs.  This means
 * we don't need to store types for values.  If a need arises type
 * specific FieldChange classes can always be added.  Having
 * VARCHAR and NUMBER should suffice for other db implementations.
 * NUMBER covers (dates, booleans and numbers).  Maybe REALs will
 * also be required.
 */
class RecordHistoryOldValue {
}

/**
 * Created by Papa on 9/15/2016.
 */
/**
 * An entry in repository Transaction History/Log.
 * The main synchronization unit exchanged between terminals.
 */
class RepositoryTransactionHistory {
    constructor(data) {
        this.repositoryTransactionType = RepositoryTransactionType.LOCAL;
        this.operationHistory = [];
        // Tracked only in the Terminal database where originally added, for the
        // purpose of sending out synchronization messages
        // IS resent in RepositorySynchronizationMessage
        this.newRepositoryMemberInvitations = [];
        // Tracked only in the Terminal database where originally added, for the
        // purpose of sending out synchronization messages
        // IS resent in RepositorySynchronizationMessage
        this.newRepositoryMemberAcceptances = [];
        // Tracked only in the Terminal database where originally added, for the
        // purpose of sending out synchronization messages
        // IS NOT implemented (currently)
        this.newRepositoryMemberUpdates = [];
        // Tracked only in the Terminal database where originally added, for the
        // purpose of sending out synchronization messages
        // IS NOT resent in RepositorySynchronizationMessage
        this.newRepositoryMembers = [];
        if (!data) {
            return;
        }
        this._localId = data._localId;
        this.transactionHistory = data.transactionHistory;
        this.repository = data.repository;
        this.saveTimestamp = data.saveTimestamp;
        this.operationHistory = data.operationHistory;
    }
}

/**
 * Created by Papa on 5/1/2017./
 */
class TransactionHistory {
    constructor() {
        this.applicationMap = new globalThis.SyncApplicationMap();
        this.allOperationHistory = [];
        this.allRecordHistory = [];
        this.allRecordHistoryNewValues = [];
        this.allRecordHistoryOldValues = [];
        this.allRepositoryMemberAcceptances = [];
        this.allRepositoryMemberInvitations = [];
        this.allRepositoryMembers = [];
    }
}

class Actor {
}

/**
 * Created by Papa on 2/17/2017.
 */
// Used withint the framework because it imports from '@airport/travel-document-checkpoint/dist/app/bundle'
class InternalAirEntity {
    constructor(entityId) {
        this.ageSuitability = 0;
        // TODO: if and when records are copied, make this a column
        // @Column({ name: 'COPIED', nullable: false })
        this.copied = false;
        this.createdAt = new Date();
        // Currently TypeScript does not support optional getters/setters
        // this is a workaround
        delete this.id;
        Object.defineProperty(this, 'id', {
            get() {
                return globalThis.IOC.getSync(globalThis.AIR_ENTITY_UTILS).encodeId(this);
            },
            set(idString) {
                globalThis.IOC.getSync(globalThis.AIR_ENTITY_UTILS).setId(idString, this);
            }
        });
        delete this.isNew;
        Object.defineProperty(this, 'isNew', {
            get() {
                return !!this._actorRecordId;
            }
        });
        delete this.createdBy;
        Object.defineProperty(this, 'createdBy', {
            get() {
                return this.actor.userAccount;
            }
        });
        this.id = entityId;
    }
}

/**
 * Created by Papa on 2/9/2017.
 */
class Repository {
    constructor() {
        this._localId = null;
        // Local-only, represents state of the repository
        // false if only a reference stub is loaded
        this.isLoaded = true;
        this.repositoryMembers = [];
        this.repositoryTransactionHistory = [];
        this.repositoryApplications = [];
        this.repositoryClients = [];
        this.repositoryDatabases = [];
        this.repositoryTerminals = [];
        this.repositoryTypes = [];
    }
}

class RepositoryApplication {
}

class RepositoryClient {
}

class RepositoryDatabase {
}

class RepositoryMember {
    constructor() {
        this.updates = [];
    }
}

class RepositoryMemberAcceptance {
}

class RepositoryMemberInvitation {
}

class RepositoryMemberUpdate {
}

class RepositoryTerminal {
}

class RepositoryType {
}

const __constructors__$2 = {
    Actor,
    InternalAirEntity,
    OperationHistory,
    RecordHistory,
    RecordHistoryNewValue,
    RecordHistoryOldValue,
    Repository,
    RepositoryApplication,
    RepositoryClient,
    RepositoryDatabase,
    RepositoryMember,
    RepositoryMemberAcceptance,
    RepositoryMemberInvitation,
    RepositoryMemberUpdate,
    RepositoryTerminal,
    RepositoryTransactionHistory,
    RepositoryType,
    TransactionHistory
};
const Q_airport____at_airport_slash_holding_dash_pattern = {
    __constructors__: __constructors__$2,
    domain: 'airport',
    name: '@airport/holding-pattern'
};
if (globalThis.airApi) {
    globalThis.airApi.setQApp(Q_airport____at_airport_slash_holding_dash_pattern);
}

for (let apiStub of [RepositoryApi]) {
    apiStub.application = application$1;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

let RepositoryMaintenanceManager = class RepositoryMaintenanceManager {
    async selfJoinRepository(repositoryGUID) {
        let context = arguments[1];
        const userAccount = await this.terminalSessionManager.getUserAccountFromSession();
        const repository = await this.repositoryDao.findRepository(repositoryGUID);
        if (!repository) {
            throw new Error(`Repository with GUID: ${repositoryGUID} is not found.`);
        }
        if (!repository.isPublic) {
            throw new Error(`Cannot self-join a non-public Repository, use the joinRepository method.`);
        }
        const repositoryMember = await this.repositoryMemberDao
            .findForRepositoryLocalIdAndAccountPublicSingingKey(repository._localId, userAccount.accountPublicSigningKey);
        if (repositoryMember) {
            console.warn(`User ${userAccount.username} is already a member of Repository ${repository.name}`);
            return;
        }
        await this.createRepositoryMember(repository, userAccount, false, false, true, true, context);
    }
    async acceptRepositoryMemberInvitation(repositoryGUID, base64EncodedInvitationPrivateSigningKey, base64EncodedInvitationPublicSigningKey) {
        let context = arguments[1];
        const userAccount = await this.terminalSessionManager.getUserAccountFromSession();
        const repository = await this.repositoryDao.findRepository(repositoryGUID);
        if (!repository) {
            throw new Error(`Repository with GUID: ${repositoryGUID} is not found.`);
        }
        if (repository.isPublic) {
            throw new Error(`Cannot join a public Repository, use selfJoinRepository method.`);
        }
        const invitationPublicSigningKey = atob(base64EncodedInvitationPublicSigningKey);
        const acceptingRepositoryMember = await this.repositoryMemberDao
            .findForRepositoryLocalIdAndIvitationPublicSigningKey(repository._localId, invitationPublicSigningKey);
        if (!acceptingRepositoryMember) {
            throw new Error(`User '${userAccount.username}' is not a member of Repository '${repository.name}'`);
        }
        const publicSigningKey = await this.keyRingManager.addRepositoryKey(repository.GUID, repository.name);
        acceptingRepositoryMember.memberPublicSigningKey = publicSigningKey;
        const repositoryMemberAcceptance = new RepositoryMemberAcceptance();
        repositoryMemberAcceptance.createdAt = new Date();
        repositoryMemberAcceptance.acceptingRepositoryMember = acceptingRepositoryMember;
        repositoryMemberAcceptance.invitationPublicSigningKey = invitationPublicSigningKey;
        await this.addRepositoryMemberInfoToHistory(acceptingRepositoryMember, repository, repositoryMemberAcceptance, atob(base64EncodedInvitationPrivateSigningKey), null, context);
    }
    async inviteUserToRepository(repository, userEmail) {
        let context = arguments[2];
        const invitationSigningKey = await this.keyUtils.getSigningKey();
        const base64EncodedKeyInvitationPrivateSigningKey = btoa(invitationSigningKey.private);
        const invitedRepositoryMember = await this.createRepositoryMember(repository, null, false, false, true, false, context);
        const base64EncodedKeyInvitationPublicSigningKey = btoa(invitationSigningKey.public);
        const repositoryMemberInvitation = new RepositoryMemberInvitation$1();
        repositoryMemberInvitation.createdAt = new Date();
        repositoryMemberInvitation.invitationPublicSigningKey = invitationSigningKey.public;
        repositoryMemberInvitation.invitedRepositoryMember = invitedRepositoryMember;
        await this.addRepositoryMemberInfoToHistory(invitedRepositoryMember, repository, null, null, repositoryMemberInvitation, context);
        const joinUrl = `https://localhost:3000/joinRepository/${repository.GUID}/${base64EncodedKeyInvitationPublicSigningKey}/${base64EncodedKeyInvitationPrivateSigningKey}`;
        await this.sendEmail(userEmail, `Join '${repository.name}' on Turbase`, joinUrl);
        if (this.canUseWebShareAPI()) {
            await this.share(`Join ${repository.name.substring(0, 20)}${repository.name.length > 20 ? '...' : ''}`, `You are invited to join '${repository.name}' on Turbase`, joinUrl);
        }
    }
    async createRepositoryMember(repository, userAccount, isOwner, isAdministrator, canWrite, addRepositoryKey, context) {
        let memberPublicSigningKey = null;
        if (addRepositoryKey) {
            memberPublicSigningKey = await this.keyRingManager.addRepositoryKey(repository.GUID, repository.name);
        }
        const repositoryMember = this.getRepositoryMember(userAccount, repository, isOwner, isAdministrator, canWrite, memberPublicSigningKey);
        await this.addRepositoryMemberInfoToHistory(repositoryMember, repository, null, null, null, context);
        return repositoryMember;
    }
    async addRepositoryMemberInfoToHistory(repositoryMember, repository, repositoryMemberAcceptance, invitationPrivateSigningKey, repositoryMemberInvitation, context) {
        const { repositoryTransactionHistory, transactionHistory } = await this.getRepositoryTransactionHistory(repository, context);
        repositoryTransactionHistory.newRepositoryMembers.push(repositoryMember);
        transactionHistory.allRepositoryMembers.push(repositoryMember);
        if (repositoryMemberAcceptance) {
            repositoryTransactionHistory.newRepositoryMemberAcceptances.push(repositoryMember);
            repositoryTransactionHistory.invitationPrivateSigningKey = invitationPrivateSigningKey;
            transactionHistory.allRepositoryMemberAcceptances.push(repositoryMember);
        }
        if (repositoryMemberInvitation) {
            repositoryTransactionHistory.newRepositoryMemberInvitations.push(repositoryMember);
            transactionHistory.allRepositoryMemberInvitations.push(repositoryMember);
        }
    }
    async getRepositoryTransactionHistory(repository, context) {
        const userSession = await this.terminalSessionManager.getUserSession();
        if (!userSession) {
            throw new Error('No User Session present');
        }
        const transaction = userSession.currentTransaction;
        if (!transaction) {
            throw new Error('No Current Transaction present');
        }
        const actor = transaction.actor;
        if (!actor) {
            throw new Error('No actor associated with transaction Id: ' + transaction.id);
        }
        const repositoryTransactionHistory = await this
            .historyManager.getRepositoryTransactionHistory(userSession.currentTransaction.transactionHistory, repository._localId, actor, context);
        return {
            repositoryTransactionHistory,
            transactionHistory: userSession.currentTransaction.transactionHistory
        };
    }
    getRepositoryMember(userAccount, repository, isOwner, isAdministrator, canWrite, memberPublicSigningKey) {
        const repositoryMember = new RepositoryMember();
        repositoryMember.isOwner = isOwner;
        repositoryMember.isAdministrator = isAdministrator;
        repositoryMember.canWrite = canWrite;
        repositoryMember.memberPublicSigningKey = memberPublicSigningKey;
        repositoryMember.repository = repository;
        repositoryMember.userAccount = userAccount;
        if (userAccount) {
            repositoryMember.status = RepositoryMember_Status.JOINED;
        }
        else {
            repositoryMember.status = RepositoryMember_Status.INVITED;
        }
        return repositoryMember;
    }
    sendEmail(to, subject, text) {
        return `mailto:${to}?subject=${subject}&body=${text}`;
    }
    canUseWebShareAPI() {
        return navigator.canShare && navigator.canShare();
    }
    async share(title, text, url) {
        const shareData = {
            title,
            text,
            url
        };
        await navigator.share(shareData);
    }
};
__decorate([
    Inject()
], RepositoryMaintenanceManager.prototype, "historyManager", void 0);
__decorate([
    Inject()
], RepositoryMaintenanceManager.prototype, "keyRingManager", void 0);
__decorate([
    Inject()
], RepositoryMaintenanceManager.prototype, "keyUtils", void 0);
__decorate([
    Inject()
], RepositoryMaintenanceManager.prototype, "repositoryDao", void 0);
__decorate([
    Inject()
], RepositoryMaintenanceManager.prototype, "repositoryMemberDao", void 0);
__decorate([
    Inject()
], RepositoryMaintenanceManager.prototype, "terminalSessionManager", void 0);
__decorate([
    Api()
], RepositoryMaintenanceManager.prototype, "selfJoinRepository", null);
__decorate([
    Api()
], RepositoryMaintenanceManager.prototype, "acceptRepositoryMemberInvitation", null);
__decorate([
    Api()
], RepositoryMaintenanceManager.prototype, "inviteUserToRepository", null);
RepositoryMaintenanceManager = __decorate([
    Injected()
], RepositoryMaintenanceManager);

let SSOManager = class SSOManager {
    async signUp(userAccountInfo, context) {
        if (this.terminalStore.getIsServer()) {
            throw new Error('Implement');
        }
        const allSessions = this.userStore.getAllSessions();
        let session = {
            currentRootTransaction: null,
            currentTransaction: null,
            keyRing: null,
            userAccount: null
        };
        allSessions.push(session);
        const signingKey = await this.keyUtils.getSigningKey(521);
        const { userAccount } = await this.userAccountManager
            .addUserAccount(userAccountInfo.username, userAccountInfo.email, signingKey.public, context);
        session.userAccount = userAccount;
        // FIXME: replace with passed in key
        const userPrivateKey = await this.keyUtils.getEncryptionKey();
        const keyRing = await this.keyRingManager.getKeyRing(userPrivateKey, signingKey.private, context);
        session.keyRing = keyRing;
        const sessionMapByAccountPublicSigningKey = this.userStore
            .getSessionMapByAccountPublicSigningKey();
        sessionMapByAccountPublicSigningKey.set(userAccount.accountPublicSigningKey, session);
        this.userStore.state.next({
            allSessions,
            sessionMapByAccountPublicSigningKey
        });
    }
    async login(userAccount) {
        throw new Error(`Implement`);
    }
    async signIn(email) {
        throw new Error(`Implement`);
        // return await this.signInAdapter.getKeyRing({
        //     email
        // })
    }
};
__decorate([
    Inject()
], SSOManager.prototype, "keyUtils", void 0);
__decorate([
    Inject()
], SSOManager.prototype, "keyRingManager", void 0);
__decorate([
    Inject()
], SSOManager.prototype, "signInAdapter", void 0);
__decorate([
    Inject()
], SSOManager.prototype, "terminalStore", void 0);
__decorate([
    Inject()
], SSOManager.prototype, "userAccountManager", void 0);
__decorate([
    Inject()
], SSOManager.prototype, "userStore", void 0);
__decorate([
    Api()
], SSOManager.prototype, "signUp", null);
__decorate([
    Api()
], SSOManager.prototype, "login", null);
__decorate([
    Api()
], SSOManager.prototype, "signIn", null);
SSOManager = __decorate([
    Injected()
], SSOManager);

const __constructors__$1 = {};
const Q_bridge____at_airbridge_slash_sso = {
    __constructors__: __constructors__$1,
    domain: 'bridge',
    name: '@airbridge/sso'
};
if (globalThis.airApi) {
    globalThis.airApi.setQApp(Q_bridge____at_airbridge_slash_sso);
}

const sso = domain('airbridge').app('sso');
sso.register(RepositoryMaintenanceManager, SSOManager);
sso.setDependencies(RepositoryMaintenanceManager, {
    historyManager: HISTORY_MANAGER,
    keyRingManager: KeyRingManager,
    keyUtils: KeyUtils,
    repositoryDao: RepositoryDao,
    repositoryMemberDao: RepositoryMemberDao,
    terminalSessionManager: TERMINAL_SESSION_MANAGER
});
sso.setDependencies(SSOManager, {
    keyUtils: KeyUtils,
    keyRingManager: KeyRingManager,
    // signInAdapter: ISignInAdapter,
    terminalStore: TerminalStore,
    userAccountManager: UserAccountManager,
    userStore: UserStore
});

class CopiedRecordLedger extends InternalAirEntity$1 {
}

class LocalCopyReplacementLedger {
}

class CrossRepositoryRelationLedger extends InternalAirEntity$1 {
}

const __constructors__ = {
    CopiedRecordLedger,
    CrossRepositoryRelationLedger,
    LocalCopyReplacementLedger
};
const Q_airport____at_airport_slash_flight_dash_recorder = {
    __constructors__,
    domain: 'airport',
    name: '@airport/flight-recorder'
};
function airport____at_airport_slash_flight_dash_recorder_diSet(dbEntityId) {
    return globalThis.airApi.dS(Q_airport____at_airport_slash_flight_dash_recorder.__dbApplication__, dbEntityId);
}
if (globalThis.airApi) {
    globalThis.airApi.setQApp(Q_airport____at_airport_slash_flight_dash_recorder);
}

// Application Q object Dependency Injection readiness detection Dao
class SQDIDao extends Dao {
    constructor(dbEntityId) {
        super(dbEntityId, Q_airport____at_airport_slash_flight_dash_recorder);
    }
}
class BaseCopiedRecordLedgerDao extends SQDIDao {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_flight_dash_recorder_diSet(0);
    }
    constructor() {
        super(0);
    }
}
BaseCopiedRecordLedgerDao.Find = new DaoQueryDecorators();
BaseCopiedRecordLedgerDao.FindOne = new DaoQueryDecorators();
BaseCopiedRecordLedgerDao.Search = new DaoQueryDecorators();
BaseCopiedRecordLedgerDao.SearchOne = new DaoQueryDecorators();
class BaseCrossRepositoryRelationLedgerDao extends SQDIDao {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_flight_dash_recorder_diSet(1);
    }
    constructor() {
        super(1);
    }
}
BaseCrossRepositoryRelationLedgerDao.Find = new DaoQueryDecorators();
BaseCrossRepositoryRelationLedgerDao.FindOne = new DaoQueryDecorators();
BaseCrossRepositoryRelationLedgerDao.Search = new DaoQueryDecorators();
BaseCrossRepositoryRelationLedgerDao.SearchOne = new DaoQueryDecorators();
class BaseLocalCopyReplacementLedgerDao extends SQDIDao {
    static Save(config) {
        return Dao.BaseSave(config);
    }
    static diSet() {
        return airport____at_airport_slash_flight_dash_recorder_diSet(2);
    }
    constructor() {
        super(2);
    }
}
BaseLocalCopyReplacementLedgerDao.Find = new DaoQueryDecorators();
BaseLocalCopyReplacementLedgerDao.FindOne = new DaoQueryDecorators();
BaseLocalCopyReplacementLedgerDao.Search = new DaoQueryDecorators();
BaseLocalCopyReplacementLedgerDao.SearchOne = new DaoQueryDecorators();

class CopiedRecordLedgerDao extends BaseCopiedRecordLedgerDao {
}

class CrossRepositoryRelationLedgerDao extends BaseCrossRepositoryRelationLedgerDao {
}

class LocalCopyReplacementLedgerDao extends BaseLocalCopyReplacementLedgerDao {
}

class CrossRepositoryRelationManager {
    addCopiedRecordLedger(manySideRelation, manySideEntity, copiedEntity) {
        const copiedRecordLedger = new CopiedRecordLedger();
        copiedRecordLedger.repository = manySideEntity.repository;
        copiedRecordLedger.copyAppEntity = manySideRelation.relationEntity;
        copiedRecordLedger.copyActorRecordId = copiedEntity._actorRecordId;
        copiedRecordLedger.copyActor = copiedEntity.actor;
        copiedRecordLedger.copyRepository = copiedEntity.repository;
        return copiedRecordLedger;
    }
    addRecords(manySideRelation, manySideEntity, copiedEntity) {
        let oneSideRelation;
        let oneSideDbEntity = manySideRelation.relationEntity;
        for (const oneSideEntityDbRelation of oneSideDbEntity.relations) {
            if (oneSideEntityDbRelation.oneToManyElems.mappedBy === manySideRelation.property.name) {
                oneSideRelation = oneSideEntityDbRelation;
                break;
            }
        }
        const oneSideRepositoryLedger = this.getLedger(oneSideRelation, manySideEntity);
        oneSideRepositoryLedger.repository = copiedEntity.repository;
        const manySideRepositoryLedger = this.getLedger(manySideRelation, copiedEntity);
        manySideRepositoryLedger.repository = manySideEntity.repository;
        return {
            manySideRepositoryLedger,
            oneSideRepositoryLedger
        };
    }
    getLedger(relation, relatedEntity) {
        const crossRepositoryRelationLedger = new CrossRepositoryRelationLedger();
        crossRepositoryRelationLedger.relation = relation;
        crossRepositoryRelationLedger.relatedRepository = relatedEntity.repository;
        return crossRepositoryRelationLedger;
    }
}

const application = {
    name: '@airport/flight-recorder',
    domain: {
        name: 'airport'
    }
};

const flightRecorder = app(application);
flightRecorder.register(CopiedRecordLedgerDao, LocalCopyReplacementLedgerDao, CrossRepositoryRelationLedgerDao, CrossRepositoryRelationManager);

class RepositoryLoader {
    /*
    Repository can be loaded because:
    - Repository is not present at all
    - Central: Last non-local Transaction Log timestamp is too old
    - Distributed:  Also stale timestamp but not as frequently (maybe once an hour)
    Immutable repositories are only loaded once
    */
    async loadRepository(repositoryGUID, context) {
        if (context.repositoryExistenceChecked) {
            return;
        }
        context.repositoryExistenceChecked = true;
        const repositoryLoadInfo = await this.repositoryDao.getRepositoryLoadInfo(repositoryGUID, context);
        let loadRepository = false;
        let lastSyncTimestamp = 0;
        if (!repositoryLoadInfo) {
            loadRepository = true;
        }
        else if (!repositoryLoadInfo.immutable) {
            loadRepository = true;
            for (const remoteRepositoryTransactionHistory of repositoryLoadInfo.repositoryTransactionHistory) {
                if (lastSyncTimestamp < remoteRepositoryTransactionHistory.saveTimestamp) {
                    lastSyncTimestamp = remoteRepositoryTransactionHistory.saveTimestamp;
                }
            }
        }
        if (!loadRepository) {
            return;
        }
        const now = new Date().getTime();
        const synchronizationAdapter = await this.synchronizationAdapterLoader
            .load(repositoryGUID);
        let messages;
        try {
            if (lastSyncTimestamp) {
                // If it's been less than 10 seconds, don't retrieve the repository
                if (lastSyncTimestamp >= now - 10000) {
                    return;
                }
                // Check 100 seconds back, in case there were update issues
                lastSyncTimestamp -= 100000;
                messages = await synchronizationAdapter.getTransactionsForRepository(repositoryGUID, lastSyncTimestamp);
            }
            else {
                messages = await synchronizationAdapter.getTransactionsForRepository(repositoryGUID);
            }
            // TODO: Add a special message for repository for adding users
            // into the repository 
            // each user will have a public key that they will distribute
            // each message is signed with the private key and the initial
            // message for repository is CREATE_REPOSITORY with the public 
            // key of the owner user
            const messageMapByGUID = new Map();
            for (const message of messages) {
                messageMapByGUID.set(message.data.history.GUID, message);
            }
            await this.synchronizationInManager.receiveMessages(messageMapByGUID, context);
        }
        catch (e) {
            console.error(e);
            return;
        }
    }
}

// import is reserved for Application use
class RepositoryManager {
    async createRepository(repositoryName, isPublic, context) {
        const userSession = await this.terminalSessionManager.getUserSession();
        let isInternalDomain = this.appTrackerUtils
            .isInternalDomain(context.transaction.credentials.domain);
        if (!isInternalDomain && userSession.currentRootTransaction.newRepository) {
            throw new Error(`Cannot create more than one repository per transaction:
Attempting to create a new repository and Operation Context
already contains a new repository.`);
        }
        const userAccount = isInternalDomain
            ? userSession.userAccount
            : userSession.currentTransaction.actor.userAccount;
        const repositoryGUID = context.newRepositoryGUID
            ? context.newRepositoryGUID
            : 'DEVSERVR_' + v4();
        let repository = await this.createRepositoryRecord(repositoryName, repositoryGUID, userAccount, isInternalDomain
            ? context.applicationFullName
            : userSession.currentTransaction.actor.application.fullName, isPublic, context);
        if (!context.forKeyRingRepository) {
            await this.repositoryMaintenanceManager.createRepositoryMember(repository, userAccount, true, true, true, true, context);
        }
        if (!isInternalDomain) {
            userSession.currentRootTransaction.newRepository = repository;
        }
        return repository;
    }
    async addRepositoryToKeyRing(repository, context) {
        await this.terminalSessionManager.getUserAccountFromSession();
        throw new Error(`Implement`);
    }
    async setUiEntryUri(uiEntryUri, repository, context) {
        const userSession = await this.terminalSessionManager.getUserSession();
        if (userSession.currentTransaction.actor.application.fullName !== repository.fullApplicationName) {
            throw new Error(`Only the Application that created a repository may change the uiEntityUri.`);
        }
        repository.uiEntryUri = uiEntryUri;
        await this.repositoryDao.updateUiEntityUri(repository.GUID, uiEntryUri);
    }
    goOffline() {
        throw new Error(`not implemented`);
    }
    getUpdateState(repository) {
        throw new Error(`not implemented`);
    }
    setUpdateStateForAll(updateState) {
        throw new Error(`not implemented`);
    }
    setUpdateState(repository, updateState) {
        throw new Error(`not implemented`);
    }
    async createRepositoryRecord(name, GUID, userAccount, applicationFullName, isPublic, context) {
        const repository = {
            _localId: null,
            ageSuitability: 0,
            createdAt: new Date(),
            fullApplicationName: applicationFullName,
            immutable: false,
            isLoaded: true,
            isPublic,
            name,
            owner: userAccount,
            repositoryTransactionHistory: [],
            // FIXME: propage the 
            source: 'DEVSERVR',
            uiEntryUri: null,
            GUID,
        };
        await this.repositoryDao.save(repository, context);
        return repository;
    }
    ensureRepositoryScopeOnInsertValues(repository, rawInsertValues) {
        let qEntity = rawInsertValues.INSERT_INTO;
        if (!qEntity.__driver__.dbEntity.isAirEntity) {
            return rawInsertValues;
        }
        const repositoryPropertyName = this.dictionary.AirEntity.properties.repository;
        let columns = rawInsertValues.columns.slice();
        if (columns.some((column, _index) => {
            // return column.fieldName === repositoryPropertyName
            return column.dbProperty.name === repositoryPropertyName;
        })) {
            return rawInsertValues;
        }
        columns.push(qEntity[repositoryPropertyName]);
        let VALUES = rawInsertValues.VALUES.slice();
        for (let i = 0; i < VALUES.length; i++) {
            let row = VALUES[i].slice();
            VALUES[i] = row;
            row.push(repository._localId);
        }
        return {
            INSERT_INTO: qEntity, columns, VALUES
        };
    }
    ensureRepositoryLinkOnUpdateWhere(qEntity, repository, rawUpdate) {
        if (!qEntity.__driver__.dbEntity.isAirEntity) {
            return;
        }
        return {
            UPDATE: rawUpdate.UPDATE,
            SET: rawUpdate.SET,
            WHERE: AND(rawUpdate.WHERE, qEntity.repository._localId.equals(repository._localId))
        };
    }
    ensureRepositoryScopeOnDeleteWhere(qEntity, repository, rawDelete) {
        if (!qEntity.__driver__.dbEntity.isAirEntity) {
            return;
        }
        return {
            DELETE_FROM: rawDelete.DELETE_FROM,
            WHERE: AND(rawDelete.WHERE, qEntity.repository._localId.equals(repository._localId))
        };
    }
}

class InternalRecordManager {
    async ensureApplicationRecords(application, context) {
        await this.transactionManager.transactInternal(async (_transaction, context) => {
            await this.updateDomain(application, context);
            let actorMapForDomain = this.terminalStore
                .getApplicationActorMapByDomainAndApplication_Names().get(application.domain);
            let actors;
            if (actorMapForDomain) {
                actors = actorMapForDomain.get(application.name);
                if (!actors || !actors.length) {
                    return;
                }
            }
            const frameworkActor = this.terminalStore.getFrameworkActor();
            // TODO: add request object
            const userSession = await this.terminalSessionManager.getUserSession();
            let actor = await this.actorDao
                .findOneByDomainAndApplication_Names_AccountPublicSigningKey_TerminalGUID(application.domain, application.name, userSession.userAccount.accountPublicSigningKey, frameworkActor.terminal.GUID);
            let anApplication = await this.applicationDao.findByIndex(application.lastIds.applications + 1);
            if (!actor) {
                actor = {
                    _localId: null,
                    application: anApplication,
                    terminal: frameworkActor.terminal,
                    userAccount: userSession.userAccount,
                    GUID: v4()
                };
                await this.actorDao.save(actor, context);
                actors = [actor];
            }
            const lastTerminalState = this.terminalStore.getTerminalState();
            const applications = lastTerminalState.applications.slice();
            applications.push(anApplication);
            let applicationActors = lastTerminalState.applicationActors.slice();
            applicationActors = applicationActors.concat(actors);
            this.terminalStore.state.next({
                ...lastTerminalState,
                applicationActors,
                applications
            });
        }, null, context);
    }
    async initTerminal(firstApp, context) {
        await this.transactionManager.transactInternal(async (_transaction) => {
            const userAccount = new UserAccount();
            userAccount.username = "internalUserAccount";
            userAccount.accountPublicSigningKey = v4();
            const terminal = new Terminal();
            terminal.owner = userAccount;
            terminal.isLocal = true;
            terminal.GUID = v4();
            const application = await this.applicationDao.findOneByDomain_NameAndApplication_Name(firstApp.domain, firstApp.name);
            const actor = new Actor$1();
            actor.application = application;
            actor.userAccount = userAccount;
            actor.terminal = terminal;
            actor.GUID = v4();
            const actorDao = await this.getactorDaoAsync();
            await actorDao.save(actor, context);
            const lastTerminalState = this.terminalStore.getTerminalState();
            this.terminalStore.state.next({
                ...lastTerminalState,
                frameworkActor: actor,
                terminal
            });
        }, null, context);
    }
    async updateDomain(application, context) {
        let domain = this.terminalStore.getDomainMapByName().get(application.domain);
        if (domain && this.entityStateManager.getOriginalValues(domain)) {
            return domain;
        }
        let dbDomain = await this.domainDao.findByName(application.domain);
        let updatedDomain;
        if (domain) {
            if (dbDomain) {
                this.entityStateManager.setOriginalValues(this.entityStateManager.getOriginalValues(dbDomain), domain);
                updatedDomain = domain;
            }
        }
        else {
            if (dbDomain) {
                updatedDomain = dbDomain;
            }
            else {
                updatedDomain = {
                    _localId: null,
                    name: application.domain,
                };
                await this.domainDao.save(updatedDomain, context);
            }
        }
        if (!updatedDomain) {
            return domain;
        }
        const lastTerminalState = this.terminalStore.getTerminalState();
        const domains = lastTerminalState.domains.slice();
        let replaced = false;
        for (let i = 0; i < domains.length; i++) {
            let currentDomain = domains[i];
            if (currentDomain.name === domain.name) {
                domains.splice(i, 1, domain);
                replaced = true;
            }
        }
        if (!replaced) {
            domains.push(domain);
        }
        this.terminalStore.state.next({
            ...lastTerminalState,
            domains
        });
        return updatedDomain;
    }
}

class InternalTransactionalConnector {
    constructor() {
        this.internal = true;
    }
    callApi(_) {
        throw new Error(`InternalTransactionalConnector.callApi should never be called.
Interal Application API requests should be made directly (since
they are internal to the AIRport framework).`);
    }
    async find(portableQuery, context, cachedSqlQueryId) {
        return await this.transactionalServer.find(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, cachedSqlQueryId);
    }
    async findOne(portableQuery, context, cachedSqlQueryId) {
        return await this.transactionalServer.findOne(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, cachedSqlQueryId);
    }
    search(portableQuery, context, cachedSqlQueryId) {
        return this.transactionalServer.search(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, cachedSqlQueryId);
    }
    searchOne(portableQuery, context, cachedSqlQueryId) {
        return this.transactionalServer.searchOne(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, cachedSqlQueryId);
    }
    async save(entity, context) {
        return await this.transactionalServer.save(entity, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    async saveToDestination(repositoryDestination, entity, context) {
        return await this.transactionalServer.saveToDestination(repositoryDestination, entity, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    async insertValues(portableQuery, context, ensureGeneratedValues // For internal use only
    ) {
        return await this.transactionalServer.insertValues(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        }, ensureGeneratedValues);
    }
    async insertValuesGetLocalIds(portableQuery, context) {
        return await this.transactionalServer.insertValuesGetLocalIds(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    async updateValues(portableQuery, context) {
        return await this.transactionalServer.updateValues(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    async deleteWhere(portableQuery, context) {
        return await this.transactionalServer.deleteWhere(portableQuery, this.terminalStore.getInternalConnector().internalCredentials, {
            internal: true,
            ...context
        });
    }
    onMessage(callback) {
        // Nothing to do, onMessage callback was added for demo purposes for Web implementations
    }
}
function injectTransactionalConnector() {
    console.log('Injecting TransactionalConnector');
}

// TODO: implement
class OnlineManager {
    constructor() {
        this.online = false;
    }
    async goOffline(context = {}) {
        this.repositoryManager.goOffline();
        this.online = false;
    }
    /**
     There are tree update states:
     LOCAL            0
     REMOTE_CHANGES   1
     GO_ONLINE        2
     Mutation operations of lower order type are blocked until the higher order operation finishes.
     Blocking prevents conflicts in remove transaction application.
     Go-Online logic
     1)  Flip update state to GO_ONLINE
     2)  Find the lastSyncedTransaction recorded locally
     3)  Go Online and start listening for new transactions coming in
     a) While Go-Online is in progress continue gatethering all remote transactions that come in
     and add them to remoteChangesSinceInitialGoOffline
     b) Once Go-Online finishes, when remote transactions come in
     i)  Flip update state to REMOTE_CHANGES
     ii)  Add remote transactions to local store
     iii) Flip state to LOCAL
     4)  Load from deltaStore all remote transactions since lastSyncedTransaction
     5)  Add remote transactions to local store
     6)  While there are more transactions coming in remotely:
     Add them to local store
     7)  Find all local unsynced transactions
     a)  Mark them as synchronized
     b)  add them to deltaStore
     c)  save them back in local store, now with the synched flag
     (and update db with new lastSyncedTransaction)
     8)  While there are more transactions coming in remotely:
     Add them to local store
     9)  Flip the online state to true
     Finally, always flip update state to LOCAL
     * @returns {Promise<void>}
     */
    async goOnline(context = {}) {
        // await this.transactionManager.transactInternal(async () => {
        //   try {
        //     // 1)  Flip update state to GO_ONLINE
        //     this.repositoryManager.setUpdateStateForAll(UpdateState.GO_ONLINE);
        //     // 2)  Find repositories
        //     // const repoRecords = await this.repositoryDao.findWithTransaction()
        //     const repoRecords = await this.repositoryDao.findReposWithDetailsByIds();
        //     // 3) make each repository go Online
        //     let goOnlineCalls: Promise<void>[] = [];
        //     repoRecords.forEach((repository) => {
        //       goOnlineCalls.push(this.repositoryGoOnline(
        //         repository,
        //         this.repositoryManager
        //       ));
        //     });
        //     await Promise.all(goOnlineCalls);
        //     // 9)  Flip the online state to true
        //     this.online = true;
        //   } catch (error) {
        //     // TODO: notify of error
        //     throw error;
        //   } finally {
        //     // Finally, always flip update state to LOCAL
        //     this.repositoryManager.setUpdateStateForAll(UpdateState.LOCAL);
        //   }
        // }, null, context);
    }
    // async repositoryGoOnline(
    //   repository: IRepository,
    //   repositoryManager: IRepositoryManager,
    // ): Promise<void> {
    //   let deltaStore = repositoryManager.deltaStore[repository._localId];
    //   let remoteChangesSinceInitialGoOnline = [];
    //   // 3)  Go Online and start listening for new transactions coming in
    //   await deltaStore.goOnline(async (transactions: IRepositoryTransactionHistory[]) => {
    //     if (!transactions.length) {
    //       return;
    //     }
    //     transactions = transactions.map((repoTransaction) => {
    //       repoTransaction = new RepositoryTransactionHistory(repoTransaction);
    //       // TODO: ?is the following needed?
    //       // repoTransaction.deserialize(repository)
    //       return repoTransaction;
    //     });
    //     // a) While Go-Online is in progress continue gathering all remote transactions
    //     // that come in and add them to remoteChangesSinceInitialGoOffline
    //     if (repositoryManager.getUpdateState(repository) === UpdateState.GO_ONLINE) {
    //       remoteChangesSinceInitialGoOnline.push(transactions);
    //     }
    //     // b) Once Go-Online finishes, when remote transactions come in
    //     else {
    //       try {
    //         // i)  Flip update state to REMOTE_CHANGES
    //         repositoryManager.setUpdateState(repository, UpdateState.REMOTE);
    //         // ii)  Add remote transactions to local store
    //         await this.offlineDeltaStore.addRemoteChanges(repository, transactions);
    //       } catch (error) {
    //         // TODO: notify of error
    //         throw error;
    //       } finally {
    //         // iii) Flip state to LOCAL
    //         repositoryManager.setUpdateState(repository, UpdateState.LOCAL);
    //       }
    //     }
    //   });
    //   // 4)  Load from deltaStore all remote transactions since lastSyncedTransaction
    //   let remoteChangesIter = await deltaStore.loadTransactionsSinceLastKnown(repository.lastSyncedTransaction);
    //   let remoteChanges = [];
    //   while (remoteChangesIter.hasNext()) {
    //     remoteChanges.push(remoteChangesIter.next());
    //   }
    //   // 5)  Add remote transactions to local store
    //   if (remoteChanges.length) {
    //     await this.offlineDeltaStore.addRemoteChanges(repository, remoteChanges);
    //   }
    //   // 6)  While there are more transactions coming in remotely:
    //   while (remoteChangesSinceInitialGoOnline.length) {
    //     remoteChanges = remoteChangesSinceInitialGoOnline;
    //     remoteChangesSinceInitialGoOnline = [];
    //     // Add them to local store
    //     await this.offlineDeltaStore.addRemoteChanges(repository, remoteChanges);
    //   }
    //   // 7)  Find all local unsynced transactions
    //   let unsyncedChanges = await this.repositoryTransactionHistoryDao
    //     .findUnsyncedTransactions(repository);
    //   if (unsyncedChanges.length) {
    //     unsyncedChanges.forEach((transaction) => {
    //       // a)  Mark them as synchronized
    //       transaction.syncStatus = BlockSyncStatus.SYNCHRONIZED;
    //     });
    //     // b)  add them to deltaStore
    //     await deltaStore.addChanges(deltaStore.config.changeListConfig, unsyncedChanges);
    //     // c)  save them back in local store, now with the synched flag
    //     // (and update db with new lastSyncedTransaction)
    //     await this.offlineDeltaStore.markChangesAsSynced(repository, null);
    //   }
    //   // 	8)  While there are more transactions coming in remotely:
    //   // Add them to local store
    //   while (remoteChangesSinceInitialGoOnline.length) {
    //     remoteChanges = remoteChangesSinceInitialGoOnline;
    //     remoteChangesSinceInitialGoOnline = [];
    //     await this.offlineDeltaStore.addRemoteChanges(repository, remoteChanges);
    //   }
    //   // 9)  Flip the online state to true
    //   this.online = true;
    // }
    isOnline(context = {}) {
        return this.online;
    }
}

class TransactionalReceiver {
    constructor() {
        this.WITH_ID = {};
    }
    async processMessage(message) {
        let result;
        let errorMessage;
        try {
            const isInternalDomain = await this.appTrackerUtils
                .isInternalDomain(message.domain);
            if (isInternalDomain) {
                throw new Error(`Internal domains cannot be used in external calls`);
            }
            let credentials = {
                application: message.application,
                domain: message.domain,
                methodName: message.methodName,
                objectName: message.objectName,
                transactionId: message.transactionId
            };
            let context = {};
            context.startedAt = new Date();
            const { theErrorMessage, theResult } = await this.doProcessMessage(message, credentials, context);
            errorMessage = theErrorMessage;
            result = theResult;
        }
        catch (error) {
            console.error(error);
            result = null;
            errorMessage = error.message;
        }
        return {
            application: message.application,
            category: 'FromDb',
            domain: message.domain,
            errorMessage,
            id: message.id,
            type: message.type,
            result
        };
    }
    async doProcessMessage(message, credentials, context) {
        let theErrorMessage = null;
        let theResult = null;
        switch (message.type) {
            case IsolateMessageType.APP_INITIALIZING:
                let initConnectionMessage = message;
                const application = initConnectionMessage.jsonApplication;
                const fullApplication_Name = this.dbApplicationUtils.
                    getApplication_FullName(application);
                const messageApplication_FullName = this.dbApplicationUtils.
                    getApplication_FullNameFromDomainAndName(message.domain, message.application);
                if (fullApplication_Name !== messageApplication_FullName) {
                    theResult = null;
                    break;
                }
                if (this.terminalStore.getReceiver().initializingApps
                    .has(fullApplication_Name)) {
                    return {
                        theErrorMessage,
                        theResult
                    };
                }
                this.terminalStore.getReceiver().initializingApps
                    .add(fullApplication_Name);
                // FIXME: initalize ahead of time, at Isolate Loading
                await this.databaseManager.initFeatureApplications({}, [application]);
                await this.internalRecordManager.ensureApplicationRecords(application, {});
                theResult = application.lastIds;
                break;
            case IsolateMessageType.APP_INITIALIZED:
                const initializedApps = this.terminalStore.getReceiver().initializedApps;
                initializedApps.add(message.fullApplication_Name);
                return {
                    theErrorMessage,
                    theResult
                };
            case IsolateMessageType.GET_LATEST_APPLICATION_VERSION_BY_APPLICATION_NAME: {
                theResult = this.terminalStore.getLatestApplicationVersionMapByApplication_FullName()
                    .get(message.fullApplication_Name);
                break;
            }
            case IsolateMessageType.RETRIEVE_DOMAIN: {
                theResult = this.terminalStore.getDomainMapByName()
                    .get(message.domain);
                break;
            }
            case IsolateMessageType.DELETE_WHERE:
                const deleteWhereMessage = message;
                theResult = await this.transactionalServer.deleteWhere(deleteWhereMessage.portableQuery, credentials, context);
                break;
            case IsolateMessageType.FIND:
                const findMessage = message;
                theResult = await this.transactionalServer.find(findMessage.portableQuery, credentials, {
                    ...context,
                    repository: findMessage.repository
                });
                break;
            case IsolateMessageType.FIND_ONE:
                const findOneMessage = message;
                theResult = await this.transactionalServer.findOne(findOneMessage.portableQuery, credentials, {
                    ...context,
                    repository: findOneMessage.repository,
                });
                break;
            case IsolateMessageType.INSERT_VALUES:
                const insertValuesMessage = message;
                theResult = await this.transactionalServer.insertValues(insertValuesMessage.portableQuery, credentials, context);
                break;
            case IsolateMessageType.INSERT_VALUES_GET_IDS:
                const insertValuesGetIdsMessage = message;
                theResult = await this.transactionalServer.insertValuesGetLocalIds(insertValuesGetIdsMessage.portableQuery, credentials, context);
                break;
            case IsolateMessageType.SAVE:
            case IsolateMessageType.SAVE_TO_DESTINATION: {
                const saveMessage = message;
                if (!saveMessage.dbEntity) {
                    theErrorMessage = `DbEntity id was not passed in`;
                    break;
                }
                const dbEntityId = saveMessage.dbEntity._localId;
                const dbEntity = this.terminalStore.getAllEntities()[dbEntityId];
                if (!dbEntity) {
                    theErrorMessage = `Could not find DbEntity with Id ${dbEntityId}`;
                    break;
                }
                context.dbEntity = dbEntity;
                if (message.type === IsolateMessageType.SAVE) {
                    theResult = await this.transactionalServer.save(saveMessage.entity, credentials, context);
                }
                else {
                    const saveToDestinationMessage = message;
                    theResult = await this.transactionalServer.saveToDestination(saveToDestinationMessage.repositoryDestination, saveToDestinationMessage.entity, credentials, context);
                }
                break;
            }
            case IsolateMessageType.SEARCH:
                const searchMessage = message;
                theResult = await this.transactionalServer.search(searchMessage.portableQuery, credentials, {
                    ...context,
                    repository: searchMessage.repository,
                });
                break;
            case IsolateMessageType.SEARCH_ONE:
                const searchOneMessage = message;
                theResult = await this.transactionalServer.search(searchOneMessage.portableQuery, credentials, {
                    ...context,
                    repository: searchOneMessage.repository,
                });
                break;
            case IsolateMessageType.UPDATE_VALUES:
                const updateValuesMessage = message;
                theResult = await this.transactionalServer.updateValues(updateValuesMessage.portableQuery, credentials, context);
                break;
            default:
                // Unexpected IsolateMessageInType
                return {
                    theErrorMessage,
                    theResult
                };
        }
        return {
            theErrorMessage,
            theResult,
        };
    }
    async startApiCall(message, context, nativeHandleCallback) {
        const transactionCredentials = {
            application: message.application,
            domain: message.domain,
            methodName: message.methodName,
            objectName: message.objectName,
            transactionId: message.transactionId
        };
        if (!await this.transactionalServer
            .startTransaction(transactionCredentials, context)) {
            return {
                isStarted: false
            };
        }
        let actor = await this.getApiCallActor(message, context);
        const initiator = context.transaction.initiator;
        initiator.application = message.application;
        initiator.domain = message.domain;
        initiator.methodName = message.methodName;
        initiator.objectName = message.objectName;
        let isFramework = true;
        try {
            const isInternalDomain = await this.appTrackerUtils
                .isInternalDomain(message.domain);
            if (!isInternalDomain) {
                isFramework = false;
                await this.doNativeHandleCallback(message, actor, context, nativeHandleCallback);
            }
        }
        catch (e) {
            context.errorMessage = e.message;
            this.transactionalServer.rollback(transactionCredentials, context);
            return {
                isStarted: false
            };
        }
        return {
            isFramework,
            isStarted: true
        };
    }
    async doNativeHandleCallback(message, actor, context, nativeHandleCallback) {
        message.transactionId = context.transaction.id;
        message.actor = {
            ...this.WITH_ID,
            application: actor.application,
            GUID: actor.GUID,
            terminal: {
                ...this.WITH_ID,
                GUID: actor.terminal.GUID
            },
            userAccount: {
                ...this.WITH_ID,
                accountPublicSigningKey: actor.userAccount.accountPublicSigningKey,
                username: actor.userAccount.username
            }
        };
        await nativeHandleCallback();
    }
    async getApiCallActor(message, context) {
        let actor;
        const userSession = await this.terminalSessionManager.getUserSession();
        try {
            const isInternalDomain = await this.appTrackerUtils
                .isInternalDomain(message.domain);
            if (isInternalDomain
                && context.transaction.parentTransaction) {
                actor = context.transaction.parentTransaction.actor;
                return actor;
            }
            const terminal = this.terminalStore.getTerminal();
            actor = await this.actorDao.findOneByDomainAndApplication_Names_AccountPublicSigningKey_TerminalGUID(message.domain, message.application, userSession.userAccount.accountPublicSigningKey, terminal.GUID);
            if (actor) {
                return actor;
            }
            const application = await this.applicationDao.findOneByDomain_NameAndApplication_Name(message.domain, message.application);
            actor = {
                _localId: null,
                application,
                GUID: v4(),
                terminal: terminal,
                userAccount: userSession.userAccount
            };
            await this.actorDao.save(actor, context);
            return actor;
        }
        finally {
            context.transaction.actor = actor;
            userSession.currentTransaction = context.transaction;
        }
    }
    async endApiCall(credentials, errorMessage, context) {
        try {
            if (errorMessage) {
                return await this.transactionalServer.rollback(credentials, context);
            }
            else {
                return await this.transactionalServer.commit(credentials, context);
            }
        }
        finally {
            const userSession = await this.terminalSessionManager.getUserSession();
            userSession.currentTransaction = context.transaction;
        }
    }
}

/**
 * Keeps track of transactions, per client and validates that a given
 * transaction belongs to the provided client.  If the connection
 * information matches, passes the transaction for handling.
 *
 * All transactions are queued.  Read operations are not blocked while
 * any transaction is in progress.  Best way to make sure that you get
 * the latest state is to subscribe to a query, which is guaranteed to
 * be updated after data has changed.
 *
 *
 * Should read operations be blocked while transactions are in process?
 * Probably not since they will just get snapshot of the state at any
 * given point in time and transactionality takes care of not exposing
 * inconsistent state.  There doesn't appear to be a need to que-up
 * read transactions, since SqLite can handle it:
 *
 * https://www.skoumal.net/en/parallel-read-and-write-in-sqlite/
 *
 * Also, there doesn't appear to be a reason to prioritize remote transactions
 * over local ones, since ultimately the state needs to sync either way.
 * A single transactional queue should be enough.
 *
 */
class TransactionalServer {
    async init(context = {}) {
        return await this.transactionManager.initialize('airport', context);
    }
    async find(portableQuery, credentials, context, cachedSqlQueryId) {
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        return await this.queryManager.find(portableQuery, context, cachedSqlQueryId);
    }
    async findOne(portableQuery, credentials, context, cachedSqlQueryId) {
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        return await this.queryManager.findOne(portableQuery, context, cachedSqlQueryId);
    }
    search(portableQuery, credentials, context, cachedSqlQueryId) {
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        return this.queryManager.search(portableQuery, context);
    }
    searchOne(portableQuery, credentials, context, cachedSqlQueryId) {
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        return this.queryManager.searchOne(portableQuery, context);
    }
    async startTransaction(credentials, context) {
        try {
            await this.transactionManager.startTransaction(credentials, context);
            return true;
        }
        catch (e) {
            context.errorMessage = e.message;
            console.error(e);
            return false;
        }
    }
    async commit(credentials, context) {
        try {
            await this.transactionManager.commit(credentials, context);
            return true;
        }
        catch (e) {
            console.error(e);
            context.errorMessage = e.message;
            return false;
        }
    }
    async rollback(credentials, context) {
        try {
            await this.transactionManager.rollback(credentials, context);
            return true;
        }
        catch (e) {
            console.error(e);
            context.errorMessage = e.message;
            return false;
        }
    }
    async save(entity, credentials, context) {
        if (!entity) {
            return null;
        }
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        const actor = await this.getActor(credentials);
        context.actor = actor;
        let saveResult;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            saveResult = await this.operationManager.performSave(entity, actor, transaction, context.rootTransaction, context);
        }, credentials, context);
        return saveResult;
    }
    async saveToDestination(repositoryDestination, entity, credentials, context) {
        if (!entity) {
            return null;
        }
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        const actor = await this.getActor(credentials);
        context.actor = actor;
        let saveResult;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            // TODO: save to serialized repository to the specified destination
            saveResult = await this.operationManager.performSave(entity, actor, transaction, context.rootTransaction, context);
        }, credentials, context);
        return saveResult;
    }
    async insertValues(portableQuery, credentials, context, ensureGeneratedValues // for internal use only
    ) {
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        const actor = await this.getActor(credentials);
        let numInsertedRecords;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            numInsertedRecords = await this.insertManager.insertValues(portableQuery, actor, transaction, context.rootTransaction, context, ensureGeneratedValues);
        }, credentials, context);
        return numInsertedRecords;
    }
    async insertValuesGetLocalIds(portableQuery, credentials, context) {
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        const actor = await this.getActor(credentials);
        let _localIds;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            _localIds = await this.insertManager.insertValuesGetLocalIds(portableQuery, actor, transaction, context.rootTransaction, context);
        }, credentials, context);
        return _localIds;
    }
    async updateValues(portableQuery, credentials, context) {
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        const actor = await this.getActor(credentials);
        let numUpdatedRecords;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            numUpdatedRecords = await this.updateManager.updateValues(portableQuery, actor, transaction, context.rootTransaction, context);
        }, credentials, context);
        return numUpdatedRecords;
    }
    async deleteWhere(portableQuery, credentials, context) {
        if (context.transaction || credentials.transactionId) {
            this.transactionManager.getTransactionFromContextOrCredentials(credentials, context);
        }
        const actor = await this.getActor(credentials);
        let numDeletedRecords;
        await this.transactionManager.transactInternal(async (transaction, context) => {
            numDeletedRecords = await this.deleteManager.deleteWhere(portableQuery, actor, transaction, context.rootTransaction, context);
        }, credentials, context);
        return numDeletedRecords;
    }
    async getActor(credentials) {
        if (this.tempActor) {
            return this.tempActor;
        }
        if (this.appTrackerUtils.isInternalDomain(credentials.domain)) {
            return this.terminalStore.getFrameworkActor();
        }
        const transaction = this.terminalStore.getTransactionManager()
            .transactionInProgressMap.get(credentials.transactionId);
        if (!transaction) {
            throw new Error('Could not find transaction by Id: ' + credentials.transactionId);
        }
        const actor = transaction.actor;
        if (!actor) {
            throw new Error('No actor associated with transaction Id: ' + credentials.transactionId);
        }
        return actor;
    }
}
function injectTransactionalServer() {
    console.log('Injecting TransactionalServer');
}

class AbstractMutationManager {
    getPortableQuery(applicationIndex, tableIndex, query, queryResultType) {
        return {
            applicationIndex,
            tableIndex,
            jsonQuery: query.toJSON(this.queryUtils, this.fieldUtils, this.relationManager),
            parameterMap: query.getParameters(),
            queryResultType,
            trackedRepoGUIDs: Array.from(query.trackedRepoGUIDSet),
            trackedRepoLocalIds: Array.from(query.trackedRepoLocalIdSet)
        };
    }
    async doInsertValues(transaction, q, entities, context) {
        const dbEntity = q.__driver__.dbEntity;
        const columnIndexes = [];
        const columnValueLookups = [];
        for (const dbProperty of dbEntity.properties) {
            let columnValueLookup = {
                name: dbProperty.name,
                nested: null,
            };
            if (dbProperty.relation && dbProperty.relation.length) {
                const dbRelation = dbProperty.relation[0];
                this.applicationUtils.forEachColumnTypeOfRelation(dbRelation, (dbColumn, propertyNameChains) => {
                    if (columnIndexes[dbColumn.index]) {
                        return;
                    }
                    columnIndexes[dbColumn.index] = dbColumn.index;
                    columnValueLookups[dbColumn.index] = columnValueLookup;
                    const firstPropertyNameChain = propertyNameChains[0];
                    for (let i = 1; i < firstPropertyNameChain.length; i++) {
                        const propertyName = firstPropertyNameChain[i];
                        const nextColumnValueLookup = {
                            name: propertyName,
                            nested: null,
                        };
                        columnValueLookup.nested = nextColumnValueLookup;
                        columnValueLookup = nextColumnValueLookup;
                    }
                });
            }
            else {
                const dbColumn = dbProperty.propertyColumns[0].column;
                if (columnIndexes[dbColumn.index]) {
                    continue;
                }
                columnIndexes[dbColumn.index] = dbColumn.index;
                columnValueLookups[dbColumn.index] = columnValueLookup;
            }
        }
        const VALUES = entities.map(entity => {
            return columnValueLookups.map(lookup => {
                let value = entity[lookup.name];
                while (lookup.nested) {
                    if (!(value instanceof Object)) {
                        break;
                    }
                    lookup = lookup.nested;
                    value = value[lookup.name];
                }
                return value === undefined ? null : value;
            });
        });
        const rawInsertValues = {
            INSERT_INTO: q,
            columns: null,
            VALUES
        };
        let insertValues = new InsertValues(rawInsertValues, columnIndexes);
        let portableQuery = this.getPortableQuery(dbEntity.applicationVersion.application.index, dbEntity.index, insertValues, null);
        return await transaction.insertValues(portableQuery, context);
    }
}

class DatabaseManager {
    constructor() {
        this.initialized = false;
    }
    async initNoDb(context, ...applications) {
        this.airportDatabase.load();
        this.transactionalServer.tempActor = new Actor$1();
        await this.installStarterApplication(true, false, context);
        await this.applicationInitializer.stage(applications, context);
        this.transactionalServer.tempActor = null;
        this.initialized = true;
    }
    async initWithDb(domainName, context) {
        this.airportDatabase.load();
        this.transactionalServer.tempActor = new Actor$1();
        await this.transactionManager.transactInternal(async (_transaction, context) => {
            const firstApp = BLUEPRINT[0];
            const hydrate = await this.storeDriver.doesTableExist(this.dbApplicationUtils
                .getApplication_FullName(firstApp), 'PACKAGES', context);
            await this.installStarterApplication(false, hydrate, context);
            if (!hydrate) {
                await this.internalRecordManager.initTerminal(firstApp, context);
            }
            this.transactionalServer.tempActor = null;
            this.initialized = true;
        }, null, {
            doNotRecordHistory: true
        });
    }
    isInitialized() {
        return this.initialized;
    }
    async initFeatureApplications(context, jsonApplications) {
        const applications = await this.applicationDao.findAllWithJson();
        const existingApplicationMap = new Map();
        for (const application of applications) {
            existingApplicationMap.set(application.fullName, application);
        }
        const applicationsToCreate = [];
        for (const jsonApplication of jsonApplications) {
            const existingApplication = existingApplicationMap.get(this.dbApplicationUtils
                .getApplication_FullName(jsonApplication));
            if (existingApplication) {
                jsonApplication.lastIds =
                    existingApplication.versions[0].jsonApplication.lastIds;
            }
            else {
                applicationsToCreate.push(jsonApplication);
            }
        }
        this.transactionalServer.tempActor = new Actor$1();
        await this.applicationInitializer.initialize(applicationsToCreate, context, true, true, true);
        this.transactionalServer.tempActor = null;
    }
    async installStarterApplication(stage, hydrate, context) {
        const schemasDefinitions = await Promise.resolve().then(function () { return index; });
        const schemas = schemasDefinitions.BLUEPRINT;
        if (stage) {
            await this.applicationInitializer.stage(schemas, context);
        }
        else if (hydrate) {
            await this.applicationInitializer.hydrate(schemas, context);
        }
        else {
            await this.applicationInitializer.initialize(schemas, context, false, false, false);
        }
    }
}

class DeleteManager {
    async deleteWhere(portableQuery, actor, transaction, rootTransaction, context) {
        const dbEntity = this.airportDatabase
            .applications[portableQuery.applicationIndex].currentVersion[0].applicationVersion
            .entities[portableQuery.tableIndex];
        const deleteCommand = transaction.deleteWhere(portableQuery, context);
        if (dbEntity.isLocal || transaction.isSync) {
            return await deleteCommand;
        }
        const selectCascadeTree = this.getCascadeSubTree(dbEntity);
        const jsonDelete = portableQuery.jsonQuery;
        const jsonSelect = {
            S: selectCascadeTree,
            F: [jsonDelete.DF],
            W: jsonDelete.W,
        };
        const portableSelect = {
            applicationIndex: portableQuery.applicationIndex,
            tableIndex: portableQuery.tableIndex,
            jsonQuery: jsonSelect,
            queryResultType: QueryResultType.ENTITY_TREE,
            parameterMap: portableQuery.parameterMap,
            // values: portableQuery.values,
        };
        const treesToDelete = await transaction
            .find(portableSelect, {}, context);
        const recordsToDelete = new Map();
        const repositoryIdSet = new Set();
        for (const treeToDelete of treesToDelete) {
            this.recordRepositoryIds(treeToDelete, dbEntity, recordsToDelete, repositoryIdSet, this.applicationUtils);
        }
        await this.recordTreeToDelete(recordsToDelete, actor, transaction, rootTransaction, context);
        return await deleteCommand;
    }
    recordRepositoryIds(treeToDelete, dbEntity, recordsToDelete, repositoryIdSet, applicationUtils) {
        const repositoryId = treeToDelete.repository._localId;
        repositoryIdSet.add(repositoryId);
        const recordsToDeleteForApplication = this.datastructureUtils.ensureChildJsMap(recordsToDelete, dbEntity.applicationVersion.application.index);
        const recordsToDeleteForTable = this.datastructureUtils.ensureChildJsMap(recordsToDeleteForApplication, dbEntity.index);
        const recordsToDeleteForRepository = this.datastructureUtils.ensureChildArray(recordsToDeleteForTable, repositoryId);
        const recordToDelete = {};
        // FIXME: implement
        recordsToDeleteForRepository.push(recordToDelete);
        for (const dbProperty of dbEntity.properties) {
            if (dbProperty.relation && dbProperty.relation.length) {
                if (!treeToDelete[dbProperty.name]) {
                    continue;
                }
                const dbRelation = dbProperty.relation[0];
                switch (dbRelation.relationType) {
                    case EntityRelationType.MANY_TO_ONE:
                        applicationUtils.forEachColumnOfRelation(dbRelation, treeToDelete, (dbColumn, value, propertyNameChains) => {
                            this.columnProcessed(dbProperty, recordToDelete, dbColumn, value);
                        }, false);
                        break;
                    case EntityRelationType.ONE_TO_MANY:
                        if (!dbRelation.oneToManyElems) {
                            continue;
                        }
                        let childTrees = treeToDelete[dbRelation.property.name];
                        if (childTrees && childTrees.length) {
                            const childDbEntity = dbRelation.relationEntity;
                            childTrees.forEach(childTree => {
                                this.recordRepositoryIds(childTree, childDbEntity, recordsToDelete, repositoryIdSet, applicationUtils);
                            });
                        }
                        break;
                    default:
                        throw new Error(`Unknown relation type: '${dbRelation.relationType}' 
							on '${dbEntity.name}.${dbRelation.property.name}'.`);
                }
            }
            else {
                const value = treeToDelete[dbProperty.name];
                if (value === null || value === undefined) {
                    continue;
                }
                this.columnProcessed(dbProperty, recordToDelete, dbProperty.propertyColumns[0].column, value);
            }
        }
    }
    /*
     Values for the same column could be repeated in different places in the object graph.
     For example, if the same column is mapped to two different @ManyToOne relations.
     In this case, when persisting an entity we need to make sure that all values for the
     entity in question are being persisted.
     */
    columnProcessed(dbProperty, foundValues, dbColumn, value) {
        // if (value === undefined) {
        // 	throw new Error(`Values cannot be undefined, please use null.`_;
        // }
        if (foundValues[dbColumn.name] === undefined) {
            foundValues[dbColumn.name] = value;
            return false;
        }
        if (!this.utils.valuesEqual(foundValues[dbColumn.name], value)) {
            throw new Error(`Found value mismatch in '${dbProperty.entity.name}.${dbProperty.name}'
			(column: '${dbColumn.name}'): ${foundValues[dbColumn.name]} !== ${value}`);
        }
        return true;
    }
    async recordTreeToDelete(recordsToDelete, actor, transaction, rootTransaction, context) {
        let systemWideOperationId;
        for (const [applicationIndex, applicationRecordsToDelete] of recordsToDelete) {
            for (const [entityIndex, entityRecordsToDelete] of applicationRecordsToDelete) {
                const dbEntity = this.airportDatabase.applications[applicationIndex].currentVersion[0]
                    .applicationVersion.entities[entityIndex];
                if (!systemWideOperationId) {
                    systemWideOperationId = await this.systemWideOperationIdUtils.getSysWideOpId();
                }
                for (const [repositoryId, entityRecordsToDeleteForRepo] of entityRecordsToDelete) {
                    const repositoryTransactionHistory = await this.historyManager.getRepositoryTransactionHistory(transaction.transactionHistory, repositoryId, actor, context);
                    const operationHistory = this.repositoryTransactionHistoryDuo.startOperation(repositoryTransactionHistory, systemWideOperationId, ChangeType.DELETE_ROWS, dbEntity, rootTransaction);
                    for (const recordToDelete of entityRecordsToDeleteForRepo) {
                        const recordHistory = this.operationHistoryDuo.startRecordHistory(operationHistory, recordToDelete.actor._localId, recordToDelete._actorRecordId);
                        for (const dbProperty of dbEntity.properties) {
                            if (dbProperty.relation && dbProperty.relation.length) {
                                const dbRelation = dbProperty.relation[0];
                                switch (dbRelation.relationType) {
                                    case EntityRelationType.MANY_TO_ONE:
                                        this.applicationUtils.forEachColumnOfRelation(dbRelation, recordToDelete, (dbColumn, value, propertyNameChains) => {
                                            switch (dbColumn.name) {
                                                // Do not add Actor or Repository the are recorded
                                                // at record history level
                                                case this.dictionary.AirEntity.columns.ACTOR_LID:
                                                case this.dictionary.AirEntity.columns.REPOSITORY_LID:
                                                    break;
                                                default:
                                                    this.recordHistoryDuo.addOldValue(recordHistory, dbColumn, value);
                                            }
                                        });
                                        break;
                                    case EntityRelationType.ONE_TO_MANY:
                                        // One-To-Many do not contain any columns in source entity
                                        break;
                                    default:
                                        throw new Error(`Unknown relation type: '${dbRelation.relationType}'
										on '${dbEntity.name}.${dbProperty.name}'.`);
                                }
                            }
                            else {
                                const dbColumn = dbProperty.propertyColumns[0].column;
                                this.recordHistoryDuo
                                    .addOldValue(recordHistory, dbColumn, recordToDelete[dbProperty.name]);
                            }
                        }
                    }
                }
            }
        }
    }
    getCascadeSubTree(dbEntity, selectClause = {}) {
        for (const dbProperty of dbEntity.properties) {
            let dbRelation;
            if (dbProperty.relation && dbProperty.relation.length) {
                dbRelation = dbProperty.relation[0];
            }
            if (dbRelation) {
                switch (dbRelation.relationType) {
                    case EntityRelationType.ONE_TO_MANY:
                        if (!dbRelation.oneToManyElems) {
                            continue;
                        }
                        const subTree = {};
                        selectClause[dbProperty.name] = subTree;
                        this.getCascadeSubTree(dbRelation.relationEntity, subTree);
                        break;
                    case EntityRelationType.MANY_TO_ONE:
                        this.applicationUtils.addRelationToEntitySelectClause(dbRelation, selectClause);
                        break;
                    default:
                        throw new Error(`Unknown relation type: '${dbRelation.relationType}' 
							on '${dbEntity.name}.${dbProperty.name}'.`);
                }
            }
            else {
                selectClause[dbProperty.name] = Y;
            }
        }
        return selectClause;
    }
}

class HistoryManager {
    async getNewTransactionHistory(transactionType = TransactionType.LOCAL) {
        return await this.transactionHistoryDuo.getNewRecord(transactionType);
    }
    async getRepositoryTransactionHistory(transactionHistory, repositoryLocalId, actor, context) {
        let isRepositoryCreation = false;
        let isPublic = false;
        const newRepository = context.rootTransaction.newRepository;
        if (newRepository) {
            isRepositoryCreation = true;
            isPublic = newRepository.isPublic;
        }
        return await this.transactionHistoryDuo.getRepositoryTransaction(transactionHistory, repositoryLocalId, actor, isRepositoryCreation, isPublic);
    }
}

class InsertManager {
    async insertValues(portableQuery, actor, transaction, rootTransaction, context, ensureGeneratedValues) {
        return await this.internalInsertValues(portableQuery, actor, transaction, rootTransaction, context, false, ensureGeneratedValues);
    }
    async insertValuesGetLocalIds(portableQuery, actor, transaction, rootTransaction, context) {
        return await this.internalInsertValues(portableQuery, actor, transaction, rootTransaction, context, true);
    }
    verifyNoGeneratedColumns(dbEntity, jsonInsertValues, errorPrefix) {
        for (let i = 0; i < jsonInsertValues.C.length; i++) {
            const columnIndex = jsonInsertValues.C[i];
            const dbColumn = dbEntity.columns[columnIndex];
            if (dbColumn.isGenerated) {
                throw new Error(errorPrefix +
                    `You cannot explicitly insert into a @GeneratedValue column '${dbColumn.name}'`);
            }
        }
        return dbEntity.columns.filter(dbColumn => dbColumn.isGenerated);
    }
    async internalInsertValues(portableQuery, actor, transaction, rootTransaction, context, getIds = false, ensureGeneratedValues = true) {
        const dbEntity = this.airportDatabase.applications[portableQuery.applicationIndex]
            .currentVersion[0].applicationVersion.entities[portableQuery.tableIndex];
        const errorPrefix = `Error inserting into '${dbEntity.name}'.'
`;
        this.validateValueRowLength(portableQuery, errorPrefix);
        const jsonInsertValues = portableQuery.jsonQuery;
        const columnIndexSet = {};
        let inStatementIndex = 0;
        for (const columnIndex of jsonInsertValues.C) {
            if (columnIndex < 0 || columnIndex >= dbEntity.columns.length) {
                throw new Error(errorPrefix +
                    `Invalid column index: ${columnIndex}`);
            }
            if (columnIndexSet[columnIndex]) {
                throw new Error(errorPrefix +
                    `Column ${dbEntity.name}.${dbEntity.columns[columnIndex].name} 
appears more than once in the Columns clause`);
            }
            let rowNumber = 1;
            for (let row of jsonInsertValues.V) {
                if (row[inStatementIndex] === undefined) {
                    throw new Error(errorPrefix +
                        `
	'undefined' value in column ${dbEntity.name}.${dbEntity.columns[columnIndex].name} of row ${rowNumber}.
	All values in an insert statment must either be null or have a non-null value.`);
                }
                rowNumber++;
            }
            inStatementIndex++;
            columnIndexSet[columnIndex] = true;
        }
        let columnsToPopulate;
        const insertValues = portableQuery.jsonQuery;
        if (dbEntity.isAirEntity) {
            columnsToPopulate = this.ensureAirEntityIdValues(actor, dbEntity, insertValues, errorPrefix, transaction, context);
        }
        let generatedColumns;
        if (!transaction.isSync || context.generateOnSync) {
            generatedColumns = this.verifyNoGeneratedColumns(dbEntity, portableQuery.jsonQuery, errorPrefix);
        }
        let _localIds;
        let systemWideOperationId;
        if (!dbEntity.isLocal) {
            systemWideOperationId = await this.systemWideOperationIdUtils
                .getSysWideOpId();
        }
        if ((!transaction.isSync || context.generateOnSync) && ensureGeneratedValues) {
            _localIds = await this.ensureGeneratedValues(dbEntity, insertValues, actor, columnsToPopulate, generatedColumns, systemWideOperationId, errorPrefix);
        }
        if (!dbEntity.isLocal && !transaction.isSync) {
            await this.addInsertHistory(dbEntity, portableQuery, actor, systemWideOperationId, transaction, rootTransaction, context);
        }
        const numberOfInsertedRecords = await transaction.insertValues(portableQuery, context);
        return getIds ? _localIds : numberOfInsertedRecords;
    }
    async validateValueRowLength(portableQuery, errorPrefix) {
        const values = portableQuery.jsonQuery.V;
        if (!values.length) {
            throw new Error(errorPrefix + `no colum values provided`);
        }
        const firstValuesRow = values[0];
        if (!firstValuesRow || !firstValuesRow.length) {
            throw new Error(errorPrefix + `First row has no values`);
        }
        const numValuesInRow = firstValuesRow.length;
        for (let i = 0; i < values.length; i++) {
            const valuesRow = values[i];
            if (valuesRow.length !== numValuesInRow) {
                throw new Error(errorPrefix + `First row has ${numValuesInRow} values,
	while row ${i + 1} has ${valuesRow.length} values`);
            }
        }
    }
    async ensureGeneratedValues(dbEntity, jsonInsertValues, actor, columnsToPopulate, generatedColumns, systemWideOperationId, errorPrefix) {
        const values = jsonInsertValues.V;
        const idColumns = dbEntity.idColumns;
        const allIds = [];
        for (const _entityValues of values) {
            allIds.push([]);
        }
        let actorIdColumn;
        let sysWideOperationIdColumn;
        if (!dbEntity.isLocal) {
            actorIdColumn = columnsToPopulate.actorIdColumn;
            sysWideOperationIdColumn = columnsToPopulate.sysWideOperationIdColumn;
        }
        for (const idColumn of idColumns) {
            if (idColumn.isGenerated) {
                continue;
            }
            let isActorIdColumn = false;
            let inStatementColumnIndex;
            const matchingColumns = jsonInsertValues.C.filter((columnIndex, index) => {
                if (columnIndex === idColumn.index) {
                    inStatementColumnIndex = index;
                    return true;
                }
            });
            if (matchingColumns.length < 1) {
                // Actor Id cannot be in the insert statement
                if (idColumn._localId === actorIdColumn._localId) {
                    isActorIdColumn = true;
                    inStatementColumnIndex = jsonInsertValues.C.length;
                    jsonInsertValues.C.push(actorIdColumn.index);
                }
                else {
                    throw new Error(errorPrefix +
                        `Could not find @Id column ${dbEntity.name}.${idColumn.name} in
					the insert statement.  Non-generated @Id columns must be present in the Insert
					statement (with exception of Actor ID).`);
                }
            }
            for (let i = 0; i < values.length; i++) {
                const entityValues = values[i];
                const idValues = allIds[i];
                let idValue;
                if (isActorIdColumn) {
                    idValue = actor._localId;
                }
                else {
                    idValue = entityValues[inStatementColumnIndex];
                    if (!idValue && idValue !== 0) {
                        throw new Error(errorPrefix +
                            `No value provided on insert for @Id '${dbEntity.name}.${idColumn.name}'.`);
                    }
                }
                idValues[idColumn.index] = idValue;
            }
        }
        // if (dbEntity.isAirEntity) {
        // 	const repositoryColumn  = dbEntity.columnMap[airEntity.FOREIGN_KEY]
        // 	const repositoryIdIndex = repositoryColumn.index
        // 	for (const entityValues of values) {
        // 		const repositoryId = entityValues[repositoryIdIndex]
        // 		if (!repositoryId && repositoryId !== 0) {
        // 			throw new Error(`@Column({ name: 'REPOSITORY_LID'}) value is not specified on
        // insert for '${dbEntity0.name}.${repositoryColumn.name}'.`) } } }
        const generatedColumnIndexes = [];
        // let numAddedColumns                    = 0
        for (const generatedColumn of generatedColumns) {
            // const matchingColumns = jsonInsertValues.C.filter(
            // 	columnIndex => columnIndex === generatedColumn.index)
            // if (!matchingColumns.length) {
            // TODO: verify that it is OK to mutate the JsonInsertValues query
            jsonInsertValues.C.length;
            generatedColumnIndexes.push(jsonInsertValues.C.length);
            jsonInsertValues.C.push(generatedColumn.index);
            // numAddedColumns++
            continue;
        }
        // Populating generated values AFTER the checks
        // to not waste sequence numbers on invalid input
        // (thus reducing storage requirements in SqLite)
        const numSequencesNeeded = generatedColumns.map(_ => values.length);
        const generatedSequenceValues = await this.sequenceGenerator.generateSequenceNumbers(generatedColumns, numSequencesNeeded);
        generatedColumns.forEach((dbColumn, generatedColumnIndex) => {
            const generatedColumnSequenceValues = generatedSequenceValues[generatedColumnIndex];
            const insertColumnIndex = generatedColumnIndexes[generatedColumnIndex];
            // const columnIndex                   = dbColumn.index
            values.forEach((entityValues, index) => {
                const generatedValue = generatedColumnSequenceValues[index];
                entityValues[insertColumnIndex] = generatedValue;
                allIds[index][dbColumn.index] = generatedValue;
            });
        });
        if (!dbEntity.isLocal) {
            jsonInsertValues.C.push(sysWideOperationIdColumn.index);
            values.forEach(entityValues => {
                entityValues.push(systemWideOperationId);
            });
        }
        if (!idColumns.length && !generatedColumns.length) {
            return values.length;
        }
        // switch (idColumns.length) {
        // 	case 0: {
        // 		// If there is just one @Generated column and no @Id columns
        // 		if (generatedColumns.length == 1) {
        // 			const columnIndex = generatedColumns[0].index
        // 			return allIds.map(
        // 				rowIds => rowIds[columnIndex])
        // 		}
        // 		break
        // 	}
        // 	case 1: {
        // 		// If there is exactly 1 @Id column and no @Generated columns
        // 		// or it is the @Generated column
        // 		if (!generatedColumns.length
        // 			|| (generatedColumns.length === 1
        // 				&& idColumns[0].index === generatedColumns[0].index)) {
        // 			const columnIndex = idColumns[0].index
        // 			return allIds.map(
        // 				rowIds => rowIds[columnIndex])
        // 		}
        // 		break
        // 	}
        // }
        return allIds;
    }
    ensureAirEntityIdValues(actor, dbEntity, jsonInsertValues, errorPrefix, transaction, context) {
        const airEntityColumns = this.dictionary.AirEntity.columns;
        const actorIdColumn = dbEntity.idColumnMap[airEntityColumns.ACTOR_LID];
        const actorRecordIdColumn = dbEntity.idColumnMap[airEntityColumns.ACTOR_RECORD_ID];
        const repositoryIdColumn = dbEntity.idColumnMap[airEntityColumns.REPOSITORY_LID];
        const sysWideOperationIdColumn = dbEntity.columnMap[airEntityColumns.SYSTEM_WIDE_OPERATION_LID];
        let repositoryIdColumnQueryIndex;
        let foundActorIdColumn = false;
        let foundActorRecordIdColumn = false;
        let foundSystemWideOperationIdColumn = false;
        for (let i = 0; i < jsonInsertValues.C.length; i++) {
            const columnIndex = jsonInsertValues.C[i];
            switch (columnIndex) {
                case actorIdColumn.index:
                    foundActorIdColumn = true;
                    if (context.isSaveOperation) {
                        // Save operations validate Actor ealier and set it on the entity objects
                        break;
                    }
                    if (!transaction.isSync) {
                        throw new Error(errorPrefix +
                            `You cannot explicitly provide an ACTOR_LID value for Repository entities.`);
                    }
                    break;
                case actorRecordIdColumn.index:
                    foundActorRecordIdColumn = true;
                    if (!transaction.isSync) {
                        throw new Error(errorPrefix +
                            `You cannot explicitly provide an ACTOR_RECORD_ID value for Repository entities.`);
                    }
                    break;
                case sysWideOperationIdColumn.index:
                    foundSystemWideOperationIdColumn = true;
                    if (!transaction.isSync) {
                        throw new Error(`Error inserting into '${dbEntity.name}'.
You cannot explicitly provide a SYSTEM_WIDE_OPERATION_ID value for Repository entities.`);
                    }
                    break;
                case repositoryIdColumn.index:
                    repositoryIdColumnQueryIndex = i;
                    break;
            }
        }
        const missingRepositoryIdErrorMsg = errorPrefix +
            `Error inserting into '${dbEntity.name}'.
You must provide a valid REPOSITORY_LID value for Repository entities.`;
        if (repositoryIdColumnQueryIndex === undefined) {
            throw new Error(missingRepositoryIdErrorMsg);
        }
        if (transaction.isSync) {
            if (!foundActorIdColumn) {
                throw new Error(errorPrefix +
                    `ACTOR_LID must be provided for sync operations.`);
            }
            if (!foundActorRecordIdColumn) {
                throw new Error(errorPrefix +
                    `ACTOR_RECORD_ID must be provided for sync operations.`);
            }
            if (!foundSystemWideOperationIdColumn) {
                throw new Error(errorPrefix +
                    `SYSTEM_WIDE_OPERATION_ID must be provided for sync operations.`);
            }
        }
        for (const entityValues of jsonInsertValues.V) {
            if (entityValues.length !== jsonInsertValues.C.length) {
                throw new Error(errorPrefix +
                    `Number of columns (${jsonInsertValues.C.length}) does not match number of values (${entityValues.length}).
				`);
            }
            let repositoryId = entityValues[repositoryIdColumnQueryIndex];
            if (typeof repositoryId !== 'number'
                || !Number.isInteger(repositoryId)
                || repositoryId < 1) {
                throw new Error(missingRepositoryIdErrorMsg);
            }
            for (let i = 0; i < entityValues.length; i++) {
                switch (i) {
                    case repositoryIdColumnQueryIndex:
                        continue;
                }
                const value = entityValues[i];
                const columnIndex = jsonInsertValues.C[i];
                const dbColumn = dbEntity.columns[columnIndex];
                if (dbColumn.notNull && value === null) {
                    throw new Error(errorPrefix +
                        `Column '${dbColumn.name}' is NOT NULL
and cannot have NULL values.`);
                }
            }
            if (!context.isSaveOperation && !transaction.isSync) {
                // Save operation set Actor ealier (at the entity level, to be returned back to client)
                entityValues[actorIdColumn.index] = actor._localId;
            }
        }
        return {
            actorIdColumn,
            sysWideOperationIdColumn
        };
    }
    /**
     *
     * All repository records must have _localIds when inserted.  Currently AP doesn't support
     * inserting from SELECT and in the values provided id's must either be explicitly
     * specified or already provided. For all repository entities all _localIds must be
     * auto-generated.
     *
     * @param {DbEntity} dbEntity
     * @param {PortableQuery} portableQuery
     * @returns {Promise<void>}
     */
    async addInsertHistory(dbEntity, portableQuery, actor, systemWideOperationId, transaction, rootTransaction, context) {
        const jsonInsertValues = portableQuery.jsonQuery;
        let operationsByRepo = [];
        let repoTransHistories = [];
        const airEntityColumns = this.dictionary.AirEntity.columns;
        const repositoryIdIndex = dbEntity.columnMap[airEntityColumns.REPOSITORY_LID].index;
        const actorIdIndex = dbEntity.columnMap[airEntityColumns.ACTOR_LID].index;
        const actorRecordIdIndex = dbEntity.columnMap[airEntityColumns.ACTOR_RECORD_ID].index;
        let repositoryIdColumnNumber;
        let actorIdColumnNumber;
        let actorRecordIdColumnNumber;
        for (const columnNumber in jsonInsertValues.C) {
            const columnIndex = jsonInsertValues.C[columnNumber];
            switch (columnIndex) {
                case repositoryIdIndex:
                    repositoryIdColumnNumber = columnNumber;
                    break;
                case actorIdIndex:
                    actorIdColumnNumber = columnNumber;
                    break;
                case actorRecordIdIndex:
                    actorRecordIdColumnNumber = columnNumber;
                    break;
            }
        }
        // Rows may belong to different repositories
        for (const row of jsonInsertValues.V) {
            const repositoryId = row[repositoryIdColumnNumber];
            // const repo           = await repoManager.getRepository(repositoryId)
            let repositoryTransactionHistory = repoTransHistories[repositoryId];
            if (!repositoryTransactionHistory) {
                repositoryTransactionHistory = await this.historyManager
                    .getRepositoryTransactionHistory(transaction.transactionHistory, repositoryId, actor, context);
            }
            let operationHistory = operationsByRepo[repositoryId];
            if (!operationHistory) {
                operationHistory = this.repositoryTransactionHistoryDuo.startOperation(repositoryTransactionHistory, systemWideOperationId, ChangeType.INSERT_VALUES, dbEntity, rootTransaction);
                operationsByRepo[repositoryId] = operationHistory;
            }
            const _actorRecordId = row[actorRecordIdColumnNumber];
            const actorId = row[actorIdColumnNumber];
            const recordHistory = this.operationHistoryDuo.startRecordHistory(operationHistory, actorId, _actorRecordId);
            for (const columnNumber in jsonInsertValues.C) {
                if (columnNumber === repositoryIdColumnNumber
                    || columnNumber === actorIdColumnNumber
                    || columnNumber === actorRecordIdColumnNumber) {
                    continue;
                }
                const columnIndex = jsonInsertValues.C[columnNumber];
                const dbColumn = dbEntity.columns[columnIndex];
                const newValue = row[columnNumber];
                this.recordHistoryDuo.addNewValue(recordHistory, dbColumn, newValue);
            }
        }
        // for (const repositoryId in operationsByRepo) {
        // 	const repoTransHistory = await
        // 		this.currentTransHistory.getRepositoryTransaction(
        // 			repositoryId, null, null, null, repoTransHistoryDuo);
        // 	repoTransHistory.endGroupMutation(operationsByRepo[repositoryId]);
        // }
    }
}

class QueryManager {
    async find(portableQuery, context, cachedSqlQueryId) {
        await this.ensureRepositoryPresenceAndCurrentState(context);
        const entityArray = await this.storeDriver.find(portableQuery, {}, context, cachedSqlQueryId);
        if (!entityArray || !entityArray.length) {
            return entityArray;
        }
        await this.populateEntityGuidEntitiesAndUserAccounts(portableQuery, entityArray);
        return entityArray;
    }
    async findOne(portableQuery, context, cachedSqlQueryId) {
        await this.ensureRepositoryPresenceAndCurrentState(context);
        const entity = await this.storeDriver.findOne(portableQuery, {}, context, cachedSqlQueryId);
        if (!entity) {
            return entity;
        }
        await this.populateEntityGuidEntitiesAndUserAccounts(portableQuery, [entity]);
        return entity;
    }
    search(portableQuery, context, cachedSqlQueryId) {
        return this.observableQueryAdapter.wrapInObservable(portableQuery, () => {
            return this.storeDriver.find(portableQuery, {}, context)
                .then((result) => {
                if (!result || !result.length) {
                    return result;
                }
                return this.populateEntityGuidEntitiesAndUserAccounts(portableQuery, result);
            });
        });
    }
    searchOne(portableQuery, context, cachedSqlQueryId) {
        return this.observableQueryAdapter.wrapInObservable(portableQuery, () => {
            return this.storeDriver.findOne(portableQuery, {}, context)
                .then((result) => {
                if (!result) {
                    return result;
                }
                return this.populateEntityGuidEntitiesAndUserAccounts(portableQuery, [result])[0];
            });
        });
    }
    async ensureRepositoryPresenceAndCurrentState(context) {
        if (context.repository && context.repository.GUID) {
            await this.repositoryLoader.loadRepository(context.repository.GUID, context);
        }
    }
    async populateEntityGuidEntitiesAndUserAccounts(portableQuery, entities) {
        if (!entities.length) {
            return;
        }
        if (portableQuery.queryResultType !== QueryResultType.ENTITY_GRAPH
            && portableQuery.queryResultType !== QueryResultType.ENTITY_TREE) {
            return;
        }
        const dbEntity = this.airportDatabase.applications[portableQuery.applicationIndex]
            .currentVersion[0].applicationVersion.entities[portableQuery.tableIndex];
        const entityMapByRepositoryLocalId = new Map();
        const entityMapByActorRecordId = new Map();
        const actorsToRetrieveUserAccountForByLocalId = new Map();
        this.markEntities(entities, new Set(), entityMapByRepositoryLocalId, entityMapByActorRecordId, actorsToRetrieveUserAccountForByLocalId, dbEntity);
        await this.populateActorsAndUserAccounts(entityMapByActorRecordId, actorsToRetrieveUserAccountForByLocalId);
        await this.populateRepositories(entityMapByRepositoryLocalId);
        return entities;
    }
    markEntities(currentEntities, processedEntitySet, entityMapByRepositoryLocalId, entityMapByActorRecordId, actorsToRetrieveUserAccountForByLocalId, dbEntity) {
        for (const entity of currentEntities) {
            // const previouslyFoundEntity = entitiesByOperationIndex[operationUniqueId]
            if (processedEntitySet.has(entity)) {
                continue;
            }
            processedEntitySet.add(entity);
            for (const dbProperty of dbEntity.properties) {
                let propertyValue = entity[dbProperty.name];
                if (!propertyValue) {
                    continue;
                }
                if (dbProperty.relation && dbProperty.relation.length) {
                    const dbRelation = dbProperty.relation[0];
                    let relatedEntities = propertyValue;
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            if (this.processRepositoryOrActor(entity, dbRelation, propertyValue, entityMapByRepositoryLocalId, entityMapByActorRecordId, actorsToRetrieveUserAccountForByLocalId)) {
                                continue;
                            }
                            relatedEntities = [propertyValue];
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            break;
                    }
                    this.markEntities(relatedEntities, processedEntitySet, entityMapByRepositoryLocalId, entityMapByActorRecordId, actorsToRetrieveUserAccountForByLocalId, dbRelation.relationEntity);
                }
            }
        }
    }
    processRepositoryOrActor(entity, dbRelation, propertyValue, entityMapByRepositoryLocalId, entityMapByActorLocalId, actorsToRetrieveUserAccountForByLocalId) {
        let isActor = this.dictionary.isActor(dbRelation.relationEntity);
        if (!isActor) {
            if (!this.dictionary.isRepository(dbRelation.relationEntity)) {
                return false;
            }
        }
        if (!propertyValue[this.dictionary.column._localId]) {
            throw new Error(`Actor entity does not have a _localId`);
        }
        if (propertyValue.GUID) {
            if (!isActor) {
                return true;
            }
            if (!propertyValue[this.dictionary.Actor.properties.userAccount]) {
                actorsToRetrieveUserAccountForByLocalId.set(propertyValue._localId, propertyValue);
            }
            return true;
        }
        if (isActor) {
            this.datastructureUtils.ensureChildArray(entityMapByActorLocalId, propertyValue._localId)
                .push(entity);
        }
        else {
            this.datastructureUtils.ensureChildArray(entityMapByRepositoryLocalId, propertyValue._localId)
                .push(entity);
        }
        return true;
    }
    async populateActorsAndUserAccounts(entityMapByActorRecordId, actorsToRetrieveUserAccountForByLocalId) {
        const actorIdSet = new Set();
        for (const actorLocalId of entityMapByActorRecordId.keys()) {
            actorIdSet.add(actorLocalId);
        }
        for (const actorLocalId of actorsToRetrieveUserAccountForByLocalId.keys()) {
            actorIdSet.add(actorLocalId);
        }
        if (!actorIdSet.size) {
            return;
        }
        const actorLocalIds = Array.from(actorIdSet);
        const actors = await this.actorDao.findWithUserAccountBy_LocalIdIn(actorLocalIds);
        for (const actor of actors) {
            const entitiesWithoutActorObject = entityMapByActorRecordId.get(actor._localId);
            if (entitiesWithoutActorObject) {
                for (const entity of entitiesWithoutActorObject) {
                    entity.actor = actor;
                }
            }
            const actorWithoutUserAccountObject = actorsToRetrieveUserAccountForByLocalId.get(actor._localId);
            if (actorWithoutUserAccountObject) {
                actorWithoutUserAccountObject.userAccount = actor.userAccount;
            }
        }
    }
    async populateRepositories(entityMapByRepositoryLocalId) {
        const repositoryLocalIds = Array.from(entityMapByRepositoryLocalId.keys());
        if (!repositoryLocalIds.length) {
            return;
        }
        const repositories = await this.repositoryDao
            .findWithOwnerBy_LocalIdIn(repositoryLocalIds);
        for (const repository of repositories) {
            const entiesWithoutRepositoryObject = entityMapByRepositoryLocalId.get(repository._localId);
            for (const entity of entiesWithoutRepositoryObject) {
                entity.repository = repository;
            }
        }
    }
}

class TransactionManager extends AbstractMutationManager {
    /**
     * Initializes the EntityManager at server load time.
     * @returns {Promise<void>}
     */
    async initialize(dbName, context) {
        return await this.storeDriver.initialize(dbName, context);
        // await this.dataStore.initialize(dbName)
        // await this.repositoryManager.initialize();
    }
    getInProgressTransactionById(transactionId) {
        return this.terminalStore.getTransactionManager()
            .transactionInProgressMap.get(transactionId);
    }
    isServer(context) {
        return this.terminalStore.getIsServer();
    }
    async transactInternal(transactionalCallback, credentials, context) {
        if (!credentials) {
            credentials = {
                application: this.appTrackerUtils.getInternalApp(),
                domain: this.appTrackerUtils.getInternalDomain(),
                methodName: null,
                objectName: null
            };
        }
        await this.transact(credentials, transactionalCallback, context);
    }
    async transact(credentials, transactionalCallback, context) {
        if (context.transaction) {
            // Nested transact() calls in internal operations
            // do not create nested transactions
            await transactionalCallback(context.transaction, context);
            return;
        }
        const transaction = await this.startTransaction(credentials, context);
        try {
            await transactionalCallback(transaction, context);
            await this.commit(credentials, context);
        }
        catch (e) {
            console.error(e);
            await this.rollback(credentials, context);
            throw e;
        }
    }
    async startTransaction(credentials, context) {
        if (context.transaction) {
            return;
        }
        const transactionManagerStore = this.terminalStore.getTransactionManager();
        let parentTransaction;
        if (credentials.transactionId) {
            parentTransaction = transactionManagerStore
                .transactionInProgressMap.get(credentials.transactionId);
            if (!parentTransaction) {
                throw new Error(`
Recieved a startTransaction call (@Api call) with parent transaction id:
	${credentials.transactionId}
But, there is no such transaction in progress.`);
            }
            if (parentTransaction.id !==
                credentials.transactionId) {
                throw new Error(`
In-progress transaction id does not match the passed in transaction id:
${credentials.transactionId}`);
            }
            this.checkForCircularDependencies(parentTransaction, credentials);
        }
        else {
            /*
             * NOTE: Current policy is to NOT limit the number of transactions
             * a domain can initiate.  In the future, specifically for the
             * client-side Turbase, it may make sence to limit the number
             * of transactions to 1 per tab.  This can be accomplished by
             * generating a unique id on the nested client iframe of an
             * application.
             */
            /*
throw new Error(`
    Domain:
        ${credentials.domain}
    Application:
        ${credentials.application}
initialized multiple transactions at the same time.
Only one concurrent transaction is allowed per application.`)
            */
            if (!this.isServer(context)
                && transactionManagerStore.transactionInProgressMap.size > 0) {
                // Delay the start of the transaction
                return new Promise((resolve, reject) => {
                    // Add the transaction to the queue of pending transactions
                    transactionManagerStore.pendingTransactionQueue.unshift({
                        context,
                        credentials,
                        reject,
                        resolve
                    });
                });
            }
        }
        const transaction = await this.internalStartTransaction(credentials, parentTransaction, context);
        if (!parentTransaction) {
            const rootTransaction = transaction;
            rootTransaction.numberOfOperations = 0;
            // Internal calls don't maintain rootTransaction and can create more than
            // one repository at a time.  APIs exposed externally will never be top
            // level transactions
            if (!this.appTrackerUtils.isInternalDomain(credentials.domain)) {
                const userSession = await this.terminalSessionManager.getUserSession();
                userSession.currentRootTransaction = rootTransaction;
            }
        }
        return transaction;
    }
    async internalStartTransaction(credentials, parentTransaction, context) {
        const transactionManagerStore = this.terminalStore.getTransactionManager();
        const transaction = await this.storeDriver
            .setupTransaction(context, parentTransaction);
        await this.storeDriver.startTransaction(transaction, context);
        transaction.credentials = credentials;
        await this.setupTransaction(credentials, transaction, parentTransaction, transactionManagerStore, context);
        return transaction;
    }
    async rollback(credentials, context) {
        const transaction = this.getTransactionFromContextOrCredentials(credentials, context);
        let parentTransaction = transaction.parentTransaction;
        await transaction.rollback(null, context);
        const transactionCleared = await this.clearTransaction(transaction, parentTransaction, credentials, context);
        if (!parentTransaction) {
            await this.clearUserSessionRootTransaction(transaction);
        }
        if (transactionCleared) {
            await this.resumeParentOrPendingTransaction(parentTransaction, context);
        }
    }
    getTransactionFromContextOrCredentials(credentials, context) {
        let transaction = context.transaction;
        if (!transaction) {
            if (!credentials.transactionId) {
                throw new Error(`
No Transaction Id is passed in Credentials for a transactional operation.
				`);
            }
            const transactionManagerStore = this.terminalStore
                .getTransactionManager();
            transaction = transactionManagerStore.transactionInProgressMap.get(credentials.transactionId);
            if (!transaction) {
                throw new Error(`
Could not find Transaction: ${credentials.transactionId} in Transactons in-progress.
NOTE: nested/child transactions must be commited or rolled back before their
parent transactions.
				`);
            }
            context.transaction = transaction;
        }
        let ancestorTransaction = transaction;
        for (; ancestorTransaction.parentTransaction; ancestorTransaction = ancestorTransaction.parentTransaction) {
        }
        context.rootTransaction = ancestorTransaction;
        return transaction;
    }
    async resumeParentOrPendingTransaction(parentTransaction, context) {
        const transactionManagerStore = this.terminalStore.getTransactionManager();
        if (parentTransaction) {
            await this.setupTransaction(parentTransaction.credentials, parentTransaction, parentTransaction.parentTransaction, transactionManagerStore, context);
        }
        else if (transactionManagerStore.pendingTransactionQueue.length) {
            const pendingTransaction = transactionManagerStore.pendingTransactionQueue.pop();
            const transaction = await this.internalStartTransaction(pendingTransaction.credentials, null, pendingTransaction.context);
            pendingTransaction.resolve(transaction);
        }
    }
    async commit(credentials, context) {
        const transaction = this.getTransactionFromContextOrCredentials(credentials, context);
        let parentTransaction = transaction.parentTransaction;
        try {
            if (parentTransaction) {
                if (!context.doNotRecordHistory) {
                    this.copyTransactionHistoryToParentTransaction(transaction, parentTransaction);
                }
            }
            else {
                // This is the root transaction, save it's history, along with any nested transactions
                if (!context.doNotRecordHistory) {
                    await this.saveRepositoryHistory(transaction, context);
                }
            }
            await transaction.commit(null, context);
            let transactionHistory = transaction.transactionHistory;
            if (!context.doNotRecordHistory && !transaction.isSync) {
                if (!parentTransaction && transactionHistory.allRecordHistory.length) {
                    await this.synchronizationOutManager.synchronizeOut(transactionHistory.repositoryTransactionHistories);
                }
            }
            if (!parentTransaction) {
                await this.clearUserSessionRootTransaction(transaction);
            }
        }
        finally {
            if (await this.clearTransaction(transaction, parentTransaction, credentials, context)) {
                // Right now transactions are tied to @Api() calls,
                // If an @Api() fails to commit the parent @Api() call should resume
                // it's transaction or the next 
                await this.resumeParentOrPendingTransaction(parentTransaction, context);
            }
        }
    }
    async clearUserSessionRootTransaction(transaction) {
        // Internal calls don't maintain rootTransaction and can create more than
        // one repository at a time.  APIs exposed externally will never be top
        // level transactions
        if (this.appTrackerUtils.isInternalDomain(transaction.credentials.domain)) {
            return;
        }
        const userSession = await this.terminalSessionManager.getUserSession();
        userSession.currentRootTransaction = null;
    }
    copyTransactionHistoryToParentTransaction(transaction, parentTransaction) {
        let childTransactionHistory = transaction.transactionHistory;
        let parentTransactionHistory = parentTransaction.transactionHistory;
        for (const operationHistory of childTransactionHistory.allOperationHistory) {
            const repositoryLocalId = operationHistory.repositoryTransactionHistory.repository._localId;
            const parentRepositoryTransactionRecord = parentTransactionHistory
                .repositoryTransactionHistoryMap[repositoryLocalId];
            if (parentRepositoryTransactionRecord) {
                operationHistory.repositoryTransactionHistory = parentRepositoryTransactionRecord;
            }
            else {
                parentTransactionHistory.repositoryTransactionHistoryMap[repositoryLocalId]
                    = operationHistory.repositoryTransactionHistory;
                parentTransactionHistory.repositoryTransactionHistories
                    .push(operationHistory.repositoryTransactionHistory);
            }
        }
        parentTransactionHistory.allOperationHistory = parentTransactionHistory
            .allOperationHistory.concat(childTransactionHistory.allOperationHistory);
        parentTransactionHistory.allRecordHistory = parentTransactionHistory
            .allRecordHistory.concat(childTransactionHistory.allRecordHistory);
        parentTransactionHistory.allRecordHistoryNewValues = parentTransactionHistory
            .allRecordHistoryNewValues.concat(childTransactionHistory.allRecordHistoryNewValues);
        parentTransactionHistory.allRecordHistoryOldValues = parentTransactionHistory
            .allRecordHistoryOldValues.concat(childTransactionHistory.allRecordHistoryOldValues);
        parentTransactionHistory.allRepositoryMembers = parentTransactionHistory
            .allRepositoryMembers.concat(childTransactionHistory.allRepositoryMembers);
        parentTransactionHistory.allRepositoryMemberAcceptances = parentTransactionHistory
            .allRepositoryMemberAcceptances.concat(childTransactionHistory.allRepositoryMemberAcceptances);
        parentTransactionHistory.allRepositoryMemberInvitations = parentTransactionHistory
            .allRepositoryMemberInvitations.concat(childTransactionHistory.allRepositoryMemberInvitations);
    }
    checkForCircularDependencies(transaction, credentials) {
        if (this.appTrackerUtils.isInternalDomain(credentials.domain)) {
            return;
        }
        do {
            if (this.isSameSource(transaction, credentials)) {
                let callHerarchy = this.getApiName(credentials);
                let hierarchyTransaction = transaction;
                do {
                    callHerarchy = `${this.getApiName(hierarchyTransaction.initiator)} ->
${callHerarchy}`;
                } while (hierarchyTransaction = hierarchyTransaction.parentTransaction);
                throw new Error(`Circular API call detected:
				
${callHerarchy}

				`);
            }
        } while (transaction = transaction.parentTransaction);
    }
    async setupTransaction(credentials, transaction, parentTransaction, transactionManagerStore, context) {
        context.transaction = transaction;
        credentials.transactionId = transaction.id;
        if (!context.doNotRecordHistory) {
            transaction.transactionHistory = this.transactionHistoryDuo.getNewRecord();
        }
        transactionManagerStore.transactionInProgressMap.set(transaction.id, transaction);
        if (parentTransaction) {
            transactionManagerStore.transactionInProgressMap.delete(parentTransaction.id);
            let ancestorTransaction = transaction;
            for (; ancestorTransaction.parentTransaction; ancestorTransaction = ancestorTransaction.parentTransaction) {
            }
            context.rootTransaction = ancestorTransaction;
        }
        else {
            transactionManagerStore.rootTransactionInProgressMap.set(transaction.id, transaction);
            context.rootTransaction = transaction;
        }
    }
    isSameSource(transaction, credentials) {
        const initiator = transaction.initiator;
        return initiator.domain === credentials.domain
            && initiator.application === credentials.application
            && initiator.objectName === credentials.objectName
            && initiator.methodName === credentials.methodName;
    }
    getApiName(nameContainer) {
        return `${nameContainer.domain}.${nameContainer.application}.${nameContainer.objectName}.${nameContainer.methodName}`;
    }
    async clearTransaction(transaction, parentTransaction, credentials, context) {
        const transactionManagerStore = this.terminalStore
            .getTransactionManager();
        transactionManagerStore.transactionInProgressMap.delete(transaction.id);
        if (!parentTransaction) {
            transactionManagerStore.rootTransactionInProgressMap.delete(transaction.id);
        }
        context.transaction = null;
        credentials.transactionId = null;
        return true;
    }
    async saveRepositoryHistory(transaction, context) {
        let transactionHistory = transaction.transactionHistory;
        if (!transactionHistory.allRecordHistory.length) {
            return false;
        }
        let applicationMap = transactionHistory.applicationMap;
        const transactionHistoryIds = await this.idGenerator.generateTransactionHistory_LocalIds(transactionHistory.repositoryTransactionHistories.length, transactionHistory.allOperationHistory.length, transactionHistory.allRecordHistory.length);
        applicationMap.ensureEntity(Q_airport____at_airport_slash_holding_dash_pattern$1.TransactionHistory.__driver__.dbEntity, true);
        transactionHistory._localId = transactionHistoryIds.transactionHistory_LocalId;
        await this.doInsertValues(transaction, Q_airport____at_airport_slash_holding_dash_pattern$1.TransactionHistory, [transactionHistory], context);
        applicationMap.ensureEntity(Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryTransactionHistory.__driver__.dbEntity, true);
        transactionHistory.repositoryTransactionHistories.forEach((repositoryTransactionHistory, index) => {
            repositoryTransactionHistory._localId = transactionHistoryIds.repositoryHistory_LocalIds[index];
            repositoryTransactionHistory.transactionHistory = transactionHistory;
        });
        await this.doInsertValues(transaction, Q_airport____at_airport_slash_holding_dash_pattern$1.RepositoryTransactionHistory, transactionHistory.repositoryTransactionHistories, context);
        applicationMap.ensureEntity(Q_airport____at_airport_slash_holding_dash_pattern$1.OperationHistory.__driver__.dbEntity, true);
        transactionHistory.allOperationHistory.forEach((operationHistory, index) => {
            operationHistory._localId = transactionHistoryIds.operationHistory_LocalIds[index];
        });
        await this.doInsertValues(transaction, Q_airport____at_airport_slash_holding_dash_pattern$1.OperationHistory, transactionHistory.allOperationHistory, context);
        applicationMap.ensureEntity(Q_airport____at_airport_slash_holding_dash_pattern$1.RecordHistory.__driver__.dbEntity, true);
        transactionHistory.allRecordHistory.forEach((recordHistory, index) => {
            recordHistory._localId = transactionHistoryIds.recordHistory_LocalIds[index];
        });
        await this.doInsertValues(transaction, Q_airport____at_airport_slash_holding_dash_pattern$1.RecordHistory, transactionHistory.allRecordHistory, context);
        if (transactionHistory.allRecordHistoryNewValues.length) {
            applicationMap.ensureEntity(Q_airport____at_airport_slash_holding_dash_pattern$1.RecordHistoryNewValue.__driver__.dbEntity, true);
            await this.doInsertValues(transaction, Q_airport____at_airport_slash_holding_dash_pattern$1.RecordHistoryNewValue, transactionHistory.allRecordHistoryNewValues, context);
        }
        if (transactionHistory.allRecordHistoryOldValues.length) {
            applicationMap.ensureEntity(Q_airport____at_airport_slash_holding_dash_pattern$1.RecordHistoryOldValue.__driver__.dbEntity, true);
            await this.doInsertValues(transaction, Q_airport____at_airport_slash_holding_dash_pattern$1.RecordHistoryOldValue, transactionHistory.allRecordHistoryOldValues, context);
        }
        if (transactionHistory.allRepositoryMembers.length) {
            await this.repositoryMemberDao
                .insert(transactionHistory.allRepositoryMembers, context);
        }
        if (transactionHistory.allRepositoryMemberAcceptances.length) {
            await this.repositoryMemberAcceptanceDao
                .insert(transactionHistory.allRepositoryMemberAcceptances, context);
        }
        if (transactionHistory.allRepositoryMemberInvitations.length) {
            await this.repositoryMemberInvitationDao
                .insert(transactionHistory.allRepositoryMemberInvitations, context);
        }
        return true;
    }
}

class UpdateManager {
    async updateValues(portableQuery, actor, transaction, rootTransaction, context) {
        const dbEntity = this.airportDatabase.applications[portableQuery.applicationIndex]
            .currentVersion[0].applicationVersion.entities[portableQuery.tableIndex];
        const errorPrefix = `Error updating '${dbEntity.name}'
`;
        const internalFragments = {
            SET: []
        };
        let recordHistoryMap;
        let repositorySheetSelectInfo;
        let systemWideOperationId;
        if (!dbEntity.isLocal && !transaction.isSync) {
            systemWideOperationId = await this.systemWideOperationIdUtils
                .getSysWideOpId();
            // TODO: For entity queries an additional query really shouldn't be needed
            // Specifically for entity queries, we got the new values, just record them
            // This will require an additional operation on the first update
            // where the original values of the record are saved
            // This eats up more disk space but saves on operations that need
            // to be performed (one less query)
            [recordHistoryMap, repositorySheetSelectInfo]
                = await this.addUpdateHistory(portableQuery, actor, systemWideOperationId, errorPrefix, transaction, rootTransaction, context);
            internalFragments.SET.push({
                column: repositorySheetSelectInfo.systemWideOperationIdColumn,
                value: systemWideOperationId
            });
        }
        const numUpdatedRows = await transaction
            .updateWhere(portableQuery, internalFragments, context);
        if (!dbEntity.isLocal && !transaction.isSync) {
            const previousDbEntity = context.dbEntity;
            context.dbEntity = dbEntity;
            // TODO: Entity based updates already have all of the new values being
            // updated, detect the type of update and if entity just pull out
            // the new values from them
            await this.addNewValueHistory(portableQuery.jsonQuery, recordHistoryMap, systemWideOperationId, repositorySheetSelectInfo, errorPrefix, transaction, context);
            context.dbEntity = previousDbEntity;
        }
        return numUpdatedRows;
    }
    async addUpdateHistory(portableQuery, actor, systemWideOperationId, errorPrefix, transaction, rootTransaction, context) {
        if (!context.dbEntity.isAirEntity) {
            throw new Error(errorPrefix +
                `Cannot add update history for a non-AirEntity`);
        }
        const qEntity = this.airportDatabase
            .qApplications[context.dbEntity.applicationVersion.application.index][context.dbEntity.name];
        const jsonUpdate = portableQuery.jsonQuery;
        const getSheetSelectFromSetClauseResult = this.queryUtils.getSheetSelectFromSetClause(context.dbEntity, qEntity, jsonUpdate.S, errorPrefix);
        const sheetQuery = new SheetQuery(null);
        const jsonSelectClause = sheetQuery.nonDistinctSelectClauseToJSON(getSheetSelectFromSetClauseResult.selectClause, this.queryUtils, this.fieldUtils, this.relationManager);
        const jsonSelect = {
            S: jsonSelectClause,
            F: [jsonUpdate.U],
            W: jsonUpdate.W,
        };
        const portableSelect = {
            applicationIndex: portableQuery.applicationIndex,
            tableIndex: portableQuery.tableIndex,
            jsonQuery: jsonSelect,
            queryResultType: QueryResultType.SHEET,
            parameterMap: portableQuery.parameterMap,
            // values: portableQuery.values,
        };
        const recordsToUpdate = await transaction.find(portableSelect, {}, context);
        const { recordsByRepositoryId, repositoryIdSet } = this.groupRecordsByRepository(recordsToUpdate, getSheetSelectFromSetClauseResult);
        const repositoryIds = Array.from(repositoryIdSet);
        const recordHistoryMapByRecordId = {};
        for (const repositoryId of repositoryIds) {
            // const repository                         = repositories.get(repositoryId)
            const recordHistoryMapForRepository = {};
            recordHistoryMapByRecordId[repositoryId] = recordHistoryMapForRepository;
            const repositoryTransactionHistory = await this.historyManager.getRepositoryTransactionHistory(transaction.transactionHistory, repositoryId, actor, context);
            const operationHistory = this.repositoryTransactionHistoryDuo.startOperation(repositoryTransactionHistory, systemWideOperationId, ChangeType.UPDATE_ROWS, context.dbEntity, rootTransaction);
            const recordsForRepositoryId = recordsByRepositoryId[repositoryId];
            for (const recordToUpdate of recordsForRepositoryId) {
                const actorId = recordToUpdate[getSheetSelectFromSetClauseResult.actorIdColumnIndex];
                const recordHistoryMapForActor = this.datastructureUtils.ensureChildMap(recordHistoryMapForRepository, actorId);
                const _actorRecordId = recordToUpdate[getSheetSelectFromSetClauseResult.actorRecordIdColumnIndex];
                const recordHistory = this.operationHistoryDuo.startRecordHistory(operationHistory, actorId, _actorRecordId);
                recordHistoryMapForActor[_actorRecordId] = recordHistory;
                for (let i = 0; i < recordToUpdate.length; i++) {
                    switch (i) {
                        case getSheetSelectFromSetClauseResult.actorIdColumnIndex:
                        case getSheetSelectFromSetClauseResult.actorRecordIdColumnIndex:
                        case getSheetSelectFromSetClauseResult.repositoryIdColumnIndex:
                            continue;
                    }
                    const dbColumn = getSheetSelectFromSetClauseResult
                        .selectClause[i].dbColumn;
                    const value = recordToUpdate[i];
                    this.recordHistoryDuo.addOldValue(recordHistory, dbColumn, value);
                }
            }
        }
        return [recordHistoryMapByRecordId, getSheetSelectFromSetClauseResult];
    }
    async addNewValueHistory(jsonUpdate, recordHistoryMapByRecordId, systemWideOperationId, repositorySheetSelectInfo, errorPrefix, transaction, context) {
        const qEntity = this.airportDatabase.qApplications[context.dbEntity.applicationVersion.application.index][context.dbEntity.name];
        const sheetQuery = new SheetQuery({
            FROM: [
                qEntity
            ],
            SELECT: [],
            WHERE: qEntity[this.dictionary.AirEntity.properties
                .systemWideOperationId]
                .equals(systemWideOperationId)
        });
        let portableSelect = this.queryFacade.getPortableQuery(sheetQuery, QueryResultType.SHEET, context);
        const resultSetIndexByColumnIndex = new Map();
        const selectDbColumns = [];
        let i = 0;
        for (const qField of repositorySheetSelectInfo.selectClause) {
            const dbColumn = qField.dbColumn;
            selectDbColumns.push(dbColumn);
            resultSetIndexByColumnIndex.set(dbColumn.index, i);
            i++;
        }
        const internalFragments = {
            SELECT: selectDbColumns
        };
        const updatedRecords = await transaction.find(portableSelect, internalFragments, context);
        const { recordsByRepositoryId, repositoryIdSet } = this.groupRecordsByRepository(updatedRecords, repositorySheetSelectInfo);
        for (const repositoryId of repositoryIdSet) {
            const recordsForRepositoryId = recordsByRepositoryId[repositoryId];
            for (const updatedRecord of recordsForRepositoryId) {
                const repositoryId = updatedRecord[resultSetIndexByColumnIndex.get(repositorySheetSelectInfo.repositoryIdColumnIndex)];
                const actorId = updatedRecord[resultSetIndexByColumnIndex.get(repositorySheetSelectInfo.actorIdColumnIndex)];
                const _actorRecordId = updatedRecord[resultSetIndexByColumnIndex.get(repositorySheetSelectInfo.actorRecordIdColumnIndex)];
                const recordHistory = recordHistoryMapByRecordId[repositoryId][actorId][_actorRecordId];
                for (const columnName in jsonUpdate.S) {
                    const dbColumn = context.dbEntity.columnMap[columnName];
                    const value = updatedRecord[resultSetIndexByColumnIndex.get(dbColumn.index)];
                    if (value === undefined) {
                        throw new Error(errorPrefix + `Values cannot be 'undefined'.`);
                    }
                    if (dbColumn.notNull && value === null) {
                        throw new Error(errorPrefix + `Column '${dbColumn.entity.name}'.'${dbColumn.name}' is NOT NULL
						and cannot have NULL values.`);
                    }
                    this.recordHistoryDuo.addNewValue(recordHistory, dbColumn, value);
                }
            }
        }
    }
    groupRecordsByRepository(records, repositorySheetSelectInfo) {
        const recordsByRepositoryId = {};
        const repositoryIdSet = new Set();
        for (const recordToUpdate of records) {
            const repositoryId = recordToUpdate[repositorySheetSelectInfo.repositoryIdColumnIndex];
            repositoryIdSet.add(repositoryId);
            const recordsForRepositoryId = this.datastructureUtils.ensureChildArray(recordsByRepositoryId, repositoryId);
            recordsForRepositoryId.push(recordToUpdate);
        }
        return {
            recordsByRepositoryId,
            repositoryIdSet
        };
    }
}

class CascadeGraphVerifier {
    verify(root, context) {
        if (!(root instanceof Array)) {
            root = [root];
        }
        // TODO: validate the rules specified in the graph
        // The graph will be defined via a @Save({
        //	...RULES
        //})
        // decorator
        return root;
    }
}

/*
 * Takes a (potentially) interconnected entity graph and returns
 * an array of entities to be operated on, in a order that is valid
 * for insertion (with all needed new _localIds being inserted in an order
 * that will work).
 */
class DependencyGraphResolver {
    getOperationsInOrder(entities, context) {
        const unorderedDependencies = this.getEntitiesToPersist(entities, [], [], context);
        this.resolveCircularDependencies(unorderedDependencies, context);
        const orderedDependencies = this.orderEntitiesToPersist(unorderedDependencies, context);
        const operationNodes = this.optimizePersistOperations(orderedDependencies, context);
        return this.ensureUpdatesAreGroupedCorrectly(operationNodes, context);
    }
    getEntitiesToPersist(entities, operatedOnEntities, operatedOnPassThroughs, context, dependsOn, dependency, deleteByCascade = false) {
        let allProcessedNodes = [];
        const dbEntity = context.dbEntity;
        for (const entity of entities) {
            /*
             * A passed in graph has either entities to be saved or
             * entity stubs that are needed structurally to get to
             * other entities (or parentIds in case part of an id
             * actually resides in a nested object that that object
             * has no associated operations or child entities of
             * it's own).
             */
            const { isCreate, isDelete, isParentSchemaId, isPassThrough, isStub, isUpdate } = this.entityStateManager
                .getEntityStateTypeAsFlags(entity, dbEntity);
            if (isStub) {
                // No processing is needed
                continue;
            }
            const operationUniqueId = this.entityStateManager.getOperationUniqueId(entity);
            if (deleteByCascade && (isCreate || isUpdate)) {
                throw new Error(`Cannot do a Create or Update operation on an entity that will be
deleted by cascading rules.  Entity: ${dbEntity.name}.
Entity "${this.entityStateManager.getUniqueIdFieldName()}":  ${operationUniqueId}`);
            }
            let dependencyGraphNode;
            if (isPassThrough) {
                if (operatedOnPassThroughs[operationUniqueId]) {
                    continue;
                }
                else {
                    operatedOnPassThroughs[operationUniqueId] = true;
                }
            }
            else {
                dependencyGraphNode = operatedOnEntities[operationUniqueId];
                let isExistingNode = false;
                if (dependencyGraphNode) {
                    isExistingNode = true;
                }
                else if (!isParentSchemaId && !deleteByCascade) {
                    dependencyGraphNode = {
                        circleTraversedFor: {},
                        dbEntity,
                        dependsOnByOUID: [],
                        dependsOn: [],
                        entity,
                        isCreate,
                        isDelete
                    };
                    allProcessedNodes.push(dependencyGraphNode);
                    operatedOnEntities[operationUniqueId] = dependencyGraphNode;
                }
                if (!isParentSchemaId && !isDelete) {
                    if (dependsOn && !isDelete) {
                        const dependsOnOUID = this.entityStateManager.getOperationUniqueId(dependsOn.entity);
                        if (!dependencyGraphNode.dependsOnByOUID[dependsOnOUID]
                            && this.entityStateManager
                                .getOperationUniqueId(dependencyGraphNode.entity) !== dependsOnOUID) {
                            dependencyGraphNode.dependsOnByOUID[dependsOnOUID] = dependsOn;
                            dependencyGraphNode.dependsOn.push(dependsOn);
                        }
                    }
                    if (dependency) {
                        if (!dependencyGraphNode.dependsOnByOUID[operationUniqueId]
                            && this.entityStateManager
                                .getOperationUniqueId(dependency.entity) !== operationUniqueId) {
                            dependency.dependsOnByOUID[operationUniqueId] = dependencyGraphNode;
                            dependency.dependsOn.push(dependencyGraphNode);
                        }
                    }
                }
                if (isExistingNode) {
                    continue;
                }
            }
            for (const dbProperty of context.dbEntity.properties) {
                let relatedEntities;
                let propertyValue = entity[dbProperty.name];
                if (!propertyValue || typeof propertyValue !== 'object'
                    || !(dbProperty.relation && dbProperty.relation.length)) {
                    continue;
                }
                let fromDependencyForChild = null;
                let isDependency = false;
                let childDeleteByCascade = deleteByCascade || isDelete;
                const dbRelation = dbProperty.relation[0];
                switch (dbRelation.relationType) {
                    // Relation is an entity that this entity depends on
                    case EntityRelationType.MANY_TO_ONE:
                        childDeleteByCascade = false;
                        // TODO: see if there is a cleaner way to escape nested Actor and Repository records
                        if (dbEntity.isAirEntity && (this.dictionary.isActor(dbRelation.relationEntity)
                            || this.dictionary.isRepository(dbRelation.relationEntity))
                            && !propertyValue[this.entityStateManager.getStateFieldName()]) {
                            continue;
                        }
                        const parentState = this.entityStateManager
                            .getEntityStateTypeAsFlags(propertyValue, dbRelation.relationEntity);
                        if (parentState.isParentSchemaId) {
                            continue;
                        }
                        if (parentState.isDelete) {
                            if (isPassThrough) {
                                // Automatically delete all contained records
                                this.entityStateManager.markForDeletion(entity);
                            }
                            else if (!isDelete) {
                                throw new Error(`Cannot delete an entity without removing all references to it.
								Found a reference in ${dbEntity.name}.${dbProperty.name}.
								Entity "${this.entityStateManager.getUniqueIdFieldName()}":  ${operationUniqueId}`);
                            }
                            else {
                                // Prune this entry
                                if (!deleteByCascade) {
                                    if (dependency) {
                                        dependency.dependsOn.pop();
                                    }
                                    allProcessedNodes.pop();
                                }
                                deleteByCascade = true;
                            }
                        }
                        if (parentState.isCreate) {
                            isDependency = true;
                        }
                        // Do not persist actor or repository, they
                        // are created separately
                        relatedEntities = [propertyValue];
                        break;
                    // Relation is an array of entities that depend in this entity
                    case EntityRelationType.ONE_TO_MANY:
                        if (isCreate) {
                            fromDependencyForChild = dependencyGraphNode;
                        }
                        // Nested deletions wil be automatically pruned in recursive calls
                        relatedEntities = propertyValue;
                        break;
                }
                if (relatedEntities) {
                    const dbEntity = dbRelation.relationEntity;
                    const previousDbEntity = context.dbEntity;
                    context.dbEntity = dbEntity;
                    const childDependencyLinkedNodes = this.getEntitiesToPersist(relatedEntities, operatedOnEntities, operatedOnPassThroughs, context, fromDependencyForChild, !isParentSchemaId && !isDelete && isDependency ? dependencyGraphNode : null, childDeleteByCascade);
                    allProcessedNodes = allProcessedNodes.concat(childDependencyLinkedNodes);
                    context.dbEntity = previousDbEntity;
                }
            } // for properties
        } // for entities
        return allProcessedNodes;
    }
    resolveCircularDependencies(unorderedDependencies, context) {
        for (const node of unorderedDependencies) {
            const nodeOUID = this.entityStateManager.getOperationUniqueId(node.entity);
            this.resolveCircularDependenciesForNode(node, nodeOUID, node, context);
        }
    }
    resolveCircularDependenciesForNode(node, nodeOUID, currentlyTraversedNode, context, nodePath = []) {
        if (!currentlyTraversedNode.dependsOn
            || currentlyTraversedNode.circleTraversedFor[nodeOUID]) {
            return;
        }
        currentlyTraversedNode.circleTraversedFor[nodeOUID] = true;
        for (let i = currentlyTraversedNode.dependsOn.length - 1; i >= 0; i--) {
            const dependency = currentlyTraversedNode.dependsOn[i];
            const dependencyOUID = this.entityStateManager
                .getOperationUniqueId(dependency.entity);
            if (dependencyOUID === nodeOUID) {
                let entityPath = [];
                for (let pathNode of nodePath) {
                    let entityLongName = pathNode.dbEntity.applicationVersion.application.name + ':' + pathNode.dbEntity.name;
                    entityPath.push(entityLongName);
                }
                let entityLongName = dependency.dbEntity.applicationVersion.application.name + ':' + dependency.dbEntity.name;
                entityPath.push(entityLongName);
                entityLongName = nodePath[0].dbEntity.applicationVersion.application.name + ':' + nodePath[0].dbEntity.name;
                throw new Error(`Found a circular dependency in
					${entityPath.join(' -> ')}
					`);
            }
            nodePath.push(dependency);
            this.resolveCircularDependenciesForNode(node, nodeOUID, dependency, context, nodePath);
            nodePath.pop();
        }
    }
    orderEntitiesToPersist(unorderedDependencies, context) {
        let orderedNodes = [];
        let processedNodes = [];
        while (orderedNodes.length < unorderedDependencies.length) {
            for (const node of unorderedDependencies) {
                const entityUid = this.entityStateManager
                    .getOperationUniqueId(node.entity);
                if (processedNodes[entityUid]) {
                    continue;
                }
                let nodeProcessed = true;
                for (const dependency of node.dependsOn) {
                    const dependencyUid = this.entityStateManager
                        .getOperationUniqueId(dependency.entity);
                    // If a dependency is not yet processed (and is possibly has
                    // other dependencies of it's own)
                    if (!processedNodes[dependencyUid]) {
                        nodeProcessed = false;
                        break;
                    }
                }
                if (nodeProcessed) {
                    processedNodes[entityUid] = node;
                    orderedNodes.push(node);
                }
            }
        }
        return orderedNodes;
    }
    // Group alike operations together, where possible
    optimizePersistOperations(orderedDependencies, context) {
        let operationNodes = [];
        let processedNodes = [];
        let operationsByApplication_Index = [];
        for (const node of orderedDependencies) {
            const dbEntity = node.dbEntity;
            const applicationOperationNodes = this.datastructureUtils.ensureChildArray(operationsByApplication_Index, dbEntity.applicationVersion.application.index);
            let entityOperations = applicationOperationNodes[dbEntity.index];
            if (!entityOperations) {
                entityOperations = {
                    create: [],
                    delete: [],
                    update: []
                };
                applicationOperationNodes[dbEntity.index] = entityOperations;
            }
            let operations = [];
            if (node.isCreate) {
                operations = entityOperations.create;
            }
            else if (node.isDelete) {
                operations = entityOperations.delete;
            }
            else {
                operations = entityOperations.update;
            }
            let operation;
            if (!operations.length) {
                operation = {
                    dbEntity,
                    entities: [],
                    isCreate: node.isCreate,
                    isDelete: node.isDelete,
                };
                operations.push(operation);
                operationNodes.push(operation);
            }
            else {
                operation = operations[operations.length - 1];
            }
            // For each node traverse its dependencies
            // if it has dependencies that haven't been processed yet
            // then it can't be combined with an earlier alike operation
            // on the same entity
            let canBeCombined = true;
            for (const dependency of node.dependsOn) {
                const dependencyUid = this.entityStateManager
                    .getOperationUniqueId(dependency.entity);
                this.entityStateManager.getOperationUniqueId(dependency.entity);
                if (!processedNodes[dependencyUid]) {
                    canBeCombined = false;
                    break;
                }
            }
            if (!canBeCombined && operation.entities.length) {
                operation = {
                    dbEntity,
                    entities: [],
                    isCreate: node.isCreate,
                    isDelete: node.isDelete,
                };
                operations.push(operation);
                operationNodes.push(operation);
            }
            operation.entities.push(node.entity);
        }
        return operationNodes;
    }
    /**
     *
     * @param operationNodes
     * @param context
     */
    ensureUpdatesAreGroupedCorrectly(operationNodes, context) {
        // TODO: group related updates ONLY if all updates field values are
        // the same
        // throw new Error('Not Implemented.')
        return operationNodes;
    }
}

/**
 * Takes a serialized object tree and reconstructs a (potentially)
 * interlinked object graph.
 */
class EntityGraphReconstructor {
    restoreEntityGraph(root, context) {
        const entitiesByOperationIndex = [];
        const rootCopy = this.linkEntityGraph(root, entitiesByOperationIndex, false, context);
        for (let i = 1; i < entitiesByOperationIndex.length; i++) {
            const entity = entitiesByOperationIndex[i];
            if (!entity) {
                throw new Error(`Missing entity for
"${this.entityStateManager.getUniqueIdFieldName()}": ${i}`);
            }
        }
        context.lastOUID = entitiesByOperationIndex.length - 1;
        return rootCopy;
    }
    linkEntityGraph(currentEntities, entitiesByOperationIndex, isParentEntity, context) {
        const dbEntity = context.dbEntity;
        const results = [];
        for (const entity of currentEntities) {
            if (!entity) {
                throw new Error(`Null root entities and @OneToMany arrays with null entities are not allowed`);
            }
            const operationUniqueId = this.entityStateManager.getOperationUniqueId(entity);
            if (!operationUniqueId || typeof operationUniqueId !== 'number'
                || operationUniqueId < 1) {
                throw new Error(`Invalid entity Unique Id Field
"${this.entityStateManager.getUniqueIdFieldName()}": ${operationUniqueId}.`);
            }
            const previouslyFoundEntity = entitiesByOperationIndex[operationUniqueId];
            if (previouslyFoundEntity) {
                results.push(previouslyFoundEntity);
                continue;
            }
            /*
             * A passed in graph has either entities to be saved or
             * entity stubs that are needed structurally to get to
             * other entities.
             */
            let { isParentSchemaId, isStub } = this.entityStateManager
                .getEntityStateTypeAsFlags(entity, dbEntity);
            let entityCopy = {};
            entityCopy[this.entityStateManager.getUniqueIdFieldName()]
                = operationUniqueId;
            entityCopy[this.entityStateManager.getStateFieldName()]
                = this.entityStateManager.getEntityState(entity);
            this.entityStateManager.copyEntityState(entity, entityCopy);
            entitiesByOperationIndex[operationUniqueId]
                = entityCopy;
            if (isParentEntity) {
                this.entityStateManager.markAsOfParentSchema(entityCopy);
                isParentSchemaId = true;
            }
            for (const dbProperty of dbEntity.properties) {
                let propertyValue = entity[dbProperty.name];
                if (propertyValue === undefined) {
                    continue;
                }
                if (dbProperty.relation && dbProperty.relation.length) {
                    let relationIsFromParentSchema = false;
                    const dbRelation = dbProperty.relation[0];
                    let relatedEntities = propertyValue;
                    let isManyToOne = false;
                    this.assertRelationValueIsAnObject(propertyValue, dbProperty);
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            isManyToOne = true;
                            this.assertManyToOneNotArray(propertyValue, dbProperty);
                            relatedEntities = [propertyValue];
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            this.assertOneToManyIsArray(propertyValue, dbProperty);
                            break;
                        default:
                            throw new Error(`Unexpected relation type ${dbRelation.relationType}
for ${dbEntity.name}.${dbProperty.name}`);
                    } // switch dbRelation.relationType
                    const previousDbEntity = context.dbEntity;
                    const previousDbApplication = previousDbEntity.applicationVersion.application;
                    const propertyDbApplication = dbRelation.relationEntity.applicationVersion.application;
                    if (!this.appTrackerUtils.isInternalDomain(propertyDbApplication.domain.name)
                        && previousDbApplication.fullName !== propertyDbApplication.fullName) {
                        // If a child entity is in a different application it won't be processed
                        // the calling application should call the API of the other application
                        // explicitly so that the application logic may be run
                        relationIsFromParentSchema = true;
                    }
                    context.dbEntity = dbRelation.relationEntity;
                    let propertyCopyValue;
                    if (propertyValue) {
                        propertyCopyValue = this.linkEntityGraph(relatedEntities, entitiesByOperationIndex, isParentSchemaId || relationIsFromParentSchema, context);
                        if (isParentSchemaId || relationIsFromParentSchema) {
                            for (const propertyCopyValueEntry of propertyCopyValue) {
                                const operationUniqueId = this.entityStateManager
                                    .getOperationUniqueId(propertyCopyValueEntry);
                                if (!entitiesByOperationIndex[operationUniqueId]) {
                                    this.checkPropertyParentEntityStatus(propertyCopyValueEntry);
                                }
                            }
                        }
                        if (isManyToOne) {
                            propertyCopyValue = propertyCopyValue[0];
                        } // if (isManyToOne
                        // if !isManyToOne - nothing to do
                    } // if (propertyValue
                    propertyValue = propertyCopyValue;
                    context.dbEntity = previousDbEntity;
                } // if (dbProperty.relation
                else {
                    if (!dbProperty.isId) {
                        if (isStub) {
                            throw new Error(`Deletes and Stubs may only contain @Id properties or relations.`);
                        }
                    }
                } // else (dbProperty.relation
                entityCopy[dbProperty.name] = propertyValue;
            } // for (const dbProperty
            results.push(entityCopy);
        } // for (const entity
        return results;
    }
    checkPropertyParentEntityStatus(propertyCopyValue) {
        if (!this.entityStateManager.isParentSchemaId(propertyCopyValue)
            && !this.entityStateManager.isPassThrough(propertyCopyValue)) {
            throw new Error(`Parent Ids may only contain relations that are themselves Parent Ids or Pass-Though objects.`);
        }
    }
    assertRelationValueIsAnObject(relationValue, dbProperty) {
        if (relationValue !== null && relationValue !== undefined &&
            (typeof relationValue != 'object' || relationValue instanceof Date)) {
            throw new Error(`Unexpected value in relation property: ${dbProperty.name}, 
				of entity ${dbProperty.entity.name}`);
        }
    }
    assertManyToOneNotArray(relationValue, dbProperty) {
        if (relationValue instanceof Array) {
            throw new Error(`@ManyToOne relation cannot be an array. Relation property: ${dbProperty.name}, 
of entity ${dbProperty.entity.name}`);
        }
    }
    assertOneToManyIsArray(relationValue, dbProperty) {
        if (relationValue !== null
            && relationValue !== undefined
            && !(relationValue instanceof Array)) {
            throw new Error(`@OneToMany relation must be an array. Relation property: ${dbProperty.name}, 
of entity ${dbProperty.entity.name}\``);
        }
    }
}

/**
 * Created by Papa on 11/15/2016.
 */
class OperationManager {
    /**
     * Transactional context must have been started by the time this method is called.
     *
     * @param qEntity
     * @param entity
     */
    async performSave(entities, actor, transaction, rootTransaction, context) {
        let entityGraph;
        context.isSaveOperation = true;
        if (context.internal) {
            if (entities instanceof Array) {
                entityGraph = entities;
            }
            else {
                entityGraph = [entities];
            }
        }
        else {
            const verifiedTree = this.cascadeGraphVerifier
                .verify(entities, context);
            entityGraph = this.entityGraphReconstructor
                .restoreEntityGraph(verifiedTree, context);
        }
        const validationContext = {
            ...context,
            copiedRecordLedgers: [],
            crossRepositoryRelationLedgers: []
        };
        const missingRepositoryRecords = [];
        const topLevelObjectRepositoryHolder = [];
        this.structuralEntityValidator.validate(entityGraph, [], missingRepositoryRecords, topLevelObjectRepositoryHolder, validationContext);
        if (missingRepositoryRecords.length) {
            if (!topLevelObjectRepositoryHolder.length) {
                throw new Error(`There are entities without an assigned repository and no top level object
passed to '...Dao.save(...)' has a repository assigned`);
            }
            if (topLevelObjectRepositoryHolder.length > 1) {
                throw new Error(`When there are entities without an assigned repository
(when passed to '...Dao.save(...)') there may only be one (and same) repository assigned
in top level objects (that are passed into '...Dao.save(...)')`);
            }
            const repository = topLevelObjectRepositoryHolder[0];
            for (const missingRepositoryRecord of missingRepositoryRecords) {
                missingRepositoryRecord.record[missingRepositoryRecord.repositoryPropertyName]
                    = repository;
            }
        }
        const operations = this.dependencyGraphResolver
            .getOperationsInOrder(entityGraph, context);
        const rootDbEntity = context.dbEntity;
        let saveActor = {
            _localId: actor._localId,
            GUID: actor.GUID,
            userAccount: actor.userAccount ? {
                _localId: null,
                accountPublicSigningKey: actor.userAccount.accountPublicSigningKey
            } : null
        };
        let newRepository;
        if (context.rootTransaction.newRepository) {
            newRepository = {
                _localId: context.rootTransaction.newRepository._localId,
                createdAt: context.rootTransaction.newRepository.createdAt,
                GUID: context.rootTransaction.newRepository.GUID,
                ageSuitability: context.rootTransaction.newRepository.ageSuitability,
                source: context.rootTransaction.newRepository.source,
                owner: actor.userAccount ? {
                    _localId: null,
                    accountPublicSigningKey: actor.userAccount.accountPublicSigningKey
                } : null
            };
        }
        const saveResult = {
            actor: saveActor,
            created: {},
            deleted: {},
            newRepository,
            repositoryIdParts: newRepository ? {
                source: newRepository.source,
                GUID: newRepository.GUID
            } : null,
            updated: {},
        };
        for (const operation of operations) {
            context.dbEntity = operation.dbEntity;
            if (operation.isCreate) {
                await this.internalCreate(operation.entities, actor, transaction, rootTransaction, saveResult, context, true);
            }
            else if (operation.isDelete) {
                await this.internalDelete(operation.entities, actor, transaction, rootTransaction, saveResult, context);
            }
            else {
                await this.internalUpdate(operation.entities, actor, transaction, rootTransaction, saveResult, context);
            }
        }
        const flightRecorderDbApp = this.airportDatabase.applications.filter(dbApplication => dbApplication.domain.name === 'airport'
            && dbApplication.name === '@airport/flight-recorder')[0];
        // context.dbEntity = flightRecorderDbApp.currentVersion[0].applicationVersion.entityMapByName['CopiedRecordLedger']
        // await this.internalCreate(
        // 	validationContext.copiedRecordLedgers, actor, transaction, rootTransaction,
        // 	saveResult, context, true)
        context.dbEntity = flightRecorderDbApp.currentVersion[0].applicationVersion.entityMapByName['CrossRepositoryRelationLedger'];
        await this.internalCreate(validationContext.crossRepositoryRelationLedgers, actor, transaction, rootTransaction, saveResult, context, true);
        context.dbEntity = rootDbEntity;
        return saveResult;
    }
    async internalCreate(entities, actor, transaction, rootTransaction, saveResult, context, ensureGeneratedValues) {
        const qEntity = this.airportDatabase.qApplications[context.dbEntity.applicationVersion.application.index][context.dbEntity.name];
        let rawInsert = {
            INSERT_INTO: qEntity,
            columns: this.qMetadataUtils.getAllInsertableColumns(qEntity),
            VALUES: []
        };
        let columnIndexesInValues = [];
        rawInsert.columns.forEach((qField, index) => {
            columnIndexesInValues[qField.dbColumn.index] = index;
        });
        for (const entity of entities) {
            entity.createdAt = new Date();
        }
        for (const entity of entities) {
            let valuesFragment = [];
            for (const dbProperty of context.dbEntity.properties) {
                let newValue = entity[dbProperty.name];
                if (newValue === undefined) {
                    newValue = null;
                }
                if (dbProperty.relation && dbProperty.relation.length) {
                    const dbRelation = dbProperty.relation[0];
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            this.applicationUtils.forEachColumnOfRelation(dbRelation, entity, (dbColumn, columnValue, _propertyNameChains) => {
                                if (dbColumn.isGenerated) {
                                    return;
                                }
                                valuesFragment[columnIndexesInValues[dbColumn.index]]
                                    = columnValue === undefined ? null : columnValue;
                            }, false);
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            break;
                        default:
                            throw new Error(`Unknown relationType '${dbRelation.relationType}' 
						for '${context.dbEntity.name}.${dbProperty.name}'.`);
                    }
                }
                else {
                    let column = dbProperty.propertyColumns[0].column;
                    if (!column.isGenerated) {
                        valuesFragment[columnIndexesInValues[column.index]] = newValue;
                    }
                }
            }
            rawInsert.VALUES.push(valuesFragment);
        }
        const insertValues = new InsertValues(rawInsert, null);
        if (rawInsert.VALUES.length) {
            const generatedColumns = context.dbEntity.columns.filter(column => column.isGenerated);
            if (generatedColumns.length && ensureGeneratedValues) {
                const portableQuery = this.queryFacade
                    .getPortableQuery(insertValues, null, context);
                const idsAndGeneratedValues = await this.insertManager
                    .insertValuesGetLocalIds(portableQuery, actor, transaction, rootTransaction, context);
                for (let i = 0; i < entities.length; i++) {
                    const entity = entities[i];
                    const entitySaveResult = {};
                    saveResult.created[this.entityStateManager.getOperationUniqueId(entity)] = entitySaveResult;
                    for (const generatedColumn of generatedColumns) {
                        // Return index for generated column values is: DbColumn.index
                        const generatedPropertyName = generatedColumn.propertyColumns[0].property.name;
                        const generatedPropertyValue = idsAndGeneratedValues[i][generatedColumn.index];
                        entity[generatedPropertyName] = generatedPropertyValue;
                        entitySaveResult[generatedPropertyName] = generatedPropertyValue;
                    }
                }
            }
            else {
                const portableQuery = this.queryFacade
                    .getPortableQuery(insertValues, null, context);
                await this.insertManager.insertValues(portableQuery, actor, transaction, rootTransaction, context, ensureGeneratedValues);
                for (let i = 0; i < entities.length; i++) {
                    const entity = entities[i];
                    saveResult.created[this.entityStateManager.getOperationUniqueId(entity)] = true;
                }
            }
        }
    }
    /**
     * On an UPDATE operation, can a nested create contain an update?
     * Via:
     *  OneToMany:
     *    Yes, if the child entity is itself in the update cache
     *  ManyToOne:
     *    Cascades do not travel across ManyToOne
     */
    async internalUpdate(entities, actor, transaction, rootTransaction, saveResult, context) {
        const qEntity = this.airportDatabase.qApplications[context.dbEntity.applicationVersion.application.index][context.dbEntity.name];
        for (const entity of entities) {
            const setFragment = {};
            const idWhereFragments = [];
            let runUpdate = false;
            const originalEntity = this.entityStateManager.getOriginalValues(entity);
            if (!originalEntity) {
                continue;
            }
            for (const dbProperty of context.dbEntity.properties) {
                const updatedValue = entity[dbProperty.name];
                if (!dbProperty.relation || !dbProperty.relation.length) {
                    const originalValue = originalEntity[dbProperty.name];
                    if (dbProperty.isId) {
                        // For an id property, the value is guaranteed to be the same (and not empty) -
                        // cannot entity-update id fields
                        idWhereFragments.push(qEntity[dbProperty.name]
                            .equals(updatedValue));
                    }
                    else if (!this.utils.valuesEqual(originalValue, updatedValue)) {
                        setFragment[dbProperty.name] = updatedValue;
                        saveResult.updated[this.entityStateManager.getOperationUniqueId(entity)] = true;
                        runUpdate = true;
                    }
                }
                else {
                    const dbRelation = dbProperty.relation[0];
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            let propertyOriginalValue = originalEntity[dbProperty.name];
                            this.applicationUtils.forEachColumnOfRelation(dbRelation, entity, (_dbColumn, value, propertyNameChains) => {
                                let originalColumnValue = propertyOriginalValue;
                                let columnValue = value;
                                let valuePropertyNameChain = value;
                                for (const childPropertyName of propertyNameChains[0]) {
                                    if (originalColumnValue instanceof Object
                                        && originalColumnValue[childPropertyName]) {
                                        originalColumnValue = originalColumnValue[childPropertyName];
                                    }
                                    else {
                                        originalColumnValue = null;
                                    }
                                    if (columnValue instanceof Object
                                        && columnValue[childPropertyName]) {
                                        columnValue = columnValue[childPropertyName];
                                        valuePropertyNameChain.push(childPropertyName);
                                    }
                                    else {
                                        columnValue = null;
                                    }
                                }
                                if (dbProperty.isId) {
                                    let idQProperty = qEntity;
                                    for (const propertyNameLink of propertyNameChains[0]) {
                                        idQProperty = idQProperty[propertyNameLink];
                                    }
                                    // For an id property, the value is guaranteed to be the same (and not
                                    // empty) - cannot entity-update id fields
                                    idWhereFragments.push(idQProperty.equals(value));
                                }
                                else if (!this.utils.valuesEqual(originalColumnValue, columnValue)) {
                                    let currentSetFragment = setFragment;
                                    for (let i = 0; i < valuePropertyNameChain.length - 1; i++) {
                                        const childPropertyName = valuePropertyNameChain[i];
                                        if (!currentSetFragment[childPropertyName]) {
                                            currentSetFragment[childPropertyName] = {};
                                        }
                                        currentSetFragment = currentSetFragment[childPropertyName];
                                    }
                                    currentSetFragment[valuePropertyNameChain.length - 1] = columnValue;
                                    saveResult.updated[this.entityStateManager.getOperationUniqueId(entity)] = true;
                                    runUpdate = true;
                                }
                            }, dbProperty.isId);
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            break;
                        default:
                            throw new Error(`Unknown relationType '${dbRelation.relationType}' 
						for '${context.dbEntity.name}.${dbProperty.name}'.`);
                    }
                }
            }
            if (runUpdate) {
                let whereFragment;
                if (idWhereFragments.length > 1) {
                    whereFragment = AND(...idWhereFragments);
                }
                else {
                    whereFragment = idWhereFragments[0];
                }
                const rawUpdate = {
                    UPDATE: qEntity,
                    SET: setFragment,
                    WHERE: whereFragment
                };
                const update = new UpdateProperties(rawUpdate);
                const portableQuery = this.queryFacade.getPortableQuery(update, null, context);
                await this.updateManager.updateValues(portableQuery, actor, transaction, rootTransaction, context);
            }
        }
    }
    async internalDelete(entities, actor, transaction, rootTransaction, saveResult, context) {
        const dbEntity = context.dbEntity;
        const qEntity = this.airportDatabase.qApplications[dbEntity.applicationVersion.application.index][dbEntity.name];
        const idWhereFragments = [];
        const valuesMapByColumn = [];
        let entityIdWhereClauses = [];
        for (const entity of entities) {
            for (let propertyName in entity) {
                if (!entity.hasOwnProperty(propertyName)) {
                    continue;
                }
                const dbProperty = dbEntity.propertyMap[propertyName];
                // Skip transient fields
                if (!dbProperty) {
                    continue;
                }
                const deletedValue = entity[propertyName];
                let dbRelation;
                if (dbProperty.relation && dbProperty.relation.length) {
                    dbRelation = dbProperty.relation[0];
                }
                if (!dbRelation) {
                    if (dbProperty.isId) {
                        // For an id property, the value is guaranteed to be the same (and not empty) -
                        // cannot entity-update id fields
                        idWhereFragments.push(qEntity[propertyName].equals(deletedValue));
                    }
                }
                else {
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            this.applicationUtils.forEachColumnOfRelation(dbRelation, dbEntity, (dbColumn, value, propertyNameChains) => {
                                if (dbProperty.isId && valuesMapByColumn[dbColumn.index] === undefined) {
                                    let idQProperty = qEntity;
                                    for (const propertyNameLink of propertyNameChains[0]) {
                                        idQProperty = idQProperty[propertyNameLink];
                                    }
                                    // For an id property, the value is guaranteed to be the same (and not
                                    // empty) - cannot entity-update id fields
                                    idWhereFragments.push(idQProperty.equals(value));
                                }
                            }, false);
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            break;
                        default:
                            throw new Error(`Unknown relationType '${dbRelation.relationType}' 
						for '${dbEntity.name}.${dbProperty.name}'.`);
                    }
                }
            }
            if (idWhereFragments.length > 1) {
                entityIdWhereClauses.push(AND(...idWhereFragments));
            }
            else {
                entityIdWhereClauses.push(idWhereFragments[0]);
            }
            saveResult.deleted[this.entityStateManager.getOperationUniqueId(entity)] = true;
        }
        let WHERE;
        if (entityIdWhereClauses.length === 1) {
            WHERE = entityIdWhereClauses[0];
        }
        else {
            WHERE = OR(...entityIdWhereClauses);
        }
        let rawDelete = {
            DELETE_FROM: qEntity,
            WHERE
        };
        let deleteWhere = new Delete(rawDelete);
        let portableQuery = this.queryFacade.getPortableQuery(deleteWhere, null, context);
        await this.deleteManager.deleteWhere(portableQuery, actor, transaction, rootTransaction, context);
    }
}

class StructuralEntityValidator {
    validate(records, operatedOnEntityIndicator, missingRepositoryRecords, topLevelObjectRepositories, context, depth = 1, fromOneToMany = false, parentRelationProperty = null, rootRelationRecord = null, parentRelationRecord = null) {
        const dbEntity = context.dbEntity;
        if (!dbEntity.idColumns.length) {
            throw new Error(`Cannot run 'save' for entity '${dbEntity.name}' with no @Id(s).
					Please use non-entity operations (like 'insert' or 'updateWhere') instead.`);
        }
        let haveRootRelationRecord = !!rootRelationRecord;
        const levelObjectRepositoryMapByGUID = new Map();
        for (const record of records) {
            if (!haveRootRelationRecord) {
                rootRelationRecord = record;
            }
            const { isCreate, isParentSchemaId, isPassThrough, isStub } = this.entityStateManager.getEntityStateTypeAsFlags(record, dbEntity);
            if (isParentSchemaId) {
                // No processing is needed (already covered by id check)
                continue;
            }
            const operationUniqueId = this.entityStateManager.getOperationUniqueId(record);
            const entityAlreadyOperatedOn = operatedOnEntityIndicator[operationUniqueId];
            if (entityAlreadyOperatedOn) {
                continue;
            }
            operatedOnEntityIndicator[operationUniqueId] = true;
            let repositoryAssignmentFromParentNeeded = false;
            for (const dbProperty of dbEntity.properties) {
                let propertyValue = record[dbProperty.name];
                if (propertyValue === undefined && !isStub) {
                    propertyValue = null;
                    record[dbProperty.name] = propertyValue;
                }
                /*
                 * It is possible for the @Id's of an entity to be in
                 * a @ManyToOne, so we need to check
                 */
                if (dbProperty.relation && dbProperty.relation.length) {
                    const dbRelation = dbProperty.relation[0];
                    let relatedEntities = null;
                    let relationIsOneToMany = false;
                    let isRelationNullable = true;
                    switch (dbRelation.relationType) {
                        case EntityRelationType.MANY_TO_ONE:
                            // Id columns are for the parent (currently processed) entity and must be
                            // checked as part of this entity
                            if (dbProperty.isId) {
                                let isMissingRepositoryProperty = false;
                                this.applicationUtils.forEachColumnOfRelation(dbRelation, record, (dbColumn, columnValue, _propertyNameChains) => {
                                    if (dbColumn.notNull) {
                                        isRelationNullable = false;
                                    }
                                    if (this.isRepositoryColumnAndNewRepositoryNeed(dbEntity, dbProperty, dbColumn, isCreate, record, columnValue, context)) {
                                        isMissingRepositoryProperty = true;
                                    }
                                    else if (this.applicationUtils.isRepositoryId(dbColumn.name)) {
                                        const repository = record[dbProperty.name];
                                        if (!repository._localId || !repository.GUID) {
                                            throw new Error(`Repository must have a _localId and GUID assigned:
hence, it must an existing repository that exists locally.`);
                                        }
                                        if (!levelObjectRepositoryMapByGUID.has(repository.GUID)) {
                                            levelObjectRepositoryMapByGUID.set(repository.GUID, repository);
                                            if (depth == 1) {
                                                topLevelObjectRepositories.push(repository);
                                            }
                                        }
                                    }
                                }, false);
                                if (isMissingRepositoryProperty) {
                                    // TODO: document that creating a new repository will automatically
                                    // populate it in all objects passed to save that don't have a
                                    // repository record reference
                                    // TODO: document that if no new repository record is created
                                    // then a top level object must have a repository record reference.
                                    // Then all nested records without a repository record reference
                                    // will have that repository assigned
                                    if (!context.rootTransaction.newRepository) {
                                        repositoryAssignmentFromParentNeeded = true;
                                        missingRepositoryRecords.push({
                                            record,
                                            repositoryPropertyName: dbProperty.name
                                        });
                                    }
                                    else {
                                        record[dbProperty.name] = context.rootTransaction.newRepository;
                                    }
                                }
                            }
                            if (fromOneToMany) {
                                const parentOneToManyElems = parentRelationProperty.relation[0].oneToManyElems;
                                const parentMappedBy = parentOneToManyElems ? parentOneToManyElems.mappedBy : null;
                                const mappedBy = dbRelation.manyToOneElems ? dbRelation.manyToOneElems.mappedBy : null;
                                // NOTE: 'actor' or the 'repository' properties may be automatically populated
                                // in the entity by this.validateRelationColumn
                                if (parentMappedBy === dbProperty.name
                                    || mappedBy === parentRelationProperty.name) {
                                    // Always fix to the parent record
                                    record[dbProperty.name] = parentRelationRecord;
                                    // if (!propertyValue && !entity[dbProperty.name]) {
                                    // 	// The @ManyToOne side of the relationship is missing, add it
                                    // 	entity[dbProperty.name] = parentRelationEntity
                                    // }
                                }
                            }
                            const isActorProperty = this.dictionary.isActor(dbRelation.relationEntity);
                            if (propertyValue) {
                                if (isCreate && isActorProperty) {
                                    throw new Error(`.actor property must not be populated for new objects`);
                                }
                                relatedEntities = [propertyValue];
                            }
                            else if (!isRelationNullable) {
                                // Actor properties must be null when passed in
                                if (!isCreate && !isActorProperty) {
                                    throw new Error(`Non-nullable relation ${dbEntity.name}.${dbProperty.name} does not have value assigned`);
                                }
                            }
                            else {
                                console.warn(`Probably OK: Nullable @ManyToOne ${dbEntity.name}.${dbProperty.name} does not have anything assigned.`);
                            }
                            break;
                        case EntityRelationType.ONE_TO_MANY:
                            relationIsOneToMany = true;
                            relatedEntities = propertyValue;
                            break;
                        default:
                            throw new Error(`Unexpected relation type ${dbRelation.relationType}
for ${dbEntity.name}.${dbProperty.name}`);
                    } // switch dbRelation.relationType
                    if (relatedEntities && relatedEntities.length) {
                        const previousDbEntity = context.dbEntity;
                        context.dbEntity = dbRelation.relationEntity;
                        this.validate(relatedEntities, operatedOnEntityIndicator, missingRepositoryRecords, topLevelObjectRepositories, context, depth + 1, relationIsOneToMany, dbProperty, rootRelationRecord, record);
                        context.dbEntity = previousDbEntity;
                    }
                } // if (dbProperty.relation // else its not a relation property
                else {
                    const dbColumn = dbProperty.propertyColumns[0].column;
                    if (dbProperty.isId) {
                        const isIdColumnEmpty = this.applicationUtils.isIdEmpty(propertyValue);
                        this.ensureIdValue(dbEntity, dbProperty, dbColumn, isCreate, isIdColumnEmpty);
                    }
                    else {
                        if (isStub || isParentSchemaId) {
                            if (propertyValue !== undefined) {
                                throw new Error(`Unexpected non-@Id value Stub|ParentSchemaId|Deleted record.
Property: ${dbEntity.name}.${dbProperty.name}, with "${this.entityStateManager.getUniqueIdFieldName()}":  ${operationUniqueId}`);
                            }
                        }
                    }
                    this.ensureNonRelationalValue(dbProperty, dbColumn, propertyValue);
                } // else (dbProperty.relation
            } // for (const dbProperty of dbEntity.properties)
            if (!isPassThrough && !isStub && !isParentSchemaId) {
                this.ensureRepositoryValidity(record, rootRelationRecord, parentRelationRecord, dbEntity, parentRelationProperty, isCreate, repositoryAssignmentFromParentNeeded, context);
            }
        } // for (const record of records)
    }
    ensureRepositoryValidity(record, rootRelationRecord, parentRelationRecord, dbEntity, parentRelationProperty, _isCreate, repositoryAssignmentFromParentNeeded, context) {
        if (!dbEntity.isAirEntity) {
            return;
        }
        const airEntity = record;
        if (!parentRelationRecord) {
            if (repositoryAssignmentFromParentNeeded) {
                throw new Error(`
Invalid condition - entity that is root in the passed
in object graph does not have a repository assigned
`);
            }
            // There is no relationship yet between the parent and child records
            // This is the root record in the passed in object graph
            // NOTE: it's child records (both from @ManyToOne & @OneToMany)
            // will be check subsequently (with possible cross-Repository
            // relations added)
            return;
        }
        // If a repository from the parent record is assigned to this record
        if (repositoryAssignmentFromParentNeeded) {
            // no further checks needed, current record isn't get assigned to a
            // different (or new) Repository so it will be assigned to the
            // Repository of the parent record
            // Since the repository will be same as that of the parent, it's
            // not a cross-Repository scenario
            return;
        }
        // If the repositories of root record passed into the save operation and
        // the repository of the child record match
        if (rootRelationRecord.repository._localId === airEntity.repository._localId) {
            // no further checks needed, Repository is the same
            // across parent and child records
            return;
        }
        // NOTE: This rule is currently disabled - to can create new records
        // and assign them to existing repositories that are different from 
        // repositories of paret records (or assign it the newly created repository).
        // NOTE: it is possible to have records in the same repository that
        // cannot be joined together in queries, so there is no need to check a valid
        // path from this records to all other records passed to this save call that
        // have the same repository.
        // The disabled rule:
        // A new record cannot be created - it has a repository that isn't:
        // * Repository found in it's parent record,
        // * a new Repository,
        // 
        // So a new record is being created and either has an explicitly
        // assigned a Repository or has the sole (one and only per current rules)
        // new Repository that is created in the (root) transaction.
        /* 		if (_isCreate) {
                    throw new Error(`
        A newly created '${dbEntity.name}' record
        is being assigned to Repository _localId ${airEntity.repository._localId} (GUID: ${airEntity.repository.GUID})
        This is because it is being referenced via ${parentRelationProperty.entity.name}.${parentRelationProperty.name},
        from a record of Repository _localId ${parentRelationRecord.repository._localId} (GUID: ${parentRelationRecord.repository.GUID})
        
        Did you mean to set this record's Repository to be the same one
        as the Repository of the referencing (parent) record?
        `)
                } */
        // 
        const { manySideRepositoryLedger, oneSideRepositoryLedger } = this.crossRepositoryRelationManager.addRecords(parentRelationProperty.relation[0], parentRelationRecord, airEntity);
        context.crossRepositoryRelationLedgers.push(manySideRepositoryLedger);
        context.crossRepositoryRelationLedgers.push(oneSideRepositoryLedger);
        // NOTE: the below commented out code is for scenario where records
        // via @ManyToOne links that point to other repositories are copied
        // into the referencing repository
        // If it doesn't then it is a reference to another repository - switch
        // the record to the parent repository and set the sourceRepositoryValue
        // airEntity.repository = rootRelationRecord.repository
        // airEntity.copied = true
        // Flip the state of this record to EntityState.CREATE this record now
        // has to be created in the referencing repository
        // airEntity[this.entityStateManager.getStateFieldName()] = EntityState.CREATE
        // NOTE: If the child record is not provided and it's an optional
        // @ManyToOne() it will be treated as if no record is there.  That is
        // probaby the only correct way to handle it and a warning is
        // shown to the user in this case
    }
    isRepositoryColumnAndNewRepositoryNeed(dbEntity, dbProperty, dbColumn, isCreate, entity, columnValue, context) {
        if (!dbColumn.idIndex && dbColumn.idIndex !== 0) {
            return;
        }
        const isIdColumnEmpty = this.applicationUtils.isIdEmpty(columnValue);
        if (!dbEntity.isAirEntity) {
            this.ensureIdValue(dbEntity, dbProperty, dbColumn, isCreate, isIdColumnEmpty);
            return false;
        }
        if (!isIdColumnEmpty) {
            if (isCreate) {
                if (this.applicationUtils.isActorId(dbColumn.name)) {
                    throw new Error(`Actor cannot be passed in for create Operations`);
                }
            }
            return false;
        }
        if (!isCreate) {
            throw new Error(`Ids must be populated in entities for non-Create operations`);
        }
        if (this.applicationUtils.isRepositoryId(dbColumn.name)) {
            // Repository was not provided - use context's 'newRepository'
            return true;
        }
        else if (this.applicationUtils.isActorId(dbColumn.name)) {
            // Use context's 'actor'
            entity[dbProperty.name] = context.actor;
            return false;
        }
        else if (this.applicationUtils.isActorRecordId(dbColumn.name)) {
            return false;
        }
        throw new Error(`Unexpected @Id column '${dbColumn.name}' in a AirEntity.`);
    }
    ensureIdValue(dbEntity, dbProperty, dbColumn, isCreate, isIdColumnEmpty) {
        if (dbColumn.isGenerated) {
            if (isCreate && !isIdColumnEmpty) {
                throw new Error(`@GeneratedValue() @Id() ${dbEntity.name}.${dbProperty.name},
column:  ${dbColumn.name}
must NOT have a value for entity Insert operation.`);
            }
            else if (!isCreate && isIdColumnEmpty) {
                throw new Error(`@GeneratedValue() @Id() ${dbEntity.name}.${dbProperty.name} 
column:  ${dbColumn.name}
must have a value for entity non-Insert operations.`);
            }
        }
        else if (isIdColumnEmpty) {
            throw new Error(`non-@GeneratedValue() @Id() ${dbEntity.name}.${dbProperty.name},
column:  ${dbColumn.name}
must always have a value for all entity operations.`);
        }
    }
    ensureNonRelationalValue(dbProperty, dbColumn, value) {
        if (value === undefined || value === null) {
            return;
        }
        switch (dbColumn.type) {
            case SQLDataType.ANY:
                break;
            case SQLDataType.BOOLEAN:
                if (typeof value !== 'boolean') {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
            case SQLDataType.DATE:
                if (typeof value !== 'object' || !(value instanceof Date)) {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
            case SQLDataType.JSON:
                if (typeof value !== 'object' || value instanceof Date) {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
            case SQLDataType.NUMBER:
                if (typeof value !== 'number') {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
            case SQLDataType.STRING:
                if (typeof value !== 'string') {
                    this.throwUnexpectedProperty(dbProperty, dbColumn, value);
                }
                break;
        }
    }
    throwUnexpectedProperty(dbProperty, dbColumn, value) {
        throw new Error(`Unexpected property value '${value.toString()}' in property '${dbProperty.entity.name}.${dbProperty.name}'
		(column: '${dbColumn.name}').`);
    }
}

// TODO: figure out if this is needed - originally written for deserializing
// Client-side query parameters.  Since then moved to Isolates and generic
// API calls.  Probably should be used in go-tower to deserialize all of the
// method argiments passed it (and won't be tied to a query of any kind, API
// interface is generic, unless already known to contain entity objects.)
class QueryParameterDeserializer {
    deserialize(parameters, query, entityStateManager) {
        if (parameters.length !== query.jsonQuery.parameters.length) {
            throw new Error(`Wrong number of parameters for ${query.dbEntity.name}.${query.jsonQuery.queryName}
            Received:  ${parameters.length}
            Expecting: ${query.jsonQuery.parameters.length}
            `);
        }
        const deserializedParameters = [];
        for (let i = 0; i < parameters.length; i++) {
            const deserializedParameter = this.deserializeParameter(parameters[i], query.jsonQuery.parameters[i], i + 1, query, entityStateManager);
            deserializedParameters.push(deserializedParameter);
        }
        return deserializedParameters;
    }
    deserializeParameter(parameter, jsonQueryParameter, parameterIndex, query, entityStateManager) {
        switch (jsonQueryParameter.type) {
            case SQLDataType.BOOLEAN:
                this.checkTypeOfParameter(parameter, 'boolean', parameterIndex, query);
                break;
            case SQLDataType.DATE:
                if (!(parameter instanceof Object)
                    // || parameter[entityStateManager.getStateFieldName()] !== EntityState.RESULT_DATE
                    || !parameter.value) {
                    throw new Error(`Invalid Serialized Date format for:
                    ${query.dbEntity.name}.${query.jsonQuery.queryName}
                    parameter #: ${parameterIndex}
        got: ${JSON.stringify(parameter)}
                    `);
                }
                try {
                    return new Date(parameter);
                }
                catch (e) {
                    throw new Error(`Invalid Serialized Date format for:
                    ${query.dbEntity.name}.${query.jsonQuery.queryName}
                    parameter #: ${parameterIndex}
        got: ${JSON.stringify(parameter)}
                    `);
                }
                break;
            case SQLDataType.NUMBER:
                this.checkTypeOfParameter(parameter, 'number', parameterIndex, query);
                break;
            case SQLDataType.STRING:
                this.checkTypeOfParameter(parameter, 'string', parameterIndex, query);
                break;
            default:
                throw new Error(`Unsupported parameter type for:
                ${query.dbEntity.name}.${query.jsonQuery.queryName}
                parameter #: ${parameterIndex}
    got: ${jsonQueryParameter.type}
                `);
        }
        return parameter;
    }
    checkTypeOfParameter(parameter, expectedParameterType, parameterIndex, query) {
        const typeOfParameter = typeof parameter;
        if (typeOfParameter !== expectedParameterType) {
            throw new Error(`Expecting a '${expectedParameterType}' parameter for:
            ${query.dbEntity.name}.${query.jsonQuery.queryName}
            parameter #: ${parameterIndex}
got: ${typeOfParameter}
            `);
        }
    }
}

// TODO: figure out if this is needed - originally written for serializing
// query resuts returned to the client.  Since then moved to Isolates and
// generic API calls.  Probably should be used in go-tower to serialize
// the values returned (and won't be tied to a query of any kind, API
// interface is generic, unless already known to contain entity objects.)
class QueryResultsSerializer {
    serialize(entity, dbEntity, entityStateManager, applicationUtils) {
        const operation = {
            lookupTable: [],
            sequence: 0,
            stubLookupTable: []
        };
        let serializedEntity;
        if (entity instanceof Array) {
            serializedEntity = entity.map(anEntity => this.doSerialize(anEntity, dbEntity, operation, entityStateManager, applicationUtils));
        }
        else {
            serializedEntity = this.doSerialize(entity, dbEntity, operation, entityStateManager, applicationUtils);
        }
        for (let i = 1; i < operation.lookupTable.length; i++) {
            delete operation.lookupTable[i][entityStateManager.getUniqueIdFieldName()];
        }
        return serializedEntity;
    }
    doSerialize(entity, dbEntity, operation, entityStateManager, applicationUtils) {
        // TODO: add support for non-create operations
        let operationUniqueId = entityStateManager.getOperationUniqueId(entity);
        if (operationUniqueId) {
            return operation.stubLookupTable[operationUniqueId];
        }
        operationUniqueId = ++operation.sequence;
        let entityStub = {};
        entityStub[entityStateManager.getUniqueIdFieldName()] = operationUniqueId;
        entityStub[entityStateManager.getStateFieldName()] = EntityState.STUB;
        operation.stubLookupTable[operationUniqueId] = entityStub;
        let entityCopy = {};
        operation.lookupTable[operationUniqueId] = entity;
        entityCopy[entityStateManager.getUniqueIdFieldName()] = operationUniqueId;
        // TODO: Test this - used to be assigned to EntitState.RESULT, which is removed
        entityCopy[entityStateManager.getStateFieldName()]
            = entity[entityStateManager.getStateFieldName()];
        for (const dbProperty of dbEntity.properties) {
            let property = entity[dbProperty.name];
            if (applicationUtils.isEmpty(property)) {
                continue;
            }
            let propertyCopy;
            if (dbProperty.relation) {
                const dbRelation = dbProperty.relation[0];
                if (property instanceof Array) {
                    propertyCopy = property.map(manyObject => {
                        this.doSerialize(manyObject, dbRelation.relationEntity, operation, entityStateManager, applicationUtils);
                    });
                }
                else {
                    propertyCopy = this.doSerialize(property, dbRelation.relationEntity, operation, entityStateManager, applicationUtils);
                }
            }
            else {
                switch (dbProperty.propertyColumns[0].column.type) {
                    case SQLDataType.JSON:
                        // 	if (property instanceof Array) {
                        // 		propertyCopy = {
                        // 			value: property
                        // 		}
                        // 		propertyCopy[entityStateManager.getStateFieldName()]
                        // 			= EntityState.RESULT_JSON_ARRAY
                        // 	} else {
                        // 		propertyCopy = property
                        // 		propertyCopy[entityStateManager.getStateFieldName()]
                        // 			= EntityState.RESULT_JSON
                        // 	}
                        throw new Error(`@Json() properties cannot be serialized.`);
                    case SQLDataType.DATE:
                        propertyCopy = {
                            value: property.toISOString()
                        };
                        propertyCopy[entityStateManager.getStateFieldName()]
                            = EntityState.DATE;
                        break;
                    case SQLDataType.ANY:
                    case SQLDataType.BOOLEAN:
                    case SQLDataType.NUMBER:
                    case SQLDataType.STRING:
                        propertyCopy = property;
                        break;
                    default:
                        throw new Error(`Unsupported data type for property ${dbEntity.applicationVersion.application.name}.${dbEntity.name}.${dbProperty.name}`);
                }
            }
            entityCopy[dbProperty.name] = propertyCopy;
        }
        return entityCopy;
    }
}

/**
 * Created by Papa on 6/30/2016.
 */
new Date().getTime();

class TerminalSessionManager {
    async getUserSession() {
        let session;
        if (this.terminalStore.getIsServer()) {
            throw new Error(`Implement`);
        }
        else {
            const allSessions = this.userStore.getAllSessions();
            if (allSessions.length != 1) {
                throw new Error(`No User Session found`);
            }
            session = allSessions[0];
        }
        return session;
    }
    async getUserAccountFromSession() {
        const userSession = await this.getUserSession();
        const userAccount = userSession.userAccount;
        if (!userAccount) {
            throw new Error(`No UserAccount found in User Session`);
        }
        return userAccount;
    }
}

const terminal = lib('terminal');
REPOSITORY_LOADER.setClass(RepositoryLoader);
TRANSACTIONAL_CONNECTOR.setClass(InternalTransactionalConnector);
TRANSACTIONAL_CONNECTOR.setDependencies({
    terminalStore: TerminalStore,
    transactionalServer: TRANSACTIONAL_SERVER
});
TRANSACTIONAL_SERVER.setClass(TransactionalServer);
TRANSACTION_MANAGER.setClass(TransactionManager);
QUERY_PARAMETER_DESERIALIZER.setClass(QueryParameterDeserializer);
QUERY_RESULTS_SERIALIZER.setClass(QueryResultsSerializer);
terminal.register(AbstractMutationManager, TransactionalReceiver, CascadeGraphVerifier, DatabaseManager, DeleteManager, DependencyGraphResolver, EntityGraphReconstructor, InsertManager, InternalRecordManager, OnlineManager, OperationManager, QueryManager, StructuralEntityValidator, UpdateManager);
terminal.setDependencies(AbstractMutationManager, {
    applicationUtils: ApplicationUtils,
    fieldUtils: FieldUtils,
    queryUtils: QUERY_UTILS,
    relationManager: RelationManager
});
terminal.setDependencies(TransactionalReceiver, {
    appTrackerUtils: AppTrackerUtils,
    terminalStore: TerminalStore,
    transactionalServer: TRANSACTIONAL_SERVER
});
terminal.setDependencies(DatabaseManager, {
    airportDatabase: AIRPORT_DATABASE,
    applicationDao: ApplicationDao,
    applicationInitializer: APPLICATION_INITIALIZER,
    dbApplicationUtils: DbApplicationUtils,
    internalRecordManager: InternalRecordManager,
    storeDriver: STORE_DRIVER,
    transactionalServer: TRANSACTIONAL_SERVER,
    transactionManager: TRANSACTION_MANAGER
});
terminal.setDependencies(DeleteManager, {
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: ApplicationUtils,
    datastructureUtils: DatastructureUtils,
    dictionary: Dictionary,
    historyManager: HISTORY_MANAGER,
    operationHistoryDuo: OperationHistoryDuo,
    recordHistoryDuo: RecordHistoryDuo,
    repositoryTransactionHistoryDuo: RepositoryTransactionHistoryDuo,
    systemWideOperationIdUtils: SystemWideOperationIdUtils,
    utils: Utils
});
terminal.setDependencies(DependencyGraphResolver, {
    datastructureUtils: DatastructureUtils,
    dictionary: Dictionary,
    entityStateManager: ENTITY_STATE_MANAGER
});
terminal.setDependencies(EntityGraphReconstructor, {
    appTrackerUtils: AppTrackerUtils,
    entityStateManager: ENTITY_STATE_MANAGER
});
HISTORY_MANAGER.setClass(HistoryManager);
HISTORY_MANAGER.setDependencies({
    transactionHistoryDuo: TransactionHistoryDuo,
});
terminal.setDependencies(InsertManager, {
    airportDatabase: AIRPORT_DATABASE,
    dictionary: Dictionary,
    historyManager: HISTORY_MANAGER,
    operationHistoryDuo: OperationHistoryDuo,
    recordHistoryDuo: RecordHistoryDuo,
    repositoryTransactionHistoryDuo: RepositoryTransactionHistoryDuo,
    sequenceGenerator: SEQUENCE_GENERATOR,
    systemWideOperationIdUtils: SystemWideOperationIdUtils,
});
terminal.setDependencies(InternalRecordManager, {
    actorDao: ActorDao,
    applicationDao: ApplicationDao,
    domainDao: DomainDao,
    entityStateManager: ENTITY_STATE_MANAGER,
    terminalSessionManager: TERMINAL_SESSION_MANAGER,
    terminalStore: TerminalStore,
    transactionManager: TRANSACTION_MANAGER
});
REPOSITORY_MANAGER.setClass(RepositoryManager);
REPOSITORY_MANAGER.setDependencies({
    dictionary: Dictionary,
    repositoryMaintenanceManager: RepositoryMaintenanceManager,
    repositoryDao: RepositoryDao,
    repositoryMemberDao: RepositoryMemberDao,
    terminalSessionManager: TERMINAL_SESSION_MANAGER,
    terminalStore: TerminalStore
});
terminal.setDependencies(OnlineManager, {
    repositoryDao: RepositoryDao,
    repositoryManager: RepositoryManager,
    repositoryTransactionHistoryDao: RepositoryTransactionHistoryDao,
    transactionManager: TRANSACTION_MANAGER
});
terminal.setDependencies(OperationManager, {
    airportDatabase: AIRPORT_DATABASE,
    applicationUtils: ApplicationUtils,
    cascadeGraphVerifier: CascadeGraphVerifier,
    deleteManager: DeleteManager,
    dependencyGraphResolver: DependencyGraphResolver,
    dictionary: Dictionary,
    entityGraphReconstructor: EntityGraphReconstructor,
    entityStateManager: ENTITY_STATE_MANAGER,
    insertManager: InsertManager,
    qMetadataUtils: QMetadataUtils,
    queryFacade: QUERY_FACADE,
    repositoryManager: RepositoryManager,
    structuralEntityValidator: StructuralEntityValidator,
    updateManager: UpdateManager,
    utils: Utils
});
terminal.setDependencies(QueryManager, {
    actorDao: ActorDao,
    airportDatabase: AIRPORT_DATABASE,
    datastructureUtils: DatastructureUtils,
    dictionary: Dictionary,
    observableQueryAdapter: ObservableQueryAdapter,
    repositoryDao: RepositoryDao,
    repositoryLoader: REPOSITORY_LOADER,
    storeDriver: STORE_DRIVER
});
REPOSITORY_LOADER.setDependencies({
    repositoryDao: RepositoryDao,
    synchronizationAdapterLoader: SynchronizationAdapterLoader,
    synchronizationInManager: SynchronizationInManager
});
terminal.setDependencies(StructuralEntityValidator, {
    applicationUtils: ApplicationUtils,
    crossRepositoryRelationManager: CrossRepositoryRelationManager,
    dbApplicationUtils: DbApplicationUtils,
    dictionary: Dictionary,
    entityStateManager: ENTITY_STATE_MANAGER,
});
TERMINAL_SESSION_MANAGER.setClass(TerminalSessionManager);
TERMINAL_SESSION_MANAGER.setDependencies({
    terminalStore: TerminalStore,
    userStore: UserStore
});
TRANSACTION_MANAGER.setDependencies({
    appTrackerUtils: AppTrackerUtils,
    idGenerator: IdGenerator,
    repositoryMemberAcceptanceDao: RepositoryMemberAcceptanceDao,
    repositoryMemberDao: RepositoryMemberDao,
    repositoryMemberInvitationDao: RepositoryMemberInvitationDao,
    storeDriver: STORE_DRIVER,
    synchronizationOutManager: SynchronizationOutManager,
    terminalSessionManager: TERMINAL_SESSION_MANAGER,
    terminalStore: TerminalStore,
    transactionHistoryDuo: TransactionHistoryDuo,
});
TRANSACTIONAL_RECEIVER.setDependencies({
    actorDao: ActorDao,
    applicationDao: ApplicationDao,
    databaseManager: DatabaseManager,
    dbApplicationUtils: DbApplicationUtils,
    internalRecordManager: InternalRecordManager,
    localApiServer: LOCAL_API_SERVER,
    terminalSessionManager: TERMINAL_SESSION_MANAGER,
    terminalStore: TerminalStore,
    transactionManager: TRANSACTION_MANAGER,
    transactionalServer: TRANSACTIONAL_SERVER
});
TRANSACTIONAL_SERVER.setDependencies({
    appTrackerUtils: AppTrackerUtils,
    deleteManager: DeleteManager,
    insertManager: InsertManager,
    operationManager: OperationManager,
    queryManager: QueryManager,
    repositoryManager: RepositoryManager,
    terminalStore: TerminalStore,
    transactionManager: TRANSACTION_MANAGER,
    updateManager: UpdateManager
});
terminal.setDependencies(UpdateManager, {
    airportDatabase: AIRPORT_DATABASE,
    datastructureUtils: DatastructureUtils,
    dictionary: Dictionary,
    fieldUtils: FieldUtils,
    historyManager: HISTORY_MANAGER,
    operationHistoryDuo: OperationHistoryDuo,
    queryFacade: QUERY_FACADE,
    queryUtils: QUERY_UTILS,
    recordHistoryDuo: RecordHistoryDuo,
    relationManager: RelationManager,
    repositoryTransactionHistoryDuo: RepositoryTransactionHistoryDuo,
    systemWideOperationIdUtils: SystemWideOperationIdUtils,
});

class OperationSerializer {
    serializeAsArray(entity) {
        let serializedEntity = [];
        if (!entity) {
            return serializedEntity;
        }
        if (entity instanceof Array) {
            serializedEntity = entity
                .map(anEntity => this.serialize(anEntity));
        }
        else {
            serializedEntity = [this.serialize(entity)];
        }
        return serializedEntity;
    }
    serialize(entity) {
        const operation = {
            namePath: ['root'],
            processedEntityMap: new Map(),
            sequence: 0,
            stubLookupTable: [],
        };
        return this.doSerialize(entity, operation);
    }
    doSerialize(entity, operation) {
        if (entity instanceof Object) {
            if (entity instanceof Array) {
                return entity.map(anEntity => this.doSerialize(anEntity, operation));
            }
            else if (entity instanceof Date) {
                return this.serializationStateManager.serializeAsDate(entity);
            }
        }
        else {
            return entity;
        }
        let operationUniqueId = operation.processedEntityMap.get(entity);
        if (operationUniqueId) {
            return operation.stubLookupTable[operationUniqueId];
        }
        operationUniqueId = ++operation.sequence;
        operation.processedEntityMap.set(entity, operationUniqueId);
        let entityStub = {};
        this.serializationStateManager.markAsStub(entity);
        entityStub[this.serializationStateManager.getUniqueIdFieldName()] = operationUniqueId;
        operation.stubLookupTable[operationUniqueId] = entityStub;
        let serializedEntity = {};
        serializedEntity[this.serializationStateManager.getUniqueIdFieldName()] = operationUniqueId;
        var isFirstProperty = true;
        for (const propertyName in entity) {
            const property = entity[propertyName];
            // const propertyState = property[serializationStateManager.getStateFieldName()]
            let propertyCopy;
            if (!isFirstProperty) {
                operation.namePath.pop();
            }
            isFirstProperty = false;
            operation.namePath.push(propertyName);
            if (property instanceof Object) {
                if (property instanceof Array) {
                    // if (propertyState === EntityState.RESULT_JSON_ARRAY) {
                    // 	propertyCopy = {
                    // 		value: JSON.stringify(property)
                    // 	}
                    // 	propertyCopy[entityStateManager.getStateFieldName()] = propertyState
                    // } else {
                    propertyCopy = property.map(aProperty => this.doSerialize(aProperty, operation));
                    // }
                }
                else if (property instanceof Date) {
                    propertyCopy = this.serializationStateManager.serializeAsDate(property);
                }
                else {
                    // if (propertyState === EntityState.RESULT_JSON) {
                    // 	propertyCopy = {
                    // 		value: JSON.stringify(property)
                    // 	}
                    // 	propertyCopy[entityStateManager.getStateFieldName()] = propertyState
                    // } else {
                    propertyCopy = this.doSerialize(property, operation);
                    // }
                }
            }
            else {
                // switch (propertyState) {
                // 	// case EntityState.RESULT_JSON_ARRAY:
                // 	// 	if (property) {
                // 	// 		throw new Error(`Expecting an Array for "${operation.namePath.join('.')}", got: ${property}`)
                // 	// 	}
                // 	// 	break
                // 	// case EntityState.RESULT_JSON:
                // 	// 	if (property) {
                // 	// 		throw new Error(`Expecting an Object for "${operation.namePath.join('.')}", got: ${property}`)
                // 	// 	}
                // 	// 	break
                // 	case SerializationState.DATE:
                // 		if (property) {
                // 			throw new Error(`Expecting a Date for "${operation.namePath.join('.')}", got: ${property}`)
                // 		}
                // 		break
                // 	default:
                propertyCopy = property;
                // break
                // }
            }
            serializedEntity[propertyName] = propertyCopy;
        }
        if (!isFirstProperty) {
            operation.namePath.pop();
        }
        return serializedEntity;
    }
}

var SerializationState;
(function (SerializationState) {
    SerializationState["DATE"] = "DATE";
    SerializationState["STUB"] = "STUB";
})(SerializationState || (SerializationState = {}));
class SerializationStateManager {
    getSerializationUniqueId(entity, throwIfNotFound = true) {
        const serializationUniqueId = entity[SerializationStateManager.SERIALIZATION_UNIQUE_ID_FIELD];
        if (!serializationUniqueId || typeof serializationUniqueId !== 'number' || serializationUniqueId < 1) {
            if (throwIfNotFound) {
                throw new Error(`Could not find "${SerializationStateManager.SERIALIZATION_UNIQUE_ID_FIELD}" property on DTO:
        
        ${JSON.stringify(entity)}`);
            }
        }
        return serializationUniqueId;
    }
    getEntityState(entity) {
        return entity[SerializationStateManager.SERIALIZATION_STATE_FIELD];
    }
    markAsStub(entity) {
        this.markAs(entity, SerializationState.STUB);
    }
    isStub(entity) {
        return this.is(entity, SerializationState.STUB);
    }
    serializeAsDate(value) {
        return {
            __serializationState__: SerializationState.DATE,
            value: value.toISOString()
        };
    }
    isDate(entity) {
        return this.is(entity, SerializationState.DATE);
    }
    getUniqueIdFieldName() {
        return SerializationStateManager.SERIALIZATION_UNIQUE_ID_FIELD;
    }
    // getStateFieldName(): string {
    //     return SerializationStateManager.SERIALIZATION_STATE_FIELD
    // }
    is(entity, serializationState) {
        return entity[SerializationStateManager.SERIALIZATION_STATE_FIELD] == serializationState;
    }
    markAs(entity, serializationState) {
        entity[SerializationStateManager.SERIALIZATION_STATE_FIELD] = serializationState;
    }
}
SerializationStateManager.SERIALIZATION_UNIQUE_ID_FIELD = '__SUID__';
SerializationStateManager.SERIALIZATION_STATE_FIELD = '__serializationState__';
SerializationStateManager.ORIGINAL_VALUES_PROPERTY = '__originalValues__';

/*
interface ArrayMemberEntityRecord<T> {
    index: number,
    entity: T
}
*/
/*

Instead of doing a blind "copy if GUID is present otherwise do nothing":

1.	When sending objects, mark them all with serialization Ids
2.  Retain those Ids during operations in @Api()s & AIRport
3.	Map all objects on the way back by these serialization ids
4.	Do a copy from -> to based on those ids

interface ArrayMemberRecord<T> {
    index: number,
    isWithoutId: boolean
    isObject: boolean
    isEntity: boolean
    isPrimitive: boolean
    entity: T
}

interface ArrayEntityInfo {
    hasWithoutId: boolean
    hasObjects: boolean
    hasEntities: boolean
    hasPrimitives: boolean
    entityMap: Map<string, ArrayMemberEntityRecord<any>>
    entityArray: ArrayMemberRecord<any>[]
}
 */
class QueryResultsDeserializer {
    deserialize(entity, operation = {
        lookupTable: [],
    }) {
        let deserializedEntity;
        if (entity instanceof Array) {
            deserializedEntity = entity.map(anEntity => this.doDeserialize(anEntity, operation));
        }
        else {
            deserializedEntity = this.doDeserialize(entity, operation);
        }
        return deserializedEntity;
    }
    doDeserialize(entity, operation) {
        let state = this.serializationStateManager.getEntityState(entity);
        switch (state) {
            case SerializationState.DATE:
                return new Date(entity['value']);
            // case EntityState.RESULT_JSON:
            // 	return entity
            // case EntityState.RESULT_JSON_ARRAY:
            // 	const value = entity['value']
            // 	value[entityStateManager.getStateFieldName()] = EntityState.RESULT_JSON_ARRAY
            // 	return entity
        }
        let operationUniqueId = this.serializationStateManager.getSerializationUniqueId(entity);
        if (!operationUniqueId || typeof operationUniqueId !== 'number' || operationUniqueId < 1) {
            throw new Error(`Invalid or missing ${this.serializationStateManager.getUniqueIdFieldName()} field.`);
        }
        let alreadyDeserializedEntity = operation.lookupTable[operationUniqueId];
        switch (state) {
            case SerializationState.STUB: {
                if (!alreadyDeserializedEntity) {
                    throw new Error(`Could not find an already present entity for
					${this.serializationStateManager.getUniqueIdFieldName()} of ${operationUniqueId}`);
                }
                return alreadyDeserializedEntity;
            }
            default:
                if (alreadyDeserializedEntity) {
                    throw new Error(`Entity appears more than once for
					${this.serializationStateManager.getUniqueIdFieldName()} of ${operationUniqueId}`);
                }
        }
        let deserializedEntity = {};
        operation.lookupTable[operationUniqueId] = deserializedEntity;
        for (const propertyName in entity) {
            const property = entity[propertyName];
            let propertyCopy;
            if (property instanceof Object) {
                propertyCopy = this.deserialize(property, operation);
            }
            else {
                propertyCopy = property;
            }
            deserializedEntity[propertyName] = propertyCopy;
        }
        delete deserializedEntity[this.serializationStateManager.getUniqueIdFieldName()];
        return deserializedEntity;
    }
    // private getArrayEntityMap() {
    // 	{
    // 		hasWithoutId: boolean
    // 		hasObjects: boolean
    // 		hasEntities: boolean
    // 		hasPrimitives: boolean
    // 		entityMap: Map < string, ArrayMemberEntityRecord < any >>
    // 			entityArray: ArrayMemberRecod[]
    // 	}
    // }
    deepCopyProperties(from, to, fromToMap, processedEntities = new Set()) {
        if (!(from instanceof Object)) {
            return;
        }
        if (from instanceof Date) {
            return;
        }
        for (let propertyName in from) {
            if (!from.hasOwnProperty(propertyName)) {
                continue;
            }
            this.copyObject(from, propertyName, to, fromToMap);
        }
        for (let propertyName in to) {
            if (!to.hasOwnProperty(propertyName)) {
                continue;
            }
            if (!from.hasOwnProperty(propertyName)) {
                delete to[propertyName];
            }
        }
        this.doSetPropertyDescriptors(to, processedEntities);
    }
    copyObject(fromParent, key, toParent, fromToMap) {
        let from = fromParent[key];
        let to = toParent[key];
        let alreadyProcessedTo = fromToMap.get(from);
        if (alreadyProcessedTo) {
            toParent[key] = alreadyProcessedTo;
            return;
        }
        if (from instanceof Object) {
            if (from instanceof Array) {
                if (!to || !(to instanceof Array)) {
                    to = [];
                    toParent[key] = to;
                }
                fromToMap.set(from, to);
                for (let i = 0; i < from.length; i++) {
                    this.copyObject(from, i, to, fromToMap);
                }
            }
            else if (from instanceof Date) {
                toParent[key] = new Date(from.getTime());
            }
            else {
                if (!to || !(to instanceof Object) || to instanceof Date || to instanceof Array) {
                    to = {};
                    toParent[key] = to;
                }
                fromToMap.set(from, to);
                this.deepCopyProperties(from, to, fromToMap);
            }
        }
        else {
            toParent[key] = from;
        }
    }
    setPropertyDescriptors(object, processedEntities = new Set()) {
        if (object instanceof Array) {
            for (let i = 0; i < object.length; i++) {
                this.setPropertyDescriptors(object[i], processedEntities);
            }
            return;
        }
        if (!(object instanceof Object)) {
            return;
        }
        if (object instanceof Date) {
            return;
        }
        if (processedEntities.has(object)) {
            return;
        }
        processedEntities.add(object);
        for (let propertyName in object) {
            if (!object.hasOwnProperty(propertyName)) {
                continue;
            }
            let property = object[propertyName];
            if (propertyName !== SerializationStateManager.ORIGINAL_VALUES_PROPERTY
                && !(property instanceof Date) && property instanceof Object) {
                this.setPropertyDescriptors(property, processedEntities);
            }
        }
        this.doSetPropertyDescriptors(object, processedEntities);
    }
    doSetPropertyDescriptors(object, processedEntities) {
        let objectPrototype = Object.getPrototypeOf(object);
        if (!Object.getOwnPropertyDescriptor(object, 'id')
            && (!objectPrototype
                || !Object.getOwnPropertyDescriptor(objectPrototype, 'id'))
            && !object.id) {
            let _this = this;
            Object.defineProperty(object, 'id', {
                get() {
                    let container = _this.__container__;
                    // In UI mode this.__container__ won't be set since depenceny injection library
                    // is not loaded and objects are wired in manually in @airport/autopilot 
                    if (!container) {
                        container = globalThis.IOC;
                    }
                    return container.getSync(globalThis.AIR_ENTITY_UTILS).encodeId(this);
                },
                set(idString) {
                    let container = _this.__container__;
                    // In UI mode this.__container__ won't be set since depenceny injection library
                    // is not loaded and objects are wired in manually in @airport/autopilot 
                    if (!container) {
                        container = globalThis.IOC;
                    }
                    return container.getSync(globalThis.AIR_ENTITY_UTILS).setId(idString, this);
                }
            });
        }
        if (!Object.getOwnPropertyDescriptor(object, 'isNew')
            && (!objectPrototype
                || !Object.getOwnPropertyDescriptor(objectPrototype, 'isNew'))
            && !object.isNew) {
            Object.defineProperty(object, 'isNew', {
                get() {
                    return !!this._actorRecordId;
                }
            });
        }
        if (!Object.getOwnPropertyDescriptor(object, 'createdBy')
            && (!objectPrototype
                || !Object.getOwnPropertyDescriptor(objectPrototype, 'createdBy'))
            && !object.createdBy) {
            Object.defineProperty(object, 'createdBy', {
                get() {
                    return this.actor.userAccount;
                }
            });
        }
    }
}

// This library is used in UI/Client bundles and does does not include @airport/direction-indicator
// dependency injection library
if (globalThis.IOC) {
    globalThis.OPERATION_SERIALIZER.setClass(OperationSerializer);
    globalThis.SERIALIZATION_STATE_MANAGER.setClass(SerializationStateManager);
    globalThis.QUERY_RESULTS_DESERIALIZER.setClass(QueryResultsDeserializer);
    globalThis.OPERATION_SERIALIZER.setDependencies({
        serializationStateManager: globalThis.SERIALIZATION_STATE_MANAGER
    });
    globalThis.QUERY_RESULTS_DESERIALIZER.setDependencies({
        airEntityUtils: globalThis.AIR_ENTITY_UTILS,
        serializationStateManager: globalThis.SERIALIZATION_STATE_MANAGER
    });
}

class ApiRegistry {
    initialize(applicationApi) {
        this.applicationStore.state.api = applicationApi;
    }
    async findApiObjectAndOperation(domainName, applicationName, apiInterfaceName, methodName) {
        return await this.findObjectAndOperationForApi(this.applicationStore.state.api, domainName, applicationName, apiInterfaceName, methodName);
    }
    async findObjectAndOperationForApi(api, domainName, applicationName, apiInterfaceName, methodName) {
        const apiObjectDefinition = api.apiObjectMap[apiInterfaceName];
        if (!apiObjectDefinition) {
            throw new Error(`Could not find API object for
        Domain:
            ${domainName}
        Application:
            ${applicationName}
        Interface:
            ${apiInterfaceName}
            
            ---===<<<((( Please remember, generator must be run after API modifications )))>>>===---

            `);
        }
        const apiOperation = apiObjectDefinition.operationMap[methodName];
        if (!apiOperation) {
            throw new Error(`Could not find API object method for 
        Domain:
            ${domainName}
        Application:
            ${applicationName}
        Interface:
            ${apiInterfaceName}
        Method name:
            ${methodName}
            
            ---===<<<((( Please remember, generator must be run after API modifications )))>>>===---

            `);
        }
        const apiObject = await this.containerAccessor.getContainer(this)
            .getByNames(domainName, applicationName, apiInterfaceName);
        return {
            apiObject,
            apiOperation
        };
    }
}

class ApiValidator {
    validate(operation, parameters) {
        // FIXME: implement (eventually)
    }
}

class LocalAPIServer {
    async handleRequest(request) {
        let payload;
        let errorMessage;
        try {
            // TODO: this should be inside coreHandleRequest after retrieval
            // of apiOperation.  For that requestManager must be supported
            // by the main @airport/terminal. It works in App VMs since
            // a new requestManager object is created per request but
            // currently does not work in @airport/terminal (since there is
            // no per-request creating of injected objects).
            this.requestManager.actor = request.actor;
            this.requestManager.userAccount = request.actor.userAccount;
            payload = await this.coreHandleRequest(request, this.applicationStore.state.api);
        }
        catch (e) {
            errorMessage = e.message ? e.message : e;
            console.error(e);
        }
        const response = {
            application: request.application,
            args: request.args,
            category: 'ToClient',
            domain: request.domain,
            errorMessage,
            id: request.id,
            hostDomain: request.hostDomain,
            hostProtocol: request.hostProtocol,
            methodName: request.methodName,
            objectName: request.objectName,
            protocol: request.protocol,
            payload,
            transactionId: request.transactionId
        };
        return response;
    }
    async coreHandleRequest(request, api, context) {
        const { apiObject, apiOperation } = await this.apiRegistry.findObjectAndOperationForApi(api, request.domain, request.application, request.objectName, request.methodName);
        request.args;
        if (context) {
            [...request.args, context];
        }
        if (request.args.length > apiOperation.parameters.length) {
            throw new Error(`
    Too many parameters passed in to @Api() request
Domain:      ${request.domain}
Application: ${request.application}
@Api()
${request.objectName}.${request.methodName}
`);
        }
        for (let i = 0; i < apiOperation.parameters.length - request.args.length; i++) {
            request.args.push(undefined);
        }
        for (let arg of request.args) {
            this.queryResultsDeserializer.setPropertyDescriptors(arg);
        }
        const result = apiObject[request.methodName].apply(apiObject, [...request.args, context]);
        if (apiOperation.isAsync) {
            return await result;
        }
        else {
            return result;
        }
    }
}

// TODO: figure out if this is needed - originally written for deserializing
// Client-side operation entities.  Since then moved to Isolates and generic
// API calls.  Probably should be used in go-tower to deserialize all of the
// method argiments passed it (and won't be tied to a query of any kind, API
// interface is generic, unless already known to contain entity objects.)
class OperationDeserializer {
    deserialize(entity, dbEntity, entityStateManager, applicationUtils) {
        const operation = {
            lookupTable: [],
        };
        let deserializedEntity;
        if (entity instanceof Array) {
            deserializedEntity = entity.map(anEntity => this.doDeserialize(anEntity, dbEntity, operation, entityStateManager, applicationUtils));
        }
        else {
            deserializedEntity = this.doDeserialize(entity, dbEntity, operation, entityStateManager, applicationUtils);
        }
        return deserializedEntity;
    }
    doDeserialize(entity, dbEntity, operation, entityStateManager, applicationUtils) {
        let state = entityStateManager.getEntityState(entity);
        let operationUniqueId = entityStateManager.getOperationUniqueId(entity);
        if (!operationUniqueId || typeof operationUniqueId !== 'number'
            || operationUniqueId < 1 || operationUniqueId % 1 === 0) {
            throw new Error(`Invalid or missing ${entityStateManager.getUniqueIdFieldName()} field.`);
        }
        let alreadyDeserializedEntity = operation.lookupTable[operationUniqueId];
        switch (state) {
            case EntityState.STUB: {
                let alreadyDeserializedEntity = operation.lookupTable[operationUniqueId];
                if (!alreadyDeserializedEntity) {
                    throw new Error(`Could not find an already present entity for
					${entityStateManager.getUniqueIdFieldName()} of ${operationUniqueId}`);
                }
                return alreadyDeserializedEntity;
            }
            default:
                if (alreadyDeserializedEntity) {
                    throw new Error(`Entity appears more than once for
					${entityStateManager.getUniqueIdFieldName()} of ${operationUniqueId}`);
                }
        }
        let deserializedEntity = {};
        operation.lookupTable[operationUniqueId] = deserializedEntity;
        deserializedEntity[entityStateManager.getStateFieldName()] = state;
        for (const dbProperty of dbEntity.properties) {
            let value = entity[dbProperty.name];
            if (applicationUtils.isEmpty(value)) {
                continue;
            }
            let propertyCopy;
            if (dbProperty.relation) {
                const dbRelation = dbProperty.relation[0];
                switch (dbRelation.relationType) {
                    case EntityRelationType.ONE_TO_MANY:
                        if (!(value instanceof Array)) {
                            throw new Error(`Expecting @OneToMany for an array entity relation`);
                        }
                        propertyCopy = value.map(aProperty => this.doDeserialize(aProperty, dbRelation.entity, operation, entityStateManager, applicationUtils));
                        break;
                    case EntityRelationType.MANY_TO_ONE:
                        if (!(value instanceof Object) || value instanceof Array) {
                            throw new Error(`Expecting @ManyToOne for a non-array entity relation`);
                        }
                        propertyCopy = this.doDeserialize(value, dbRelation.entity, operation, entityStateManager, applicationUtils);
                        break;
                    default:
                        throw new Error(`Unknown relation type: ${dbRelation.relationType}`);
                }
            }
            else {
                const dbColumn = dbProperty.propertyColumns[0].column;
                switch (dbColumn.type) {
                    case SQLDataType.JSON:
                        // propertyCopy = this.cleanJsonObject(value, dbProperty, entityStateManager)
                        throw new Error('Json properties cannot be deserialized');
                    case SQLDataType.DATE:
                        if (!(value instanceof Object)
                            || value[entityStateManager.getStateFieldName()] !== EntityState.DATE
                            || !value.value) {
                            throw new Error(`Invalid Serialized Date format for ${dbEntity.name}.${dbProperty.name}`);
                        }
                        try {
                            propertyCopy = new Date(value);
                        }
                        catch (e) {
                            throw new Error(`Invalid Serialized Date format for ${dbEntity.name}.${dbProperty.name}`);
                        }
                        break;
                    case SQLDataType.ANY:
                    case SQLDataType.BOOLEAN:
                    case SQLDataType.NUMBER:
                    case SQLDataType.STRING:
                        propertyCopy = value;
                        break;
                    default:
                        throw new Error(`Unexpected data type for ${dbEntity.name}.${dbProperty.name}`);
                }
            }
            deserializedEntity[dbProperty.name] = propertyCopy;
        }
        return deserializedEntity;
    }
    cleanJsonObject(value, dbProperty, entityStateManager) {
        let valueCopy;
        if (value instanceof Object) {
            if (value instanceof Array) {
                valueCopy = value.map(aValue => this.cleanJsonObject(aValue, dbProperty, entityStateManager));
            }
            else {
                valueCopy = {};
                if (value[entityStateManager.getStateFieldName()] === EntityState.STUB) {
                    throw new Error(`Interlinked object graphs are not supported in @Json() columns 
                    ${dbProperty.entity.name}.${dbProperty.name}`);
                }
                delete value[entityStateManager.getStateFieldName()];
                delete value[entityStateManager.getUniqueIdFieldName()];
                for (const propertyName in value) {
                    const property = value[propertyName];
                    valueCopy[propertyName] = this.
                        cleanJsonObject(property, dbProperty, entityStateManager);
                }
            }
        }
        else {
            valueCopy = value;
        }
        return valueCopy;
    }
}

class RequestManager {
}

class EntityCopier {
    copyEntityForProcessing(entity, dbEntity, entityStateManager, context) {
        const operation = {
            processedEntityMap: new Map(),
            sequence: context.lastOUID ? context.lastOUID : 0,
        };
        const copy = this.doCopyEntityForProcessing(entity, dbEntity, entityStateManager, operation);
        context.lastOUID = operation.sequence;
        return copy;
    }
    doCopyEntityForProcessing(entity, dbEntity, entityStateManager, operation) {
        if (entity instanceof Array) {
            return entity.map(anEntity => this.doCopyEntityForProcessing(anEntity, dbEntity, entityStateManager, operation));
        }
        else {
            let entityCopy = {};
            if (operation.processedEntityMap.has(entity)) {
                return operation.processedEntityMap.get(entity);
            }
            operation.processedEntityMap.set(entity, entityCopy);
            const operationUniqueId = ++operation.sequence;
            entityCopy[entityStateManager.getUniqueIdFieldName()] = operationUniqueId;
            entity[entityStateManager.getUniqueIdFieldName()] = operationUniqueId;
            entityStateManager.setOriginalValues(entityStateManager.getOriginalValues(entity), entityCopy);
            for (let dbProperty of dbEntity.properties) {
                const property = entity[dbProperty.name];
                if (dbProperty.relation && dbProperty.relation.length && property) {
                    entityCopy[dbProperty.name] = this.doCopyEntityForProcessing(property, dbProperty.relation[0].relationEntity, entityStateManager, operation);
                }
                else {
                    // No need to clone dates or JSON objects - they
                    // won't be modified by the save process
                    entityCopy[dbProperty.name] = property;
                }
            }
            entityCopy[entityStateManager.getStateFieldName()]
                = entity[entityStateManager.getStateFieldName()];
            return entityCopy;
        }
    }
}

class UpdateCacheManager {
    saveOriginalValues(entity, dbEntity) {
        this.doSaveOriginalValues(entity, dbEntity, new Set());
    }
    doSaveOriginalValues(entity, dbEntity, processedEntities) {
        if (entity instanceof Array) {
            for (let i = 0; i < entity.length; i++) {
                this.doSaveOriginalValues(entity[i], dbEntity, processedEntities);
            }
            return;
        }
        if (!entity) {
            return;
        }
        if (processedEntities.has(entity)) {
            return;
        }
        processedEntities.add(entity);
        const originalValuesObject = {};
        this.entityStateManager.setOriginalValues(originalValuesObject, entity);
        for (let dbProperty of dbEntity.properties) {
            const property = entity[dbProperty.name];
            if (dbProperty.relation && dbProperty.relation.length) {
                if (!property) {
                    continue;
                }
                if (dbProperty.relation[0].relationType === EntityRelationType.MANY_TO_ONE) {
                    // Save the nested child object Ids in the original values of this object
                    // in case the object behind this relation is changed
                    this.applicationUtils.forEachColumnTypeOfRelation(dbProperty.relation[0], (_dbColumn, propertyNameChains) => {
                        for (let propertyNameChain of propertyNameChains) {
                            let nestedProperty = entity;
                            let currentPropertyOriginalValue = originalValuesObject;
                            for (let i = 0; i < propertyNameChain.length; i++) {
                                const propertyName = propertyNameChain[i];
                                if (nestedProperty instanceof Object) {
                                    nestedProperty = nestedProperty[propertyName];
                                    let originalValue;
                                    // Nested object continues
                                    if (i === propertyNameChain.length - 1) {
                                        originalValue = nestedProperty;
                                    }
                                    else {
                                        originalValue = {};
                                    }
                                    currentPropertyOriginalValue[propertyName] = originalValue;
                                    currentPropertyOriginalValue = currentPropertyOriginalValue[propertyName];
                                }
                                else {
                                    // This is the actual value
                                    currentPropertyOriginalValue[propertyName] = nestedProperty;
                                }
                            }
                        }
                    });
                }
                this.doSaveOriginalValues(property, dbProperty.relation[0].relationEntity, processedEntities);
            }
            else {
                originalValuesObject[dbProperty.name] = entity[dbProperty.name];
            }
        }
    }
    setOperationState(entityCopy, dbEntity, processedEntities, checkGeneratedIds) {
        if (entityCopy instanceof Array) {
            for (var i = 0; i < entityCopy.length; i++) {
                this.setOperationState(entityCopy[i], dbEntity, processedEntities, checkGeneratedIds);
            }
            return;
        }
        if (processedEntities.has(entityCopy)) {
            return;
        }
        processedEntities.add(entityCopy);
        const originalValuesObject = this.entityStateManager
            .getOriginalValues(entityCopy);
        let entityState = entityCopy[this.entityStateManager.getStateFieldName()];
        let hasId = true;
        let hasGeneratedIds = false;
        for (const dbProperty of dbEntity.properties) {
            if (!dbProperty.isId) {
                continue;
            }
            for (const propertyColumn of dbProperty.propertyColumns) {
                if (propertyColumn.column.isGenerated) {
                    hasGeneratedIds = true;
                }
            }
            if (dbProperty.relation && dbProperty.relation.length) {
                this.applicationUtils.forEachColumnTypeOfRelation(dbProperty.relation[0], (_dbColumn, propertyNameChains) => {
                    for (let propertyNameChain of propertyNameChains) {
                        let nestedProperty = entityCopy;
                        for (let i = 0; i < propertyNameChain.length; i++) {
                            const propertyName = propertyNameChain[i];
                            if (nestedProperty) {
                                nestedProperty = nestedProperty[propertyName];
                            }
                        }
                        if (!nestedProperty) {
                            if (entityState === EntityState.DELETE) {
                                throw new Error(`Entity is marked for deletion but does not have an @Id() property:
            ${propertyNameChain.join('.')}
                                    `);
                            }
                            else {
                                entityState = EntityState.CREATE;
                                hasId = false;
                                return true;
                            }
                        }
                    }
                });
            }
            else if (!entityCopy[dbProperty.name] && entityCopy[dbProperty.name] !== 0) {
                hasId = false;
            }
        }
        if (originalValuesObject) {
            for (const dbProperty of dbEntity.properties) {
                const property = entityCopy[dbProperty.name];
                if (dbProperty.relation && dbProperty.relation.length) {
                    if (!property) {
                        continue;
                    }
                    const dbRelation = dbProperty.relation[0];
                    this.entityStateManager
                        .getOriginalValues(property);
                    this.applicationUtils.forEachColumnTypeOfRelation(dbRelation, (_dbColumn, propertyNameChains) => {
                        const propertyOriginalValuesObject = this.entityStateManager
                            .getOriginalValues(property);
                        // const firstPropertyNameChain = propertyNameChains[0];
                        for (const propertyNameChain of propertyNameChains) {
                            let value = entityCopy;
                            let originalValue = propertyOriginalValuesObject;
                            for (let i = 0; i < propertyNameChain.length; i++) {
                                const propertyName = propertyNameChain[i];
                                value = value[propertyName];
                                // Skip the property itself since the original values object
                                // belongs to the property and not the checked object
                                // (in the case of relations only)
                                if (i !== 0) {
                                    originalValue = originalValue[propertyName];
                                }
                                let noValue = value === null || value === undefined;
                                let noOriginalValue = originalValue === null
                                    || originalValue === undefined;
                                if (noValue) {
                                    if (originalValue) {
                                        entityState = EntityState.UPDATE;
                                        return true;
                                    }
                                    break;
                                }
                                if (noOriginalValue) {
                                    if (value) {
                                        entityState = EntityState.UPDATE;
                                        return true;
                                    }
                                    break;
                                }
                                // If it's a nested object
                                if (typeof value === 'object') {
                                    // If original isn't a nested object
                                    if (typeof originalValue !== 'object') {
                                        entityState = EntityState.UPDATE;
                                        return true;
                                    }
                                    // Values should not be dates or json objects, only
                                    // nested object references to eventual _localIds
                                }
                                else if (typeof originalValue === 'object') {
                                    // value is not a nested object but originalValue is
                                    entityState = EntityState.UPDATE;
                                    return true;
                                }
                                else {
                                    // Both values are primitives (nested _localIds)
                                    if (value !== originalValue) {
                                        entityState = EntityState.UPDATE;
                                        return true;
                                    }
                                }
                            }
                        }
                    });
                }
                else {
                    if (entityState) {
                        continue;
                    }
                    let originalValue = originalValuesObject[dbProperty.name];
                    let propertyValue;
                    switch (dbProperty.propertyColumns[0].column.type) {
                        case SQLDataType.DATE:
                            if (originalValue) {
                                originalValue = originalValue.getTime();
                            }
                            if (property) {
                                propertyValue = property.getTime();
                            }
                            break;
                        case SQLDataType.JSON:
                            if (originalValue) {
                                originalValue = JSON.stringify(originalValue);
                            }
                            if (property) {
                                propertyValue = JSON.stringify(property);
                            }
                            break;
                        default:
                            propertyValue = property;
                            break;
                    }
                    if (propertyValue !== originalValue) {
                        entityState = EntityState.UPDATE;
                    }
                }
            }
        }
        for (const dbProperty of dbEntity.properties) {
            const property = entityCopy[dbProperty.name];
            if (property && dbProperty.relation && dbProperty.relation.length) {
                this.setOperationState(property, dbProperty.relation[0].relationEntity, processedEntities, checkGeneratedIds);
            }
        }
        if (!entityState) {
            /**
             * All records coming from Apps will have generated IDs
             * Internal APIs create non-AirEntity records, which
             * may not have framework generated Ids.
             */
            if ((hasId && (!checkGeneratedIds || hasGeneratedIds))
                || originalValuesObject) {
                entityState = EntityState.PASS_THROUGH;
            }
            else {
                entityState = EntityState.CREATE;
            }
        }
        entityCopy[this.entityStateManager.getStateFieldName()] = entityState;
    }
    afterSaveModifications(entity, dbEntity, saveResult, processedEntities) {
        this.updateOriginalValuesAfterSave(entity, dbEntity, saveResult, new Set());
        this.removeDeletedEntities(entity, dbEntity, saveResult, processedEntities);
    }
    updateOriginalValuesAfterSave(entity, dbEntity, saveResult, processedEntities) {
        if (entity instanceof Array) {
            for (let i = 0; i < entity.length; i++) {
                this.updateOriginalValuesAfterSave(entity[i], dbEntity, saveResult, processedEntities);
            }
        }
        else {
            if (processedEntities.has(entity)) {
                return;
            }
            processedEntities.add(entity);
            let operationUniqueId = this.entityStateManager.getOperationUniqueId(entity, false, dbEntity);
            let originalValuesObject = {};
            originalValuesObject = this.doUpdateOriginalValuesAfterSave(entity, dbEntity, saveResult, processedEntities, operationUniqueId);
            this.entityStateManager.setOriginalValues(originalValuesObject, entity);
        }
    }
    doUpdateOriginalValuesAfterSave(entity, dbEntity, saveResult, processedEntities, operationUniqueId) {
        let createdRecord = saveResult.created[operationUniqueId];
        if (createdRecord) {
            if (createdRecord !== true) {
                for (const generatedPropertyName in createdRecord) {
                    entity[generatedPropertyName] = createdRecord[generatedPropertyName];
                }
                if (dbEntity.isAirEntity) {
                    let airEntity = entity;
                    if (!airEntity.repository || !airEntity.repository._localId) {
                        airEntity.repository = saveResult.newRepository;
                    }
                    airEntity.actor = saveResult.actor;
                }
            }
        }
        else if (saveResult.deleted[operationUniqueId]) {
            this.entityStateManager.setIsDeleted(true, entity);
            this.entityStateManager.setOriginalValues(null, entity);
            return;
        }
        let originalValuesObject = {};
        for (const dbProperty of dbEntity.properties) {
            const property = entity[dbProperty.name];
            if (property && dbProperty.relation && dbProperty.relation.length) {
                if (dbProperty.relation[0].relationType === EntityRelationType.MANY_TO_ONE) {
                    // Save the nested child object Ids in the original values of this object
                    // in case the object behind this relation is changed
                    this.applicationUtils.forEachColumnTypeOfRelation(dbProperty.relation[0], (_dbColumn, propertyNameChains) => {
                        for (let propertyNameChain of propertyNameChains) {
                            let nestedProperty = entity;
                            let currentPropertyOriginalValue = originalValuesObject;
                            for (let i = 0; i < propertyNameChain.length; i++) {
                                const propertyName = propertyNameChain[i];
                                if (nestedProperty instanceof Object) {
                                    nestedProperty = nestedProperty[propertyName];
                                    let originalValue;
                                    // Nested object continues
                                    if (i === propertyNameChain.length - 1) {
                                        originalValue = nestedProperty;
                                    }
                                    else {
                                        originalValue = {};
                                    }
                                    currentPropertyOriginalValue[propertyName] = originalValue;
                                    currentPropertyOriginalValue = currentPropertyOriginalValue[propertyName];
                                }
                                else {
                                    // This is the actual value
                                    currentPropertyOriginalValue[propertyName] = nestedProperty;
                                }
                            }
                        }
                    });
                }
                this.updateOriginalValuesAfterSave(property, dbProperty.relation[0].relationEntity, saveResult, processedEntities);
            }
            else {
                originalValuesObject[dbProperty.name] = property;
            }
        }
        return originalValuesObject;
    }
    removeDeletedEntities(entity, dbEntity, saveResult, processedEntities) {
        if (entity instanceof Array) {
            for (let i = entity.length - 1; i >= 0; i--) {
                if (this.removeDeletedEntities(entity[i], dbEntity, saveResult, processedEntities)) {
                    entity.splice(i, 1);
                }
            }
            return !entity.length;
        }
        else {
            if (processedEntities.has(entity)) {
                return this.entityStateManager.isDeleted(entity);
            }
            processedEntities.add(entity);
            for (const dbRelation of dbEntity.relations) {
                const dbRelationProperty = dbRelation.property;
                const property = entity[dbRelationProperty.name];
                if (!property) {
                    continue;
                }
                switch (dbRelation.relationType) {
                    case EntityRelationType.MANY_TO_ONE:
                        if (this.removeDeletedEntities(property, dbRelation.relationEntity, saveResult, processedEntities)) {
                            entity[dbRelationProperty.name] = null;
                        }
                        break;
                    case EntityRelationType.ONE_TO_MANY:
                        this.removeDeletedEntities(property, dbRelation.relationEntity, saveResult, processedEntities);
                        break;
                }
            }
            return this.entityStateManager.isDeleted(entity);
        }
    }
}

class EntityStateManager {
    isStub(entity) {
        return this.getEntityState(entity) === EntityState.STUB;
    }
    isParentSchemaId(entity) {
        return this.getEntityState(entity) ===
            EntityState.PARENT_SCHEMA_ID;
    }
    isPassThrough(entity) {
        return this.getEntityState(entity) === EntityState.PASS_THROUGH;
    }
    markAsOfParentSchema(entity) {
        entity[EntityStateManager.STATE_FIELD] =
            EntityState.PARENT_SCHEMA_ID;
    }
    markForDeletion(entity) {
        entity[EntityStateManager.STATE_FIELD] = EntityState.DELETE;
    }
    markToCreate(entity) {
        entity[EntityStateManager.STATE_FIELD] = EntityState.CREATE;
    }
    markToUpdate(entity) {
        entity[EntityStateManager.STATE_FIELD] = EntityState.UPDATE;
    }
    getEntityState(entity) {
        return entity[EntityStateManager.STATE_FIELD];
    }
    getOriginalValues(entity) {
        return entity[EntityStateManager.ORIGINAL_VALUES_PROPERTY];
    }
    setOriginalValues(originalValues, entity) {
        entity[EntityStateManager.ORIGINAL_VALUES_PROPERTY] = originalValues;
    }
    copyEntityState(fromEntity, toEntity) {
        toEntity[EntityStateManager.STATE_FIELD]
            = fromEntity[EntityStateManager.STATE_FIELD];
        toEntity[EntityStateManager.ORIGINAL_VALUES_PROPERTY]
            = fromEntity[EntityStateManager.ORIGINAL_VALUES_PROPERTY];
    }
    getStateFieldName() {
        return EntityStateManager.STATE_FIELD;
    }
    getEntityStateTypeAsFlags(entity, dbEntity) {
        let isCreate, isDelete, isParentSchemaId, isPassThrough, isResultDate, isStub, isUpdate;
        const entityState = this.getEntityState(entity);
        switch (entityState) {
            case EntityState.CREATE:
                isCreate = true;
                break;
            case EntityState.DELETE:
                isDelete = true;
                break;
            case EntityState.PARENT_SCHEMA_ID:
                isParentSchemaId = true;
                break;
            case EntityState.PASS_THROUGH:
                isPassThrough = true;
                break;
            // case EntityState.RESULT:
            // 	isResult = true
            // 	break
            case EntityState.DATE:
                isResultDate = true;
                break;
            // case EntityState.RESULT_JSON:
            // 	isResultJson = true
            // 	break
            case EntityState.STUB:
                isStub = true;
                break;
            case EntityState.UPDATE:
                isUpdate = true;
                break;
            default:
                throw new Error(`Unexpected entity state
"${this.getStateFieldName()}" for ${dbEntity.name}: ${entityState}`);
        }
        return {
            isCreate,
            isDelete,
            isParentSchemaId,
            isPassThrough,
            // isResult,
            isResultDate,
            isStub,
            isUpdate,
        };
    }
    setIsDeleted(isDeleted, entity) {
        entity[EntityStateManager.STATE_FIELD] = EntityState.DELETE;
    }
    isDeleted(entity) {
        return entity[EntityStateManager.STATE_FIELD] === EntityState.DELETE;
    }
    getOperationUniqueId(entity, throwIfNotFound = true, dbEntity = null) {
        const operationUniqueId = entity[EntityStateManager.OPERATION_UNIQUE_ID_FIELD];
        if (!operationUniqueId || typeof operationUniqueId !== 'number' || operationUniqueId < 1) {
            if (throwIfNotFound) {
                let entityDescription;
                if (dbEntity) {
                    entityDescription = dbEntity.applicationVersion.application.name + '.' + dbEntity.name;
                }
                else {
                    entityDescription = JSON.stringify(entity);
                }
                throw new Error(`Could not find "${EntityStateManager.OPERATION_UNIQUE_ID_FIELD}" property on DTO:
        
        ${entityDescription}`);
            }
        }
        return operationUniqueId;
    }
    copyOperationUniqueId(entity, entityCopy) {
        const operationUniqueId = entity[EntityStateManager.OPERATION_UNIQUE_ID_FIELD];
        entityCopy[EntityStateManager.OPERATION_UNIQUE_ID_FIELD] = operationUniqueId;
    }
    markAsStub(entity) {
        entity[EntityStateManager.STATE_FIELD] = EntityState.STUB;
    }
    getUniqueIdFieldName() {
        return EntityStateManager.OPERATION_UNIQUE_ID_FIELD;
    }
}
EntityStateManager.DELETED_PROPERTY = '__deleted__';
EntityStateManager.ORIGINAL_VALUES_PROPERTY = SerializationStateManager.ORIGINAL_VALUES_PROPERTY;
EntityStateManager.STATE_FIELD = '__state__';
EntityStateManager.OPERATION_UNIQUE_ID_FIELD = '__OUID__';

/**
 * Created by Papa on 5/23/2016.
 */
class DatabaseFacade {
    async insertColumnValues(rawInsertColumnValues, context) {
        if (!rawInsertColumnValues) {
            return 0;
        }
        if (rawInsertColumnValues instanceof Function) {
            rawInsertColumnValues = rawInsertColumnValues();
        }
        const insertColumnValues = new InsertColumnValues(rawInsertColumnValues, null);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(insertColumnValues, null, queryContext);
        return await this.transactionalConnector.insertValues(portableQuery, context);
    }
    async insertValues(rawInsertValues, context) {
        if (!rawInsertValues) {
            return 0;
        }
        if (rawInsertValues instanceof Function) {
            rawInsertValues = rawInsertValues();
        }
        const insertValues = new InsertValues(rawInsertValues, null);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(insertValues, null, queryContext);
        return await this.transactionalConnector.insertValues(portableQuery, context);
    }
    async insertColumnValuesGenerateIds(rawInsertColumnValues, context) {
        if (!rawInsertColumnValues) {
            return [];
        }
        if (rawInsertColumnValues instanceof Function) {
            rawInsertColumnValues = rawInsertColumnValues();
        }
        const insertValues = new InsertColumnValues(rawInsertColumnValues, null);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(insertValues, null, queryContext);
        return await this.transactionalConnector.insertValuesGetLocalIds(portableQuery, context);
    }
    async insertValuesGenerateIds(rawInsertValues, context) {
        if (!rawInsertValues) {
            return [];
        }
        if (rawInsertValues instanceof Function) {
            rawInsertValues = rawInsertValues();
        }
        const insertValues = new InsertValues(rawInsertValues, null);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(insertValues, null, queryContext);
        return await this.transactionalConnector.insertValuesGetLocalIds(portableQuery, context);
    }
    async deleteWhere(rawDelete, context) {
        if (!rawDelete) {
            return 0;
        }
        if (rawDelete instanceof Function) {
            rawDelete = rawDelete();
        }
        let deleteWhere = new Delete(rawDelete);
        const queryContext = await this.ensureQueryContext(context);
        let portableQuery = this.queryFacade.getPortableQuery(deleteWhere, null, queryContext);
        return await this.transactionalConnector.deleteWhere(portableQuery, context);
    }
    async save(entity, context) {
        if (!entity) {
            return null;
        }
        const entityCopy = await this.preSaveOperations(entity, context, this.transactionalConnector.internal);
        const saveResult = await this.transactionalConnector.save(entityCopy, context);
        this.updateCacheManager.afterSaveModifications(entity, context.dbEntity, saveResult, new Set());
        return saveResult;
    }
    async saveToDestination(repositoryDestination, entity, context) {
        if (!entity) {
            return null;
        }
        const entityCopy = await this.preSaveOperations(entity, context, this.transactionalConnector.internal);
        const saveResult = await this.transactionalConnector
            .saveToDestination(repositoryDestination, entityCopy, context);
        this.updateCacheManager.afterSaveModifications(entity, context.dbEntity, saveResult, new Set());
        return saveResult;
    }
    async preSaveOperations(entity, context, checkGeneratedIds) {
        if (!entity) {
            return null;
        }
        const dbEntity = context.dbEntity;
        const entityCopy = this.entityCopier
            .copyEntityForProcessing(entity, dbEntity, this.entityStateManager, context);
        this.updateCacheManager.setOperationState(entityCopy, dbEntity, new Set(), checkGeneratedIds);
        return entityCopy;
    }
    /**
     * Updates an entity with a WHERE clause, using a column based set clause
     * - internal API.  Use the API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records updated
     */
    async updateColumnsWhere(rawUpdate, context) {
        if (!rawUpdate) {
            return 0;
        }
        if (rawUpdate instanceof Function) {
            rawUpdate = rawUpdate();
        }
        let updateColumns = new UpdateColumns(rawUpdate);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(updateColumns, null, queryContext);
        return await this.transactionalConnector.updateValues(portableQuery, context);
    }
    async updateWhere(rawUpdate, context, trackedRepoGUIDSet) {
        if (!rawUpdate) {
            return 0;
        }
        if (rawUpdate instanceof Function) {
            rawUpdate = rawUpdate();
        }
        let update = new UpdateProperties(rawUpdate, trackedRepoGUIDSet);
        const queryContext = await this.ensureQueryContext(context);
        const portableQuery = this.queryFacade.getPortableQuery(update, null, queryContext);
        return await this.transactionalConnector.updateValues(portableQuery, context);
    }
    prepare(queryFunction) {
        return new FunctionWrapper(queryFunction);
    }
    async ensureQueryContext(context) {
        const queryContext = context;
        return queryContext;
    }
}
class FunctionWrapper {
    constructor(queryFunction) {
        throw new Error('Not Implemented');
    }
    find(...params) {
    }
}

class QueryFacade {
    async find(query, queryResultType, context) {
        await this.ensureContext(context);
        const result = await this.transactionalConnector.find(this.getPortableQuery(query, queryResultType, context), context);
        return result;
    }
    async findOne(query, queryResultType, context) {
        await this.ensureContext(context);
        const result = await this.transactionalConnector.findOne(this.getPortableQuery(query, queryResultType, context), context);
        return result;
    }
    getPortableQuery(query, queryResultType, context) {
        return {
            jsonQuery: query.toJSON(this.queryUtils, this.fieldUtils, this.relationManager),
            parameterMap: query.getParameters(),
            queryResultType,
            applicationIndex: context.dbEntity.applicationVersion.application.index,
            tableIndex: context.dbEntity.index,
            trackedRepoGUIDs: Array.from(query.trackedRepoGUIDSet),
            trackedRepoLocalIds: Array.from(query.trackedRepoLocalIdSet)
            // values: query.values
        };
    }
    // FIXME: merge update caches on the client
    async search(query, queryResultType, context) {
        await this.ensureContext(context);
        let observable = await this.transactionalConnector.search(this.getPortableQuery(query, queryResultType, context), context);
        return observable;
    }
    async searchOne(query, queryResultType, context) {
        await this.ensureContext(context);
        let observable = await this.transactionalConnector.searchOne(this.getPortableQuery(query, queryResultType, context), context);
        return observable;
    }
    async ensureContext(context) {
    }
}

const applicationState = {
    api: null,
    application: null,
    appState: AppState.NOT_INITIALIED,
    domain: null,
    // FIXME: make this dynamic for web version (https://turbase.app), local version (https://localhost:PORT)
    // and debugging (https://localhost:3000)
    hostServer: 'https://localhost:3000',
    // FIXME: tie this in to the hostServer variable
    mainDomain: null,
    observableMessageMap: new Map(),
    pendingMessageMap: new Map(),
    messageCallback: null,
};

class ApplicationStore {
    constructor() {
        this.applicationState = applicationState;
    }
    get state() {
        return this.applicationState;
    }
}

class EntityAccumulator {
    constructor(applicationDomain, applicationName, entityMap) {
        this.applicationDomain = applicationDomain;
        this.applicationName = applicationName;
        this.entityMap = entityMap;
    }
    add(clazz, index) {
        this.entityMap.set(clazz, {
            entity: {
                index,
                name: clazz.name,
            },
            application: {
                domain: this.applicationDomain,
                name: this.applicationName,
            },
        });
    }
}
class AirportDatabase {
    get entityMap() {
        return this.databaseStore.entityMap;
    }
    ;
    get F() {
        return this.databaseStore.functions;
    }
    get functions() {
        return this.databaseStore.functions;
    }
    get A() {
        return this.databaseStore.applications;
    }
    get applications() {
        return this.databaseStore.applications;
    }
    get qApplications() {
        return this.databaseStore.qApplications;
    }
    get Q() {
        return this.databaseStore.qApplications;
    }
    get QM() {
        return this.databaseStore.QM;
    }
    async load() {
        // Calling this method loads the AirpotDatabase object
        // ('this.airportDatabase' statement by itself creates the object,
        // (without the '.load() call) but '.load()' is more intuitive)
    }
    getCurrentDbApplicationVersion(domainName, applicationName) {
        const applicationFullName = this.dbApplicationUtils
            .getApplication_FullNameFromDomainAndName(domainName, applicationName);
        return this.QM[applicationFullName]
            .__dbApplication__.currentVersion[0].applicationVersion;
    }
    getDbEntity(domainName, applicationName, entityName) {
        const dbApplicationVersion = this.getCurrentDbApplicationVersion(domainName, applicationName);
        return dbApplicationVersion.entityMapByName[entityName];
    }
    setQApp(qApplication) {
        const fullApplication_Name = this.dbApplicationUtils
            .getApplication_FullName(qApplication);
        const existingQApp = this.QM[fullApplication_Name];
        if (existingQApp) {
            const dbApplication = existingQApp.__dbApplication__;
            if (dbApplication) {
                qApplication.__dbApplication__ = dbApplication;
                this.qApplicationBuilderUtils.setQAppEntities(dbApplication, qApplication, this.qApplications, this.appliationUtils, this.relationManager);
                this.Q[dbApplication.index] = qApplication;
            }
        }
        this.QM[fullApplication_Name] = qApplication;
    }
    getAccumulator(applicationDomain, applicationName) {
        return new EntityAccumulator(applicationDomain, applicationName, this.entityMap);
    }
    async insertColumnValues(rawInsertValues, context) {
        return await this.databaseFacade.insertColumnValues(rawInsertValues, context);
    }
    async insertValues(rawInsertValues, context) {
        return await this.databaseFacade.insertValues(rawInsertValues, context);
    }
    async insertColumnValuesGenerateIds(rawInsertValues, context) {
        return await this.databaseFacade.insertColumnValuesGenerateIds(rawInsertValues, context);
    }
    async insertValuesGenerateIds(rawInsertValues, context) {
        return await this.databaseFacade.insertValuesGenerateIds(rawInsertValues, context);
    }
    /**
     * Creates an entity with a WHERE clause - internal API.  Use the
     *  API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records deleted
     */
    async deleteWhere(rawDelete, context) {
        return await this.databaseFacade.deleteWhere(rawDelete, context);
    }
    /**
     * Ether creates or updates an entity - internal API.  Use the
     *  API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records saved (1 or 0)
     */
    async save(entity, context, operationName) {
        return await this.databaseFacade.save(entity, context);
    }
    /**
     * Updates an entity with a WHERE clause, using a column based set clause
     * - internal API.  Use the API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records updated
     */
    async updateColumnsWhere(rawUpdateColumns, context) {
        return await this.databaseFacade.updateColumnsWhere(rawUpdateColumns, context);
    }
    /**
     * Updates an entity with a WHERE clause, using a property based set clause
     * - internal API.  Use the API provided by the IEntityDatabaseFacade.
     *
     * @return Number of records updated
     */
    async updateWhere(rawUpdate, context) {
        return await this.databaseFacade.updateWhere(rawUpdate, context);
    }
}
function injectAirportDatabase() {
    console.log('Injecting AirportDatabase');
}

const tower = lib('tower');
tower.register(ApplicationStore, EntityCopier, RequestManager);
AIRPORT_DATABASE.setClass(AirportDatabase);
ENTITY_STATE_MANAGER.setClass(EntityStateManager);
API_REGISTRY.setClass(ApiRegistry);
API_REGISTRY.setDependencies({
    applicationStore: ApplicationStore,
    containerAccessor: ContainerAccessor
});
API_VALIDATOR.setClass(ApiValidator);
LOCAL_API_SERVER.setClass(LocalAPIServer);
LOCAL_API_SERVER.setDependencies({
    apiRegistry: API_REGISTRY,
    applicationStore: ApplicationStore,
    queryResultsDeserializer: QUERY_RESULTS_DESERIALIZER,
    requestManager: RequestManager
});
OPERATION_DESERIALIZER.setClass(OperationDeserializer);
UPDATE_CACHE_MANAGER.setClass(UpdateCacheManager);
DATABASE_FACADE.setClass(DatabaseFacade);
DATABASE_FACADE.setDependencies({
    entityCopier: EntityCopier,
    queryFacade: QUERY_FACADE
});
QUERY_FACADE.setClass(QueryFacade);

class NoOpApplicationBuilder extends SqlSchemaBuilder {
    async createApplication(jsonApplication, context) {
        const applicationName = IOC.getSync(DbApplicationUtils).
            getApplication_FullName(jsonApplication);
        const createApplicationStatement = `CREATE APPLICATION ${applicationName}`;
        await this.storeDriver.query(QueryType.DDL, createApplicationStatement, [], context, false);
    }
    getColumnSuffix(jsonApplication, jsonEntity, jsonColumn) {
        return '';
    }
    getCreateTableSuffix(jsonApplication, jsonEntity) {
        return ``;
    }
    async buildAllSequences(jsonApplications, context) {
        let allSequences = [];
        for (const jsonApplication of jsonApplications) {
            const qApplication = this.airportDatabase.QM[IOC.getSync(DbApplicationUtils).
                getApplication_FullName(jsonApplication)];
            for (const jsonEntity of jsonApplication.versions[jsonApplication.versions.length - 1].entities) {
                allSequences = allSequences.concat(this.buildSequences(qApplication.__dbApplication__, jsonEntity));
            }
        }
        return allSequences;
    }
    stageSequences(jsonApplications, context) {
        let stagedSequences = [];
        for (const jsonApplication of jsonApplications) {
            const qApplication = this.airportDatabase.QM[IOC.getSync(DbApplicationUtils).
                getApplication_FullName(jsonApplication)];
            for (const jsonEntity of jsonApplication.versions[jsonApplication.versions.length - 1].entities) {
                stagedSequences = stagedSequences.concat(this.buildSequences(qApplication.__dbApplication__, jsonEntity));
            }
        }
        return stagedSequences;
    }
    buildSequences(dbApplication, jsonEntity) {
        const sequences = [];
        for (const jsonColumn of jsonEntity.columns) {
            if (!jsonColumn.isGenerated) {
                continue;
            }
            let incrementBy = jsonColumn.allocationSize;
            if (!incrementBy) {
                incrementBy = 10000;
            }
            sequences.push({
                applicationIndex: dbApplication.index,
                tableIndex: jsonEntity.index,
                columnIndex: jsonColumn.index,
                incrementBy,
                currentValue: 0
            });
        }
        return sequences;
    }
    getIndexSql(indexName, tableName, columnNameList, unique) {
        return '';
    }
    getForeignKeySql(tableName, foreignKeyName, foreignKeyColumnNames, referencedTableName, referencedColumnNames) {
        return null;
    }
}

/**
 * Assumptions: 7/4/2019
 *
 * 1. Only a single process will be inserting records at any given point in time
 * a)  This means that the service worker running the the background will only
 * receive and temporarily store data (in IndexedDb, but won't be inserting
 * proper relational records)
 * b)  This also means that web-workers won't be doing parallel inserts
 *
 * In general, this is consistent with SqLites policy of only one modifying
 * operation at a time (while possibly multiple read ops)
 *
 *
 * With these assumptions in place, it is safe to synchronize sequence retrieval
 * in-memory.   Hence, SequenceBlocks are retired in favor of a simpler
 * Sequence-only solution
 *
 */
class SequenceGenerator {
    get sequences() {
        return this.terminalStore.getSequenceGenerator().sequences;
    }
    get sequenceBlocks() {
        return this.terminalStore.getSequenceGenerator().sequenceBlocks;
    }
    get generatingSequenceNumbers() {
        return this.terminalStore.getSequenceGenerator().generatingSequenceNumbers;
    }
    set generatingSequenceNumbers(generatingSequenceNumbers) {
        this.terminalStore.getSequenceGenerator().generatingSequenceNumbers
            = generatingSequenceNumbers;
    }
    exists(dbEntity) {
        const generatedColumns = dbEntity.columns.filter(dbColumn => dbColumn.isGenerated);
        if (!generatedColumns.length) {
            return true;
        }
        const applicationSequences = this.sequences[dbEntity.applicationVersion.application.index];
        if (!applicationSequences) {
            return false;
        }
        const tableSequences = applicationSequences[dbEntity.index];
        if (!tableSequences) {
            return false;
        }
        return generatedColumns.every(dbColumn => !!tableSequences[dbColumn.index]);
    }
    async initialize(context, sequences) {
        if (!sequences) {
            sequences = await this.sequenceDao.findAll();
        }
        this.addSequences(sequences);
        await this.sequenceDao.incrementCurrentValues(context);
        globalThis.SEQ_GEN = this;
    }
    async tempInitialize(context, sequences) {
        this.addSequences(sequences);
        globalThis.SEQ_GEN = this;
    }
    async generateSequenceNumbers(dbColumns, numSequencesNeeded) {
        if (!dbColumns.length) {
            return [];
        }
        await this.waitForPreviousGeneration();
        this.generatingSequenceNumbers = true;
        try {
            return await this.doGenerateSequenceNumbers(dbColumns, numSequencesNeeded);
        }
        finally {
            this.generatingSequenceNumbers = false;
        }
    }
    async generateSequenceNumbersForColumn(domainName, applicationName, entityName, columnName, numSequencesNeeded) {
        if (!numSequencesNeeded) {
            return [];
        }
        const dbEntity = this.airportDatabase.getDbEntity(domainName, applicationName, entityName);
        const dbColumn = dbEntity.columnMap[columnName];
        const sequencesWrapper = await this.generateSequenceNumbers([dbColumn], [numSequencesNeeded]);
        return sequencesWrapper[0];
    }
    /**
     * Keeping return value as number[][] in case we ever revert back
     * to SequenceBlock-like solution
     * @param dbColumns
     * @param numSequencesNeeded
     */
    async doGenerateSequenceNumbers(dbColumns, numSequencesNeeded) {
        const sequentialNumbers = [];
        for (let i = 0; i < dbColumns.length; i++) {
            const dbColumn = dbColumns[i];
            let numColumnSequencesNeeded = numSequencesNeeded[i];
            const columnNumbers = this.datastructureUtils.ensureChildArray(sequentialNumbers, i);
            const dbEntity = dbColumn.propertyColumns[0].property.entity;
            const application = dbEntity.applicationVersion.application;
            let sequenceBlock = this.sequenceBlocks[application.index][dbEntity.index][dbColumn.index];
            const sequence = this.sequences[application.index][dbEntity.index][dbColumn.index];
            while (numColumnSequencesNeeded && sequenceBlock) {
                columnNumbers.push(sequence.currentValue - sequenceBlock + 1);
                numColumnSequencesNeeded--;
                sequenceBlock--;
            }
            this.sequenceBlocks[application.index][dbEntity.index][dbColumn.index] = sequenceBlock;
            if (numColumnSequencesNeeded) {
                const numNewSequencesNeeded = sequence.incrementBy + numColumnSequencesNeeded;
                const newSequence = { ...sequence };
                newSequence.currentValue += numNewSequencesNeeded;
                await this.sequenceDao.save(newSequence);
                this.sequences[application.index][dbEntity.index][dbColumn.index] = newSequence;
                sequenceBlock = numNewSequencesNeeded;
                while (numColumnSequencesNeeded) {
                    columnNumbers.push(sequence.currentValue - sequenceBlock + 1);
                    numColumnSequencesNeeded--;
                    sequenceBlock--;
                }
                this.sequenceBlocks[application.index][dbEntity.index][dbColumn.index] = sequenceBlock;
            }
        }
        return sequentialNumbers;
    }
    waitForPreviousGeneration() {
        return new Promise(resolve => {
            this.isDoneGeneratingSeqNums(resolve);
        });
    }
    isDoneGeneratingSeqNums(resolve) {
        if (this.generatingSequenceNumbers) {
            setTimeout(() => {
                this.isDoneGeneratingSeqNums(resolve);
            }, 20);
        }
        else {
            resolve();
        }
    }
    addSequences(sequences) {
        for (const sequence of sequences) {
            this.datastructureUtils.ensureChildArray(this.datastructureUtils.ensureChildArray(this.sequences, sequence.applicationIndex), sequence.tableIndex)[sequence.columnIndex] = sequence;
            sequence.currentValue += sequence.incrementBy;
            this.datastructureUtils.ensureChildArray(this.datastructureUtils.ensureChildArray(this.sequenceBlocks, sequence.applicationIndex), sequence.tableIndex)[sequence.columnIndex] = sequence.incrementBy;
        }
    }
}

SEQUENCE_GENERATOR.setClass(SequenceGenerator);
SEQUENCE_GENERATOR.setDependencies({
    airportDatabase: AIRPORT_DATABASE,
    datastructureUtils: DatastructureUtils,
    sequenceDao: SequenceDao,
    terminalStore: TerminalStore
});

class NoOpSequenceGenerator extends SequenceGenerator {
    nativeGenerate() {
        throw new Error('Method not implemented.');
    }
}

class NoOpSqlDriver extends SqlDriver {
    composeTableName(applicationName, tableName, context) {
        return '';
    }
    doesTableExist(applicationName, tableName, context) {
        return Promise.resolve(false);
    }
    dropTable(applicationName, tableName, context) {
        return Promise.resolve(false);
    }
    findNative(sqlQuery, parameters, context) {
        return Promise.resolve([]);
    }
    initialize(dbName, context) {
        return Promise.resolve(undefined);
    }
    isValueValid(value, sqlDataType, context) {
        return false;
    }
    query(queryType, query, params, context, saveTransaction) {
        return Promise.resolve(undefined);
    }
    async startTransaction(transaction, context) {
        return Promise.resolve(undefined);
    }
    async internalCommit(transaction, context) {
        return Promise.resolve(undefined);
    }
    async internalRollback(transaction, context) {
        return Promise.resolve(undefined);
    }
    async internalStartTransaction(transaction, context) {
        return Promise.resolve(undefined);
    }
    async setupTransaction(context, parentTransaction) {
        return Promise.resolve(undefined);
    }
    getSelectQuerySuffix(jsonQuery, context) {
        return '';
    }
    executeNative(sql, parameters, context) {
        return Promise.resolve(0);
    }
    getDialect(context) {
        return undefined;
    }
}

class TempDatabase {
    constructor() {
        this.tempDbInitialized = false;
    }
    async initialize(applications) {
        if (this.tempDbInitialized) {
            const applicationInitializer = await IOC.get(APPLICATION_INITIALIZER);
            await applicationInitializer.stage(applications, {});
            return;
        }
        SEQUENCE_GENERATOR.setClass(NoOpSequenceGenerator);
        APPLICATION_BUILDER.setClass(NoOpApplicationBuilder);
        STORE_DRIVER.setClass(NoOpSqlDriver);
        injectAirportDatabase();
        injectTransactionalServer();
        injectTransactionalConnector();
        await IOC.get(AIRPORT_DATABASE);
        const dbManager = await IOC.get(DatabaseManager);
        await dbManager.initNoDb({}, ...applications);
        this.tempDbInitialized = true;
    }
}

class ApplicationQueryGenerator {
    constructor() {
        this.tempDatabase = new TempDatabase();
    }
    async processQueries(entityOperationMap, jsonApplication) {
        if (!this.haveQueries(entityOperationMap)) {
            return;
        }
        await this.initTempDatabase(jsonApplication);
        for (const entityName in entityOperationMap) {
            const operations = entityOperationMap[entityName];
            for (const operationName in operations) {
                const operation = operations[operationName];
                switch (operation.type) {
                    case OperationType.DELETE:
                    case OperationType.SAVE:
                        break;
                    default:
                        // its a query
                        const queryDefinition = operation;
                        const query = await this.getApplicationQuery(queryDefinition, entityName, jsonApplication);
                        const inputs = queryDefinition.inputs.filter(input => input.type === QueryInputKind.PARAMETER);
                        inputs.forEach(input => {
                            if (!input.isArray) {
                                delete input.isArray;
                            }
                            delete input.clazz;
                            delete input.type;
                        });
                        operations[operationName] = {
                            inputs,
                            query,
                            type: queryDefinition.type,
                        };
                        break;
                }
            }
        }
    }
    haveQueries(entityOperationMap) {
        for (const entityName in entityOperationMap) {
            const operations = entityOperationMap[entityName];
            for (const operationName in operations) {
                const operation = operations[operationName];
                switch (operation.type) {
                    case OperationType.DELETE:
                    case OperationType.SAVE:
                        break;
                    default:
                        // its a query
                        return true;
                }
                // dao[dao](...(new QQueryPreparationField() as Array<any>));
            }
        }
        return false;
    }
    async initTempDatabase(application) {
        await this.tempDatabase.initialize([application]);
    }
    async getApplicationQuery(queryDefinition, entityName, jsonApplication) {
        const queryTypescript = queryDefinition.expression.getText();
        let queryJavascript = tsc__default.transpile(queryTypescript);
        const functionStartRegex = /\(\s*function \s*\(\s*[\w,\s]*\)\s*\{\s*/;
        const functionEndRegex = /\s*\}\);\s*$/;
        queryJavascript = queryJavascript.replace(functionStartRegex, '');
        queryJavascript = queryJavascript.replace(functionEndRegex, '');
        const [airDb, dbApplicationUtils] = await IOC.get(AIRPORT_DATABASE, DbApplicationUtils);
        for (const functionName in airDb.functions) {
            const regex = new RegExp(`\\s*${functionName}\\(`);
            queryJavascript = queryJavascript
                .replace(regex, ` airDb.functions.${functionName}(`);
        }
        const functionConstructorParams = [];
        for (const input of queryDefinition.inputs) {
            functionConstructorParams.push(input.name);
        }
        functionConstructorParams.push('airDb');
        functionConstructorParams.push('Y');
        functionConstructorParams.push(queryJavascript);
        const queryFunction = new Function(...functionConstructorParams);
        const [queryFunctionParameters, queryParameters] = this.getQueryFunctionParameters(queryDefinition, jsonApplication, airDb, dbApplicationUtils);
        const rawQuery = queryFunction(...queryFunctionParameters);
        const [dbAppliationUtils, lookup, queryFacade] = await IOC.get(DbApplicationUtils, Lookup, QUERY_FACADE);
        const context = lookup.ensureContext(null);
        const qApplication = airDb.QM[dbAppliationUtils.
            getApplication_FullName(jsonApplication)];
        const dbApplicationVersion = qApplication.__dbApplication__
            .versions[qApplication.__dbApplication__.versions.length - 1];
        context.dbEntity = dbApplicationVersion.entityMapByName[entityName];
        await queryFacade.ensureContext(context);
        const queryResultType = this.getQueryResultType(queryDefinition.type);
        const portableQuery = queryFacade.getPortableQuery(new LimitedEntityQuery(rawQuery), queryResultType, context);
        const parameterFieldMapByAlias = {};
        for (const queryParameter of queryParameters) {
            const qFunction = queryParameter.parameter;
            parameterFieldMapByAlias[qFunction.parameterAlias] = queryParameter;
        }
        const parameterMap = {
            ...portableQuery.parameterMap
        };
        for (const parameterAlias in portableQuery.parameterMap) {
            parameterMap[parameterAlias] = parameterFieldMapByAlias[parameterAlias].index;
        }
        return {
            jsonQuery: portableQuery.jsonQuery,
            parameterMap,
            queryResultType: portableQuery.queryResultType,
            tableIndex: portableQuery.tableIndex
        };
    }
    getQueryFunctionParameters(queryDefinition, jsonApplication, airDb, dbApplicationUtils) {
        const queryFunctionParameters = [];
        const queryParameters = [];
        let parameter;
        let queryParameter;
        let lastBooleanParameter = false;
        let lastNumberParameter = 0;
        let lastStringParameter = 0;
        let lastDateParameter = new Date().getTime();
        let Q;
        for (const input of queryDefinition.inputs) {
            switch (input.type) {
                case QueryInputKind.PARAMETER:
                    parameter = input;
                    switch (parameter.parameterType) {
                        case QueryParameterType.BOOLEAN:
                            lastBooleanParameter = !lastBooleanParameter;
                            queryParameter = new QBooleanFunction(lastBooleanParameter, true);
                            queryFunctionParameters.push(queryParameter);
                            queryParameters.push(queryParameter);
                            break;
                        case QueryParameterType.DATE:
                            lastDateParameter++;
                            if (parameter.isArray) {
                                queryParameter = new QDateArrayFunction([new Date(lastDateParameter)], true);
                            }
                            else {
                                queryParameter = new QDateFunction(new Date(lastDateParameter), true);
                            }
                            queryFunctionParameters.push(queryParameter);
                            queryParameters.push(queryParameter);
                            break;
                        case QueryParameterType.NUMBER:
                            lastNumberParameter++;
                            if (parameter.isArray) {
                                queryParameter = new QNumberArrayFunction([lastNumberParameter], true);
                            }
                            else {
                                queryParameter = new QNumberFunction(lastNumberParameter, true);
                            }
                            queryFunctionParameters.push(queryParameter);
                            queryParameters.push(queryParameter);
                            break;
                        case QueryParameterType.STRING:
                            lastStringParameter++;
                            if (parameter.isArray) {
                                queryParameter = new QStringArrayFunction(['' + lastStringParameter], true);
                            }
                            else {
                                queryParameter = new QStringFunction('' + lastStringParameter, true);
                            }
                            queryFunctionParameters.push(queryParameter);
                            queryParameters.push(queryParameter);
                            break;
                        default:
                            throw new Error(`Unsupported QueryParameterType: ` +
                                parameter.parameterType);
                    }
                    break;
                case QueryInputKind.Q:
                    Q = airDb.QM[dbApplicationUtils.
                        getApplication_FullName(jsonApplication)];
                    queryFunctionParameters.push(Q);
                    break;
                case QueryInputKind.QENTITY:
                    queryFunctionParameters.push(null);
                    break;
            }
        }
        queryFunctionParameters.push(airDb);
        queryFunctionParameters.push(Y);
        return [queryFunctionParameters, queryParameters.map((parameter, index) => ({
                index,
                parameter
            }))];
    }
    getQueryResultType(operationType) {
        switch (operationType) {
            case OperationType.FIND_ONE_GRAPH:
            case OperationType.FIND_GRAPH:
            case OperationType.SEARCH_ONE_GRAPH:
            case OperationType.SEARCH_GRAPH:
                return QueryResultType.ENTITY_GRAPH;
            case OperationType.FIND_ONE_TREE:
            case OperationType.FIND_TREE:
            case OperationType.SEARCH_ONE_TREE:
            case OperationType.SEARCH_TREE:
                return QueryResultType.ENTITY_TREE;
            default:
                throw new Error(`Unexpected OperationType: '${operationType}'.`);
        }
    }
}

class FileBuilder {
    constructor(entity, fullGenerationPath, pathBuilder, configuration) {
        this.entity = entity;
        this.fullGenerationPath = fullGenerationPath;
        this.pathBuilder = pathBuilder;
        this.configuration = configuration;
        this.importMap = {};
    }
    addImport(classNames, filePath) {
        filePath = filePath.replace('.ts', '');
        let fileImportMap = this.importMap[filePath];
        if (!fileImportMap) {
            fileImportMap = {};
            this.importMap[filePath] = fileImportMap;
        }
        classNames.forEach(className => {
            let asName;
            let sourceName;
            if (typeof className === 'string') {
                asName = className;
                sourceName = className;
            }
            else {
                asName = className.asName;
                sourceName = className.sourceName;
            }
            let existingSourceName = fileImportMap[asName];
            if (existingSourceName) {
                if (existingSourceName !== sourceName) {
                    throw new Error(`Cannot import '${sourceName}' as '${asName}' from ${filePath}.
					'${existingSourceName}' is already imported as '${asName}' from this path.`);
                }
                return;
            }
            else {
                fileImportMap[asName] = sourceName;
            }
        });
    }
    buildImports() {
        this.addImports();
        let imports = ``;
        for (let filePath in this.importMap) {
            const fileImportMap = this.importMap[filePath];
            let importedObjects = [];
            for (let asName in fileImportMap) {
                let sourceName = fileImportMap[asName];
                if (sourceName === asName) {
                    importedObjects.push(sourceName);
                }
                else {
                    importedObjects.push(`${sourceName} as ${asName}`);
                }
            }
            imports += `import {\n\t${importedObjects.join(',\n\t')},\n} from '${filePath}';\n`;
        }
        return imports;
    }
}

class ImplementationFileBuilder extends FileBuilder {
    constructor(fileName, pathBuilder) {
        super(null, null, pathBuilder, null);
        this.entityIdMapByName = {};
        this.entityNames = [];
        this.ddlPathMapByEntityName = {};
        this.generatedPathMapByEntityName = {};
        this.listingFilePath = pathBuilder.fullGeneratedDirPath + `/${fileName}.ts`;
    }
    addFileNameAndPaths(entityId, entityName, fullDdlPath, fullGenerationPath) {
        if (entityId === undefined) {
            return;
        }
        const ddlRelativePath = resolveRelativePath(this.listingFilePath, fullDdlPath)
            .replace('.ts', '');
        this.ddlPathMapByEntityName[entityName] = ddlRelativePath;
        const generatedRelativePath = resolveRelativePath(this.listingFilePath, fullGenerationPath)
            .replace('.ts', '');
        this.generatedPathMapByEntityName[entityName] = generatedRelativePath;
        this.entityNames.push(entityName);
        this.entityIdMapByName[entityName] = entityId;
    }
}

class UtilityBuilder extends ImplementationFileBuilder {
    constructor(applicationFullName, pathBuilder, classSuffix) {
        super('base' + classSuffix + 's', pathBuilder);
        this.classSuffix = classSuffix;
        // this.diSet = needsQEntity ? 'diSet' : 'duoDiSet';
        this.diSet = applicationFullName + '_diSet';
    }
    build() {
        this.entityNames.sort();
        const baseClassDefinitions = this.buildBaseClassDefinitions();
        const imports = this.buildImports();
        return `/* eslint-disable */
${imports}
import Q from './qApplication'

// Application Q object Dependency Injection readiness detection ${this.classSuffix}
export class SQDI${this.classSuffix}<Entity,
	EntitySelect extends IEntitySelectProperties,
	EntityCreate extends IEntityCreateProperties,
	EntityUpdateColumns extends IEntityUpdateColumns,
	EntityUpdateProperties extends IEntityUpdateProperties,
	ApplicationEntity_LocalId extends IEntityIdProperties,
	EntityCascadeGraph extends IEntityCascadeGraph,
	IQE extends IQEntity>
	extends ${this.classSuffix}<Entity,
		EntitySelect,
		EntityCreate,
		EntityUpdateColumns,
		EntityUpdateProperties,
		ApplicationEntity_LocalId,
		EntityCascadeGraph,
		IQE> {

	constructor(
		dbEntityId: DbEntityId
	) {
		super(dbEntityId, Q)
	}
}

${baseClassDefinitions}`;
    }
    addImports() {
        this.entityNames.forEach(entityName => {
            this.addImport([
                `${entityName}`
            ], `${this.ddlPathMapByEntityName[entityName]}`);
            this.addImport([
                `${entityName}ESelect`,
                `${entityName}ECreateColumns`,
                `${entityName}ECreateProperties`,
                `${entityName}EUpdateColumns`,
                `${entityName}EUpdateProperties`,
                `${entityName}EId`,
                `${entityName}Graph`,
                `Q${entityName}`
            ], `${this.generatedPathMapByEntityName[entityName]}`);
        });
        this.addImport([
            'IEntityCascadeGraph',
            'IEntityCreateProperties',
            'IEntityIdProperties',
            'IEntitySelectProperties',
            'IEntityUpdateColumns',
            'IEntityUpdateProperties',
            'IQEntity'
        ], '@airport/tarmaq-query');
        this.addImport([
            `${this.classSuffix}`
        ], '@airport/tarmaq-dao');
        this.addImport([
            {
                asName: 'DbEntityId',
                sourceName: 'ApplicationEntity_LocalId'
            }
        ], '@airport/ground-control');
        this.addImport([
            `${this.diSet}`
        ], './qApplication');
    }
    buildBaseClassDefinitions() {
        return this.entityNames.map(entityName => `
export interface IBase${entityName}${this.classSuffix}
  extends I${this.classSuffix}<${entityName}, ${entityName}ESelect, ${entityName}ECreateProperties, ${entityName}EUpdateColumns, ${entityName}EUpdateProperties, ${entityName}EId, ${entityName}Graph, Q${entityName}> {
}

export class Base${entityName}${this.classSuffix}
  extends SQDI${this.classSuffix}<${entityName}, ${entityName}ESelect, ${entityName}ECreateProperties, ${entityName}EUpdateColumns, ${entityName}EUpdateProperties, ${entityName}EId, ${entityName}Graph, Q${entityName}>
	implements IBase${entityName}${this.classSuffix} {${this.buildStaticProperties(entityName)}

	static diSet(): boolean {
		return ${this.diSet}(${this.entityIdMapByName[entityName]})
	}
	
	constructor() {
		super(${this.entityIdMapByName[entityName]})
	}
}
`).join('\n');
    }
    buildStaticProperties(entityName) {
        return '';
    }
}

class DaoBuilder extends UtilityBuilder {
    constructor(applicationFullName, pathBuilder) {
        super(applicationFullName, pathBuilder, 'Dao');
    }
    addImports() {
        super.addImports();
        this.addImport([
            'DaoQueryDecorators',
            'IDao'
        ], '@airport/tarmaq-dao');
    }
    buildStaticProperties(entityName) {
        return `
	
	static Find      = new DaoQueryDecorators<${entityName}ESelect>();
	static FindOne   = new DaoQueryDecorators<${entityName}ESelect>();
	static Search    = new DaoQueryDecorators<${entityName}ESelect>();
	static SearchOne = new DaoQueryDecorators<${entityName}ESelect>();
	static Save(
		config: ${entityName}Graph
	): PropertyDecorator {
		return Dao.BaseSave<${entityName}Graph>(config);
  }`;
    }
}

class DvoBuilder extends ImplementationFileBuilder {
    constructor(applicationFullName, pathBuilder) {
        super('baseDvos', pathBuilder);
        this.classSuffix = 'Dvo';
        this.diSet = applicationFullName + '_diSet';
    }
    build() {
        this.entityNames.sort();
        const baseClassDefinitions = this.buildBaseClassDefinitions();
        const imports = this.buildImports();
        return `/* eslint-disable */
${imports}
import Q from './qApplication'

// Application Q object Dependency Injection readiness detection ${this.classSuffix}
export class SQDI${this.classSuffix}<Entity, EntityVDescriptor>
	extends ${this.classSuffix}<Entity, EntityVDescriptor> {

	constructor(
		dbEntityId: DbEntityId
	) {
		super(dbEntityId, Q)
	}
}

${baseClassDefinitions}`;
    }
    addImports() {
        this.entityNames.forEach(entityName => {
            this.addImport([
                `${entityName}`
            ], `${this.ddlPathMapByEntityName[entityName]}`);
            this.addImport([
                `${entityName}VDescriptor`
            ], `${this.pathBuilder.prefixToFileName(this.generatedPathMapByEntityName[entityName], '')}`);
        });
        this.addImport([
            `${this.classSuffix}`,
            'IDvo'
        ], '@airbridge/validate');
        this.addImport([
            {
                asName: 'DbEntityId',
                sourceName: 'ApplicationEntity_LocalId'
            }
        ], '@airport/ground-control');
        this.addImport([
            `${this.diSet}`
        ], './qApplication');
    }
    buildBaseClassDefinitions() {
        return this.entityNames.map(entityName => `
export interface IBase${entityName}${this.classSuffix}
  extends I${this.classSuffix}<${entityName}, ${entityName}VDescriptor<${entityName}>> {
}

export class Base${entityName}${this.classSuffix}
  extends SQDI${this.classSuffix}<${entityName}, ${entityName}VDescriptor<${entityName}>>
	implements IBase${entityName}${this.classSuffix} {${this.buildStaticProperties(entityName)}

	static diSet(): boolean {
		return ${this.diSet}(${this.entityIdMapByName[entityName]})
	}
	
	constructor() {
		super(${this.entityIdMapByName[entityName]})
	}
}
`).join('\n');
    }
    buildStaticProperties(entityName) {
        return '';
    }
}

class ApplicationRelationResolver {
    constructor() {
        this.dictionary = new Dictionary();
    }
    resolveAllRelationLinks(indexedApplication) {
        for (const entityName in indexedApplication.entityMapByName) {
            const indexedEntity = indexedApplication.entityMapByName[entityName];
            if (indexedEntity.entity.isAirEntity) {
                if (indexedEntity.idColumns[0].name !== this.dictionary.AirEntity.columns.REPOSITORY_LID) {
                    throw new Error(`@Id Column at index 0, must be 'REPOSITORY_LID'`);
                }
            }
            this.resolveEntityRelationLinks(indexedApplication, indexedEntity);
        }
    }
    getEntityRelationsOfType(relationIndexedEntity, entityRelationType, entityName) {
        return relationIndexedEntity.relations.filter((relation) => {
            return relation.relationType === entityRelationType
                && relation.entityName === entityName;
        });
    }
    resolveEntityRelationLinks(indexedApplication, indexedEntity) {
        const anEntity = indexedEntity.entity;
        const relationEntityNameSet = {};
        for (const aProperty of anEntity.properties) {
            const aRelation = aProperty.relation;
            if (!aRelation) {
                continue;
            }
            // TODO: find matching relation
            let relatedOneToManys;
            let relationIndexedEntity;
            let relationEntityName;
            let crossApplication = aRelation.referencedApplication_Index || aRelation.referencedApplication_Index === 0;
            if (crossApplication) {
                relationIndexedEntity = indexedApplication.application
                    .referencedApplications[aRelation.referencedApplication_Index].dbApplication.currentVersion[0]
                    .applicationVersion.entityMapByName[aRelation.entityName];
                relationEntityName = relationIndexedEntity.name;
                relationIndexedEntity.isLocal;
            }
            else {
                relationIndexedEntity =
                    indexedApplication.entityMapByName[aRelation.entityName];
                if (!relationIndexedEntity) {
                    throw new Error(`Did not find ${aRelation.entityName} entity `
                        + `(via the ${anEntity.name}.${aProperty.name} relation).`);
                }
                relatedOneToManys = this.getEntityRelationsOfType(relationIndexedEntity, EntityRelationType.ONE_TO_MANY, anEntity.name);
                if (relatedOneToManys.length > 1) {
                    for (const relatedOneToMany of relatedOneToManys) {
                        if (relatedOneToMany.oneToMany &&
                            relatedOneToMany.oneToMany.mappedBy) {
                            if (relatedOneToMany.sRelationColumns
                                && relatedOneToMany.sRelationColumns.length) {
                                throw new Error(`@OneToMany with 'mappedBy' cannot define any @JoinColumn(s).`);
                            }
                        }
                        else if (!relatedOneToMany.sRelationColumns
                            || !relatedOneToMany.sRelationColumns.length) {
                            throw new Error(`@OneToMany without 'mappedBy' must define any @JoinColumn(s)`);
                        }
                    }
                }
                this.getEntityRelationsOfType(relationIndexedEntity, EntityRelationType.MANY_TO_ONE, anEntity.name);
                const relationEntity = relationIndexedEntity.entity;
                relationEntityName = relationEntity.name;
                relationEntity.isLocal;
            }
            relationEntityNameSet[aRelation.entityName] = true;
            switch (aRelation.relationType) {
                case EntityRelationType.ONE_TO_MANY:
                    /*					if (aRelation.oneToMany && aRelation.oneToMany.cascade
                                            && anEntity.isLocal && !relationEntityIsLocal) {
                                            throw new Error(
                                                `@OneToMany Relation '${anEntity.name}.${aProperty.name}' is on a Local entity and is cascading
                                            into a repository entity '${aRelation.entityName}'.
                                            Cascading from Local entities to Repository entities is not currently supported.`)
                                        }*/
                    if (crossApplication && !aRelation.sRelationColumns.length) {
                        throw new Error(`@OneToMany Relation '${anEntity.name}.${aProperty.name}' is a cross-application @OneToMany association.
						@OneToMany associations are not allowed across applications (without @JoinColumn(s)).`);
                    }
                    break;
                case EntityRelationType.MANY_TO_ONE:
                    // Many-To-One relations are not cascaded, so no cascade check is needed
                    break;
                default:
                    throw new Error(`Unknown EntityRelationType: ${aRelation.relationType}.`);
            }
            let oneSideRelationIndex;
            switch (aRelation.relationType) {
                case EntityRelationType.ONE_TO_MANY:
                    // Don't need to assign oneSideRelationIndex
                    // oneSideRelationIndex = aRelation.index
                    break;
                case EntityRelationType.MANY_TO_ONE:
                    if (!crossApplication) {
                        const matchingRelatedOneToManys = relatedOneToManys.filter(relatedOneToMany => relatedOneToMany.oneToMany && relatedOneToMany.oneToMany.mappedBy === aProperty.name);
                        // FIXME: right now there is no check on the One side of the relationship for
                        // mappedBy pointing to invalid location - add it
                        if (matchingRelatedOneToManys.length > 1) {
                            throw new Error(`Found more ${matchingRelatedOneToManys.length} matching @OneToMany 
							for ${anEntity.name}.${aProperty.name}. Expecting 1 or 0.`);
                        }
                        if (!matchingRelatedOneToManys.length) {
                            break;
                            // throw new Error(`Expecting one matching @OneToMany for
                            // ${anEntity.name}.${aProperty.name} and found
                            // ${matchingRelatedOneToManys.length}`);
                        }
                        oneSideRelationIndex = matchingRelatedOneToManys[0].index;
                    }
                    break;
                default:
                    throw new Error(`Unknown relation type ${aRelation.relationType}.`);
            }
            for (const sRelationColumn of aRelation.sRelationColumns) {
                sRelationColumn.oneSideRelationIndex = oneSideRelationIndex;
                let ownColumn;
                // if (sRelationColumn.ownColumnIdIndex) {
                // 	ownColumn = indexedEntity.idColumns[sRelationColumn.ownColumnIdIndex]
                // 	if (!ownColumn) {
                // 		throw new Error(`Did not find @Id column of ${anEntity.name} at index
                // ${sRelationColumn.ownColumnIdIndex} ` + `(via the
                // ${anEntity.name}.${aProperty.name} relation).`) } } else {
                ownColumn = indexedEntity.columnMap[sRelationColumn.ownColumnReference];
                if (!ownColumn) {
                    throw new Error(`Did not find column ${anEntity.name}.${sRelationColumn.ownColumnReference} `
                        + `(via the ${anEntity.name}.${aProperty.name} relation).`);
                }
                // }
                let relatedColumn;
                // if (sRelationColumn.relationColumnIdIndex
                // 	|| sRelationColumn.relationColumnIdIndex == 0) {
                // 	relatedColumn =
                // relationIndexedEntity.idColumns[sRelationColumn.relationColumnIdIndex] if
                // (!relatedColumn) { throw new Error(
                // `Did not find @Id column of ${relationEntityName} at
                // index ${sRelationColumn.relationColumnIdIndex} ` + `(via the
                // ${anEntity.name}.${aProperty.name} relation).`) } } else
                if (sRelationColumn.relationColumnReference) {
                    relatedColumn = relationIndexedEntity.columnMap[sRelationColumn.relationColumnReference];
                    if (!relatedColumn) {
                        throw new Error(`Did not find column ${relationEntityName}.${sRelationColumn.relationColumnReference} `
                            + `(via the ${anEntity.name}.${aProperty.name} relation).`);
                    }
                }
                else {
                    relatedColumn = relationIndexedEntity.columnMap[ownColumn.name];
                    if (!relatedColumn) {
                        throw new Error(`Did not find column ${relationEntityName}.${ownColumn.name} `
                            + `(via the ${anEntity.name}.${aProperty.name} relation).`);
                    }
                    sRelationColumn.relationColumnReference = ownColumn.name;
                }
                if (crossApplication) {
                    ownColumn.type = this.getTypeFromSQLDataType(relatedColumn.type);
                    this.setTypeForLinkedColumns(ownColumn);
                }
                else {
                    this.linkColumnTypes(ownColumn, relatedColumn);
                    this.setType(ownColumn, relatedColumn);
                }
            }
        }
    }
    linkColumnTypes(ownColumn, relatedColumn) {
        let relatedColumns;
        if (ownColumn.tempColumnTypeLinks) {
            relatedColumns = ownColumn.tempColumnTypeLinks;
            if (relatedColumn.tempColumnTypeLinks) {
                relatedColumns = relatedColumns.concat(relatedColumn.tempColumnTypeLinks);
                ownColumn.tempColumnTypeLinks = relatedColumns;
            }
            else {
                relatedColumns.push(relatedColumn);
            }
            relatedColumn.tempColumnTypeLinks = relatedColumns;
        }
        else if (relatedColumn.tempColumnTypeLinks) {
            relatedColumns = relatedColumn.tempColumnTypeLinks;
            relatedColumns.push(ownColumn);
            ownColumn.tempColumnTypeLinks = relatedColumns;
        }
        else {
            relatedColumns = [ownColumn, relatedColumn];
            ownColumn.tempColumnTypeLinks = relatedColumns;
            relatedColumn.tempColumnTypeLinks = relatedColumns;
        }
    }
    setType(ownColumn, relatedColumn) {
        let type = ownColumn.type;
        if (!type) {
            type = relatedColumn.type;
        }
        if (!type) {
            return;
        }
        for (const column of ownColumn.tempColumnTypeLinks) {
            column.type = type;
        }
    }
    setTypeForLinkedColumns(ownColumn) {
        let type = ownColumn.type;
        if (!type
            || !ownColumn.tempColumnTypeLinks) {
            return;
        }
        for (const column of ownColumn.tempColumnTypeLinks) {
            column.type = type;
        }
    }
    getTypeFromSQLDataType(sqlDataType) {
        switch (sqlDataType) {
            case SQLDataType.ANY:
                return 'any';
            case SQLDataType.BOOLEAN:
                return 'boolean';
            case SQLDataType.DATE:
                return 'Date';
            case SQLDataType.JSON:
                return 'Json';
            case SQLDataType.NUMBER:
                return 'number';
            case SQLDataType.STRING:
                return 'string';
            default:
                throw new Error(`Unexpected SQLDataType: ${sqlDataType}.`);
        }
    }
}

function buildIndexedSApplication(application, referencedApplicationsByName) {
    const idx = {
        entities: [],
        entityMapByName: {},
        referencedApplicationsByName,
        application
    };
    for (const entity of application.entities) {
        const columnMap = {};
        const propertyMap = {};
        const relationMap = {};
        const columns = [];
        const idColumns = [];
        const relations = [];
        for (const property of entity.properties) {
            propertyMap[property.name] = property;
            if (property.columns) {
                for (const column of property.columns) {
                    columnMap[column.name] = column;
                    columns[column.index] = column;
                    if (column.idIndex || column.idIndex === 0) {
                        idColumns[column.idIndex] = column;
                    }
                }
            }
            if (property.relation) {
                relationMap[property.name] = property.relation;
                relations[property.relation.index] = property.relation;
            }
        }
        const indexedEntity = {
            columnMap,
            columns,
            entity,
            idColumns,
            propertyMap,
            relationMap,
            relations,
        };
        idx.entities[entity.tableIndex] = indexedEntity;
        idx.entityMapByName[entity.name] = indexedEntity;
    }
    return idx;
}

class SApplicationBuilder {
    constructor(config, entityMapByName) {
        this.config = config;
        this.entityMapByName = entityMapByName;
        this.dictionary = new Dictionary();
    }
    build(applicationMapByProjectName) {
        const referencedApplicationsByProjectName = {};
        const originalReferencedApplicationsByProjectName = {};
        const referencedApplications = [];
        let applicationReferenceIndex = 0;
        for (let projectName in applicationMapByProjectName) {
            const sApplicationReference = {
                index: applicationReferenceIndex,
                dbApplication: applicationMapByProjectName[projectName]
            };
            referencedApplications.push(sApplicationReference);
            referencedApplicationsByProjectName[projectName] = sApplicationReference;
            originalReferencedApplicationsByProjectName[projectName] = sApplicationReference;
            applicationReferenceIndex++;
        }
        const application = {
            domain: this.config.airport.domain,
            entities: [],
            packageName: this.config.name,
            name: this.config.name,
            referencedApplications,
        };
        for (const entityName in this.entityMapByName) {
            const entityCandidate = this.entityMapByName[entityName];
            const tableIndex = application.entities.length;
            const entity = this.buildEntity(entityCandidate, tableIndex, referencedApplicationsByProjectName);
            if (entity) {
                application.entities.push(entity);
            }
        }
        for (const projectName in referencedApplicationsByProjectName) {
            if (!originalReferencedApplicationsByProjectName[projectName]) {
                referencedApplications.push(referencedApplicationsByProjectName[projectName]);
            }
        }
        referencedApplications.sort((a, b) => a.index - b.index);
        const indexedApplication = buildIndexedSApplication(application, referencedApplicationsByProjectName);
        new ApplicationRelationResolver().resolveAllRelationLinks(indexedApplication);
        return indexedApplication;
    }
    getIdColumnIndex(entity, columnName) {
        if (!entity.isAirEntity) {
            return entity.numIdColumns++;
        }
        entity.numIdColumns = 3;
        const airEntityColumns = this.dictionary.AirEntity.columns;
        switch (columnName) {
            case airEntityColumns.REPOSITORY_LID:
                return 0;
            case airEntityColumns.ACTOR_LID:
                return 1;
            case airEntityColumns.ACTOR_RECORD_ID:
                return 2;
            default:
                throw new Error(`AirEntity @Id columns must be 'REPOSITORY_LID', 'ACTOR_LID' and 'ACTOR_RECORD_ID'`);
        }
    }
    getColumnIndex(entity, idIndex) {
        if (!entity.isAirEntity) {
            return entity.numColumns++;
        }
        if (!entity.numColumns) {
            entity.numColumns = 3;
        }
        if (idIndex !== undefined) {
            return idIndex;
        }
        return entity.numColumns++;
    }
    buildEntity(entityCandidate, tableIndex, referencedApplicationsByProjectName) {
        let foundEntityDecorator = false;
        let tableConfig;
        const file = this.dictionary.file;
        for (const decorator of entityCandidate.docEntry.decorators) {
            switch (decorator.name) {
                case file.ENTITY: {
                    foundEntityDecorator = true;
                    break;
                }
                case file.TABLE: {
                    const decoratorValue = decorator.values[0];
                    if (!decoratorValue) {
                        throw new Error(`@Table decorator is missing property definition object:
@Entity()
@Table({ name: "YOUR_TABLE_NAME"})
class ${entityCandidate.docEntry.name}
						
`);
                    }
                    const tableName = decoratorValue.name;
                    if (!decoratorValue) {
                        throw new Error(`@Table decorator is missing name property:
@Entity()
@Table({ name: "YOUR_TABLE_NAME"})
class ${entityCandidate.docEntry.name}
						
`);
                    }
                    if (!/^[A-Z]/.test(tableName)) {
                        throw new Error(`
Table name does not start with an uppercase letter:

@Entity()
@Table({ name: "${tableName}"})
class ${entityCandidate.docEntry.name}

`);
                    }
                    else if (!/^[0-9A-Z_\$#]+$/.test(tableName)) {
                        throw new Error(`
Table name contains characters other than uppercase letters, numbers, $, # and underscores:

@Entity()
@Table({ name: "${tableName}"})
class ${entityCandidate.docEntry.name}

`);
                    }
                    tableConfig = {
                        ...decorator.values[0]
                    };
                    if (!tableConfig.indexes) {
                        tableConfig.indexes = [];
                    }
                    break;
                }
            }
        }
        if (!foundEntityDecorator) {
            return null;
        }
        if (!tableConfig) {
            tableConfig = {
                indexes: []
            };
        }
        const [isAirEntity, isLocal] = entityExtendsAirEntity(entityCandidate);
        let entity = {
            isLocal,
            isAirEntity,
            name: entityCandidate.docEntry.name,
            numColumns: 0,
            numIdColumns: 0,
            numRelations: 0,
            properties: [],
            table: tableConfig,
            tableIndex
        };
        const primitiveColumnMapByName = {};
        const relationColumnMapByName = {};
        const relatedTableMap = new Map();
        this.buildColumnsWithParentEntities(entityCandidate, entity, primitiveColumnMapByName, relationColumnMapByName, relatedTableMap, referencedApplicationsByProjectName);
        entity.properties.sort((prop1, prop2) => {
            return prop1.index - prop2.index;
        });
        if (entity.isAirEntity) {
            if (entity.numIdColumns !== 3) {
                throw new Error(`Repository entity '${entity.name}' must have 3 id columns 
				and has ${entity.numIdColumns}.`);
            }
        }
        return entity;
    }
    buildColumnsWithParentEntities(entityCandidate, entity, primitiveColumnMapByName, relationColumnMapByName, relatedTableMap, referencedApplicationsByProjectName, project) {
        let parentEntity = entityCandidate.parentEntity;
        let numParentProperties = 0;
        if (parentEntity) {
            let parentProject = project;
            if (parentEntity.project) {
                parentProject = parentEntity.project;
            }
            numParentProperties = this.buildColumnsWithParentEntities(parentEntity, entity, primitiveColumnMapByName, relationColumnMapByName, relatedTableMap, referencedApplicationsByProjectName, parentProject);
        }
        return this.buildColumns(entityCandidate, entity, primitiveColumnMapByName, relationColumnMapByName, relatedTableMap, numParentProperties, referencedApplicationsByProjectName, project);
    }
    buildColumns(entityCandidate, entity, primitiveColumnMapByName, relationColumnMapByName, relatedTableMap, numParentProperties, referencedApplicationsByProjectName, project) {
        const idProperties = entityCandidate.getIdProperties();
        const primitiveIdProperties = idProperties.filter(aProperty => {
            if (!aProperty.fromProject) {
                aProperty.fromProject = project;
            }
            return aProperty.primitive;
        });
        this.processPrimitiveColumns(primitiveIdProperties, true, entity, primitiveColumnMapByName, numParentProperties);
        const nonIdProperties = entityCandidate.getNonIdProperties();
        const primitiveNonIdProperties = nonIdProperties.filter(aProperty => {
            if (!aProperty.fromProject) {
                aProperty.fromProject = project;
            }
            return aProperty.primitive;
        });
        this.processPrimitiveColumns(primitiveNonIdProperties, false, entity, primitiveColumnMapByName, numParentProperties);
        const relationIdProperties = idProperties.filter(aProperty => !aProperty.primitive);
        for (const aProperty of relationIdProperties) {
            this.processRelationProperty(aProperty, true, entityCandidate, entity, relationColumnMapByName, primitiveColumnMapByName, relatedTableMap, numParentProperties, referencedApplicationsByProjectName);
        }
        const relationNonIdProperties = nonIdProperties.filter(aProperty => !aProperty.primitive);
        for (const aProperty of relationNonIdProperties) {
            this.processRelationProperty(aProperty, false, entityCandidate, entity, relationColumnMapByName, primitiveColumnMapByName, relatedTableMap, numParentProperties, referencedApplicationsByProjectName);
        }
        return numParentProperties + idProperties.length + nonIdProperties.length;
    }
    processRelationProperty(aProperty, isIdProperty, entityCandidate, entity, relationColumnMapByName, primitiveColumnMapByName, relatedTableMap, numParentProperties, referencedApplicationsByProjectName) {
        let columnRelationDefs = [];
        let columnsDefined = false;
        let foreignKey;
        let manyToOne = undefined;
        let oneToMany = undefined;
        let isId = false;
        // let repositoryJoin                       = false;
        // let addToJoinFunction;
        // let joinFunctionWithOperator = SqlOperator.AND
        let relationType;
        for (const decorator of aProperty.decorators) {
            const property = this.dictionary.property;
            switch (decorator.name) {
                case property.ID:
                    isId = true;
                    break;
                // case property.R_JOIN_COLUMN:
                // 	if (!entity.isAirEntity) {
                // 		throw new Error(`${entity.name}.${aProperty.name} cannot be @RJoinColumn `
                // 		+ `- ${entity.name} does not extend AirEntity or
                // LocalAirEntity.`); } repositoryJoin = true;
                case property.JOIN_COLUMN:
                    if (columnsDefined) {
                        throw new Error(`Columns are defined more than once 
						for ${entity.name}.${aProperty.name}`);
                    }
                    columnsDefined = true;
                    foreignKey = decorator.values[0].foreignKey;
                    columnRelationDefs.push(decorator.values[0]);
                    break;
                // case property.R_JOIN_COLUMNS:
                // 	if (!entity.isAirEntity) {
                // 		throw new Error(`${entity.name}.${aProperty.name} cannot be @RJoinColumns `
                // 		+ `- ${entity.name} does not extend AirEntity or
                // LocalAirEntity.`); } repositoryJoin = true;
                case property.JOIN_COLUMNS:
                    if (columnsDefined) {
                        throw new Error(`Columns are defined more than once 
						for ${entity.name}.${aProperty.name}`);
                    }
                    columnsDefined = true;
                    if (decorator.values[0] instanceof Array) {
                        columnRelationDefs = columnRelationDefs.concat(decorator.values[0].slice());
                    }
                    else {
                        throw new Error(`"${entity.name}.${aProperty.name} " is decorated with @JoinColumns decorator
						which must be provided an array of column join definitions (and currently is provided
						something other than an Array).`);
                        // columnRelationDefs = columnRelationDefs.concat(decorator.values[0].value);
                        // foreignKey = decorator.values[0].foreignKey;
                    }
                    break;
                case property.MANY_TO_ONE:
                    if (relationType) {
                        throw new Error(`Cardinality (@ManyToOne,@OneToMany) is defined more than once 
							for ${entity.name}.${aProperty.name}`);
                    }
                    manyToOne = decorator.values[0];
                    relationType = EntityRelationType.MANY_TO_ONE;
                    break;
                case property.ONE_TO_MANY:
                    if (isId) {
                        throw new Error(`A property cannot be be both @OneToMany and @Id`);
                    }
                    if (relationType) {
                        throw new Error(`Cardinality (@ManyToOne,@OneToMany) is defined more than once 
						for ${entity.name}.${aProperty.name}`);
                    }
                    oneToMany = decorator.values[0];
                    relationType = EntityRelationType.ONE_TO_MANY;
                    break;
                // case property.WHERE_JOIN_TABLE:
                // 	addToJoinFunction = decorator.values[0];
                // 	if (decorator.values.length === 2) {
                // 		switch (decorator.values[1]) {
                // 			case 'var and':
                // 				joinFunctionWithOperator = SqlOperator.AND;
                // 			case 'var or':
                // 				joinFunctionWithOperator = SqlOperator.OR;
                // 			default:
                // 				throw new Error(
                // 				`Unsupported 'joinFunctionWithOperator' ${decorator.values[1]}`);
                // 		}
                // 	}
                // 	break;
                default:
                    throw new Error(`Unsupported cardinality decorator ${decorator.name}`);
            }
        }
        if (!relationType) {
            throw new Error(`Cardinality (@ManyToOne,@OneToMany) is not defined 
				for ${entity.name}.${aProperty.name}`);
        }
        const columns = [];
        const sRelationColumns = [];
        let relationMustBeSingleIdEntity = false;
        const propertyIndex = aProperty.index + numParentProperties;
        if (columnsDefined) {
            for (const columnRelationDef of columnRelationDefs) {
                let name = columnRelationDef.name;
                let notNull = false;
                if (name) {
                    name = name.toUpperCase();
                }
                else {
                    throw new Error(`"name" is not defined in for a JoinColumn(s) configuration 
					of ${entity.name}.${aProperty.name}`);
                }
                if (columnRelationDef.nullable === false) {
                    notNull = true;
                }
                let referencedColumnName = columnRelationDef.referencedColumnName;
                if (referencedColumnName) {
                    referencedColumnName = referencedColumnName.toUpperCase();
                }
                else {
                    referencedColumnName = name;
                }
                let ownColumnReference;
                let relationColumnReference;
                let isManyToOne = false;
                switch (relationType) {
                    case EntityRelationType.MANY_TO_ONE:
                        ownColumnReference = name;
                        relationColumnReference = referencedColumnName;
                        isManyToOne = true;
                        break;
                    case EntityRelationType.ONE_TO_MANY:
                        ownColumnReference = referencedColumnName;
                        relationColumnReference = name;
                        break;
                    default:
                        throw new Error(`Uknown EntityRelationType: ${relationType}.`);
                }
                const [sRelationColumn, sColumn] = this.processRelationColumn(ownColumnReference, relationColumnReference, isManyToOne, isIdProperty, propertyIndex, entity, relationColumnMapByName, primitiveColumnMapByName, notNull);
                sRelationColumns.push(sRelationColumn);
                if (sColumn) {
                    columns.push(sColumn);
                }
            }
        }
        else {
            switch (relationType) {
                case EntityRelationType.MANY_TO_ONE: {
                    let extendsEntity, isLocal;
                    if (aProperty.entity) {
                        const extendsRepoEntityResult = entityExtendsAirEntity(aProperty.entity);
                        extendsEntity = extendsRepoEntityResult[0];
                        isLocal = extendsRepoEntityResult[1];
                    }
                    else if (aProperty.otherApplicationDbEntity) {
                        const otherAppDbEntity = aProperty.otherApplicationDbEntity;
                        if (otherAppDbEntity.isAirEntity) {
                            extendsEntity = true;
                            isLocal = false;
                        }
                        else if (isLocal) {
                            extendsEntity = true;
                            isLocal = true;
                        }
                        else {
                            extendsEntity = false;
                            isLocal = false;
                        }
                    }
                    else {
                        throw new Error(`Relation must either point to an entity in this Application
	or to an entity in another application.`);
                    }
                    if (!extendsEntity || isLocal) {
                        throw new Error(`@JoinColumn(s) must be specified for @ManyToOne
					in ${entity.name}.${aProperty.name} for non-repository entities.  Did you forget 'extends AirEntity'?`);
                    }
                    let relatedTableName;
                    if (aProperty.entity) {
                        relatedTableName = this.getTableNameFromEntity(aProperty.entity);
                    }
                    else {
                        const otherAppDbEntity = aProperty.otherApplicationDbEntity;
                        if (otherAppDbEntity.tableConfig && otherAppDbEntity.tableConfig.name) {
                            relatedTableName = otherAppDbEntity.tableConfig.name;
                        }
                        else {
                            relatedTableName = otherAppDbEntity.name.toUpperCase();
                        }
                    }
                    const notNull = isManyToOnePropertyNotNull(aProperty);
                    const airEntityColumns = this.dictionary.AirEntity.columns;
                    const relationColumnReferences = [
                        airEntityColumns.REPOSITORY_LID, airEntityColumns.ACTOR_LID,
                        airEntityColumns.ACTOR_RECORD_ID
                    ];
                    let numExistingReferenceToTable = relatedTableMap.get(relatedTableName);
                    if (!numExistingReferenceToTable) {
                        numExistingReferenceToTable = 1;
                    }
                    else {
                        numExistingReferenceToTable++;
                    }
                    relatedTableMap.set(relatedTableName, numExistingReferenceToTable);
                    const columnSuffixes = ['_RID_', '_AID_', '_ARID_'].map(suffix => suffix + numExistingReferenceToTable);
                    columnSuffixes.forEach((suffix, index) => {
                        const [sRelationColumn, sColumn] = this.processRelationColumn(relatedTableName + suffix, relationColumnReferences[index], true, isIdProperty, propertyIndex, entity, relationColumnMapByName, primitiveColumnMapByName, notNull);
                        sRelationColumns.push(sRelationColumn);
                        if (sColumn) {
                            columns.push(sColumn);
                        }
                    });
                }
                // relationMustBeSingleIdEntity = true
                // const [sRelationColumn, sColumn] = this.processRelationColumn(
                // 	aProperty.name.toUpperCase(), 'IdColumnIndex.ONE', true,
                // 	isIdProperty, propertyIndex, entity,
                // 	relationColumnMapByName, primitiveColumnMapByName, notNull,
                // 	true)
                // sRelationColumns.push(sRelationColumn)
                // columns.push(sColumn)
                // break
                case EntityRelationType.ONE_TO_MANY:
                    // Nothing to do
                    break;
                default:
                    throw new Error(`Uknown EntityRelationType: ${relationType}.`);
            }
        }
        let entityName;
        let referencedApplication_Index;
        if (!aProperty.entity) {
            if (!aProperty.fromProject) {
                throw new Error(`Neither entity nor source project was specified 
				for ${entity.name}.${aProperty.name}`);
            }
            let applicationReference = referencedApplicationsByProjectName[aProperty.fromProject];
            if (!applicationReference) {
                const dbApplication = GLOBAL_CANDIDATES.registry.getReferencedApplication(aProperty.fromProject, aProperty);
                if (!dbApplication) {
                    throw new Error(`Could not find related project '${aProperty.fromProject}' 
					for ${entity.name}.${aProperty.name}`);
                }
                applicationReference = {
                    index: Object.keys(referencedApplicationsByProjectName).length,
                    dbApplication
                };
                referencedApplicationsByProjectName[aProperty.fromProject] = applicationReference;
            }
            referencedApplication_Index = applicationReference.index;
            const propertyType = aProperty.nonArrayType;
            let relatedEntity = applicationReference.dbApplication.currentVersion[0]
                .applicationVersion.entityMapByName[propertyType];
            if (!relatedEntity) {
                if (canBeInterface(propertyType)) {
                    const entityType = getImplNameFromInterfaceName(propertyType);
                    relatedEntity = applicationReference.dbApplication.currentVersion[0]
                        .applicationVersion.entityMapByName[entityType];
                    if (!relatedEntity) {
                        throw new Error(`Could not find related entity '${entityType}' 
						(from interface ${propertyType}) 
						in project '${aProperty.fromProject}' 
						for ${entity.name}.${aProperty.name}`);
                    }
                }
                else {
                    throw new Error(`Could not find related entity '${propertyType}' 
					in project '${aProperty.fromProject}' 
					for ${entity.name}.${aProperty.name}`);
                }
            }
            entityName = relatedEntity.name;
        }
        else {
            entityName = aProperty.entity.type;
        }
        let relation = {
            // addToJoinFunction,
            entityName,
            foreignKey,
            index: entity.numRelations++,
            // joinFunctionWithOperator,
            manyToOne,
            oneToMany,
            relationType,
            referencedApplication_Index,
            relationMustBeSingleIdEntity,
            // repositoryJoin,
            sRelationColumns
        };
        entity.properties.push({
            columns,
            index: propertyIndex,
            isId: isIdProperty,
            name: aProperty.name,
            optional: aProperty.optional,
            relation
        });
    }
    getTableNameFromEntity(entityCandidate) {
        const tableDecorators = entityCandidate.docEntry.decorators.filter(decorator => decorator.name === 'Table');
        if (!tableDecorators.length) {
            return entityCandidate.docEntry.name.toUpperCase();
        }
        return tableDecorators[0].values[0].name;
    }
    isManyToOnePropertyNotNull(aProperty) {
        const manyToOneDecoratorValues = aProperty.decorators.filter(decorator => decorator.name === 'ManyToOne')[0].values;
        if (!manyToOneDecoratorValues.length) {
            return false;
        }
        return manyToOneDecoratorValues[0].optional === false;
    }
    processPrimitiveColumns(properties, isIdProperty, entity, primitiveColumnMapByName, numParentProperties) {
        for (const aProperty of properties) {
            const propertyIndex = aProperty.index + numParentProperties;
            entity.properties.push({
                columns: [this.processPrimitiveColumn(aProperty, isIdProperty, propertyIndex, entity, primitiveColumnMapByName)],
                index: propertyIndex,
                isId: isIdProperty,
                name: aProperty.name,
                optional: aProperty.optional,
                relation: undefined
            });
        }
    }
    processPrimitiveColumn(aProperty, isIdProperty, propertyIndex, entity, primitiveColumnMapByName) {
        let columnName;
        let notNull = false;
        let columnDefined = false;
        let precision = null;
        let scale = null;
        for (const decorator of aProperty.decorators) {
            switch (decorator.name) {
                case this.dictionary.property.COLUMN:
                    if (columnDefined) {
                        throw new Error(`@Column is defined more than once
						 for ${entity.name}.${aProperty.name}`);
                    }
                    columnDefined = true;
                    if (decorator.values.length) {
                        const columnDecoratorDefs = decorator.values[0];
                        columnName = columnDecoratorDefs.name;
                        let columnNameCheckRegExp = /^[A-Z]/;
                        let errorMessageSuffix = '';
                        if (this.config.airport.build
                            && this.config.airport.build.allowLeadingNumbersInColumnNames) {
                            columnNameCheckRegExp = /^[0-9A-Z]/;
                            errorMessageSuffix = ' (or a number)';
                        }
                        if (!columnNameCheckRegExp.test(columnName)) {
                            throw new Error(`
Column name does not start with an uppercase letter${errorMessageSuffix}:

@Entity()
class ${entity.name}

	@Column({ name: "${columnName}")
	${aProperty.name}
	
	`);
                        }
                        else if (!/^[0-9A-Z_]+$/.test(columnName)) {
                            throw new Error(`
Column name contains characters other than uppercase letters, numbers and underscores:

@Entity()
class ${entity.name}

	@Column({ name: "${columnName}")
	${aProperty.name}
	
	`);
                        }
                        if (columnDecoratorDefs.nullable === false) {
                            notNull = true;
                        }
                        if (columnDecoratorDefs.precision) {
                            precision = columnDecoratorDefs.precision;
                        }
                        if (columnDecoratorDefs.scale) {
                            scale = columnDecoratorDefs.scale;
                        }
                    }
                    else {
                        columnName = aProperty.name;
                    }
            }
        }
        if (!columnName) {
            columnName = aProperty.name;
        }
        columnName = columnName.toUpperCase();
        if (!columnName) {
            throw new Error(`Could not find a columnName in "${entity.name}"`);
        }
        const existingColumn = primitiveColumnMapByName[columnName];
        if (existingColumn) {
            throw new Error(`More than one @Column({name: "${columnName}"}) 
			defined in "${entity.name}"`);
        }
        if (aProperty.isGenerated
            && aProperty.primitive !== 'number'
            && aProperty.primitive !== 'string') {
            throw new Error(`Column '${columnName}' defined in "${entity.name}" is a @GeneratedValue()
			but isn't of type "number" or "string"`);
        }
        let idIndex = undefined;
        if (isIdProperty) {
            idIndex = this.getIdColumnIndex(entity, columnName);
        }
        const column = {
            allocationSize: aProperty.allocationSize,
            columnDefinition: aProperty.columnDefinition,
            idIndex,
            index: this.getColumnIndex(entity, idIndex),
            isGenerated: aProperty.isGenerated,
            name: columnName,
            notNull,
            precision,
            propertyRefs: [propertyIndex],
            scale,
            type: aProperty.primitive
        };
        primitiveColumnMapByName[columnName] = column;
        return column;
    }
    /**
     * Relation column joins can be:
     *
     * Id Index     to  Id Index
     * Column Name  to  Column Name
     * Id Index     to  Column Name
     * Column Name  to  Id Index
     *
     * For Id Indexes, do not add them as references if they don't
     * yet exist.
     *
     * @param {string} ownColumnReference
     * @param {boolean} isIdProperty
     * @param {SEntity} entity
     * @param {{[p: string]: SColumn}} relationColumnMapByName
     * @param {{[p: string]: SColumn}} primitiveColumnMapByName
     * @returns {SColumn}
     */
    processRelationColumn(ownColumnReference, relationColumnReference, manyToOne, isIdProperty, propertyIndex, entity, relationColumnMapByName, primitiveColumnMapByName, notNull, entityCannotReferenceOtherColumns = false) {
        // const ownColumnIdIndex                 = this.getIdColumnIndex(ownColumnReference)
        // const relationColumnIdIndex            =
        // this.getIdColumnIndex(relationColumnReference)
        const sRelationColumn = {
            manyToOne,
            oneSideRelationIndex: null,
            // ownColumnIdIndex,
            ownColumnReference,
            // relationColumnIdIndex,
            relationColumnReference
        };
        // if (ownColumnIdIndex) {
        // 	if (isIdProperty) {
        // 		throw new Error(`ManyToOne/OneToMany relation cannot be @Id and reference Id
        // columns at the same time.`) }  return [ sRelationColumn, null ] }
        const existingPrimitiveColumn = primitiveColumnMapByName[ownColumnReference];
        if (existingPrimitiveColumn) {
            if (manyToOne && isIdProperty) {
                // if (entityCannotReferenceOtherColumns) {
                // throw new Error(`ManyToOne relation without (R)JoinColumn(s) cannot be named
                // as other columns.`);
                throw new Error(`@Id & @ManyToOne relation columns cannot be named as other non-relational columns.
			A column can either be defined as a non-relational column
			OR as a relation.
			Column: '${entity.name}.${ownColumnReference}'`);
            }
            if ((existingPrimitiveColumn.notNull && !notNull)
                || (!existingPrimitiveColumn.notNull && notNull)) {
                throw new Error(`Column ${existingPrimitiveColumn.name} has conflicting nullable definitions`);
            }
            return [
                sRelationColumn,
                existingPrimitiveColumn
            ];
        }
        const existingRelationColumn = relationColumnMapByName[ownColumnReference];
        if (existingRelationColumn) {
            if (manyToOne && isIdProperty) {
                // if (entityCannotReferenceOtherColumns) {
                // throw new Error(`ManyToOne relation without (R)JoinColumn(s) cannot be named
                // as other columns.`);
                throw new Error(`@Id & @ManyToOne relation columns cannot be named in multiple relations.
			A @Id column can be defined in only one relation.
			Column: '${entity.name}.${ownColumnReference}'`);
            }
            if (entityCannotReferenceOtherColumns) {
                throw new Error(`ManyToOne relation without JoinColumn(s) 
				cannot be named as other columns.`);
            }
            if ((existingRelationColumn.notNull && !notNull)
                || (!existingRelationColumn.notNull && notNull)) {
                throw new Error(`Column ${existingRelationColumn.name} has conflicting nullable definitions`);
            }
            existingRelationColumn.propertyRefs.push(propertyIndex);
            return [
                sRelationColumn,
                existingRelationColumn
            ];
        }
        let idIndex = undefined;
        if (isIdProperty) {
            idIndex = this.getIdColumnIndex(entity, ownColumnReference);
        }
        const column = {
            idIndex,
            index: this.getColumnIndex(entity, idIndex),
            name: ownColumnReference,
            notNull,
            propertyRefs: [propertyIndex],
            type: undefined
        };
        relationColumnMapByName[ownColumnReference] = column;
        return [
            sRelationColumn,
            column
        ];
    }
}
function entityExtendsAirEntity(//
entityCandidate //
) {
    return entityExtendsOrIsAirEntity(entityCandidate.parentEntity);
}
const dictionary = new Dictionary();
function entityExtendsOrIsAirEntity(//
entityCandidate //
) {
    if (!entityCandidate) {
        return [false, true];
    }
    if (entityCandidate.docEntry.name === dictionary.AirEntity.name
        || entityCandidate.docEntry.name === dictionary.InternalAirEntity.name) {
        return [true, false];
    }
    // if (entityCandidate.docEntry.name === airEntityColumns.LOCAL_ENTITY_NAME) {
    // 	return [true, true];
    // }
    return entityExtendsOrIsAirEntity(entityCandidate.parentEntity);
}
function isManyToOnePropertyNotNull(aProperty) {
    const manyToOneProperty = getManyToOneDecorator(aProperty);
    if (!manyToOneProperty) {
        throw `Not a @ManyToOne property.`;
    }
    const manyToOneDecoratorValues = manyToOneProperty.values;
    if (!manyToOneDecoratorValues.length) {
        return false;
    }
    return manyToOneDecoratorValues[0].optional === false;
}
function getManyToOneDecorator(aProperty) {
    const manyToOneDecorators = aProperty.decorators.filter(decorator => decorator.name === 'ManyToOne');
    if (manyToOneDecorators.length) {
        return manyToOneDecorators[0];
    }
    return null;
}

/**
 * Created by Papa on 5/20/2016.
 */
class IQEntityInterfaceBuilder {
    constructor(entity, qEntityBuilder) {
        this.entity = entity;
        this.qEntityBuilder = qEntityBuilder;
        this.idPropertyBuilders = qEntityBuilder.idPropertyBuilders;
        this.idRelationBuilders = qEntityBuilder.idRelationBuilders;
        this.nonIdColumnBuilders = qEntityBuilder.nonIdColumnBuilders;
        this.nonIdPropertyBuilders = qEntityBuilder.nonIdPropertyBuilders;
        this.nonIdRelationBuilders = qEntityBuilder.nonIdRelationBuilders;
    }
    build() {
        let entityName = `${this.entity.docEntry.name}`;
        let idEProperties = ``;
        this.idPropertyBuilders.forEach((builder) => {
            idEProperties += `\t${builder.buildInterfaceDefinition(false)}\n`;
        });
        let optionalIdEProperties = ``;
        this.idPropertyBuilders.forEach((builder) => {
            optionalIdEProperties += `\t${builder.buildInterfaceDefinition()}\n`;
        });
        let idRelationsEntityIdEProperties = ``;
        this.idRelationBuilders.forEach((builder) => {
            const idRelationsEntityIdProperty = builder.buildInterfaceDefinition(true, false);
            if (idRelationsEntityIdProperty) {
                idRelationsEntityIdEProperties += `\t${idRelationsEntityIdProperty}\n`;
            }
        });
        let optionalIdRelationsEntityIdEProperties = ``;
        this.idRelationBuilders.forEach((builder) => {
            const idRelationsEntityIdProperty = builder.buildInterfaceDefinition(true);
            if (idRelationsEntityIdProperty) {
                optionalIdRelationsEntityIdEProperties += `\t${idRelationsEntityIdProperty}\n`;
            }
        });
        let idRelationsForEntityEProperties = ``;
        this.idRelationBuilders.forEach((builder) => {
            idRelationsForEntityEProperties += `\t${builder.buildInterfaceDefinition(false)}\n`;
        });
        let nonIdEProperties = ``;
        this.nonIdPropertyBuilders.forEach((builder) => {
            nonIdEProperties += `\t${builder.buildInterfaceDefinition()}\n`;
        });
        let nonIdEColumns = ``;
        this.nonIdColumnBuilders.forEach((builder) => {
            nonIdEColumns += `\t${builder.buildInterfaceDefinition()}\n`;
        });
        let nonIdRelationsForUpdateEProperties = ``;
        this.nonIdRelationBuilders.forEach((builder) => {
            const nonIdRelationForUpdateProperties = builder.buildInterfaceDefinition(true);
            if (nonIdRelationForUpdateProperties) {
                nonIdRelationsForUpdateEProperties += `\t${nonIdRelationForUpdateProperties}\n`;
            }
        });
        let nonIdRelationsForEntityEProperties = ``;
        this.nonIdRelationBuilders.forEach((builder) => {
            nonIdRelationsForEntityEProperties += `\t${builder.buildInterfaceDefinition(false)}\n`;
        });
        const [isAirEntity, isLocal] = entityExtendsAirEntity(this.entity);
        let relationsForCascadeGraph = ``;
        if (!isAirEntity) {
            this.idRelationBuilders.forEach((builder) => {
                // if (getManyToOneDecorator(builder.entityProperty)) {
                // 	// Do NOT cascade @ManyToOne's
                // 	return
                // }
                relationsForCascadeGraph += `\t${builder.buildInterfaceDefinition(false, true, true, true)}\n`;
            });
        }
        this.nonIdRelationBuilders.forEach((builder) => {
            // if (getManyToOneDecorator(builder.entityProperty)) {
            // 	// Do NOT cascade @ManyToOne's
            // 	return
            // }
            relationsForCascadeGraph += `\t${builder.buildInterfaceDefinition(false, true, true, true)}\n`;
        });
        let extendedQInterface = `IEntitySelectProperties`;
        let extendedQUpdatePropertiesInterface = `IEntityUpdateProperties`;
        let extendedQCascadeGraphInterface = `IEntityCascadeGraph`;
        let extendedQUpdateColumnsInterface = `IEntityUpdateColumns`;
        let extendedQIdInterface = 'IEntityIdProperties';
        if (this.entity.parentEntity) {
            const parentType = this.entity.parentEntity.type;
            extendedQInterface = `${parentType}ESelect`;
            extendedQUpdatePropertiesInterface = `${parentType}EUpdateProperties`;
            extendedQCascadeGraphInterface = `${parentType}Graph`;
            extendedQUpdateColumnsInterface = `${parentType}EUpdateColumns`;
            extendedQIdInterface = `${parentType}EId`;
        }
        let interfaceSource = `
//////////////////////////////
//  API SPECIFIC INTERFACES //
//////////////////////////////

/**
 * SELECT - All fields and relations (optional).
 */
export interface ${entityName}ESelect
    extends ${extendedQInterface}, ${entityName}EOptionalId {
	// Non-Id Properties
${nonIdEProperties}
	// Id Relations - full property interfaces
${idRelationsForEntityEProperties}
  // Non-Id relations (including OneToMany's)
${nonIdRelationsForEntityEProperties}
}

/**
 * DELETE - Ids fields and relations only (required).
 */
export interface ${entityName}EId
    extends ${extendedQIdInterface} {
	// Id Properties
${idEProperties}
	// Id Relations - Ids only
${idRelationsEntityIdEProperties}
}

/**
 * Ids fields and relations only (optional).
 */
export interface ${entityName}EOptionalId {
	// Id Properties
${optionalIdEProperties}
	// Id Relations - Ids only
${optionalIdRelationsEntityIdEProperties}
}

/**
 * UPDATE - non-id fields and relations (optional).
 */
export interface ${entityName}EUpdateProperties
	extends ${extendedQUpdatePropertiesInterface} {
	// Non-Id Properties
${nonIdEProperties}
	// Non-Id Relations - _localIds only & no OneToMany's
${nonIdRelationsForUpdateEProperties}
}

/**
 * PERSIST CASCADE - non-id relations (optional).
 */
export interface ${entityName}Graph
	extends ${entityName}EOptionalId, ${extendedQCascadeGraphInterface} {
// NOT USED: Cascading Relations
// NOT USED: \${relationsForCascadeGraph}
\t// Non-Id Properties
${nonIdEProperties}
\t// Relations
${relationsForCascadeGraph}
}

/**
 * UPDATE - non-id columns (optional).
 */
export interface ${entityName}EUpdateColumns
	extends ${extendedQUpdateColumnsInterface} {
	// Non-Id Columns
${nonIdEColumns}
}

/**
 * CREATE - id fields and relations (required) and non-id fields and relations (optional).
 */
export interface ${entityName}ECreateProperties
extends Partial<${entityName}EId>, ${entityName}EUpdateProperties {
}

/**
 * CREATE - id columns (required) and non-id columns (optional).
 */
export interface ${entityName}ECreateColumns
extends ${entityName}EId, ${entityName}EUpdateColumns {
}

`;
        return interfaceSource;
    }
}

/**
 * Created by Papa on 4/25/2016.
 */
class QColumnBuilder {
    constructor(parentBuilder, sColumn) {
        this.parentBuilder = parentBuilder;
        this.sColumn = sColumn;
    }
    buildDefinition() {
        let column = this.sColumn;
        return `${this.ensureValidName(column.name)}: ${column.type};`;
    }
    build() {
        throw new Error(`Not Implemented.`);
    }
    buildInterfaceDefinition(optional = true, forInternalInterfaces = true) {
        const column = this.sColumn;
        const name = this.ensureValidName(column.name);
        let type = column.type;
        if (type === 'Json') {
            type = 'string';
        }
        let operableFieldSuffix = '';
        if (forInternalInterfaces) {
            operableFieldSuffix = ' | ' + getQColumnFieldInterface(column);
        }
        return `${name}${optional ? '?' : ''}: ${type}${operableFieldSuffix};`;
    }
    ensureValidName(columnName) {
        if (/[0-9]/.test(columnName.substring(0, 1))) {
            return '_' + columnName;
        }
        return columnName;
    }
}

/**
 * Created by Papa on 4/25/2016.
 */
class QPropertyBuilder {
    constructor(parentBuilder, propertyDocEntry) {
        this.parentBuilder = parentBuilder;
        this.propertyDocEntry = propertyDocEntry;
    }
    buildDefinition() {
        let prop = this.propertyDocEntry;
        let name = prop.name;
        let fieldClass = getQPropertyFieldClass(prop);
        return `${name}: I${fieldClass};`;
    }
    build() {
        throw new Error(`Not Implemented.`);
    }
    buildInterfaceDefinition(optional = true, forInternalInterfaces = true) {
        let prop = this.propertyDocEntry;
        let name = prop.name;
        let propertyType = prop.primitive;
        if (propertyType === 'Json') {
            propertyType = prop.type;
            let trimmedPropertyType = propertyType.trim();
            if (trimmedPropertyType.startsWith('{') || trimmedPropertyType.startsWith('[')
                || trimmedPropertyType.endsWith('}') || trimmedPropertyType.endsWith(']')) {
                throw new Error(`@Json() type must be an imported interface.  It cannot be an inplace type definition`);
            }
            const moduleImport = this.propertyDocEntry.ownerEntity.docEntry.fileImports.importMapByObjectAsName[propertyType];
            let relativePathToImport = moduleImport.path;
            if (moduleImport.path.indexOf('.') === 0) {
                const fullPathToImport = getFullPathFromRelativePath(moduleImport.path, this.propertyDocEntry.ownerEntity.path);
                relativePathToImport = resolveRelativePath(this.parentBuilder.fileBuilder.fullGenerationPath, fullPathToImport);
            }
            this.parentBuilder.addImport([moduleImport.objectMapByAsName[propertyType]], relativePathToImport);
        }
        let operableFieldSuffix = '';
        if (forInternalInterfaces) {
            operableFieldSuffix = ' | ' + getQPropertyFieldInterface(prop);
        }
        else {
            if (!prop.primitive) {
                addImportForType(prop.ownerEntity, prop.type, this.parentBuilder.fileBuilder);
                propertyType = prop.type;
            }
        }
        return `${name}${optional || prop.optional ? '?' : ''}: ${propertyType}${operableFieldSuffix};`;
    }
}

class QRelationBuilder {
    constructor(parentBuilder, entityProperty, entityMapByName, buildRelationInstance) {
        this.parentBuilder = parentBuilder;
        this.entityProperty = entityProperty;
        this.buildRelationInstance = buildRelationInstance;
    }
    buildDefinition() {
        let type;
        let entityType = this.entityProperty.type;
        if (this.entityProperty.entity) {
            entityType = this.entityProperty.entity.type;
        }
        else {
            entityType = this.entityProperty.otherApplicationDbEntity.name;
        }
        entityType = entityType.replace('[]', '');
        type = `Q${entityType}`
            + (this.buildRelationInstance ? 'QRelation' : 'QId');
        if (this.entityProperty.isArray) {
            let interfaceName = 'IQOneToManyRelation';
            if (entityExtendsOrIsAirEntity(this.parentBuilder.entity)[0]) {
                interfaceName = 'IQAirEntityOneToManyRelation';
                type = `${interfaceName}<${entityType}, Q${entityType}>`;
            }
            else {
                type = `${interfaceName}<Q${entityType}>`;
            }
        }
        return `${this.entityProperty.name}: ${type};`;
    }
    build() {
        throw new Error(`Not implemented`);
    }
    buildInterfaceDefinition(idOnly, optional = true, forInternalInterfaces = true, forCascadeGraph = false) {
        if (idOnly && this.entityProperty.decorators.filter(decorator => decorator.name === 'OneToMany').length) {
            return null;
        }
        let typeSuffix = '';
        if (forInternalInterfaces) {
            typeSuffix = idOnly ? (optional ? 'EOptionalId' : 'EId') :
                (forCascadeGraph ? 'Graph' : 'ESelect');
        }
        let type = this.entityProperty.type;
        if (this.entityProperty.entity) {
            type = this.entityProperty.entity.type;
        }
        else {
            type = this.entityProperty.otherApplicationDbEntity.name;
        }
        if (forInternalInterfaces) {
            if (!forCascadeGraph) {
                type = type.replace('[]', '');
            }
            else {
                typeSuffix += this.entityProperty.isArray ? '[]' : '';
            }
        }
        else {
            type = 'I' + type;
            if (this.entityProperty.entity && this.entityProperty.isArray) {
                type += '[]';
            }
        }
        const iType = type + typeSuffix;
        const definition = `${this.entityProperty.name}${optional ? '?' : ''}: ${iType};`;
        return definition;
    }
}

class QTransientBuilder {
    constructor(parentBuilder, propertyDocEntry) {
        this.parentBuilder = parentBuilder;
        this.propertyDocEntry = propertyDocEntry;
    }
    buildInterfaceDefinition() {
        let prop = this.propertyDocEntry;
        if (!prop.primitive && prop.type !== 'Date') {
            let type = prop.type;
            if (prop.isMap) {
                type = prop.mapValueType;
            }
            type = type.replace('[]', '');
            if (!prop.mapValueIsPrimitive) {
                addImportForType(prop.ownerEntity, type, this.parentBuilder.fileBuilder);
            }
        }
        // let type = prop.type;
        // if(prop.isMap && type.indexOf(']: ') > -1) {
        // 		type = type.replace(/\]\: (?!.*\]\: )/, "]: I");
        // } else {
        // 	type = `${type}`
        // }
        //
        // return `${prop.name}?: ${type};`;
        return `${prop.name}?: ${prop.type};`;
    }
}

class QCoreEntityBuilder {
    constructor(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName) {
        this.entity = entity;
        this.fullGenerationPath = fullGenerationPath;
        this.workingDirPath = workingDirPath;
        this.fileBuilder = fileBuilder;
        this.entityMapByName = entityMapByName;
        this.constructorFields = {};
    }
    addImport(classNames, filePath) {
        this.fileBuilder.addImport(classNames, filePath);
    }
    getQColumnBuilders(columns) {
        return columns.map(column => new QColumnBuilder(this, column));
    }
    getQPropertyBuilders(properties) {
        return properties.map(property => this.addQPropertyBuilder(property)).filter(builder => builder != null);
    }
    getQTransientPropertyBuilders(properties) {
        return properties.map(property => new QTransientBuilder(this, property));
    }
    getQRelationBuilders(properties, buildRelationInstance) {
        return properties.map(property => this.addQRelationBuilder(property, buildRelationInstance)).filter(builder => builder != null);
    }
    buildPropertyData(propertyBuilders) {
        const propertyData = {
            definitions: ``,
        };
        propertyBuilders.forEach((builder) => {
            propertyData.definitions += `	${builder.buildDefinition()}\n`;
        });
        return propertyData;
    }
    buildRelationData(relationBuilders) {
        const relationData = {
            definitions: ``,
        };
        relationBuilders.forEach((builder) => {
            relationData.definitions += `	${builder.buildDefinition()}\n`;
        });
        return relationData;
    }
    addQPropertyBuilder(property) {
        let propertyBuilder = null;
        if (property.primitive) {
            propertyBuilder = new QPropertyBuilder(this, property);
        }
        return propertyBuilder;
    }
    addQRelationBuilder(property, buildRelationInstance) {
        let relationBuilder = null;
        if (property.entity || property.fromProject) {
            relationBuilder = new QRelationBuilder(this, property, this.entityMapByName, buildRelationInstance);
        }
        return relationBuilder;
    }
}
function getQPropertyFieldInterface(//
propertyDocEntry //
) {
    return getQPrimitiveFieldInterface(propertyDocEntry.primitive);
}
function getQColumnFieldInterface(//
sColumn //
) {
    return getQPrimitiveFieldInterface(sColumn.type);
}
function getQPrimitiveFieldInterface(//
primitive //
) {
    switch (primitive) {
        case 'boolean':
            return 'IQBooleanField';
        case 'Date':
            return 'IQDateField';
        case 'number':
            return 'IQNumberField';
        case 'string':
        case 'Json':
            return 'IQStringField';
        case 'any':
            return 'IQUntypedField';
        default:
            throw new Error(`Unexpected primitive ${primitive}`);
    }
}
function getQPropertyFieldClass(//
propertyDocEntry //
) {
    switch (propertyDocEntry.primitive) {
        case 'boolean':
            return 'QBooleanField';
        case 'Date':
            return 'QDateField';
        case 'number':
            return 'QNumberField';
        case 'string':
        case 'Json':
            return 'QStringField';
        case 'any':
            return 'QUntypedField';
        default:
            throw new Error(`Unexpected primitive ${propertyDocEntry.primitive}`);
    }
}

/**
 * Created by Papa on 4/25/2016.
 */
class QEntityBuilder extends QCoreEntityBuilder {
    constructor(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName, sIndexedEntity) {
        super(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName);
        this.sIndexedEntity = sIndexedEntity;
        let idColumns = [];
        if (sIndexedEntity) {
            idColumns = sIndexedEntity.idColumns;
        }
        this.idColumnBuilders = this.getQColumnBuilders(idColumns);
        const idProperties = entity.getIdProperties();
        this.idPropertyBuilders = this.getQPropertyBuilders(idProperties);
        this.idRelationBuilders = this.getQRelationBuilders(idProperties, true);
        let nonIdColumns = [];
        if (sIndexedEntity) {
            nonIdColumns = sIndexedEntity.columns.filter((column) => {
                if (idColumns.some(idColumn => column.name === idColumn.name)) {
                    return false;
                }
                return true;
            });
        }
        this.nonIdColumnBuilders = this.getQColumnBuilders(nonIdColumns);
        const nonIdProperties = entity.getNonIdProperties();
        this.nonIdPropertyBuilders = this.getQPropertyBuilders(nonIdProperties);
        this.nonIdRelationBuilders = this.getQRelationBuilders(nonIdProperties, true);
        this.transientPropertyBuilders = this.getQTransientPropertyBuilders(entity.getTransientProperties());
    }
    build() {
        const idPropertyData = this.buildPropertyData(this.idPropertyBuilders);
        const nonIdPropertyData = this.buildPropertyData(this.nonIdPropertyBuilders);
        const nonIdRelationData = this.buildRelationData(this.nonIdRelationBuilders);
        const idRelationData = this.buildRelationData(this.idRelationBuilders);
        let parentEntityQType = 'IQEntity';
        if (this.entity.parentEntity) {
            parentEntityQType = 'Q' + this.entity.parentEntity.type;
        }
        let qName = `Q${this.entity.docEntry.name}`;
        let interfaceGenericAndExtends;
        // if (this.entity.docEntry.isMappedSuperclass) {
        interfaceGenericAndExtends = ` extends ${parentEntityQType}`;
        // } else {
        // 	interfaceGenericAndExtends = ` extends ${parentEntityQType}`
        // }
        let classSource = `/**
 * Query Entity Query Definition (used for Q.ApplicationEntity_Name).
 */
export interface ${qName}<IQE extends ${qName} = any>${interfaceGenericAndExtends}<IQE | ${qName}>
{
	// Id Fields
${idPropertyData.definitions}
	// Id Relations
${idRelationData.definitions}
	// Non-Id Fields
${nonIdPropertyData.definitions}
	// Non-Id Relations
${nonIdRelationData.definitions}
}
`;
        return classSource;
    }
}

class QEntityIdBuilder extends QCoreEntityBuilder {
    constructor(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName) {
        super(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName);
        const idProperties = entity.getIdProperties();
        this.idPropertyBuilders = this.getQPropertyBuilders(idProperties);
        this.idRelationBuilders = this.getQRelationBuilders(idProperties, false);
    }
    build() {
        const idPropertyData = this.buildPropertyData(this.idPropertyBuilders);
        const idRelationData = this.buildRelationData(this.idRelationBuilders);
        let qName = `Q${this.entity.docEntry.name}`;
        let extendsQType = '';
        if (this.entity.parentEntity) {
            extendsQType = ' extends Q' + this.entity.parentEntity.type + 'QId';
        }
        const classSource = `// Entity Id Interface
export interface ${qName}QId${extendsQType}
{
	
	// Id Fields
${idPropertyData.definitions}
	// Id Relations
${idRelationData.definitions}

}`;
        return classSource;
    }
}

class QEntityRelationBuilder extends QCoreEntityBuilder {
    constructor(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName) {
        super(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName);
    }
    build() {
        let qName = `Q${this.entity.docEntry.name}`;
        const isMappedSuperclass = this.entity.docEntry.decorators.some(decorator => {
            return decorator.name === 'MappedSuperclass';
        });
        let genericType = '';
        let entity = this.entity.docEntry.name;
        const [isAirEntity, _] = entityExtendsOrIsAirEntity(this.entity);
        let parentInterfaceType = 'IQManyToOneInternalRelation';
        if (isAirEntity) {
            parentInterfaceType = 'IQManyToOneAirEntityRelation';
        }
        let parentEntityQType = `${parentInterfaceType}<${qName}>`;
        if (isMappedSuperclass) {
            if (isAirEntity) {
                genericType = '<SubType, SubQType extends IQEntity>';
                parentEntityQType = `${parentInterfaceType}<SubType, SubQType>`;
            }
            else {
                genericType = '<SubQType extends IQEntity>';
                parentEntityQType = `${parentInterfaceType}<SubQType>`;
            }
        }
        if (this.entity.parentEntity) {
            let iqEntity = qName;
            if (isMappedSuperclass) {
                iqEntity = 'SubQType';
                entity = 'SubType';
            }
            if (isAirEntity) {
                let entityType = entity;
                parentEntityQType = `Q${this.entity.parentEntity.type}QRelation<${entityType}, ${iqEntity}>`;
            }
            else {
                parentEntityQType = `Q${this.entity.parentEntity.type}QRelation<${iqEntity}>`;
            }
        }
        const classSource = `// Entity Relation Interface
export interface ${qName}QRelation${genericType}
	extends ${parentEntityQType}, ${qName}QId {
}`;
        return classSource;
    }
}

/**
 * Created by Papa on 4/26/2016.
 */
class QEntityFileBuilder extends FileBuilder {
    constructor(entity, fullGenerationPath, pathBuilder, entityMapByName, configuration, sIndexedEntity, entityPath) {
        super(entity, fullGenerationPath, pathBuilder, configuration);
        this.entityMapByName = entityMapByName;
        this.entityPath = entityPath;
        this.importMap = {};
        this.qEntityBuilder = new QEntityBuilder(entity, fullGenerationPath, pathBuilder.workingDirPath, this, entityMapByName, sIndexedEntity);
        this.qEntityIdBuilder = new QEntityIdBuilder(entity, fullGenerationPath, pathBuilder.workingDirPath, this, entityMapByName);
        this.qEntityRelationBuilder = new QEntityRelationBuilder(entity, this.fullGenerationPath, this.pathBuilder.workingDirPath, this, entityMapByName);
        this.qEntityInterfaceBuilder = new IQEntityInterfaceBuilder(entity, this.qEntityBuilder);
        this.addImport([
            'IQEntityInternal',
            'IEntityIdProperties',
            'IEntityCascadeGraph',
            'IEntityUpdateColumns',
            'IEntityUpdateProperties',
            'IEntitySelectProperties',
            'IQBooleanField',
            'IQDateField',
            'IQNumberField',
            'IQOneToManyRelation', 'IQStringField',
            'IQUntypedField',
            'IQEntity', 'IQManyToOneInternalRelation',
            'IQAirEntityOneToManyRelation', 'IQManyToOneAirEntityRelation',
            'RawDelete', 'RawUpdate'
        ], '@airport/tarmaq-query');
        // let entityRelativePath = resolveRelativePath(fullGenerationPath, entity.path);
        if (entity.parentEntity) {
            let parentQEntityRelativePath;
            if (entity.parentEntity.project) {
                parentQEntityRelativePath = entity.parentEntity.project;
            }
            else {
                let parentFullGenerationPath = pathBuilder.getFullPathToGeneratedSource(entity.parentEntity.path, 'Q', 'query');
                parentQEntityRelativePath = resolveRelativePath(fullGenerationPath, parentFullGenerationPath);
            }
            let parentEntityType = entity.parentEntity.type;
            this.addImport([
                `${parentEntityType}Graph`,
                `${parentEntityType}EId`,
                `${parentEntityType}EUpdateColumns`,
                `${parentEntityType}EUpdateProperties`,
                `${parentEntityType}ESelect`,
                `Q${parentEntityType}QId`,
                `Q${parentEntityType}QRelation`,
                `Q${parentEntityType}`
            ], parentQEntityRelativePath);
        }
    }
    build() {
        let interfaceSource = this.qEntityInterfaceBuilder.build();
        let idClassSource = this.qEntityIdBuilder.build();
        let relationClassSource = this.qEntityRelationBuilder.build();
        let classSource = this.qEntityBuilder.build();
        let imports = this.buildImports();
        let fileSource = `${imports}
${interfaceSource}
///////////////////////////////////////////////
//  QUERY IMPLEMENTATION SPECIFIC INTERFACES //
///////////////////////////////////////////////

${classSource}
${idClassSource}

${relationClassSource}`;
        return fileSource;
    }
    addRelationImports(relationBuilders) {
        relationBuilders.forEach((builder) => {
            let property = builder.entityProperty;
            if (this.entity === property.entity) {
                return;
            }
            let type = property.type;
            let qEntityRelativePath;
            if (property.fromProject) {
                qEntityRelativePath = property.fromProject;
                type = property.otherApplicationDbEntity.name;
            }
            else {
                type = property.entity.type;
                qEntityRelativePath = resolveRelativeEntityPath(this.entity, property.entity);
                qEntityRelativePath = qEntityRelativePath.replace('.ts', '');
                qEntityRelativePath = this.pathBuilder.prefixToFileName(qEntityRelativePath, 'Q');
            }
            type = type.replace('[]', '');
            let qType = 'Q' + type;
            this.addImport([
                // 'I' + type,
                type + 'Graph',
                type + 'EId',
                type + 'EOptionalId',
                type + 'EUpdateProperties',
                type + 'ESelect',
                qType,
                qType + 'QId',
                qType + 'QRelation'
            ], qEntityRelativePath);
            if (property.fromProject) {
                let relationEntityPath = property.fromProject;
                this.addImport([type], relationEntityPath);
            }
            else {
                let entityRelativePath = resolveRelativePath(this.fullGenerationPath, this.entityMapByName[type].path);
                entityRelativePath = entityRelativePath.replace('.ts', '');
                this.addImport([type], entityRelativePath);
            }
        });
    }
    addImports() {
        this.addRelationImports(this.qEntityBuilder.idRelationBuilders);
        this.addRelationImports(this.qEntityBuilder.nonIdRelationBuilders);
        // const entityImportRelativePath = resolveRelativePath(this.fullGenerationPath,
        //   this.entityPath).replace('.ts', '');
        // this.addImport([this.entity.docEntry.name], entityImportRelativePath, false);
        const type = this.entity.docEntry.name;
        let entityRelativePath = resolveRelativePath(this.fullGenerationPath, this.entityMapByName[type].path);
        entityRelativePath = entityRelativePath.replace('.ts', '');
        this.addImport([type], entityRelativePath);
    }
}

class EntityMappingBuilder {
    constructor(entityMappingsPath, pathBuilder) {
        this.entityMappingsPath = entityMappingsPath;
        this.pathBuilder = pathBuilder;
        this.entityMappings = [];
    }
    addEntity(entityIndex, entityName, relativePath) {
        this.entityMappings.push({
            entityIndex,
            entityName,
            relativePath,
        });
    }
    build(applicationDomain, applicationName) {
        const imports = [];
        const entityDefinitions = this.entityMappings.map(entityMapping => {
            const entityImportRelativePath = resolveRelativePath(this.entityMappingsPath, entityMapping.relativePath).replace('.ts', '');
            imports.push(`import { ${entityMapping.entityName} } from '${entityImportRelativePath}';`);
            return `  accumulator.add(${entityMapping.entityName}, ${entityMapping.entityIndex});`;
        }).join('\n');
        return `/* eslint-disable */
import { AIRPORT_DATABASE } from '@airport/air-traffic-control';
import { IOC } from '@airport/direction-indicator';
${imports.join('\n')}

IOC.get(AIRPORT_DATABASE).then(airDb => {
  const accumulator = airDb.getAccumulator('${applicationDomain}', '${applicationName}');
${entityDefinitions}
});
`;
    }
}

class GeneratedFileListingBuilder {
    constructor(pathBuilder, fileName) {
        this.pathBuilder = pathBuilder;
        this.fileName = fileName;
        this.generatedFilePaths = [];
        this.generatedListingFilePath = pathBuilder.fullGeneratedDirPath + '/' + fileName;
    }
    addFileNameAndPaths(fullGenerationPath) {
        const generatedRelativePath = resolveRelativePath(this.generatedListingFilePath, fullGenerationPath).replace('.ts', '');
        this.generatedFilePaths.push(generatedRelativePath);
    }
    build() {
        this.generatedFilePaths.sort();
        const exports = this.generatedFilePaths.map(filePath => `export * from '${filePath}';`)
            .join('\n');
        return `${exports}
`;
    }
}

class GeneratedSummaryBuilder {
    constructor(pathBuilder, entityQInterfaceListingBuilder, entityVInterfaceListingBuilder) {
        this.pathBuilder = pathBuilder;
        this.entityQInterfaceListingBuilder = entityQInterfaceListingBuilder;
        this.entityVInterfaceListingBuilder = entityVInterfaceListingBuilder;
        this.generatedListingFilePath = pathBuilder.fullGeneratedDirPath + '/generated.ts';
    }
    build() {
        return `export * from './qApplication';
export * from './baseDaos';
export * from './baseDvos';
${this.entityQInterfaceListingBuilder.generatedFilePaths.length ? "export * from './qInterfaces'" : ""};
${this.entityVInterfaceListingBuilder.generatedFilePaths.length ? "export * from './vInterfaces'" : ""};
`;
    }
}

/**
 * Created by Papa on 4/28/2016.
 */
class PathBuilder {
    constructor(configuration) {
        this.configuration = configuration;
        this.dirExistanceMap = {};
        this.workingDirPath = normalizePath(process.cwd());
        this.apiDirPath = this.workingDirPath + '/' + normalizePath(configuration.airport.apiDir);
        this.ddlDirPath = this.workingDirPath + '/' + normalizePath(configuration.airport.ddlDir);
        this.generatedDirPath = normalizePath(configuration.airport.generatedDir);
        this.fullGeneratedDirPath = this.workingDirPath + '/' + this.generatedDirPath;
        this.usePathCache = configuration.airport.cacheGeneratedPaths ? true : false;
    }
    // getOutDirPrefix(fullGenerationPath: string): string {
    // 	let numDirsOut = fullGenerationPath.split('/').length
    // 		- this.workingDirPath.split('/').length
    // 		- this.configuration.airport.generatedDir.split('/').length
    // 		- 1
    //
    // 	let outDirPrefix = '..'
    // 	for (let i = 0; i < numDirsOut; i++) {
    // 		outDirPrefix += '/..'
    // 	}
    //
    // 	return outDirPrefix
    // }
    prefixToFileName(sourceRelativePath, prefix) {
        let pathFragments;
        if (sourceRelativePath.indexOf(path.sep) > -1) {
            pathFragments = sourceRelativePath.split(path.sep);
        }
        else if (sourceRelativePath.indexOf(path.posix.sep) > -1) {
            pathFragments = sourceRelativePath.split(path.posix.sep);
        }
        else {
            pathFragments = [sourceRelativePath];
        }
        let fileName = pathFragments[pathFragments.length - 1];
        fileName = prefix + fileName;
        pathFragments[pathFragments.length - 1] = fileName;
        sourceRelativePath = pathFragments.join(path.posix.sep);
        return sourceRelativePath;
    }
    getFullPathToGeneratedSource(//
    sourcePath, prefix, pathPrefix = '') {
        let generatedPath = this.getGenerationPathForFile(sourcePath, prefix, this.ddlDirPath, pathPrefix);
        return this.workingDirPath + '/' + generatedPath;
    }
    getFullPathToDdlSource(//
    sourcePath) {
        return this.getDdlPathForFile(sourcePath);
    }
    setupFileForGeneration(sourcePath, prefix, pathPrefix = '', dirPath = this.ddlDirPath) {
        let generatedPath = this.getGenerationPathForFile(sourcePath, prefix, dirPath, pathPrefix);
        let genPathFragments = generatedPath.split('/');
        let currentPath = this.workingDirPath;
        for (let i = 0; i < genPathFragments.length - 1; i++) {
            currentPath += '/' + genPathFragments[i];
            if (this.usePathCache && this.dirExistanceMap[currentPath]) {
                continue;
            }
            let pathExists = fs.existsSync(currentPath);
            if (!pathExists) {
                fs.mkdirSync(currentPath);
            }
            else {
                let pathStat = fs.statSync(currentPath);
                if (!pathStat.isDirectory()) {
                    throw new Error(`'${currentPath}' 
					is not a directory`);
                }
            }
            this.dirExistanceMap[currentPath] = true;
        }
        generatedPath.split('/');
        return './' + generatedPath;
    }
    getGenerationPathForFile(sourcePath, prefix, dirPath, pathPrefix) {
        sourcePath = normalizePath(sourcePath);
        let indexOfSourceDirInPath = sourcePath.indexOf(dirPath);
        if (indexOfSourceDirInPath !== 0) {
            throw new Error(`Cannot generate file from source outside of root source dir`);
        }
        let sourceRelativePath = sourcePath.substr(dirPath.length + 1);
        if (prefix) {
            sourceRelativePath = this.prefixToFileName(sourceRelativePath, prefix);
        }
        return this.generatedDirPath + '/' + pathPrefix + (pathPrefix ? '/' : '') + sourceRelativePath;
    }
    getDdlPathForFile(sourcePath) {
        sourcePath = normalizePath(sourcePath);
        let indexOfSourceDirInPath = sourcePath.indexOf(this.ddlDirPath);
        if (indexOfSourceDirInPath !== 0) {
            throw new Error(`Cannot generate file from source outside of root source dir`);
        }
        return sourcePath;
    }
}

class QApplicationBuilder {
    constructor(applicationFullName, pathBuilder, configuration) {
        this.applicationFullName = applicationFullName;
        this.pathBuilder = pathBuilder;
        this.configuration = configuration;
        this.entityNames = [];
        this.ddlPathMapByEntityName = {};
        this.generatedFilePaths = [];
        this.generatedPathMapByEntityName = {};
        this.mappedSuperclassSet = {};
        this.qApplicationFilePath = pathBuilder.fullGeneratedDirPath + '/qApplication.ts';
    }
    addFileNameAndPaths(entityName, fullDdlPath, fullGenerationPath, isMappedSuperclass) {
        const ddlRelativePath = resolveRelativePath(this.qApplicationFilePath, fullDdlPath)
            .replace('.ts', '');
        this.ddlPathMapByEntityName[entityName] = ddlRelativePath;
        const generatedRelativePath = resolveRelativePath(this.qApplicationFilePath, fullGenerationPath)
            .replace('.ts', '');
        this.generatedFilePaths.push(generatedRelativePath);
        this.generatedPathMapByEntityName[entityName] = generatedRelativePath;
        this.entityNames.push(entityName);
        this.mappedSuperclassSet[entityName] = isMappedSuperclass;
    }
    build(domainName, applicationName) {
        this.entityNames.sort();
        this.generatedFilePaths.sort();
        const qApiDefinitions = this.entityNames
            .filter(entityName => !this.mappedSuperclassSet[entityName])
            .map(entityName => `${entityName}: Q${entityName};`).join('\n\t');
        // TODO: enable DVO and DAO injections into QApp, if needed
        // const dvoDefinitions = this.entityNames.map(
        // 	entityName => `${entityName}: IBase${entityName}Dvo;`
        // ).join('\n\t\t');
        // const daoDefinitions = this.entityNames.map(
        // 	entityName => `${entityName}: IBase${entityName}Dao;`
        // ).join('\n\t\t');
        const constructorDefinitions = this.entityNames.map(entityName => `${entityName}`).join(',\n\t');
        const qEntityImports = this.entityNames.map(entityName => 
        // FIXME: this is a temporary hack to get Svelte to compile, revisit later
        // `import { ${entityName} } from '${this.ddlPathMapByEntityName[entityName]}';
        `import { Q${entityName} } from '${this.generatedPathMapByEntityName[entityName]}';`).join('\n');
        // FIXME: this is a temporary hack to get Svelte to compile, revisit later
        let entityImports = '';
        if (this.entityNames.length) {
            entityImports = 'import {\n' + this.entityNames.map(entityName => `  ${entityName}`).join(',\n') + `\n} from '../ddl/ddl';`;
        }
        // const iDvoImports = this.entityNames.map(
        // 	entityName =>
        // 		`IBase${entityName}Dvo`
        // ).join(',\n\t');
        // const iDaoImports = this.entityNames.map(
        // 	entityName =>
        // 		`IBase${entityName}Dao`
        // ).join(',\n\t');
        // import {
        // 	${iDvoImports}
        // } from './baseDvos';
        //
        // import {
        // 	${iDaoImports}
        // } from './baseDaos';
        // dvo: {
        // 	${dvoDefinitions}
        // }
        //
        // dao: {
        // 	${daoDefinitions}
        // }
        return `import {
    QAppInternal
} from '@airport/air-traffic-control'
import {
    DbApplication
} from '@airport/ground-control';
${qEntityImports}
${entityImports}

export interface ${this.applicationFullName}_LocalQApp extends QAppInternal {

    db: DbApplication;

  ${qApiDefinitions}

}

const __constructors__ = {
	${constructorDefinitions}
};

export const Q_${this.applicationFullName}: ${this.applicationFullName}_LocalQApp = <any>{
	__constructors__,
  domain: '${domainName}',
  name: '${applicationName}'
};
export default Q_${this.applicationFullName}

export function ${this.applicationFullName}_diSet(
	dbEntityId: number
): boolean {
	return globalThis.airApi.dS(Q_${this.applicationFullName}.__dbApplication__, dbEntityId)
}
if (globalThis.airApi) {
  globalThis.airApi.setQApp(Q_${this.applicationFullName})
}
`;
        // export function duoDiSet(
        // 	dbEntityId: number
        // ): boolean {
        // 	return globalThis.airApi.ddS(Q.__dbApplication__, dbEntityId)
        // }
    }
}

class JsonApplicationBuilder {
    // applicationVarName = 'APPLICATION'
    constructor(config, entityMapByName, existingApplicationString) {
        this.config = config;
        this.entityMapByName = entityMapByName;
        if (existingApplicationString) {
            // const indexOfAssignment = existingApplicationString.indexOf(this.applicationVarName + ' = {')
            //
            // const errorMessage = `Could not parse existing application, make sure file starts with with:
            // 	 "export const ${this.applicationVarName} = {"
            // 	 where "{" marks the start of the application definition, and ends with:
            // 	 "};"
            // 	 where "}" marks the end of the application definition.`
            //
            // if (indexOfAssignment < 0) {
            // 	throw new Error(errorMessage)
            // }
            // if (existingApplicationString.indexOf('};') !== existingApplicationString.length - 2) {
            // 	throw new Error(errorMessage)
            // }
            //
            // existingApplicationString = existingApplicationString.substring(indexOfAssignment + 9,
            // existingApplicationString.length - 1)
            this.existingApplication = JSON.parse(existingApplicationString);
        }
    }
    build(domain, applicationMapByProjectName, entityOperationMap) {
        const sApplicationBuilder = new SApplicationBuilder(this.config, this.entityMapByName);
        const sIndexedApplication = sApplicationBuilder.build(applicationMapByProjectName);
        const jsonApplication = this.convertSIndexedApplicationToJsonApplication(domain, sIndexedApplication);
        // TODO: reset table and column and relation indexes based on existing application
        return [jsonApplication, sIndexedApplication];
    }
    addOperations(jsonApplication, entityOperationMap) {
        jsonApplication.versions[jsonApplication.versions.length - 1].entities.forEach(jsonEntity => {
            let entityOperations = entityOperationMap[jsonEntity.name];
            if (!entityOperations) {
                return;
            }
            jsonEntity.operations = entityOperations;
        });
    }
    convertSIndexedApplicationToJsonApplication(domain, sIndexedApplication) {
        const jsonEntities = sIndexedApplication.entities.map(sIndexedEntity => {
            const sEntity = sIndexedEntity.entity;
            const columns = sIndexedEntity.columns.map(sColumn => {
                const jsonColumn = {
                    allocationSize: sColumn.allocationSize,
                    // columnDefinition: sColumn.columnDefinition,
                    index: sColumn.index,
                    isGenerated: sColumn.isGenerated === undefined ? false : sColumn.isGenerated,
                    manyRelationColumnRefs: [],
                    name: sColumn.name,
                    notNull: sColumn.notNull,
                    propertyRefs: sColumn.propertyRefs.map(index => ({
                        index
                    })),
                    sinceVersion: 1,
                    type: getSqlDataType(sColumn),
                };
                if (sColumn.precision) {
                    jsonColumn.precision = sColumn.precision;
                }
                if (sColumn.scale) {
                    jsonColumn.scale = sColumn.scale;
                }
                return jsonColumn;
            });
            columns.sort((a, b) => a.index < b.index ? -1 : 1);
            const [properties, relations] = this.getPropertiesAndRelations(sIndexedApplication, sIndexedEntity, columns);
            const tableConfig = this.convertTableConfig(sEntity);
            return {
                columns,
                idColumnRefs: this.getIdColumnReferences(sIndexedEntity),
                index: sEntity.tableIndex,
                isLocal: sEntity.isLocal,
                isAirEntity: sEntity.isAirEntity,
                name: sEntity.name,
                properties: properties,
                relations: relations,
                sinceVersion: 1,
                tableConfig,
            };
        });
        // FIXME: add application versioning support
        return {
            domain,
            index: null,
            name: sIndexedApplication.application.name,
            sinceVersion: 1,
            versions: [{
                    api: currentApplicationApi,
                    entities: jsonEntities,
                    integerVersion: 1,
                    referencedApplications: sIndexedApplication.application.referencedApplications.map((sApplicationReference) => ({
                        domain: sApplicationReference.dbApplication.domain.name,
                        index: sApplicationReference.index,
                        name: sApplicationReference.dbApplication.name,
                        sinceVersion: 1,
                        versions: [{
                                entities: null,
                                integerVersion: 1,
                                referencedApplications: null,
                                versionString: '1.0.0'
                            }]
                    })),
                    versionString: '1.0.0'
                }]
        };
    }
    convertTableConfig(sEntity) {
        if (!sEntity.table) {
            return null;
        }
        if (!sEntity.table.indexes) {
            return {
                name: sEntity.table.name
            };
        }
        const rawPropertyIndexes = sEntity.table.indexes;
        if (!rawPropertyIndexes.body) {
            return {
                name: sEntity.table.name,
                columnIndexes: sEntity.table.indexes
            };
        }
        if (!rawPropertyIndexes.parameters || rawPropertyIndexes.parameters.length !== 1) {
            throw new Error(`Unexpected number of parameters in 'indexes' arrow function.${getExpectedPropertyIndexesFormatMessage()}`);
        }
        const propertyMapByName = new Map();
        for (let property of sEntity.properties) {
            propertyMapByName.set(property.name, property);
        }
        const parameter = rawPropertyIndexes.parameters[0];
        if (parameter.type !== sEntity.name) {
            throw new Error(`Unexpected type of 'indexes' arrow function parameter,
	expecting '${parameter.type}' got '${parameter.type}'.${getExpectedPropertyIndexesFormatMessage()}`);
        }
        const propertyIndexes = rawPropertyIndexes.body.map((rawPropertyIndex, index) => {
            if (!rawPropertyIndex.property) {
                throw new Error(`Propery based index #${index + 1} does not have a 'property'
	specified.${getExpectedPropertyIndexesFormatMessage()}`);
            }
            const objectPropertyFragments = rawPropertyIndex.property.split('.');
            if (objectPropertyFragments.length !== 2) {
                throw new Error(`PropertyBased index #${index + 1} does not have correct property syntax.
Expecting entityAlias.propertyName.${getExpectedPropertyIndexesFormatMessage()}`);
            }
            if (objectPropertyFragments[0] !== parameter.name) {
                throw new Error(`PropertyBased index #${index + 1} does not have correct property syntax.
Expecting entityAlias.propertyName.${getExpectedPropertyIndexesFormatMessage()}`);
            }
            let propertyName = objectPropertyFragments[1];
            let property = propertyMapByName.get(propertyName);
            if (!property) {
                throw new Error(`PropertyBased index #${index + 1} does not have a valid property name.
Expecting ${parameter.name}.propertyName.  Got ${parameter.name}.${propertyName} ${getExpectedPropertyIndexesFormatMessage()}`);
            }
            const coreConfig = {
                propertyIndex: property.index
            };
            if (rawPropertyIndex.unique === true) {
                coreConfig.unique = true;
            }
            return coreConfig;
        });
        return {
            name: sEntity.table.name,
            propertyIndexes
        };
    }
    getIdColumnReferences(sIndexedEntity) {
        return sIndexedEntity.idColumns.map(sColumn => ({
            index: sColumn.index
        }));
    }
    getPropertiesAndRelations(sIndexedApplication, sIndexedEntity, columns) {
        const relations = [];
        const properties = sIndexedEntity.entity.properties.map((sProperty, index) => {
            let columnRef;
            let relationRef;
            const sRelation = sProperty.relation;
            if (!sRelation) {
                const sColumn = sProperty.columns[0];
                columnRef = {
                    index: sColumn.index
                };
            }
            else {
                let relationTableApplication_Index;
                let relationApplication_Index;
                let relationTableIndex;
                let relatedIndexedEntity;
                if (sRelation.referencedApplication_Index || sRelation.referencedApplication_Index === 0) {
                    relationTableApplication_Index = sRelation.referencedApplication_Index;
                    const relatedDbApplication = sIndexedApplication.application.referencedApplications[sRelation.referencedApplication_Index];
                    relationApplication_Index = relatedDbApplication.index;
                    relatedIndexedEntity = relatedDbApplication.dbApplication
                        .currentVersion[0].applicationVersion.entityMapByName[sRelation.entityName];
                    relationTableIndex = relatedIndexedEntity.index;
                }
                else {
                    relatedIndexedEntity = sIndexedApplication.entityMapByName[sRelation.entityName];
                    relationApplication_Index = null;
                    relationTableIndex = relatedIndexedEntity.entity.tableIndex;
                }
                this.buildColumnRelations(sIndexedEntity, sRelation, relatedIndexedEntity, relationApplication_Index, relationTableIndex, columns);
                const relation = {
                    // addToJoinFunction: sRelation.addToJoinFunction,
                    foreignKey: sRelation.foreignKey,
                    index: sRelation.index,
                    isId: sProperty.isId,
                    // isRepositoryJoin: sRelation.repositoryJoin,
                    // joinFunctionWithOperator: sRelation.joinFunctionWithOperator,
                    manyToOneElems: sRelation.manyToOne,
                    oneToManyElems: this.prepOneToManyElems(sRelation.oneToMany),
                    relationType: sRelation.relationType,
                    propertyRef: {
                        index: index
                    },
                    relationTableIndex,
                    relationTableApplication_Index,
                    sinceVersion: 1
                };
                relations[sRelation.index] = relation;
                relationRef = {
                    index: sRelation.index
                };
            }
            return {
                columnRef,
                index,
                isId: sProperty.isId,
                name: sProperty.name,
                relationRef,
                sinceVersion: 1
            };
        });
        return [properties, relations];
    }
    buildColumnRelations(sIndexedEntity, sRelation, relatedIndexedEntity, relationApplication_Index, relationTableIndex, columns) {
        switch (sRelation.relationType) {
            case EntityRelationType.MANY_TO_ONE:
                break;
            case EntityRelationType.ONE_TO_MANY:
                // Currently only need to build manyRelationColumnRefs for ManyToOne relations.
                return;
            default:
                throw new Error(`Unknown relation type: ${sRelation.relationType}.`);
        }
        sRelation.sRelationColumns.map(sRelationColumn => {
            if (!sRelationColumn.manyToOne) {
                return;
            }
            let ownColumnIndex;
            // if (sRelationColumn.ownColumnIdIndex) {
            // 	ownColumnIndex = sIndexedEntity.idColumns[sRelationColumn.ownColumnIdIndex].index
            // } else {
            ownColumnIndex = sIndexedEntity.columnMap[sRelationColumn.ownColumnReference].index;
            // }
            let relationColumnIndex;
            // if (sRelationColumn.relationColumnIdIndex
            // 	|| sRelationColumn.relationColumnIdIndex == 0) {
            // 	relationColumnIndex =
            // relatedIndexedEntity.idColumns[sRelationColumn.relationColumnIdIndex].index } else {
            relationColumnIndex = relatedIndexedEntity.columnMap[sRelationColumn.relationColumnReference].index;
            // }
            const column = columns[ownColumnIndex];
            column.manyRelationColumnRefs.push({
                manyRelationIndex: sRelation.index,
                oneApplication_Index: relationApplication_Index,
                oneTableIndex: relationTableIndex,
                oneRelationIndex: sRelationColumn.oneSideRelationIndex,
                oneColumnIndex: relationColumnIndex,
                sinceVersion: 1
            });
        });
    }
    prepOneToManyElems(elems) {
        if (!elems) {
            return elems;
        }
        return {
            mappedBy: elems.mappedBy
        };
    }
}

class MappedSuperclassBuilder {
    constructor(config, entityMapByName) {
        this.config = config;
        this.entityMapByName = entityMapByName;
        this.mappedSuperclassVarName = 'MAPPED_SUPERCLASS';
    }
    build() {
        const mappedSuperclasses = [];
        for (const entityName in this.entityMapByName) {
            const entityCandidate = this.entityMapByName[entityName];
            const entity = this.buildEntity(entityCandidate);
            if (entity) {
                mappedSuperclasses.push(entity);
            }
        }
        return `/* eslint-disable */
export const ${this.mappedSuperclassVarName} = `
            + JSON.stringify(mappedSuperclasses, null, '\t') + ';';
    }
    buildEntity(entityCandidate) {
        if (!entityCandidate.docEntry.isMappedSuperclass) {
            return null;
        }
        const objectSet = new Set();
        objectSet.add(entityCandidate);
        this.dropCircularDependencies(entityCandidate, new Set(), entityCandidate);
        entityCandidate.project = this.config.name;
        return entityCandidate;
    }
    dropCircularDependencies(rootObject, objectSet, currentObject) {
        if (currentObject instanceof Array) {
            currentObject.forEach(childObject => {
                this.dropCircularDependencies(rootObject, objectSet, childObject);
            });
        }
        else if (currentObject instanceof Object) {
            objectSet.add(currentObject);
            for (const key in currentObject) {
                let childObject = currentObject[key];
                if (
                // rootObject === childObject
                // ||
                objectSet.has(childObject)) {
                    currentObject[key] = null;
                }
                else {
                    this.dropCircularDependencies(rootObject, objectSet, childObject);
                }
            }
        }
    }
}

class ApiBuilder extends FileBuilder {
    constructor(pathBuilder, apiFile, apiFilePath) {
        super(null, null, pathBuilder, null);
        this.apiFile = apiFile;
        const relativePathToApiFile = resolveRelativePath(pathBuilder.apiDirPath, apiFilePath);
        this.fullGenerationPath = pathBuilder.fullGeneratedDirPath
            + `/api/${relativePathToApiFile}`;
    }
    addImports() {
        for (const objectAsName in this.apiFile.imports.importMapByObjectAsName) {
            const moduleImport = this.apiFile.imports
                .importMapByObjectAsName[objectAsName];
            let relativePathToImport = moduleImport.path;
            if (moduleImport.path.indexOf('.') === 0
                && !moduleImport.path.startsWith('./')) {
                const fullPathToImport = getFullPathFromRelativePath(moduleImport.path, this.fullGenerationPath);
                relativePathToImport = '../' + resolveRelativePath(this.fullGenerationPath, fullPathToImport);
            }
            this.addImport([moduleImport.objectMapByAsName[objectAsName]], relativePathToImport);
        }
        this.addImport(['ApiProxy'], '@airport/airgate');
        const appDeclarationFilePath = this.pathBuilder.workingDirPath
            + '/src/to_be_generated/app-declaration';
        const appDeclarationFileRelativePath = resolveRelativePath(this.fullGenerationPath, appDeclarationFilePath);
        this.addImport(['application'], appDeclarationFileRelativePath);
    }
    build() {
        let enumAndInterfaceDefinitionCode = '';
        for (let enumOrInterfaceCode of this.apiFile.otherMemberDefinitions) {
            enumAndInterfaceDefinitionCode += `
${enumOrInterfaceCode}`;
        }
        let apiClassDefinitionCode = '';
        for (let apiClass of this.apiFile.apiClasses) {
            apiClassDefinitionCode += this.buildClassDefinition(apiClass);
        }
        const imports = this.buildImports();
        return `${imports}
${enumAndInterfaceDefinitionCode}
${apiClassDefinitionCode}`;
    }
    buildClassDefinition(apiClass) {
        return `
// An API stub for other Applications and UIs to use
// @Injected() is implied but not specified to avoid @airport/direction-indicator
// dependency in UI API stub (eventually, once it's @airport/autopilot is cleaned
// up)
// @Injected()
export class ${apiClass.className} extends ApiProxy<${apiClass.className}> {

    constructor() {
        super(application)
    }
        
            ${this.buildApiMethodStubFragment(apiClass)}
}
`;
    }
    buildApiMethodStubFragment(apiClass) {
        let methodStubFragment = '';
        for (const apiSignature of apiClass.apiSignatures) {
            methodStubFragment += `
    ${this.buildApiMethodStub(apiSignature)}
`;
        }
        return methodStubFragment;
    }
    buildApiMethodStub(apiSignature) {
        const asyncPrefix = apiSignature.isAsync ? 'async ' : '';
        let methodParameters = '';
        let apiCallParameters = '';
        if (apiSignature.parameters.length) {
            methodParameters = `
`;
            for (let i = 0; i < apiSignature.parameters.length; i++) {
                const parameter = apiSignature.parameters[i];
                if (i === 0) {
                    methodParameters += '        ';
                }
                methodParameters += parameter;
                let parameterName = parameter.split(':')[0].trim();
                if (parameterName.endsWith('?')) {
                    parameterName = parameterName.substring(0, parameterName.length - 1);
                }
                apiCallParameters += parameterName;
                if (i < apiSignature.parameters.length - 1) {
                    if (apiSignature.parameters.length > 1) {
                        apiCallParameters += ',\n            ';
                    }
                    methodParameters += ',\n        ';
                }
            }
            if (apiSignature.parameters.length
                && apiSignature.parameters.length > 1) {
                apiCallParameters = `
            ${apiCallParameters}
        `;
            }
            methodParameters += `
    `;
        }
        let returnPrefix = '';
        if (apiSignature.returnType !== 'Promise<void>'
            && apiSignature.returnType !== 'void'
            && apiSignature.returnType) {
            returnPrefix = 'return ';
        }
        return `${asyncPrefix} ${apiSignature.name}(${methodParameters}): ${apiSignature.returnType} {
        ${returnPrefix}await this.proxy.${apiSignature.name}(${apiCallParameters})
    }`;
    }
}

class ApiIndexBuilder extends FileBuilder {
    constructor(pathBuilder) {
        super(null, null, pathBuilder, null);
        this.apiFilePaths = [];
        this.fullGenerationPath = pathBuilder.fullGeneratedDirPath
            + `/api/api.ts`;
    }
    addApiFilePath(filePath) {
        const filePathFragments = filePath.split('.');
        filePathFragments.pop();
        this.apiFilePaths.push(filePathFragments.join('.'));
    }
    addImports() {
    }
    build() {
        let exports = '';
        for (const apiFilePath of this.apiFilePaths) {
            let relativePathToImport = resolveRelativePath(this.fullGenerationPath, apiFilePath);
            exports += `export * from '${relativePathToImport}'
`;
        }
        return `${exports}
// import { loadAutopilot } from '@airport/autopilot'
       
// loadAutopilot()
`;
    }
}

/**
 * Created by Papa on 5/20/2016.
 */
class IVEntityInterfaceBuilder {
    constructor(entity, vEntityBuilder) {
        this.entity = entity;
        this.idPropertyBuilders = vEntityBuilder.idPropertyBuilders;
        this.idRelationBuilders = vEntityBuilder.idRelationBuilders;
        this.nonIdPropertyBuilders = vEntityBuilder.nonIdPropertyBuilders;
        this.nonIdRelationBuilders = vEntityBuilder.nonIdRelationBuilders;
        this.transientPropertyBuilders = vEntityBuilder.transientPropertyBuilders;
    }
    build() {
        let entityName = `${this.entity.docEntry.name}`;
        let idEProperties = ``;
        this.idPropertyBuilders.forEach((builder) => {
            idEProperties += `\t${builder.buildInterfaceDefinition()}\n`;
        });
        let idRelationsForEntityEProperties = ``;
        this.idRelationBuilders.forEach((builder) => {
            idRelationsForEntityEProperties += `\t${builder.buildInterfaceDefinition()}\n`;
        });
        let nonIdEProperties = ``;
        this.nonIdPropertyBuilders.forEach((builder) => {
            nonIdEProperties += `\t${builder.buildInterfaceDefinition()}\n`;
        });
        let nonIdRelationsForEntityEProperties = ``;
        this.nonIdRelationBuilders.forEach((builder) => {
            nonIdRelationsForEntityEProperties += `\t${builder.buildInterfaceDefinition()}\n`;
        });
        // let transientProperties = ``
        // this.transientPropertyBuilders.forEach((
        // 	builder: VTransientBuilder
        // ) => {
        // 	transientProperties += `\t${builder.buildInterfaceDefinition()}\n`
        // })
        let extendedVInterface = `IEntityVDescriptor`;
        if (this.entity.parentEntity) {
            const parentType = this.entity.parentEntity.type;
            extendedVInterface = `${parentType}VDescriptor`;
        }
        let interfaceSource = `
////////////////////
//  API INTERFACE //
////////////////////

export interface ${entityName}VDescriptor<T>
    extends ${extendedVInterface}<T> {
	// Id Properties
${idEProperties}	
	// Non-Id Properties
${nonIdEProperties}
	// Id Relations - full property interfaces
${idRelationsForEntityEProperties}
  // Non-Id relations (including OneToMany's)
${nonIdRelationsForEntityEProperties}
}

`;
        return interfaceSource;
    }
}

/**
 * Created by Papa on 4/25/2016.
 */
class VPropertyBuilder {
    constructor(parentBuilder, propertyDocEntry) {
        this.parentBuilder = parentBuilder;
        this.propertyDocEntry = propertyDocEntry;
    }
    build() {
        throw new Error(`Not Implemented.`);
    }
    buildInterfaceDefinition() {
        let prop = this.propertyDocEntry;
        let name = prop.name;
        let propertyType = prop.primitive;
        if (propertyType === 'Json') {
            propertyType = prop.type;
            let trimmedPropertyType = propertyType.trim();
            if (trimmedPropertyType.startsWith('{') || trimmedPropertyType.startsWith('[')
                || trimmedPropertyType.endsWith('}') || trimmedPropertyType.endsWith(']')) {
                throw new Error(`@Json() type must be an imported interface.  It cannot be an inplace type definition`);
            }
            const moduleImport = this.propertyDocEntry.ownerEntity.docEntry.fileImports.importMapByObjectAsName[propertyType];
            let relativePathToImport = moduleImport.path;
            if (moduleImport.path.indexOf('.') === 0) {
                const fullPathToImport = getFullPathFromRelativePath(moduleImport.path, this.propertyDocEntry.ownerEntity.path);
                relativePathToImport = resolveRelativePath(this.parentBuilder.fileBuilder.fullGenerationPath, fullPathToImport);
            }
            this.parentBuilder.addImport([moduleImport.objectMapByAsName[propertyType]], relativePathToImport);
        }
        let operableFieldSuffix = ' | ' + getVPropertyFieldInterface(prop);
        return `${name}?: ${propertyType}${operableFieldSuffix};`;
    }
}

/**
 * Created by Papa on 4/25/2016.
 */
class VRelationBuilder {
    constructor(parentBuilder, entityProperty) {
        this.parentBuilder = parentBuilder;
        this.entityProperty = entityProperty;
    }
    build() {
        throw new Error(`Not Used`);
    }
    buildInterfaceDefinition() {
        let typeSuffix = 'VDescriptor';
        let type = this.entityProperty.type;
        if (this.entityProperty.entity) {
            type = this.entityProperty.entity.type;
        }
        else {
            type = this.entityProperty.otherApplicationDbEntity.name;
        }
        type = type.replace('[]', '');
        const descriptorType = type + typeSuffix;
        const definition = `${this.entityProperty.name}?: ${descriptorType}<${type}>`;
        return definition;
    }
}

class VTransientBuilder {
    constructor(parentBuilder, propertyDocEntry) {
        this.parentBuilder = parentBuilder;
        this.propertyDocEntry = propertyDocEntry;
    }
    buildInterfaceDefinition() {
        let prop = this.propertyDocEntry;
        if (!prop.primitive && prop.type !== 'Date') {
            let type = prop.type;
            if (prop.isMap) {
                type = prop.mapValueType;
            }
            type = type.replace('[]', '');
            if (!prop.mapValueIsPrimitive) {
                addImportForType(prop.ownerEntity, type, this.parentBuilder.fileBuilder);
            }
        }
        let builder;
        if (prop.entity || prop.fromProject) {
            builder = new VRelationBuilder(this.parentBuilder, prop);
        }
        else {
            builder = new VPropertyBuilder(this.parentBuilder, prop);
        }
        // let type = prop.type;
        // if(prop.isMap && type.indexOf(']: ') > -1) {
        // 		type = type.replace(/\]\: (?!.*\]\: )/, "]: I");
        // } else {
        // 	type = prop.primitive ? `${type}` : `I${type}`
        // }
        //
        // return `${prop.name}?: ${type};`;
        return builder.buildInterfaceDefinition();
    }
}

class VCoreEntityBuilder {
    constructor(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName) {
        this.entity = entity;
        this.fullGenerationPath = fullGenerationPath;
        this.workingDirPath = workingDirPath;
        this.fileBuilder = fileBuilder;
        this.entityMapByName = entityMapByName;
        this.constructorFields = {};
    }
    addImport(classNames, filePath) {
        this.fileBuilder.addImport(classNames, filePath);
    }
    getVPropertyBuilders(properties) {
        return properties.map(property => this.addVPropertyBuilder(property)).filter(builder => builder != null);
    }
    getVTransientPropertyBuilders(properties) {
        return properties.map(property => new VTransientBuilder(this, property));
    }
    getVRelationBuilders(properties) {
        return properties.map(property => this.addVRelationBuilder(property)).filter(builder => builder != null);
    }
    addVPropertyBuilder(property) {
        let propertyBuilder = null;
        if (property.primitive) {
            propertyBuilder = new VPropertyBuilder(this, property);
        }
        return propertyBuilder;
    }
    addVRelationBuilder(property) {
        let relationBuilder = null;
        if (property.entity || property.fromProject) {
            relationBuilder = new VRelationBuilder(this, property);
        }
        return relationBuilder;
    }
}
function getVPropertyFieldInterface(//
propertyDocEntry //
) {
    return getVPrimitiveFieldInterface(propertyDocEntry.primitive);
}
function getVColumnFieldInterface(//
sColumn //
) {
    return getVPrimitiveFieldInterface(sColumn.type);
}
function getVPrimitiveFieldInterface(//
primitive //
) {
    switch (primitive) {
        case 'boolean':
            return 'IVBooleanField';
        case 'Date':
            return 'IVDateField';
        case 'number':
            return 'IVNumberField';
        case 'string':
        case 'Json':
            return 'IVStringField';
        case 'any':
            return 'IVUntypedField';
        default:
            throw new Error(`Unexpected primitive ${primitive}`);
    }
}
function getVPropertyFieldClass(//
propertyDocEntry //
) {
    switch (propertyDocEntry.primitive) {
        case 'boolean':
            return 'VBooleanField';
        case 'Date':
            return 'VDateField';
        case 'number':
            return 'VNumberField';
        case 'string':
        case 'Json':
            return 'VStringField';
        case 'any':
            return 'VUntypedField';
        default:
            throw new Error(`Unexpected primitive ${propertyDocEntry.primitive}`);
    }
}

/**
 * Created by Papa on 4/25/2016.
 */
class VEntityBuilder extends VCoreEntityBuilder {
    constructor(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName, sIndexedEntity) {
        super(entity, fullGenerationPath, workingDirPath, fileBuilder, entityMapByName);
        this.sIndexedEntity = sIndexedEntity;
        const idProperties = entity.getIdProperties();
        this.idPropertyBuilders = this.getVPropertyBuilders(idProperties);
        this.idRelationBuilders = this.getVRelationBuilders(idProperties);
        const nonIdProperties = entity.getNonIdProperties();
        this.nonIdPropertyBuilders = this.getVPropertyBuilders(nonIdProperties);
        this.nonIdRelationBuilders = this.getVRelationBuilders(nonIdProperties);
        this.transientPropertyBuilders = this.getVTransientPropertyBuilders(entity.getTransientProperties());
    }
    build() {
        throw new Error(`Not Used`);
    }
}

/**
 * Created by Papa on 4/26/2016.
 */
class VEntityFileBuilder extends FileBuilder {
    constructor(entity, fullGenerationPath, pathBuilder, entityMapByName, configuration, sIndexedEntity, entityPath) {
        super(entity, fullGenerationPath, pathBuilder, configuration);
        this.entityMapByName = entityMapByName;
        this.entityPath = entityPath;
        this.importMap = {};
        this.vEntityBuilder = new VEntityBuilder(entity, fullGenerationPath, pathBuilder.workingDirPath, this, entityMapByName, sIndexedEntity);
        this.vEntityInterfaceBuilder = new IVEntityInterfaceBuilder(entity, this.vEntityBuilder);
        this.addImport([
            'IEntityVDescriptor',
            'IVBooleanField',
            'IVDateField',
            'IVNumberField',
            'IVStringField',
            'IVUntypedField'
        ], '@airbridge/validate');
        // let entityRelativePath = resolveRelativePath(fullGenerationPath, entity.path);
        // console.log('Entity: ' + entity.path)
        if (entity.parentEntity) {
            let parentVEntityRelativePath;
            if (entity.parentEntity.project) {
                parentVEntityRelativePath = entity.parentEntity.project;
            }
            else {
                let parentFullGenerationPath = pathBuilder.getFullPathToGeneratedSource(entity.parentEntity.path, 'V', 'validation');
                parentVEntityRelativePath = resolveRelativePath(fullGenerationPath, parentFullGenerationPath);
            }
            let parentEntityType = entity.parentEntity.type;
            this.addImport([
                `${parentEntityType}VDescriptor`
            ], parentVEntityRelativePath);
        }
    }
    build() {
        let interfaceSource = this.vEntityInterfaceBuilder.build();
        let imports = this.buildImports();
        let fileSource = `${imports}

${interfaceSource}
`;
        return fileSource;
    }
    addRelationImports(relationBuilders) {
        relationBuilders.forEach((builder) => {
            let property = builder.entityProperty;
            let type = property.type;
            let vEntityRelativePath = property.fromProject;
            if (property.fromProject) {
                type = property.otherApplicationDbEntity.name;
            }
            else {
                type = property.entity.type;
                if (this.entity !== property.entity) {
                    vEntityRelativePath = resolveRelativeEntityPath(this.entity, property.entity);
                    vEntityRelativePath = vEntityRelativePath.replace('.ts', '');
                    vEntityRelativePath = this.pathBuilder.prefixToFileName(vEntityRelativePath, 'V');
                }
            }
            type = type.replace('[]', '');
            if (this.entity !== property.entity) {
                // console.log(vEntityRelativePath)
                this.addImport([type + 'VDescriptor'], vEntityRelativePath);
            }
            if (property.fromProject) {
                let relationEntityPath = property.fromProject;
                this.addImport([type], relationEntityPath);
            }
            else {
                const entityFilePath = this.pathBuilder.getFullPathToDdlSource(this.entityMapByName[type].path);
                let entityInterfaceRelativePath = resolveRelativePath(this.fullGenerationPath, entityFilePath);
                entityInterfaceRelativePath = entityInterfaceRelativePath.replace('.ts', '');
                this.addImport([type], entityInterfaceRelativePath);
            }
        });
    }
    addImports() {
        this.addRelationImports(this.vEntityBuilder.idRelationBuilders);
        this.addRelationImports(this.vEntityBuilder.nonIdRelationBuilders);
        // const entityImportRelativePath = resolveRelativePath(this.fullGenerationPath,
        //   this.entityPath).replace('.ts', '');
        // this.addImport([this.entity.docEntry.name], entityImportRelativePath, false); 
    }
}

class JsonApplicationChecker {
    constructor() {
        this.applicationReferenceChecker = new ApplicationReferenceUtils();
        this.applicationReferenceChecker.appTrackerUtils = new AppTrackerUtils();
        this.applicationReferenceChecker.appTrackerUtils.dictionary = new Dictionary();
    }
    checkFrameworkReferences(jsonApplication, indexedApplication) {
        this.applicationReferenceChecker.checkFrameworkReferences(jsonApplication, (jsonApplication, jsonApplicationVersion, jsonRelation) => {
            let relatedJsonApplication;
            let relatedJsonEntity;
            if (jsonRelation.relationTableApplication_Index
                || jsonRelation.relationTableApplication_Index === 0) {
                const referencedApplication = jsonApplicationVersion
                    .referencedApplications[jsonRelation.relationTableApplication_Index];
                // References are by name only since they are loaded from source by name
                // thus a given Applicaiton shouldn't be referencing two other applications
                // with the same names
                relatedJsonApplication = indexedApplication.referencedApplicationsByName[referencedApplication.name].dbApplication;
                const relatedApplicationVersion = relatedJsonApplication
                    .versions[relatedJsonApplication.versions.length - 1];
                relatedJsonEntity = relatedApplicationVersion.entities[jsonRelation.relationTableIndex];
            }
            else {
                relatedJsonApplication = jsonApplication;
                relatedJsonEntity = jsonApplicationVersion.entities[jsonRelation.relationTableIndex];
            }
            return {
                relatedJsonApplication,
                relatedJsonEntity
            };
        });
    }
}

/**
 * Created by Papa on 3/30/2016.
 */
const applicationQueryGenerator = new ApplicationQueryGenerator();
async function watchFiles(configuration, options, rootFileNames) {
    const files = {};
    // initialize the list of files
    rootFileNames.forEach(fileName => {
        files[fileName] = { version: 0 };
    });
    // Create the language service host to allow the LS to communicate with the host
    const servicesHost = {
        readFile: (filename, encoding) => {
            try {
                const content = fs.readFileSync(filename, encoding || 'utf8');
                return content;
            }
            catch (e) {
                return '';
            }
        },
        fileExists: (filename) => {
            return servicesHost.readFile(filename) !== '';
        },
        getCompilationSettings: () => options,
        getScriptFileNames: () => rootFileNames,
        getScriptVersion: (fileName) => files[fileName] && files[fileName].version.toString(),
        getScriptSnapshot: (fileName) => {
            if (!fs.existsSync(fileName)) {
                return undefined;
            }
            return tsc__default.ScriptSnapshot.fromString(fs.readFileSync(fileName).toString());
        },
        getCurrentDirectory: () => process.cwd(),
        getDefaultLibFileName: (options) => tsc__default.getDefaultLibFilePath(options)
    };
    // Create the language service files
    tsc__default.createLanguageService(servicesHost, tsc__default.createDocumentRegistry());
    // First time around, process all files
    await processFiles(rootFileNames, options, configuration);
    // Now let's watch the files
    // rootFileNames.forEach(
    // 	fileName => {
    // 		// Add a watch on the file to handle next change
    // 		fs.watchFile(fileName,
    // 			{ persistent: true, interval: 250 },
    // 			(
    // 				curr,
    // 				prev,
    // 			) => {
    // 				// Check timestamp
    // 				if (+curr.mtime <= +prev.mtime) {
    // 					return;
    // 				}
    // 				// Update the version to signal a change in the file
    // 				files[fileName].version++;
    // 				// process file
    // 				processFiles(
    // 					[fileName], options, configuration).then();
    // 			});
    // 	});
}
async function processFiles(rootFileNames, options, configuration) {
    currentApplicationApi.apiObjectMap = {};
    options.target = tsc__default.ScriptTarget.ES5;
    const applicationMapByProjectName = {};
    let entityMapByName = await generateDefinitions(rootFileNames, options, configuration, applicationMapByProjectName);
    emitFiles(entityMapByName, configuration, applicationMapByProjectName);
}
function emitFiles(entityMapByName, configuration, applicationMapByProjectName) {
    const pathBuilder = new PathBuilder(configuration);
    const generatedDirPath = pathBuilder.workingDirPath + '/' + pathBuilder.generatedDirPath;
    const applicationPath = generatedDirPath + '/application-spec.json';
    const applicationSourcePath = generatedDirPath + '/application.ts';
    const entityMappingsPath = generatedDirPath + '/entityMappings.ts';
    if (!fs.existsSync(generatedDirPath)) {
        fs.mkdirSync(generatedDirPath);
    }
    const generatedApiDirPath = generatedDirPath + '/api';
    if (!fs.existsSync(generatedApiDirPath)) {
        fs.mkdirSync(generatedApiDirPath);
    }
    let applicationString;
    if (fs.existsSync(applicationPath)) {
        applicationString = fs.readFileSync(applicationPath, 'utf8');
    }
    const applicationBuilder = new JsonApplicationBuilder(configuration, entityMapByName, applicationString);
    const [jsonApplication, indexedApplication] = applicationBuilder.build(configuration.airport.domain, applicationMapByProjectName, entityOperationMap);
    const applicationChecker = new JsonApplicationChecker();
    applicationChecker.checkFrameworkReferences(jsonApplication, indexedApplication);
    const applicationFullName = IOC.getSync(DbApplicationUtils).
        getApplication_FullNameFromDomainAndName(jsonApplication.domain, jsonApplication.name);
    const entityQInterfaceListingBuilder = new GeneratedFileListingBuilder(pathBuilder, 'qInterfaces.ts');
    const entityVInterfaceListingBuilder = new GeneratedFileListingBuilder(pathBuilder, 'vInterfaces.ts');
    const generatedSummaryBuilder = new GeneratedSummaryBuilder(pathBuilder, entityQInterfaceListingBuilder, entityVInterfaceListingBuilder);
    const qApplicationBuilder = new QApplicationBuilder(applicationFullName, pathBuilder, configuration);
    const daoBuilder = new DaoBuilder(applicationFullName, pathBuilder);
    const dvoBuilder = new DvoBuilder(applicationFullName, pathBuilder);
    const entityMappingBuilder = new EntityMappingBuilder(entityMappingsPath, pathBuilder);
    const apiIndexBuilder = new ApiIndexBuilder(pathBuilder);
    let numApiFiles = 0;
    for (const apiFilePath in currentApiFileSignatureMap) {
        let apiFileSignature = currentApiFileSignatureMap[apiFilePath];
        if (!apiFileSignature.apiClasses.length) {
            continue;
        }
        numApiFiles++;
        const apiBuilder = new ApiBuilder(pathBuilder, apiFileSignature, apiFilePath);
        pathBuilder.setupFileForGeneration(apiFilePath, '', 'api/', pathBuilder.apiDirPath);
        fs.writeFileSync(apiBuilder.fullGenerationPath, apiBuilder.build());
        apiIndexBuilder.addApiFilePath(apiBuilder.fullGenerationPath);
    }
    if (numApiFiles) {
        fs.writeFileSync(apiIndexBuilder.fullGenerationPath, apiIndexBuilder.build());
    }
    for (const entityName in entityMapByName) {
        const entity = entityMapByName[entityName];
        const fullQGenerationPath = pathBuilder.getFullPathToGeneratedSource(entity.path, 'Q', 'query');
        const fullVGenerationPath = pathBuilder.getFullPathToGeneratedSource(entity.path, 'V', 'validation');
        const qEntityFileBuilder = new QEntityFileBuilder(entity, fullQGenerationPath, pathBuilder, entityMapByName, configuration, indexedApplication.entityMapByName[entityName], entity.path);
        const vEntityFileBuilder = new VEntityFileBuilder(entity, fullVGenerationPath, pathBuilder, entityMapByName, configuration, indexedApplication.entityMapByName[entityName], entity.path);
        entityQInterfaceListingBuilder.addFileNameAndPaths(fullQGenerationPath);
        entityVInterfaceListingBuilder.addFileNameAndPaths(fullVGenerationPath);
        qApplicationBuilder.addFileNameAndPaths(entityName, entity.path, fullQGenerationPath, entity.docEntry.isMappedSuperclass);
        const sIndexedEntity = indexedApplication.entityMapByName[entityName];
        let tableIndex;
        if (sIndexedEntity) {
            tableIndex = sIndexedEntity.entity.tableIndex;
        }
        daoBuilder.addFileNameAndPaths(tableIndex, entityName, entity.path, fullQGenerationPath);
        dvoBuilder.addFileNameAndPaths(tableIndex, entityName, entity.path, fullVGenerationPath);
        entityMappingBuilder.addEntity(tableIndex, entityName, entity.path);
        const qGenerationPath = pathBuilder.setupFileForGeneration(entity.path, 'Q', 'query');
        const vGenerationPath = pathBuilder.setupFileForGeneration(entity.path, 'V', 'validation');
        const qEntitySourceString = qEntityFileBuilder.build();
        const vEntitySourceString = vEntityFileBuilder.build();
        fs.writeFileSync(qGenerationPath, qEntitySourceString);
        fs.writeFileSync(vGenerationPath, vEntitySourceString);
    }
    fs.writeFileSync(daoBuilder.listingFilePath, daoBuilder.build());
    fs.writeFileSync(entityMappingBuilder.entityMappingsPath, entityMappingBuilder.build(configuration.airport.domain, configuration.airport.application));
    fs.writeFileSync(dvoBuilder.listingFilePath, dvoBuilder.build());
    fs.writeFileSync(qApplicationBuilder.qApplicationFilePath, qApplicationBuilder.build(configuration.airport.domain, indexedApplication.application.name));
    fs.writeFileSync(entityQInterfaceListingBuilder.generatedListingFilePath, entityQInterfaceListingBuilder.build());
    fs.writeFileSync(entityVInterfaceListingBuilder.generatedListingFilePath, entityVInterfaceListingBuilder.build());
    fs.writeFileSync(generatedSummaryBuilder.generatedListingFilePath, generatedSummaryBuilder.build());
    const mappedSuperclassBuilder = new MappedSuperclassBuilder(configuration, entityMapByName);
    const mappedSuperclassPath = generatedDirPath + '/mappedSuperclass.ts';
    fs.writeFileSync(mappedSuperclassPath, mappedSuperclassBuilder.build());
    for (const fileProcessor of additionalFileProcessors) {
        fileProcessor.build(pathBuilder, jsonApplication);
    }
    addOperations(jsonApplication, applicationPath, applicationSourcePath, applicationBuilder).then();
}
async function addOperations(jsonApplication, applicationPath, applicationSourcePath, applicationBuilder) {
    await applicationQueryGenerator.processQueries(entityOperationMap, jsonApplication);
    applicationBuilder.addOperations(jsonApplication, entityOperationMap);
    const applicationJsonString = JSON.stringify(jsonApplication, null, '\t');
    const applicationSourceString = `export const APPLICATION = `
        + applicationJsonString + ';';
    fs.writeFileSync(applicationPath, applicationJsonString);
    fs.writeFileSync(applicationSourcePath, '/* eslint-disable */\n' + applicationSourceString);
}

function getPropertyFieldType(//
propertyDocEntry //
) {
    switch (propertyDocEntry.primitive) {
        case 'boolean':
            return 'BOOLEAN';
        case 'Date':
            return 'DATE';
        case 'number':
            return 'NUMBER';
        case 'string':
        case 'Json':
            return 'STRING';
        case 'any':
            return 'ANY';
        default:
            throw new Error(`Unexpected primitive ${propertyDocEntry.primitive}`);
    }
}
function getPropertyJSONOperationInterface(//
propertyDocEntry //
) {
    switch (propertyDocEntry.primitive) {
        case 'boolean':
            return 'JSONRawBooleanOperation';
        case 'Date':
            return 'JSONRawDateOperation';
        case 'number':
            return 'JSONRawNumberOperation';
        case 'string':
        case 'Json':
            return 'JSONRawStringOperation';
        case 'any':
            return 'JSONRawUntypedOperation';
        default:
            throw new Error(`Unexpected primitive ${propertyDocEntry.primitive}`);
    }
}
function getPropertyTypedOperationInterface(//
propertyDocEntry //
) {
    switch (propertyDocEntry.primitive) {
        case 'boolean':
            return 'IBooleanOperation';
        case 'Date':
            return 'IDateOperation';
        case 'number':
            return 'INumberOperation';
        case 'string':
        case 'Json':
            return 'IStringOperation';
        case 'any':
            return 'IUntypedOperation';
        default:
            throw new Error(`Unexpected primitive ${propertyDocEntry.primitive}`);
    }
}
function getRelationFieldType(//
entityProperty //
) {
    if (entityProperty.isArray) {
        return 'ONE_TO_MANY';
    }
    else {
        return 'MANY_TO_ONE';
    }
}

/**
 * A builder for generating injection.ts
 *
 */
class InjectionFileBuilder extends FileBuilder {
    static getTokenNameFromClassName(className) {
        let tokenName = '';
        for (let i = 0; i < className.length; i++) {
            let character = className[i];
            let upperCaseCharacter = character.toUpperCase();
            if (character === upperCaseCharacter
                && i > 0) {
                tokenName += '_';
            }
            tokenName += upperCaseCharacter;
        }
        return tokenName;
    }
    constructor(fileName, pathBuilder) {
        super(null, null, pathBuilder, null);
        // this.daoListingFilePath = pathBuilder.fullGeneratedDirPath + `/${fileName}.ts`;
    }
    addImports() {
        // this.addImport([
        //     'IQEntity'
        // ], '@airport/air-traffic-control');
    }
    build() {
        this.buildImports();
        throw new Error(`Not Implemented, yet.`);
    }
}

/**
 * Created by papa on 1/5/21.
 */
class QQueryPreparationField {
    constructor() {
        return new Proxy(this, {
            apply: function (target, thisArg, argumentsList) {
                return new QQueryPreparationField();
            },
            get: function (target, prop, receiver) {
                return new QQueryPreparationField();
            },
            set: function (obj, prop, value) {
                // Nothing to do
                return true;
            }
        });
    }
}

const projectInterfaces = new Map();

/**
 * Detecting interfaces is not really needed as long as interfaces
 * are generated for the API classes.  The interfaces themselves
 * may have class references but those should not make it into the
 * bundle.  The only executable code in the bundle should be
 * the "lib('nameOfLibrary')" and its token definitions.
 *
 * @param node
 * @param path
 * @returns
 */
function visitInterfaceCandidateFile(node, path) {
    if (node.kind !== tsc__default.SyntaxKind.InterfaceDeclaration) {
        return;
    }
    const interfaceNode = node;
    // This is a top level class, get its symbol
    globalThis.checker.getSymbolAtLocation(interfaceNode.name);
    const interfaceName = interfaceNode.name.escapedText;
    const relativePath = getRelativePath(path);
    let fileInterfaces = projectInterfaces.get(relativePath);
    if (!fileInterfaces) {
        fileInterfaces = new Set();
        projectInterfaces.set(relativePath, fileInterfaces);
    }
    fileInterfaces.add(interfaceName);
}

/**
 * Created by Papa on 3/26/2016.
 */
class Logger {
    error(message) {
        this.log('ERROR', message);
    }
    log(severity, message) {
        console.log(`${this.getNowStamp()} [${severity}]: ${message}`);
    }
    getNowStamp() {
        let date = new Date();
        return this.getTimeStamp(date);
    }
    getTimeStamp(date) {
        return date.toISOString();
    }
}

/**
 * Created by Papa on 4/24/2016.
 */
globalThis.repositoryAutoload = false;
function addRootDirPaths(dirNameFromConfig, defaultDir, existingSourceFilePaths) {
    const dir = dirNameFromConfig ? dirNameFromConfig : defaultDir;
    const dirPath = process.cwd() + '/' + dir;
    const sourceFilePaths = findAllSourceFilePaths(dirPath);
    return [...existingSourceFilePaths, ...sourceFilePaths];
}
function findAllSourceFilePaths(dirPath) {
    if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath);
    }
    const allFileNames = fs.readdirSync(dirPath);
    const containedFilePaths = allFileNames.map(fileName => {
        return dirPath + '/' + fileName;
    });
    let sourceFilePaths = [];
    const subDirectoryPaths = containedFilePaths.filter(filePath => {
        if (fs.lstatSync(filePath).isDirectory()) {
            return true;
        }
        else {
            if (isTsFile(filePath)) {
                sourceFilePaths.push(filePath);
            }
            return false;
        }
    });
    for (const subDirPath of subDirectoryPaths) {
        sourceFilePaths = sourceFilePaths.concat(findAllSourceFilePaths(subDirPath));
    }
    sourceFilePaths = sourceFilePaths.map(sourceFilePath => fs.realpathSync.native(sourceFilePath));
    return sourceFilePaths;
}
function isTsFile(fileName) {
    return fileName.substr(fileName.length - 3, 3) === '.ts';
}
async function generate() {
    console.log('START AIRport generation');
    const configuration = readConfiguration(process.cwd(), process.argv);
    globalThis.configuration = configuration;
    let sourceFilePaths = addRootDirPaths(configuration.airport.ddlDir, 'src/ddl', []);
    sourceFilePaths = addRootDirPaths(configuration.airport.daoDir, 'src/dao', sourceFilePaths);
    sourceFilePaths = addRootDirPaths(null, 'src/api', sourceFilePaths);
    for (const fileProcessor of additionalFileProcessors) {
        sourceFilePaths = addRootDirPaths(null, fileProcessor.getDir(), sourceFilePaths);
    }
    try {
        await watchFiles(configuration, {
            module: 6 // tsc.ModuleKind.ES2020,
        }, sourceFilePaths);
    }
    catch (e) {
        console.log('ERROR in AIRport generation:');
        throw e;
    }
    console.log('DONE AIRport generation');
}

export { ARGUMENT_FLAGS, ApiBuilder, ApiIndexBuilder, ApplicationLoader, ApplicationQueryGenerator, ApplicationRelationResolver, ArgumentType, DB_APPLICATION_LOADER, DaoBuilder, DbApplicationBuilder, DvoBuilder, EntityCandidate, EntityCandidateRegistry, EntityMappingBuilder, FileBuilder, Flags, GLOBAL_CANDIDATES, GeneratedFileListingBuilder, GeneratedSummaryBuilder, GlobalCandidates, IQEntityInterfaceBuilder, IVEntityInterfaceBuilder, ImplementationFileBuilder, ImportManager, InjectionFileBuilder, Interface, JsonApplicationBuilder, Logger, MappedSuperclassBuilder, NoOpApplicationBuilder, NoOpSequenceGenerator, NoOpSqlDriver, PathBuilder, QApplicationBuilder, QColumnBuilder, QCoreEntityBuilder, QEntityBuilder, QEntityFileBuilder, QEntityIdBuilder, QEntityRelationBuilder, QPropertyBuilder, QQueryPreparationField, QRelationBuilder, QTransientBuilder, SApplicationBuilder, TempDatabase, UtilityBuilder, VCoreEntityBuilder, VEntityBuilder, VEntityFileBuilder, VPropertyBuilder, VRelationBuilder, VTransientBuilder, addFileProcessor, addImportForType, additionalFileProcessors, buildIndexedSApplication, canBeInterface, currentApiFileSignatureMap, currentApplicationApi, endsWith, entityExtendsAirEntity, entityExtendsOrIsAirEntity, entityOperationMap, entityOperationPaths, forEach$1 as forEach, generate, generateDefinitions, getClassPath, getExpectedPropertyIndexesFormatMessage, getFullPathFromRelativePath, getImplNameFromInterfaceName, getImplementedInterfaces, getManyToOneDecorator, getParentClassImport, getParentClassName, getPropertyFieldType, getPropertyJSONOperationInterface, getPropertyTypedOperationInterface, getQColumnFieldInterface, getQPrimitiveFieldInterface, getQPropertyFieldClass, getQPropertyFieldInterface, getRelationFieldType, getRelativePath, getVColumnFieldInterface, getVPrimitiveFieldInterface, getVPropertyFieldClass, getVPropertyFieldInterface, isDecoratedAsEntity, isManyToOnePropertyNotNull, isPrimitive, normalizePath, parseFlags, projectInterfaces, readConfiguration, resolveRelativeEntityPath, resolveRelativePath, startsWith, visitApiFile, visitDaoFile, visitEntityFile, visitInterfaceCandidateFile, watchFiles };
//# sourceMappingURL=index.mjs.map
